/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ManagementPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian35 = require("obsidian");

// src/settingsTab.ts
var import_obsidian = require("obsidian");
var PluginMainSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Configuraci\xF3n del plugin de Gesti\xF3n Personal" });
    const tabContainer = containerEl.createDiv({ cls: "tab-container" });
    const tabContentContainer = containerEl.createDiv({ cls: "tab-content-container" });
    const tabTitles = ["Activar M\xF3dulos", "Directorios Subsistemas", "Pesta\xF1a 3"];
    tabTitles.forEach((title, index) => {
      const tabButton = document.createElement("button");
      tabButton.textContent = title;
      tabButton.classList.add("tab-link");
      tabButton.dataset.tab = `tab${index}`;
      tabButton.onclick = () => this.openTab(`tab${index}`);
      tabContainer.appendChild(tabButton);
      const tabContent = document.createElement("div");
      tabContent.id = `tab${index}`;
      tabContent.classList.add("tab-content");
      tabContentContainer.appendChild(tabContent);
      if (index > 0)
        tabContent.style.display = "none";
      if (index === 0) {
        new import_obsidian.Setting(tabContent).setName("Ver Alias en el Status Bar").setDesc("Elige si deseas ver el Aliases de las notas en el Status Bar.").addToggle((toggle) => toggle.setValue(this.plugin.settings.moduloAliasStatusBar).onChange(async (value) => {
          this.plugin.settings.moduloAliasStatusBar = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(tabContent).setName("Activar M\xF3dulo Registro Tiempo").setDesc("Activa o desactiva el m\xF3dulo de registro de tiempo.").addToggle((toggle) => toggle.setValue(this.plugin.settings.moduloRegistroTiempo).onChange(async (value) => {
          this.plugin.settings.moduloRegistroTiempo = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(tabContent).setName("Activar M\xF3dulo Base - Pruebas").setDesc("Activa o desactiva el m\xF3dulo de pruebas.").addToggle((toggle) => toggle.setValue(this.plugin.settings.moduloBase).onChange(async (value) => {
          this.plugin.settings.moduloBase = value;
          await this.plugin.saveSettings();
        }));
      }
      if (index === 1) {
        const toggleCollapse = (event) => {
          const nextElement = event.target.nextElementSibling;
          if (nextElement.style.display === "none") {
            nextElement.style.display = "block";
            event.target.innerHTML = "&#9660; " + event.target.getAttribute("data-title");
          } else {
            nextElement.style.display = "none";
            event.target.innerHTML = "&#9654; " + event.target.getAttribute("data-title");
          }
        };
        const anotacionesTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Anotaciones"' });
        anotacionesTitle.setAttribute("data-title", 'Subsistema de "Anotaciones"');
        anotacionesTitle.style.cursor = "pointer";
        const anotacionesContent = tabContent.createDiv();
        anotacionesContent.style.display = "none";
        anotacionesTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(anotacionesContent).setName("Carpeta de Anotaciones").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n todas las Anotaciones.").addText((text) => text.setValue(this.plugin.settings.folder_Anotaciones).onChange(async (value) => {
          this.plugin.settings.folder_Anotaciones = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(anotacionesContent).setName("Indice de Anotaciones").setDesc("Establece la ruta del \xEDndice de las Anotaciones.").addText((text) => text.setValue(this.plugin.settings.indice_Anotaciones).onChange(async (value) => {
          this.plugin.settings.indice_Anotaciones = value;
          await this.plugin.saveSettings();
        }));
        const blogTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Art\xEDculos de Blog"' });
        blogTitle.setAttribute("data-title", 'Subsistema de "Art\xEDculos de Blog"');
        blogTitle.style.cursor = "pointer";
        const blogContent = tabContent.createDiv();
        blogContent.style.display = "none";
        blogTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(blogContent).setName("Carpeta de Art\xEDculos del Blog").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n los art\xEDculos del blog.").addText((text) => text.setValue(this.plugin.settings.folder_ABlog).onChange(async (value) => {
          this.plugin.settings.folder_ABlog = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(blogContent).setName("Indice de Art\xEDculos del Blog").setDesc("Establece la ruta del \xEDndice de los art\xEDculos del blog.").addText((text) => text.setValue(this.plugin.settings.indice_ABlog).onChange(async (value) => {
          this.plugin.settings.indice_ABlog = value;
          await this.plugin.saveSettings();
        }));
        const desarrollosTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Desarrollos y c\xF3digos"' });
        desarrollosTitle.setAttribute("data-title", 'Subsistema de "Desarrollos y c\xF3digos"');
        desarrollosTitle.style.cursor = "pointer";
        const desarrollosContent = tabContent.createDiv();
        desarrollosContent.style.display = "none";
        desarrollosTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(desarrollosContent).setName("Carpeta de Desarrollos y C\xF3digos").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n los desarrollos y c\xF3digos.").addText((text) => text.setValue(this.plugin.settings.folder_Desarrollos).onChange(async (value) => {
          this.plugin.settings.folder_Desarrollos = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(desarrollosContent).setName("\xCDndice de Desarrollos y C\xF3digos").setDesc("Establece la ruta del \xEDndice de los desarrollos y c\xF3digos.").addText((text) => text.setValue(this.plugin.settings.indice_Desarrollos).onChange(async (value) => {
          this.plugin.settings.indice_Desarrollos = value;
          await this.plugin.saveSettings();
        }));
        const estudioTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Estudio"' });
        estudioTitle.setAttribute("data-title", 'Subsistema de "Estudio"');
        estudioTitle.style.cursor = "pointer";
        const estudioContent = tabContent.createDiv();
        estudioContent.style.display = "none";
        estudioTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(estudioContent).setName("Carpeta de Temas de Estudio").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n los temas de estudio.").addText((text) => text.setValue(this.plugin.settings.folder_Estudio).onChange(async (value) => {
          this.plugin.settings.folder_Estudio = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(estudioContent).setName("\xCDndice de Estudio").setDesc("Establece la ruta del \xEDndice de los temas de estudio.").addText((text) => text.setValue(this.plugin.settings.indice_Estudio).onChange(async (value) => {
          this.plugin.settings.indice_Estudio = value;
          await this.plugin.saveSettings();
        }));
        const gtdTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "GTD"' });
        gtdTitle.setAttribute("data-title", 'Subsistema de "GTD"');
        gtdTitle.style.cursor = "pointer";
        const gtdContent = tabContent.createDiv();
        gtdContent.style.display = "none";
        gtdTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(gtdContent).setName("Archivo de Bandeja de Entrada.").setDesc("Establece la ruta de la Bandeja de entrada GTD.").addText((text) => text.setValue(this.plugin.settings.file_Inbox).onChange(async (value) => {
          this.plugin.settings.file_Inbox = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(gtdContent).setName("Carpeta de Proyectos GTD").setDesc("Establece la ruta de la carpeta para proyectos GTD.").addText((text) => text.setValue(this.plugin.settings.folder_ProyectosGTD).onChange(async (value) => {
          this.plugin.settings.folder_ProyectosGTD = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(gtdContent).setName("\xCDndice de Proyectos GTD").setDesc("Establece la ruta del \xEDndice para proyectos GTD.").addText((text) => text.setValue(this.plugin.settings.indice_ProyectosGTD).onChange(async (value) => {
          this.plugin.settings.indice_ProyectosGTD = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(gtdContent).setName("Carpeta de Revisiones Semanales GTD").setDesc("Establece la ruta de la carpeta para las revisiones semanales GTD.").addText((text) => text.setValue(this.plugin.settings.folder_RSGTD).onChange(async (value) => {
          this.plugin.settings.folder_RSGTD = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(gtdContent).setName("\xCDndice de Revisiones Semanales GTD").setDesc("Establece la ruta del \xEDndice para las revisiones semanales GTD.").addText((text) => text.setValue(this.plugin.settings.indice_RSGTD).onChange(async (value) => {
          this.plugin.settings.indice_RSGTD = value;
          await this.plugin.saveSettings();
        }));
        const lecturaTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Lectura"' });
        lecturaTitle.setAttribute("data-title", 'Subsistema de "Lectura"');
        lecturaTitle.style.cursor = "pointer";
        const lecturaContent = tabContent.createDiv();
        lecturaContent.style.display = "none";
        lecturaTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(lecturaContent).setName("Carpeta de Sesiones de Lectura").setDesc("Establece la ruta de la carpeta para las sesiones de lectura.").addText((text) => text.setValue(this.plugin.settings.folder_LecturaSesiones).onChange(async (value) => {
          this.plugin.settings.folder_LecturaSesiones = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(lecturaContent).setName("\xCDndice de Sesiones de Lectura").setDesc("Establece la ruta del \xEDndice para las sesiones de lectura.").addText((text) => text.setValue(this.plugin.settings.indice_LecturaSesiones).onChange(async (value) => {
          this.plugin.settings.indice_LecturaSesiones = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(lecturaContent).setName("Carpeta de Res\xFAmenes de Libros").setDesc("Establece la ruta de la carpeta para los res\xFAmenes de libros.").addText((text) => text.setValue(this.plugin.settings.folder_LecturaResumenes).onChange(async (value) => {
          this.plugin.settings.folder_LecturaResumenes = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(lecturaContent).setName("\xCDndice de Res\xFAmenes de Libros").setDesc("Establece la ruta del \xEDndice para los res\xFAmenes de libros.").addText((text) => text.setValue(this.plugin.settings.indice_LecturaResumenes).onChange(async (value) => {
          this.plugin.settings.indice_LecturaResumenes = value;
          await this.plugin.saveSettings();
        }));
        const mentoriasTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Mentor\xEDas"' });
        mentoriasTitle.setAttribute("data-title", 'Subsistema de "Mentor\xEDas"');
        mentoriasTitle.style.cursor = "pointer";
        const mentoriasContent = tabContent.createDiv();
        mentoriasContent.style.display = "none";
        mentoriasTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(mentoriasContent).setName("Carpeta de Sesiones de Mentor\xEDa").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n las sesiones de mentor\xEDa.").addText((text) => text.setValue(this.plugin.settings.folder_Mentorias).onChange(async (value) => {
          this.plugin.settings.folder_Mentorias = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(mentoriasContent).setName("\xCDndice de Mentor\xEDas").setDesc("Establece la ruta del \xEDndice de las sesiones de mentor\xEDa.").addText((text) => text.setValue(this.plugin.settings.indice_Mentorias).onChange(async (value) => {
          this.plugin.settings.indice_Mentorias = value;
          await this.plugin.saveSettings();
        }));
        const mercadoTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Mercado"' });
        mercadoTitle.setAttribute("data-title", 'Subsistema de "Mercado"');
        mercadoTitle.style.cursor = "pointer";
        const mercadoContent = tabContent.createDiv();
        mercadoContent.style.display = "none";
        mercadoTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(mercadoContent).setName("Carpeta de Listados de Mercado").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n las listas de mercado.").addText((text) => text.setValue(this.plugin.settings.folder_Mercado).onChange(async (value) => {
          this.plugin.settings.folder_Mercado = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(mercadoContent).setName("\xCDndice de listados de mercado").setDesc("Establece la ruta del \xEDndice de los listados de mercado.").addText((text) => text.setValue(this.plugin.settings.indice_Mercado).onChange(async (value) => {
          this.plugin.settings.indice_Mercado = value;
          await this.plugin.saveSettings();
        }));
        const modulosTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "M\xF3dulos Sistema Gesti\xF3n"' });
        modulosTitle.setAttribute("data-title", 'Subsistema de "M\xF3dulos Sistema Gesti\xF3n"');
        modulosTitle.style.cursor = "pointer";
        const modulosContent = tabContent.createDiv();
        modulosContent.style.display = "none";
        modulosTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(modulosContent).setName("Carpeta de Modulos del Sistema de Gestion").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n los m\xF3dulos del Sistema de Gesti\xF3n.").addText((text) => text.setValue(this.plugin.settings.folder_ModulosSistema).onChange(async (value) => {
          this.plugin.settings.folder_ModulosSistema = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(modulosContent).setName("\xCDndice de los Modulos del sistema de Gestion").setDesc("Establece la ruta del \xEDndice de los M\xF3dulos del sistema de Gesti\xF3n.").addText((text) => text.setValue(this.plugin.settings.indice_ModulosSistema).onChange(async (value) => {
          this.plugin.settings.indice_ModulosSistema = value;
          await this.plugin.saveSettings();
        }));
        const transaccionesTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Transacciones"' });
        transaccionesTitle.setAttribute("data-title", 'Subsistema de "transacciones"');
        transaccionesTitle.style.cursor = "pointer";
        const transaccionesContent = tabContent.createDiv();
        transaccionesContent.style.display = "none";
        transaccionesTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(transaccionesContent).setName("Carpeta de Modulos del Sistema de Transacciones").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n los comprobantes de las transacciones.").addText((text) => text.setValue(this.plugin.settings.folder_Transacciones).onChange(async (value) => {
          this.plugin.settings.folder_Transacciones = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(transaccionesContent).setName("\xCDndice de Transacciones").setDesc("Establece la ruta del \xEDndice de Transacciones.").addText((text) => text.setValue(this.plugin.settings.indice_Transacciones).onChange(async (value) => {
          this.plugin.settings.indice_Transacciones = value;
          await this.plugin.saveSettings();
        }));
        const presentacionesTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Presentaciones"' });
        presentacionesTitle.setAttribute("data-title", 'Subsistema de "Presentaciones"');
        presentacionesTitle.style.cursor = "pointer";
        const presentacionesContent = tabContent.createDiv();
        presentacionesContent.style.display = "none";
        presentacionesTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(presentacionesContent).setName("Carpeta de Notas de Presentaciones").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n las notas de presentaciones.").addText((text) => text.setValue(this.plugin.settings.folder_Presentaciones).onChange(async (value) => {
          this.plugin.settings.folder_Presentaciones = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(presentacionesContent).setName("\xCDndice de Presentaciones").setDesc("Establece la ruta del \xEDndice de presentaciones.").addText((text) => text.setValue(this.plugin.settings.indice_Presentaciones).onChange(async (value) => {
          this.plugin.settings.indice_Presentaciones = value;
          await this.plugin.saveSettings();
        }));
        const proyectosQTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Proyectos de Q"' });
        proyectosQTitle.setAttribute("data-title", 'Subsistema de "Proyectos de Q"');
        proyectosQTitle.style.cursor = "pointer";
        const proyectosQContent = tabContent.createDiv();
        proyectosQContent.style.display = "none";
        proyectosQTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(proyectosQContent).setName("Carpeta de Proyectos de Q").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n los proyectos de Q.").addText((text) => text.setValue(this.plugin.settings.folder_ProyectosQ).onChange(async (value) => {
          this.plugin.settings.folder_ProyectosQ = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(proyectosQContent).setName("\xCDndice de Proyectos de Q").setDesc("Establece la ruta del \xEDndice de proyectos de Q.").addText((text) => text.setValue(this.plugin.settings.indice_ProyectosQ).onChange(async (value) => {
          this.plugin.settings.indice_ProyectosQ = value;
          await this.plugin.saveSettings();
        }));
        const publicacionesTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Publicaciones"' });
        publicacionesTitle.setAttribute("data-title", 'Subsistema de "Publicaciones"');
        publicacionesTitle.style.cursor = "pointer";
        const publicacionesContent = tabContent.createDiv();
        publicacionesContent.style.display = "none";
        publicacionesTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(publicacionesContent).setName("Carpeta de Piezas de Publicaciones").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n las piezas de publicaciones.").addText((text) => text.setValue(this.plugin.settings.folder_Publicaciones).onChange(async (value) => {
          this.plugin.settings.folder_Publicaciones = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(publicacionesContent).setName("\xCDndice de Publicaciones").setDesc("Establece la ruta del \xEDndice de publicaciones.").addText((text) => text.setValue(this.plugin.settings.indice_Publicaciones).onChange(async (value) => {
          this.plugin.settings.indice_Publicaciones = value;
          await this.plugin.saveSettings();
        }));
        const recetasTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Recetas"' });
        recetasTitle.setAttribute("data-title", 'Subsistema de "Recetas"');
        recetasTitle.style.cursor = "pointer";
        const recetasContent = tabContent.createDiv();
        recetasContent.style.display = "none";
        recetasTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(recetasContent).setName("Carpeta de Recetas").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n las recetas.").addText((text) => text.setValue(this.plugin.settings.folder_Recetas).onChange(async (value) => {
          this.plugin.settings.folder_Recetas = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(recetasContent).setName("\xCDndice de Recetas").setDesc("Establece la ruta del \xEDndice de recetas.").addText((text) => text.setValue(this.plugin.settings.indice_Recetas).onChange(async (value) => {
          this.plugin.settings.indice_Recetas = value;
          await this.plugin.saveSettings();
        }));
        const recursosRecurrentesTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Recursos Recurrentes"' });
        recursosRecurrentesTitle.setAttribute("data-title", 'Subsistema de "Recursos Recurrentes"');
        recursosRecurrentesTitle.style.cursor = "pointer";
        const recursosRecurrentesContent = tabContent.createDiv();
        recursosRecurrentesContent.style.display = "none";
        recursosRecurrentesTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(recursosRecurrentesContent).setName("Carpeta de Recursos Recurrentes").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n los recursos recurrentes.").addText((text) => text.setValue(this.plugin.settings.folder_RecursosRecurrentes).onChange(async (value) => {
          this.plugin.settings.folder_RecursosRecurrentes = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(recursosRecurrentesContent).setName("\xCDndice de Recursos Recurrentes").setDesc("Establece la ruta del \xEDndice de recursos recurrentes.").addText((text) => text.setValue(this.plugin.settings.indice_RecursosRecurrentes).onChange(async (value) => {
          this.plugin.settings.indice_RecursosRecurrentes = value;
          await this.plugin.saveSettings();
        }));
        const registroTiempoTitle = tabContent.createEl("p", { text: '\u25B6 Subsistema de "Registro Tiempo"' });
        registroTiempoTitle.setAttribute("data-title", 'Subsistema de "Registro Tiempo"');
        registroTiempoTitle.style.cursor = "pointer";
        const registroTiempoContent = tabContent.createDiv();
        registroTiempoContent.style.display = "none";
        registroTiempoTitle.onclick = toggleCollapse;
        new import_obsidian.Setting(registroTiempoContent).setName("Carpeta de Registros de Tiempo").setDesc("Establece la ruta de la carpeta donde se guardar\xE1n los registros de tiempo.").addText((text) => text.setValue(this.plugin.settings.folder_RegistroTiempo).onChange(async (value) => {
          this.plugin.settings.folder_RegistroTiempo = value;
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(registroTiempoContent).setName("\xCDndice de Registro de Tiempo").setDesc("Establece la ruta del \xEDndice de registros de tiempo.").addText((text) => text.setValue(this.plugin.settings.indice_RegistroTiempo).onChange(async (value) => {
          this.plugin.settings.indice_RegistroTiempo = value;
          await this.plugin.saveSettings();
        }));
      }
      if (index === 2) {
        const dateLabel = tabContent.createEl("label");
        dateLabel.textContent = "Fecha";
        const dateInput = tabContent.createEl("input");
        dateInput.type = "datetime-local";
      }
    });
    containerEl.createEl("style", {
      text: `
                .tab-content { display: none; padding-top: 20px; } // A\xF1adido padding-top para el espacio
                .tab-content.active { display: block; }
                .tab-link { cursor: pointer; padding: 5px 10px; margin-right: 5px; background: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; }
                .tab-link.active { background: #e0e0e0; }
                .setting-item { margin-bottom: 10px; }
            `
    });
    this.openTab = (tabName) => {
      document.querySelectorAll(".tab-content").forEach((content) => {
        content.style.display = "none";
        content.classList.remove("active");
      });
      document.querySelectorAll(".tab-link").forEach((link) => {
        link.classList.remove("active");
      });
      const activeTabContent = document.getElementById(tabName);
      const activeTabLink = document.querySelector(`[data-tab="${tabName}"]`);
      if (activeTabContent)
        activeTabContent.style.display = "block";
      if (activeTabLink)
        activeTabLink.classList.add("active");
    };
    this.openTab("tab0");
  }
  openTab(arg0) {
    throw new Error("Method not implemented.");
  }
};

// src/modules/moduloBase/index.ts
var import_obsidian6 = require("obsidian");

// src/modules/moduloBase/utils/crearCarpeta.ts
async function crearCarpeta(rutaCarpeta) {
  try {
    debugger;
    const carpetaExistente = app.vault.getAbstractFileByPath(rutaCarpeta);
    if (carpetaExistente) {
      console.log(`La carpeta '${rutaCarpeta}' ya existe.`);
      return;
    }
    debugger;
    await app.vault.createFolder(rutaCarpeta);
    console.log(`Carpeta '${rutaCarpeta}' creada exitosamente.`);
  } catch (error) {
    console.error(`Error al crear la carpeta '${rutaCarpeta}':`, error);
  }
}

// src/plantillas/Anotaciones/Plt - Anotaciones.ts
var plantilla = `<%*
debugger
const dv = this.DataviewAPI;
const {update} = this.app.plugins.plugins["metaedit"].api
const fileCampos =dv.page("Estructura/Campos Sistema Gestion/Campos Sistema Central")
let clasificacionAX = fileCampos.tituloClasificacionAX
let tagsClasificacionAX = fileCampos.tagsClasificacionAX
let activo = app.workspace.getActiveFile();
let idAux = dv.pages('"Anotaciones/Notas"').file.frontmatter.sort(b=> b.id , 'desc').id;

// Comprueba si idAux tiene al menos un elemento y asigna a 'id' el siguiente valor en la secuencia o 1 si no hay elementos.
let id = idAux.length > 0 ? (idAux[0] + 1) : 1;

let newName, titulo, existe, asunto, nombre
	titulo = await tp.system.prompt("\xBFSobre que es esta anotaci\xF3n?", "A-"+ id, true)
	// Verificar si el usuario presion\xF3 Esc.
    if (titulo === null) {
    new Notice("Creaci\xF3n de nota cancelada por el usuario.");
    return; // Termina la ejecuci\xF3n de la funci\xF3n aqu\xED.
	}
	if (activo != null){ 
		nombre = activo.basename;
		const nota = app.metadataCache.getFileCache(activo); 
		asunto = await tp.system.suggester(["Si","No"],[true, false], true, nombre + " es origen de " + titulo + "?")
		}
	newName = "Anotaciones/Notas/A - " + id  
await tp.file.move(newName);
let clasificacion, descripcion, estado
let tagClasificacion = await tp.system.suggester(clasificacionAX, tagsClasificacionAX, false, "\xBFClasificar\xEDas esta nota bajo alguna de las siguientes categor\xEDas?")
	// Verificar si el usuario presion\xF3 Esc.
    if (tagClasificacion === null) {
    new Notice("Creaci\xF3n de nota cancelada por el usuario.");
    return; // Termina la ejecuci\xF3n de la funci\xF3n aqu\xED.
	}
let nuevaClasificacion = false
if(tagClasificacion=="Nuevo"){
	clasificacion = await tp.system.prompt("\xBFCual es el nombre de la nueva clasificaci\xF3n que vas a ingresar?", "MiClasificaci\xF3n", true)
	// Verificar si el usuario presion\xF3 Esc.
    if (clasificacion === null) {
    new Notice("Creaci\xF3n de nota cancelada por el usuario.");
    return; // Termina la ejecuci\xF3n de la funci\xF3n aqu\xED.
	}
	tagClasificacion = await tp.system.prompt("\xBFCual es el tag que utilizaras para " + clasificacion + "?. No utilices espacios en la definici\xF3n del tag.", "nuevoTag", true)
	// Verificar si el usuario presion\xF3 Esc.
    if (tagClasificacion === null) {
    new Notice("Creaci\xF3n de nota cancelada por el usuario.");
    return; // Termina la ejecuci\xF3n de la funci\xF3n aqu\xED.
	}
	nuevaClasificacion = true
// --> Validar que el nombre del grupo no sea igual al nombre de ninguna area de Vida.
}else if(tagClasificacion=="Ninguna"){
	tagClasificacion = ""
	clasificacion = ""	
}else {
	let indice = tagsClasificacionAX.indexOf(tagClasificacion)
	clasificacion = clasificacionAX[indice]
}
if (nuevaClasificacion) {
    let nuevoC = clasificacionAX.pop(); // \xDAltima clasificaci\xF3n
    let ningunoC = clasificacionAX.pop(); // Pen\xFAltima clasificaci\xF3n

    clasificacionAX.push(clasificacion);
    clasificacionAX.push(ningunoC);
    clasificacionAX.push(nuevoC);

    await update("tituloClasificacionAX", clasificacionAX, fileCampos.file.path);
	await new Promise(resolve => setTimeout(resolve, 1000));

    let nuevoTagC = tagsClasificacionAX.pop(); // \xDAltimo tag
    let ningunoTagC = tagsClasificacionAX.pop(); // Pen\xFAltimo tag

    tagsClasificacionAX.push(tagClasificacion);
    tagsClasificacionAX.push(ningunoTagC);
    tagsClasificacionAX.push(nuevoTagC);

    await update("tagsClasificacionAX", tagsClasificacionAX, fileCampos.file.path);
}


if (tagClasificacion != ""){
tagClasificacion = "cl/" + tagClasificacion 
}
if (clasificacion == "Feedback Semanal"){
	descripcion = []
	let aux = 0
	let otra
	do{
		descripcion[aux] = await tp.system.prompt("Escribe tu feedback de "+ titulo, "P" + aux, false, true)
		aux += 1
		otra = await tp.system.suggester(["Si","No"],[true,false], true, "\xBFAgregar otro parrafo?" )
	}while(otra)
}else{
	descripcion = await tp.system.prompt("\xBFQuieres agregar una descripci\xF3n?", " " + titulo, false, true )
	// Verificar si el usuario presion\xF3 Esc.
    if (descripcion === null) {
    new Notice("Creaci\xF3n de nota cancelada por el usuario.");
    return; // Termina la ejecuci\xF3n de la funci\xF3n aqu\xED.
	}
}
estado = await tp.system.suggester(["\u{1F535} -> Completado - Informaci\xF3n", "\u{1F7E2} -> Finalizado","\u{1F7E1} -> En ejecuci\xF3n", "\u{1F534} -> Detenido"],["\u{1F535}", "\u{1F7E2}","\u{1F7E1}", "\u{1F534}"], false, "Cual es el estado de esta anotaci\xF3n?")
// Verificar si el usuario presion\xF3 Esc.
    if (estado === null) {
    new Notice("Creaci\xF3n de nota cancelada por el usuario.");
    return; // Termina la ejecuci\xF3n de la funci\xF3n aqu\xED.
	}
-%>
---
tipo: Anotaci\xF3n
idq: 6
id: <% id %> 
idManual:
aliases: 
- <%titulo%>
descripcion: <%*if (clasificacion != "Feedback Semanal"){%> <%descripcion%><%* }else{%>>-  <%* for (let a=0; a<descripcion.length;a++){%>
   <%descripcion[a]%> 
<%*}}%>
tema: <%clasificacion%> 
estado: <% estado %> 
fecha: <% tp.date.now("YYYY-MM-DD dddd HH:mm") %>
hora: <% tp.date.now("HHmm", 0,)%>
valor:  
tags: <%tagClasificacion%> 
asunto: <%* if(asunto){ %> 
- "[[<%nombre%>]]" <%*}%>
related:
---
# \`VIEW[{aliases}]\` 
>[!info]- Descripcion
>\`VIEW[{descripcion}]\`
> 

Plantilla oculta
<%* if(clasificacion=="Meditaciones de alteraci\xF3n de futuro"){ -%>
## Objetivo 

## Evento imaginario que seguir\xEDa al cumplimiento del deseo

### Que es lo que siento?

### Detalles para la visualizaci\xF3n.
## Premisas que alimenten el deseo cumplido
_Frases que apoyan mi objetivo_
## Tareas de seguimiento de la meditaci\xF3n
- [ ] Total de meditaciones de <% titulo %> 
	- [ ] Meditaci\xF3n de <% titulo %> #cx/Meditacion \u{1F501} every day when done \u{1F4C5} <% tp.date.now("YYYY-MM-DD") %>
<%*}else if(clasificacion =="Feedback Semanal"){-%>
## Feedback
\`\`\`dataviewjs
dv.paragraph(dv.current().descripcion)
\`\`\`
<%*}else if(clasificacion =="Video Youtube"){-%>
## Video

> [!tip]- Como crear el link del video?
>Estamos utilizando el plugin TimeStamp Notes. Para crear el link aqu\xED, solamente debes pegar el link de youtube, seleccionarlo y utilizar el comando Open Video Player, o el shortcut  \u2325 ^ O
### Timestamps
> [!important]- Crear los timestamps del video
> Para crear los timestamps del video, en el momento en el que llegues al video, solo debes pulsar el shortcut \u2325 ^ 0, o buscar el comando Insert Timestamp. 
 

## Comentarios Personales

## Hitos del video.

## Resumen IA

<%*}else if(clasificacion =="Grupo de Hojas de Trabajo"){-%>

## [[Comentarios a las plantillas#Temas relacionados a este grupo de hojas de trabajo|Temas relacionados a este grupo de hojas de trabajo:]]
\`\`\`dataviewjs
const {crearAx} = customJS
let hijos = dv.pages().filter(b=> dv.func.contains(b.asunto, dv.current().file.link))
let totalHijos = 
dv.table(["Tema","Tipo","Fecha Modificaci\xF3n", "Pendientes","Hijos"], hijos.map(b=> [b.file.link, b.tema, b.fecha, b.file.tasks.filter(b=> b.status == ' ' || b.status == '/').length, crearAx.paginasHijos(dv,b).length-1]))
\`\`\`


<%*}%>


# Fin
- [/] Finalizado el desarrollo de Anotaci\xF3n <%id%> #cx/Computador/OrganizarNotas  
Estado de la nota:  \`INPUT[estadoNota][:estado]\`
\`\`\`dataviewjs
const {callDV} = customJS
callDV.CambiarTituloDescripcion(dv)
\`\`\`
---
\`\`\`dataviewjs
const {callDV} = customJS
callDV.CarruselAnotaciones(dv)
\`\`\`
\`\`\`dataviewjs
const {callDV} = customJS
callDV.BotonesStandar(dv)
\`\`\`

`;

// src/modules/moduloBase/utils/crearPlantilla.ts
var import_obsidian2 = require("obsidian");
async function crearPlantilla(contenido) {
  const folder = "Plantillas";
  let filename = "Archivo De Plantilla";
  let pathTemporal = folder + "/" + filename + ".md";
  const archivoCreado = await app.vault.create(pathTemporal, contenido);
  return archivoCreado;
}

// src/modules/moduloBase/utils/fileLinkModal.ts
var import_obsidian3 = require("obsidian");
var FileLinkModal = class extends import_obsidian3.Modal {
  constructor(app2) {
    super(app2);
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.style.display = "flex";
    contentEl.style.flexDirection = "column";
    contentEl.style.justifyContent = "center";
    contentEl.style.alignItems = "center";
    contentEl.style.height = "50%";
    contentEl.createEl("h1", {
      text: "Insertar el link de un archivo.",
      attr: { style: "text-align: center;" }
      // Asegura que el texto del título esté centrado si es más largo que una línea
    });
    const inputContainer = contentEl.createDiv();
    inputContainer.style.margin = "10px";
    const fileInput = inputContainer.createEl("input", { type: "file" });
    fileInput.style.display = "none";
    const fileButton = inputContainer.createEl("button", {
      text: "Seleccione su archivo",
      cls: "mod-cta"
    });
    fileButton.style.padding = "5px 10px";
    fileButton.style.fontSize = "16px";
    fileButton.style.marginTop = "5px";
    fileButton.style.cursor = "pointer";
    fileButton.onclick = () => fileInput.click();
    fileInput.onchange = (e) => {
      const file = e.target.files[0];
      if (file) {
        this.insertLinkAtCursor(file.path, file.name);
      }
      this.close();
    };
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
  async insertLinkAtCursor(filePath, fileName) {
    const activeLeaf = this.app.workspace.activeLeaf;
    if (activeLeaf) {
      const editor = activeLeaf.view.sourceMode.cmEditor;
      const cursor = editor.getCursor();
      const linkText = `[${fileName}](<file://${filePath}>)`;
      editor.replaceRange(linkText, cursor);
    }
  }
};
async function insertFileLink(app2) {
  new FileLinkModal(app2).open();
}

// src/modules/moduloBase/commands.ts
var import_obsidian5 = require("obsidian");

// src/modules/moduloBase/utils/createNoteFromTemplate.ts
var import_obsidian4 = require("obsidian");
async function createNoteFromTemplate(plugin, template, folder, filename, openNewNote = true) {
  if (!plugin || !plugin.app.plugins.enabledPlugins.has("templater-obsidian")) {
    console.error("El plugin Templater no est\xE1 habilitado.");
    return;
  }
  const templaterPlugin = plugin.app.plugins.plugins["templater-obsidian"];
  const tp = templaterPlugin.templater.current_functions_object;
  if (!tp) {
    console.error("No se pudo acceder al objeto de funciones actuales de Templater.");
    return;
  }
  debugger;
  let templateFile = tp.file.find_tfile(template);
  try {
    const newNote = await tp.file.create_new(templateFile, filename, openNewNote, folder);
    return newNote;
  } catch (error) {
    console.error("Error al crear la nota desde la plantilla:", error);
    return;
  }
}

// src/modules/moduloBase/commands.ts
function registerCommands(plugin) {
  const comando1 = plugin.addCommand({
    id: "Creacion-Carpeta",
    name: "Creaci\xF3n de Carpeta",
    callback: async () => {
      debugger;
      await crearCarpeta("Mi Carpeta de plugin");
    }
  });
  plugin.registeredCommandIdsMB.push(comando1.id);
  const comando2 = plugin.addCommand({
    id: "crear-template",
    name: "Crear un archivo template",
    callback: async () => {
      const archivo = await crearPlantilla(plantilla);
      if (!archivo) {
        new Notice("No se pudo crear el archivo.");
        return;
      }
    }
  });
  plugin.registeredCommandIdsMB.push(comando2.id);
  const comando3 = plugin.addCommand({
    id: "crear-archivo-template",
    name: "Crear archivo desde template",
    callback: async () => {
      const pluginId = "templater-obsidian";
      const isPluginInstalled = plugin.app.plugins.enabledPlugins.has(pluginId);
      let template = "Plantillas/Anotaciones/Plt - Anotaciones.md";
      let folderObj = plugin.app.vault.getAbstractFileByPath("Inbox");
      if (!(folderObj instanceof import_obsidian5.TFolder)) {
        new Notice("La carpeta especificada no existe o no es una carpeta.");
        return;
      }
      let fileName = "toDefine";
      let openNote = true;
      debugger;
      const archivo = await createNoteFromTemplate(plugin, template, folderObj, fileName, openNote);
      if (!archivo) {
        new Notice("No se pudo crear el archivo.");
        return;
      }
    }
  });
  plugin.registeredCommandIdsMB.push(comando3.id);
  const comando4 = plugin.addCommand({
    id: "crear-link-Archivo",
    name: "Crear un link a archivo del Disco.",
    callback: async () => {
      await insertFileLink(app);
    }
  });
  plugin.registeredCommandIdsMB.push(comando4.id);
  const comando5 = plugin.addCommand({
    id: "abrir-nota-activa",
    name: "Abrir Nota Activa",
    callback: async () => {
      app.workspace.detachLeavesOfType("vista-nota-activa");
      await app.workspace.getRightLeaf(true).setViewState({
        type: "vista-nota-activa"
      });
      app.workspace.revealLeaf(
        app.workspace.getLeavesOfType("vista-nota-activa")[0]
      );
    }
  });
  plugin.registeredCommandIdsMB.push(comando5.id);
}
function deactivateCommands(plugin) {
  if (!plugin.registeredCommandIdsMB)
    return;
  plugin.registeredCommandIdsMB.forEach((commandId) => {
    const command = plugin.app.commands.commands[commandId];
    if (command) {
      command.callback = () => new Notice("Este comando ha sido desactivado.");
    }
  });
}

// src/modules/moduloBase/index.ts
var ModuloBase = class {
  constructor(plugin) {
    this.moduloBase = null;
    this.plugin = plugin;
  }
  activate() {
    if (this.moduloBase)
      return;
    registerCommands(this.plugin);
  }
  deactivate() {
    if (!this.statusBar)
      return;
    deactivateCommands(this.plugin);
  }
};

// src/modules/M_busquedaAvanzada/activadores.ts
var import_obsidian10 = require("obsidian");

// src/modules/M_busquedaAvanzada/ui/ribbonButton.ts
var import_obsidian9 = require("obsidian");

// src/modules/M_busquedaAvanzada/ui/modal.ts
var import_obsidian8 = require("obsidian");

// src/modules/M_busquedaAvanzada/search/FuzzyNoteSuggester.ts
var import_obsidian7 = require("obsidian");

// src/modules/moduloAliasStatusBar/statusBar.ts
var import_obsidian11 = require("obsidian");
var StatusBarExtension = class {
  constructor(plugin) {
    this.statusBar = null;
    this.plugin = plugin;
  }
  activate() {
    if (this.statusBar)
      return;
    this.statusBar = this.plugin.addStatusBarItem();
    this.updateStatusBar();
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-open", (file) => {
        this.updateStatusBar(file);
      })
    );
  }
  deactivate() {
    if (!this.statusBar)
      return;
    this.statusBar.remove();
    this.statusBar = null;
  }
  updateStatusBar(file) {
    var _a, _b;
    const currentFile = file || this.plugin.app.workspace.getActiveFile();
    if (!currentFile || !this.statusBar) {
      (_a = this.statusBar) == null ? void 0 : _a.setText("");
      return;
    }
    const fileCache = this.plugin.app.metadataCache.getFileCache(currentFile);
    const aliases = ((_b = fileCache.frontmatter) == null ? void 0 : _b.aliases) || [];
    this.statusBar.setText(aliases.length > 0 ? `Alias: ${aliases[0]}` : "No Alias");
  }
};

// src/modules/moduloRegistroTiempo/index.ts
var import_obsidian17 = require("obsidian");

// src/modules/moduloRegistroTiempo/ribbonMenu.ts
var import_obsidian14 = require("obsidian");

// src/modules/moduloRegistroTiempo/utils.ts
var import_obsidian13 = require("obsidian");

// src/modules/modales/seleccionModal.ts
var import_obsidian12 = require("obsidian");
var SeleccionModal = class extends import_obsidian12.FuzzySuggestModal {
  // Flag para determinar si se ha hecho una selección.
  // Constructor de la clase.
  constructor(app2, titles, values, placeholder) {
    super(app2);
    // Objeto para mapear títulos a valores.
    this.seleccionHecha = false;
    this.titles = titles;
    this.values = values;
    this.valueMap = titles.reduce((acc, title, index) => {
      acc[title] = values[index];
      return acc;
    }, {});
    this.setPlaceholder(placeholder);
  }
  // Método para obtener los ítems (títulos) que se mostrarán en el modal.
  getItems() {
    return this.titles;
  }
  // Método para obtener el texto que se mostrará para cada ítem en el modal.
  getItemText(item) {
    return item;
  }
  // Método que se llama al cerrar el modal.
  onClose() {
    if (!this.seleccionHecha) {
      this.reject(new Error("Modal cerrado sin selecci\xF3n"));
    }
  }
  // Método para manejar la selección de un ítem.
  selectSuggestion(item, evt) {
    this.seleccionHecha = true;
    super.selectSuggestion(item, evt);
  }
  // Método que se llama al elegir un ítem, donde se resuelve la promesa con el valor asociado al ítem seleccionado.
  onChooseItem(item, evt) {
    const value = this.valueMap[item];
    this.resolve(value);
  }
  // Método para abrir el modal y esperar a que el usuario haga una selección, devolviendo una promesa con el valor seleccionado.
  openAndAwaitSelection() {
    return new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
      this.open();
    });
  }
};

// src/modules/moduloRegistroTiempo/utils.ts
async function cumpleCondicion(app2) {
  var _a;
  const files = app2.vault.getMarkdownFiles();
  for (let file of files) {
    if (file.path.startsWith("Estructura/Registro Tiempo")) {
      const metadata = app2.metadataCache.getFileCache(file);
      if (((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.estado) === "\u{1F7E2}") {
        return true;
      }
    }
  }
  return false;
}
async function buscarRegistrosActivos(app2) {
  var _a;
  const files = app2.vault.getMarkdownFiles();
  for (let file of files) {
    if (file.path.startsWith("Subsistemas/Registro Tiempo/Registros")) {
      const metadata = app2.metadataCache.getFileCache(file);
      if (((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.estado) === "\u{1F7E2}") {
        return file;
      }
    }
  }
  return;
}
async function crearObjetoRegistro(plugin) {
  const activo = plugin.app.workspace.getActiveFile();
  if (!activo) {
    console.error("No hay un archivo activo para la creaci\xF3n de registro de tiempo. Se descarta para la creaci\xF3n de registro de tiempo.");
    return null;
  }
  const folder = plugin.settings.folder_RegistroTiempo;
  const indice = plugin.settings.indice_RegistroTiempo;
  let maxId = 0;
  const files = app.vault.getMarkdownFiles();
  const registrosExistentes = files.filter((file) => file.path.startsWith(folder));
  registrosExistentes.forEach((file) => {
    var _a;
    const metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (metadata && metadata.id && !isNaN(metadata.id)) {
      const id = parseInt(metadata.id);
      if (id > maxId)
        maxId = id;
    }
  });
  const nextId = maxId + 1;
  const fechaCompleta = formatearFecha(/* @__PURE__ */ new Date());
  return {
    activo,
    nombre: activo.basename,
    folder,
    indice,
    id: nextId,
    fecha: fechaCompleta,
    indice_DVJS: `"${indice}"`
  };
}
function formatearFecha(fecha) {
  const offset2 = fecha.getTimezoneOffset() * 6e4;
  const fechaLocal = new Date(fecha.getTime() - offset2);
  const fechaFormato = fechaLocal.toISOString().split("T")[0];
  const dias = ["Domingo", "Lunes", "Martes", "Mi\xE9rcoles", "Jueves", "Viernes", "S\xE1bado"];
  const diaSemana = dias[fecha.getDay()];
  const horaFormato = fecha.toTimeString().split(" ")[0].substring(0, 5);
  return `${fechaFormato} ${diaSemana} ${horaFormato}`;
}
async function verificarTareasActivas(registro, app2) {
  var _a;
  const files = app2.vault.getMarkdownFiles();
  const tareasActivas = [];
  for (let file of files) {
    if (file.path.startsWith(registro.folder)) {
      const metadata = (_a = app2.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if ((metadata == null ? void 0 : metadata.estado) === "\u{1F7E2}") {
        tareasActivas.push({ file, aliases: metadata.aliases || file.basename });
      }
    }
  }
  if (tareasActivas.length === 1) {
    const tareaActiva = tareasActivas[0];
    debugger;
    const deseaDetener = await mostrarSugerencia(`La tarea ${tareaActiva.aliases} est\xE1 corriendo. \xBFDesea detenerla?`);
    if (deseaDetener === void 0) {
      new import_obsidian13.Notice(`Creaci\xF3n de registro cancelado por el usuario.`);
      registro.detener = true;
      return;
    }
    if (deseaDetener) {
      await detenerTarea(tareaActiva, app2);
      registro.detener = false;
    } else {
      new import_obsidian13.Notice(`La tarea ${tareaActiva.aliases} seguir\xE1 registr\xE1ndose.`);
      registro.detener = true;
      return;
    }
  } else if (tareasActivas.length > 1) {
    new import_obsidian13.Notice("Hay un error con la cantidad de tareas corriendo en este momento.");
    registro.detener = true;
  } else {
    console.log("No hay m\xE1s tareas corriendo.");
    registro.detener = false;
  }
}
function mostrarSugerencia(mensaje) {
  return new Promise((resolve) => {
    let seleccionado = false;
    const modal = new import_obsidian13.Modal(app);
    modal.contentEl.createEl("h1", { text: mensaje });
    const buttonsContainer = modal.contentEl.createEl("div");
    const yesButton = buttonsContainer.createEl("button", {
      text: "S\xED"
    });
    yesButton.addEventListener("click", () => {
      seleccionado = true;
      modal.close();
      resolve(true);
    });
    const noButton = buttonsContainer.createEl("button", {
      text: "No"
    });
    noButton.addEventListener("click", () => {
      seleccionado = true;
      modal.close();
      resolve(false);
    });
    modal.onClose = () => {
      if (!seleccionado) {
        resolve(void 0);
      }
    };
    modal.open();
  });
}
async function definirTipoRegistro(registro, app2) {
  const totTareas = await encontrarTareasPendientes(app2);
  let opcionesTitulo, valoresOpcion;
  if (totTareas.length > 0) {
    opcionesTitulo = [registro.nombre, "Alguna tarea en Ejecuci\xF3n", "Otro"];
    valoresOpcion = ["Nota", "Tarea", "Otro"];
  } else {
    opcionesTitulo = [registro.nombre, "Otro"];
    valoresOpcion = ["Nota", "Otro"];
  }
  const placeholder = "\xBFSobre qu\xE9 es el registro de tiempo?";
  const modalMenu1 = new SeleccionModal(app2, opcionesTitulo, valoresOpcion, placeholder);
  try {
    const selection = await modalMenu1.openAndAwaitSelection();
    registro.tipoRegistro = selection;
    switch (registro.tipoRegistro) {
      case "Nota":
        registro.titulo = registro.nombre;
        registro.siAsunto = true;
        break;
      case "Tarea":
        await elegirTareaParaRegistro(app2, registro, totTareas);
        break;
      default:
        registro.siAsunto = registro.tituloDefinido !== "Otro";
        break;
    }
  } catch (error) {
    console.error("Error o modal cerrado sin selecci\xF3n:", error);
  }
}
async function encontrarTareasPendientes(app2) {
  let tareasPendientes = [];
  const archivos = app2.vault.getMarkdownFiles();
  const archivosRelevantes = archivos.filter((archivo) => !archivo.path.includes("Plantillas"));
  for (const archivo of archivosRelevantes) {
    const contenido = await app2.vault.read(archivo);
    const coincidencias = contenido.match(/^ *- \[\/\] .*/gm) || [];
    const tareasLimpias = coincidencias.map((tarea) => tarea.trim());
    tareasPendientes = tareasPendientes.concat(tareasLimpias);
  }
  return tareasPendientes;
}
async function elegirTareaParaRegistro(app2, registro, tareasPendientes) {
  const placeholder = "Elige la tarea que vas a registrar.";
  let promesasLimpias = tareasPendientes.map((tarea) => limpiarTextoTarea(tarea));
  Promise.all(promesasLimpias).then((tareasLimpias) => {
    const modalMenu = new SeleccionModal(app2, tareasLimpias, tareasLimpias, placeholder);
    modalMenu.openAndAwaitSelection().then((selection) => {
      debugger;
      registro.titulo = limpiarTextoTarea(selection);
    }).catch((error) => {
      registro.detener = true;
      console.error("Error o modal cerrado sin selecci\xF3n:", error);
    });
  }).catch((error) => {
    console.error("Hubo un error al limpiar las tareas:", error);
  });
}
function limpiarTextoTarea(titulo) {
  return new Promise((resolve) => {
    let textoLimpio = titulo.split("\n")[0];
    textoLimpio = textoLimpio.replace(/#[\w-/]+/g, "");
    textoLimpio = textoLimpio.replace(/\[\w+::[^\]]+\]/g, "");
    textoLimpio = textoLimpio.replace(/^\s*-\s*\[\/\]\s*/, "");
    const caracteresNoPermitidos = /[<>:"\/\\|?*\x00-\x1F]/g;
    textoLimpio = textoLimpio.replace(caracteresNoPermitidos, "_");
    textoLimpio = textoLimpio.replace(/\s+/g, " ");
    resolve(textoLimpio.trim());
  });
}
async function detenerTarea(tareaActiva, app2) {
  console.log(`Deteniendo la tarea: ${tareaActiva.titulo}`);
  const fileContents = await app2.vault.read(tareaActiva.file);
  const newContents = fileContents.replace("estado: \u{1F7E2}", "estado: \u{1F535}");
  await app2.vault.modify(tareaActiva.file, newContents);
}

// src/modules/moduloRegistroTiempo/ribbonMenu.ts
function registerRibbonMenu2(plugin) {
  plugin.ribbonButtonRT = plugin.addRibbonIcon("clock", "Registro de Tiempo", async (event) => {
    const menu = new import_obsidian14.Menu(plugin.app);
    if (await cumpleCondicion(plugin.app)) {
      menu.addItem((item) => item.setTitle("Ahora").onClick(() => {
        console.log("Ahora");
      }));
    }
    menu.addItem((item) => item.setTitle("Registrar Tiempo").onClick(() => {
      console.log("Registrar Tiempo");
    }));
    if (await cumpleCondicion(plugin.app)) {
      menu.addItem((item) => item.setTitle("Detener Registro").onClick(() => {
        console.log("Detener Registro");
      }));
    }
    menu.addItem((item) => item.setTitle("Tareas en progreso").onClick(() => {
      console.log("Tareas en progreso");
    }));
    menu.addItem((item) => item.setTitle("Registros de hoy").onClick(() => {
      console.log("Registros de hoy");
    }));
    menu.showAtPosition({ x: event.pageX, y: event.pageY });
  });
}
function deactivateRibbonMenu(plugin) {
  if (plugin.ribbonButtonRT) {
    plugin.ribbonButtonRT.remove();
    plugin.ribbonButtonRT = null;
  }
}

// src/modules/moduloRegistroTiempo/commands.ts
var import_obsidian16 = require("obsidian");

// src/modules/moduloRegistroTiempo/modals/modal_Ahora.ts
var import_obsidian15 = require("obsidian");
var modal_Ahora = class extends import_obsidian15.Modal {
  constructor(app2, file) {
    super(app2);
    this.app = app2;
    this.file = file;
  }
  async onOpen() {
    var _a, _b;
    const { contentEl } = this;
    const metadata = this.app.metadataCache.getFileCache(this.file);
    const aliases = ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.aliases) || "Actividad sin alias";
    const horaInicioStr = ((_b = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _b.horaInicio) ? window.moment(metadata.frontmatter.horaInicio, "YYYY-MM-DD dddd HH:mm").format("YYYY-MM-DDTHH:mm") : "";
    contentEl.createEl("h2", { text: `Registro de actividad.` });
    contentEl.createEl("p", { text: `Tarea: "${aliases}"` });
    if (horaInicioStr) {
      const horaInicio = window.moment(horaInicioStr, "YYYY-MM-DD dddd HH:mm");
      const ahora = window.moment();
      const diff = ahora.diff(horaInicio);
      const duracion = window.moment.duration(diff);
      const diffFormatted = `${duracion.hours()}h ${duracion.minutes()}m`;
      contentEl.createEl("p", { text: `Esta actividad lleva ${diffFormatted} en ejecuci\xF3n.` });
    } else {
      contentEl.createEl("p", { text: "No se pudo determinar el tiempo de inicio de la actividad." });
    }
    contentEl.createEl("p", { text: "Hora de inicio:" });
    this.horaInicioInput = contentEl.createEl("input", {
      type: "datetime-local",
      value: horaInicioStr
    });
    const saveButton = contentEl.createEl("button", { text: "Guardar cambios" });
    saveButton.onclick = () => this.guardarCambios();
  }
  async guardarCambios() {
    const nuevaHoraInicioLocal = this.horaInicioInput.value;
    if (!nuevaHoraInicioLocal) {
      new import_obsidian15.Notice("Por favor, seleccione una hora de inicio.");
      return;
    }
    const nuevaHoraInicio = window.moment(nuevaHoraInicioLocal).format("YYYY-MM-DD dddd HH:mm");
    try {
      const contenidoOriginal = await this.app.vault.read(this.file);
      const contenidoActualizado = contenidoOriginal.replace(/(horaInicio: ).*/, `$1${nuevaHoraInicio}`);
      await this.app.vault.modify(this.file, contenidoActualizado);
      this.close();
      new import_obsidian15.Notice("Hora de inicio actualizada correctamente.");
    } catch (error) {
      console.error("Error al guardar cambios en la nota:", error);
      new import_obsidian15.Notice("Error al guardar los cambios en la nota.");
    }
  }
};

// src/modules/moduloRegistroTiempo/commands.ts
function registerCommands2(plugin) {
  const id1 = plugin.addCommand({
    id: "registros-de-tiempo-del-dia",
    name: "Registros de tiempo del d\xEDa",
    checkCallback: (checking) => {
      var _a;
      const activeLeaf = plugin.app.workspace.activeLeaf;
      if (activeLeaf) {
        const filePath = ((_a = activeLeaf.view.file) == null ? void 0 : _a.path) || "";
        if (filePath.startsWith("Estructura/Periodos/Diario/")) {
          if (!checking) {
            console.log("Registros de tiempo del d\xEDa");
          }
          return true;
        }
      }
      return false;
    }
  });
  plugin.registeredCommandIdsRT.push(id1.id);
  const id2 = plugin.addCommand({
    id: "ahora-RegistroTiempo",
    name: "Tarea activa en registro de tiempo",
    callback: async () => {
      const activa = await buscarRegistrosActivos(plugin.app);
      if (!activa) {
        new import_obsidian16.Notice("No hay notas activas");
      } else {
        let modal = new modal_Ahora(plugin.app, activa);
        modal.open();
      }
    }
  });
  plugin.registeredCommandIdsRT.push(id2.id);
  const id3 = plugin.addCommand({
    id: "crear-registro-tiempo",
    name: "Crear Registro de Tiempo",
    callback: async () => {
      const registro = await crearObjetoRegistro(plugin);
      if (!registro) {
        new import_obsidian16.Notice("No se pudo crear el objeto de registro.");
        return;
      }
      await verificarTareasActivas(registro, plugin.app);
      await definirTipoRegistro(registro, plugin.app);
    }
  });
  plugin.registeredCommandIdsRT.push(id3.id);
  const id4 = plugin.addCommand({
    id: "vista-registro-tiempo-activa",
    name: "Mostrar RT Activo",
    callback: async () => {
      app.workspace.detachLeavesOfType("vista-registro-activo");
      await app.workspace.getRightLeaf(true).setViewState({
        type: "vista-registro-activo"
      });
      app.workspace.revealLeaf(
        app.workspace.getLeavesOfType("vista-registro-activo")[0]
      );
    }
  });
  plugin.registeredCommandIdsRT.push(id4.id);
}
function deactivateCommands2(plugin) {
  if (!plugin.registeredCommandIdsRT)
    return;
  plugin.registeredCommandIdsRT.forEach((commandId) => {
    const command = plugin.app.commands.commands[commandId];
    if (command) {
      command.callback = () => new import_obsidian16.Notice("Este comando ha sido desactivado.");
    }
  });
}

// src/modules/moduloRegistroTiempo/index.ts
var ModuloRegistroTiempo = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  activate() {
    if (!this.plugin.ribbonButtonRT) {
      registerRibbonMenu2(this.plugin);
    }
    registerCommands2(this.plugin);
  }
  deactivate() {
    deactivateRibbonMenu(this.plugin);
    deactivateCommands2(this.plugin);
  }
};

// src/defaults/defaultSettings.ts
var DEFAULT_SETTINGS = {
  moduloRegistroTiempo: true,
  moduloAliasStatusBar: true,
  moduloBase: true,
  moduloGTD: true,
  file_camposCentral: "Estructura/Campos Sistema Gestion/Campos Sistema Central",
  folder_Anotaciones: "Anotaciones/Notas",
  indice_Anotaciones: "Anotaciones/Indice Anotaciones",
  folder_ABlog: "Subsistemas/Articulos Blog/Articulos",
  indice_ABlog: "Subsistemas/Articulos Blog/Indice Articulos Blog",
  folder_Desarrollos: "Subsistemas/Desarrollos/Codigos",
  indice_Desarrollos: "Subsistemas/Desarrollos/Indice Desarrollo",
  folder_Estudio: "Subsistemas/Estudio/Temas",
  indice_Estudio: "Subsistemas/Estudio/Indice Estudio",
  folder_LecturaSesiones: "Subsistemas/Lectura/Sesiones de Lectura/Sesiones",
  indice_LecturaSesiones: "Subsistemas/Lectura/Sesiones de Lectura/Indice Sesiones Lectura",
  folder_LecturaResumenes: "Subsistemas/Lectura/Libros/Resumenes",
  indice_LecturaResumenes: "Subsistemas/Lectura/Libros/Indice Resumenes",
  folder_Mentorias: "Subsistemas/Mentorias/Sesiones Mentoria",
  indice_Mentorias: "Subsistemas/Mentorias/Indice Mentorias",
  folder_Mercado: "Subsistemas/Mercado/Listas",
  indice_Mercado: "Subsistemas/Mercado/Indice Mercado",
  folder_ModulosSistema: "Subsistemas/Modulos Sistema Gestion/Modulos",
  indice_ModulosSistema: "Subsistemas/Modulos Sistema Gestion/Indice Modulos",
  folder_Transacciones: "Subsistemas/Transacciones",
  indice_Transacciones: "Subsistemas/Transacciones/Indice Transacciones",
  folder_Presentaciones: "Subsistemas/Presentaciones/Notas",
  indice_Presentaciones: "Subsistemas/Presentaciones/Indice Presentaciones",
  folder_Publicaciones: "Subsistemas/Publicaciones/Piezas",
  indice_Publicaciones: "Subsistemas/Publicaciones/Indice Publicaciones",
  folder_Recetas: "Subsistemas/Recetas/Recetas",
  indice_Recetas: "Subsistemas/Recetas/Indice Recetas",
  folder_RegistroTiempo: "Subsistemas/Registro Tiempo/Registros",
  indice_RegistroTiempo: "Subsistemas/Registro Tiempo/Indice Registro Tiempo",
  folder_ContenidoParaEstudio: "Subsistemas/Contenido para Estudio/Contenido",
  indice_ContenidoParaEstudio: "Subsistemas/Contenido para Estudio/Indice Contenido para Estudio",
  // Estructura
  folder_AreasVida: "Estructura/Areas de Vida",
  indice_AreasVida: "Estructura/Areas de Vida/Indice Areas de Vida",
  folder_AreasInteres: "Estructura/Areas de Interes",
  indice_AreasInteres: "Estructura/Areas de Interes/Indice Areas de Interes",
  folder_TemasInteres: "Estructura/Temas de Interes",
  indice_TemasInteres: "Estructura/Temas de Interes/Indice Temas de Interes",
  folder_RecursosRecurrentes: "Estructura/Recursos Recurrentes/Recursos",
  indice_RecursosRecurrentes: "Estructura/Recursos Recurrentes/Indice Recursos Recurrentes",
  folder_ProyectosQ: "Estructura/Proyectos de Q",
  indice_ProyectosQ: "Estructura/Proyectos de Q/Indice Proyectos de Q",
  file_Inbox: "Estructura/GTD/Bandeja de Entrada/Bandeja de Entrada",
  folder_ProyectosGTD: "Estructura/GTD/Proyectos GTD/Proyectos",
  indice_ProyectosGTD: "Estructura/GTD/Proyectos GTD/Indice Proyectos GTD",
  folder_RSGTD: "Estructura/GTD/Revision Semanal/Revisiones",
  indice_RSGTD: "Estructura/GTD/Revision Semanal/Indice Revision Semanal",
  // Journal
  folder_Diario: "Estructura/Journal/Diario/Notas",
  indice_Diario: "Estructura/Journal/Diario/Indice Diario",
  folder_Semanal: "Estructura/Journal/Semanal/Notas",
  indice_Semanal: "Estructura/Journal/Semanal/Indice Semanal",
  folder_Mensual: "Estructura/Journal/Mensual/Notas",
  indice_Mensual: "Estructura/Journal/Mensual/Indice Mensual",
  folder_Trimestral: "Estructura/Journal/Trimestral/Notas",
  indice_Trimestral: "Estructura/Journal/Trimestral/Indice Trimestral",
  folder_Anual: "Estructura/Journal/Anual/Notas",
  indice_Anual: "Estructura/Journal/Anual/Indice Anual",
  // COMPASS
  folder_CompassAnual: "Estructura/Compass/Reportes/Anual",
  indice_CompassAnual: "Estructura/Compass/Reportes/Indice Compass Anual",
  folder_CompassTrimestral: "Estructura/Compass/Reportes/Trimestral",
  indice_CompassTrimestral: "Estructura/Compass/Reportes/Indice Compass trimestral",
  folder_ObjCompassAnual: "Estructura/Compass/Objetivos/Anual",
  indice_ObjCompassAnual: "Estructura/Compass/Objetivos/Indice Compass Anual",
  folder_ObjCompassTrimestral: "Estructura/Compass/Objetivos/Trimestral",
  indice_ObjCompassTrimestral: "Estructura/Compass/Objetivos/Indice Compass trimestral"
};

// src/modules/moduloRegistroTiempo/API/utilsAPI.ts
var import_obsidian20 = require("obsidian");

// src/modules/moduloRegistroTiempo/API/menuOtro.ts
var import_obsidian19 = require("obsidian");

// src/modules/modales/fuzzySelectOrCreate.ts
var import_obsidian18 = require("obsidian");
var fuzzySelectOrCreate = class {
  constructor(app2, plugin) {
    this.pathCampos = "Estructura/Campos Sistema Gestion/Campos Registro Tiempo.md";
    this.app = app2;
    this.plugin = plugin;
  }
  createModal() {
    const modal = document.createElement("div");
    modal.setAttribute("id", "fuzzySearchModal");
    modal.style.position = "fixed";
    modal.style.top = "50%";
    modal.style.left = "50%";
    modal.style.transform = "translate(-50%, -50%)";
    modal.style.zIndex = "1000";
    modal.style.padding = "20px";
    modal.style.backgroundColor = "white";
    modal.style.border = "1px solid #ccc";
    modal.style.borderRadius = "5px";
    modal.style.boxShadow = "0 4px 6px rgba(0,0,0,.1)";
    modal.style.width = "300px";
    const closeButton = document.createElement("button");
    closeButton.textContent = "\xD7";
    closeButton.style.position = "absolute";
    closeButton.style.top = "5px";
    closeButton.style.right = "5px";
    closeButton.style.border = "none";
    closeButton.style.background = "none";
    closeButton.style.cursor = "pointer";
    closeButton.style.fontSize = "16px";
    closeButton.style.fontWeight = "bold";
    closeButton.style.padding = "0px 4px";
    closeButton.style.borderRadius = "10px";
    closeButton.style.outline = "none";
    closeButton.style.boxShadow = "none";
    closeButton.onclick = () => modal.remove();
    modal.appendChild(closeButton);
    return modal;
  }
  filterItems(query, items) {
    return items.filter(
      (item) => item.value.toLowerCase().includes(query.toLowerCase())
    );
  }
  async updateYAMLFields(tipo, selectedValue, selectedGroup) {
    try {
      debugger;
      const file = app.vault.getAbstractFileByPath(this.pathCampos);
      await app.fileManager.processFrontMatter(file, (frontmatter) => {
        debugger;
        let currentActs = frontmatter[tipo] || [];
        let newValueForActs = [...currentActs, [selectedGroup, selectedValue]];
        frontmatter[tipo] = newValueForActs;
      });
      console.log("Frontmatter actualizado con \xE9xito");
    } catch (err) {
      console.error("Error al actualizar el frontmatter", err);
    }
  }
  async showFuzzySearchModal(items, groups, tipo) {
    return new Promise((resolve, reject) => {
      let selectedValue = "";
      let selectedGroup = "";
      const modal = this.createModal();
      const title = document.createElement("h2");
      title.textContent = "Busca o crea tu actividad";
      title.style.textAlign = "center";
      modal.appendChild(title);
      const input = document.createElement("input");
      input.type = "text";
      input.placeholder = "Escribe tu actividad...";
      input.style.width = "80%";
      input.style.textAlign = "center";
      modal.style.display = "flex";
      modal.style.flexDirection = "column";
      modal.style.alignItems = "center";
      modal.appendChild(input);
      const spacer = document.createElement("div");
      spacer.style.height = "16px";
      modal.appendChild(spacer);
      const resultsDiv = document.createElement("div");
      modal.appendChild(resultsDiv);
      function updateResultsDisplay(filteredResults, menuOtro2) {
        resultsDiv.innerHTML = "";
        filteredResults.forEach((result) => {
          const div = document.createElement("div");
          div.textContent = result.value;
          div.style.cursor = "pointer";
          div.onmouseover = () => div.style.backgroundColor = "#f0f0f0";
          div.onmouseout = () => div.style.backgroundColor = "transparent";
          div.onclick = () => {
            selectedValue = result.activity;
            selectedGroup = result.group;
            modal.remove();
            resolve([selectedValue, selectedGroup]);
          };
          resultsDiv.appendChild(div);
        });
        if (filteredResults.length === 0 && input.value.trim() !== "") {
          const createNewDiv = document.createElement("div");
          createNewDiv.textContent = `Crear nueva actividad: "${input.value}"`;
          createNewDiv.style.cursor = "pointer";
          createNewDiv.style.color = "blue";
          createNewDiv.onclick = () => {
            selectedValue = input.value;
            debugger;
            if (tipo == void 0) {
              tipo = "actsTemas";
            }
            selectGroupForNewActivity(menuOtro2, tipo);
          };
          resultsDiv.appendChild(createNewDiv);
        }
      }
      function selectGroupForNewActivity(menuOtro2, tipo2) {
        resultsDiv.innerHTML = "";
        input.remove();
        spacer.remove();
        title.remove();
        const texto = document.createElement("p");
        texto.textContent = `Vamos a crear la actividad: "${selectedValue}". Selecciona un grupo:`;
        ;
        texto.style.textAlign = "center";
        resultsDiv.appendChild(texto);
        groups.forEach((group) => {
          const groupDiv = document.createElement("div");
          groupDiv.textContent = group;
          groupDiv.style.cursor = "pointer";
          groupDiv.onmouseover = () => groupDiv.style.backgroundColor = "#f0f0f0";
          groupDiv.onmouseout = () => groupDiv.style.backgroundColor = "transparent";
          groupDiv.onclick = async () => {
            selectedGroup = group;
            modal.remove();
            let recurrente = await menuOtro2.esRecurrente(selectedValue);
            if (recurrente) {
              await menuOtro2.updateYAMLFields(tipo2, selectedValue, selectedGroup);
            }
            resolve([selectedValue, selectedGroup]);
          };
          resultsDiv.appendChild(groupDiv);
        });
      }
      function displaySelectedValue(activity, group) {
        resultsDiv.innerHTML = `Seleccionado: ${activity} / ${group}`;
      }
      input.oninput = () => {
        const filteredItems = this.filterItems(input.value, items);
        updateResultsDisplay(filteredItems, this);
      };
      document.body.appendChild(modal);
    });
  }
  async esRecurrente(tarea) {
    const opciones = ["Si", "No"];
    const valores = [true, false];
    const placeholder = `${tarea} es tarea recurrente?`;
    const modal = new SeleccionModal(app, opciones, valores, placeholder);
    try {
      return await modal.openAndAwaitSelection();
    } catch (error) {
      console.error("Error o modal cerrado sin selecci\xF3n:", error);
      return false;
    }
  }
};

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// node_modules/luxon/src/zone.js
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class _SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new _SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type: type2, value } = formatted[i];
    const pos = typeToPos[type2];
    if (type2 === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class _IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new _IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = _IANAZone.isValidZone(name);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
var weekInfoCache = {};
function getCachedWeekInfo(locString) {
  let data = weekInfoCache[locString];
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data;
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
var Locale = class _Locale {
  static fromOpts(opts) {
    return _Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return _Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return _Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class _FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new _FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new _FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /** @override **/
  get isUniversal() {
    return true;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset2;
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var defaultWeekSettings = null;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined(obj.localWeekday))
      obj.weekday = obj.localWeekday;
    if (!isUndefined(obj.localWeekNumber))
      obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined(obj.localWeekYear))
      obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class _Formatter {
  static create(locale, opts = {}) {
    return new _Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = _Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/regexParser.js
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  var _a;
  let sum = (_a = vals.milliseconds) != null ? _a : 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits.reduceRight((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class _Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return _Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new _Duration({
      values: normalizeObject(obj, _Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return _Duration.fromMillis(durationLike);
    } else if (_Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return _Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new _Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid)
      return INVALID;
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid)
      return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = _Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = _Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[_Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values, _Duration.normalizeUnit) };
    return clone(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => _Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class _Interval {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new _Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new _Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return _Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return _Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s2, e] = (text || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return _Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return _Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return _Interval.before(end, dur);
        }
      }
    }
    return _Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts == null ? void 0 : opts.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return _Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return _Interval.fromDateTimes(s2, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return _Interval.fromDateTimes(s2, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(_Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return _Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type: type2, value } = part;
  if (type2 === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type2];
  let actualType = type2;
  if (type2 === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}
function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class _DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new _DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return _DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new _DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return _DateTime.invalid("Timestamp out of range");
    } else {
      return new _DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new _DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return _DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return _DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return _DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return _DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new _DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return _DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(_DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return _DateTime.fromFormatExplain(text, fmt, options);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// src/modules/moduloRegistroTiempo/API/menuOtro.ts
var menuOtro = class {
  constructor(plugin) {
    this.pathCampos = "Estructura/Campos Sistema Gestion/Campos Registro Tiempo.md";
    this.selectedActivity = "";
    this.selectedGroup = "";
    this.plugin = plugin;
    this.fuzzySelectOrC = new fuzzySelectOrCreate(this.app, plugin);
  }
  async menuOtro(app2, registro) {
    const opcionesOtro = ["Propias", "Areas de Vida", "Areas de Inter\xE9s", "Proyectos de Q", "Proyectos GTD", "Tema de Inter\xE9s", "Recurso Recurrente"];
    const valoresOtro = ["hab", "actsAV", "actsAI", "actsPQ", "actsPGTD", "actsTI", "actsRR"];
    const placeholderOtro = "\xBFQue categoria?";
    const modalOtro = new SeleccionModal(app2, opcionesOtro, valoresOtro, placeholderOtro);
    let temaOtro;
    let siAsunto = false;
    try {
      const selectionOtro = await modalOtro.openAndAwaitSelection();
      switch (selectionOtro) {
        case "hab":
          temaOtro = await this.habitual(app2);
          break;
        case "actsAV":
        case "actsAI":
        case "actsPQ":
        case "actsPGTD":
        case "actsTI":
        case "actsRR":
          temaOtro = await this.elemSG(app2, selectionOtro);
          siAsunto = true;
          break;
        case "bus":
          break;
      }
    } catch (error) {
      console.error("Error o modal cerrado sin selecci\xF3n:", error);
      registro.detener = true;
      return error;
    }
    debugger;
    return { titulo: temaOtro.actividad + " / " + temaOtro.grupo, siAsunto, nombre: temaOtro.grupo, areaVida: temaOtro.grupo };
  }
  async habitual(app2) {
    const grupos = await this.getFrontmatterField(app2, this.pathCampos, "temas");
    const actsGrupos = await this.resultYaml(app2, "actsTemas");
    let itemsForSearch = actsGrupos.filter((item) => grupos.includes(item.grupo)).map((item) => ({
      value: `${item.actividad} / ${item.grupo}`,
      // Cambia el orden si es necesario
      activity: item.actividad,
      // Usa la propiedad 'actividad' en lugar de item[1]
      group: item.grupo
      // Usa la propiedad 'grupo' en lugar de item[0]
    }));
    let eleccion = await this.fuzzySelectOrC.showFuzzySearchModal(itemsForSearch, grupos);
    let objEleccion = { grupo: eleccion[1], actividad: eleccion[0], nombre: "" };
    return objEleccion;
  }
  async ninguno(app2) {
  }
  async elemSG(app2, tipo) {
    const actividades = await this.resultYaml(app2, tipo);
    const activeSG = await this.findMainFilesWithState(app2, tipo);
    let groups;
    debugger;
    switch (tipo) {
      case "actsAV":
        groups = activeSG.map((page) => page.frontmatter.areaVida);
        break;
      default:
        groups = activeSG.map((page) => page.frontmatter.aliases ? page.frontmatter.aliases[0] : null).filter((alias2) => alias2 !== null);
        break;
    }
    let itemsForSearch = actividades.filter((item) => groups.includes(item.grupo)).map((item) => ({
      value: `${item.actividad} / ${item.grupo}`,
      // Cambia el orden si es necesario
      activity: item.actividad,
      // Usa la propiedad 'actividad' en lugar de item[1]
      group: item.grupo
      // Usa la propiedad 'grupo' en lugar de item[0]
    }));
    let eleccion = await this.fuzzySelectOrC.showFuzzySearchModal(itemsForSearch, groups, tipo);
    const foundElement = activeSG.find((b) => b.frontmatter.aliases[0] === eleccion[1]);
    let alias = foundElement == null ? void 0 : foundElement.file.path;
    let objEleccion = { grupo: eleccion[1], actividad: eleccion[0], nombre: alias };
    return objEleccion;
  }
  async buscar(app2) {
  }
  async resultYaml(app2, tema) {
    var _a;
    const file = app2.vault.getAbstractFileByPath(this.pathCampos);
    try {
      if (file instanceof import_obsidian19.TFile) {
        const metadata = app2.metadataCache.getFileCache(file);
        const arregloResult = ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a[tema]) || [];
        const resultado = [];
        if (Array.isArray(arregloResult)) {
          arregloResult.forEach((item) => {
            if (Array.isArray(item) && item.length >= 2) {
              resultado.push({ grupo: item[0], actividad: item[1] });
            }
          });
        }
        return resultado;
      }
    } catch (error) {
      console.error("Error obteniendo el archivo de campos:", error);
      throw error;
    }
    return [];
  }
  async getFrontmatterField(app2, file, field) {
    try {
      const tFile = app2.vault.getAbstractFileByPath(file);
      if (tFile instanceof import_obsidian19.TFile) {
        const cache = app2.metadataCache.getFileCache(tFile);
        const frontmatter = cache == null ? void 0 : cache.frontmatter;
        if (frontmatter && frontmatter.hasOwnProperty(field)) {
          const fieldValue = frontmatter[field];
          if (fieldValue === void 0 || fieldValue === null || fieldValue === "") {
            console.log("El campo est\xE1 vac\xEDo o no existe.");
            return null;
          } else {
            console.log("Frontmatter consultado con \xE9xito");
            return fieldValue;
          }
        } else {
          console.log("El campo no existe en el frontmatter.");
          return null;
        }
      } else {
        console.error("El archivo no existe o no es un archivo de texto.");
        return null;
      }
    } catch (err) {
      console.error("Error al consultar el frontmatter", err);
      return null;
    }
  }
  // Esta función encuentra los archivos de subsistemas y cuyo estado es 🟢
  async findMainFilesWithState(app2, tipo) {
    var _a;
    const propertiesTipo = {
      actsAV: {
        folder: this.plugin.settings.folder_AreasVida,
        sameName: false,
        nameFile: this.plugin.settings.nameFile_AreasVida
      },
      actsAI: {
        folder: this.plugin.settings.folder_AreasInteres,
        sameName: true,
        nameFile: this.plugin.settings.nameFile_AreasInteres
      },
      actsPQ: {
        folder: this.plugin.settings.folder_ProyectosQ,
        sameName: false,
        nameFile: ""
      },
      actsPGTD: {
        folder: this.plugin.settings.folder_ProyectosGTD,
        sameName: false,
        nameFile: ""
      },
      actsTI: {
        folder: this.plugin.settings.folder_TemasInteres,
        sameName: false,
        nameFile: ""
      },
      actsRR: {
        folder: this.plugin.settings.folder_RecursosRecurrentes,
        sameName: false,
        nameFile: ""
      }
      // Puedes continuar añadiendo más casos aquí
    };
    debugger;
    const activeFilesWithFrontmatter = [];
    switch (tipo) {
      case "actsAV":
        const { folder, sameName, nameFile } = propertiesTipo[tipo];
        let ahora = DateTime.now().toFormat("yyyy-Qq");
        const files = app2.vault.getMarkdownFiles().filter((file) => file.path.includes(folder) && !file.path.includes("Plantillas") && file.name.startsWith(ahora));
        for (let file of files) {
          let metadata = (_a = app2.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if ((metadata == null ? void 0 : metadata.estado) === "\u{1F7E2}") {
            activeFilesWithFrontmatter.push({ file, frontmatter: metadata });
          }
        }
        break;
      default:
        if (propertiesTipo.hasOwnProperty(tipo)) {
          const { folder: folder2, sameName: sameName2, nameFile: nameFile2 } = propertiesTipo[tipo];
          const filesInFolder = app2.vault.getFiles().filter((file) => file.path.startsWith(folder2));
          for (const file of filesInFolder) {
            if (sameName2 && file.basename === nameFile2 || !sameName2) {
              const metadata = app2.metadataCache.getFileCache(file);
              if (metadata.frontmatter && metadata.frontmatter.estado === "\u{1F7E2}") {
                activeFilesWithFrontmatter.push({ file, frontmatter: metadata.frontmatter });
              }
            }
          }
        } else {
          console.log("Selecci\xF3n no reconocida:", tipo);
          return [];
        }
        break;
    }
    return activeFilesWithFrontmatter;
  }
};

// src/modules/moduloRegistroTiempo/API/utilsAPI.ts
var utilsAPI = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.menuOtro = new menuOtro(plugin);
  }
  // La declaración del método estaba asi: buscarRegistrosActivos(app: App, registro: any)
  // Devuelve el file del registro activo. Utilizado para cuando necesito obtener el dato solamente de si hay algún registro activo.
  async buscarRegistrosActivos(app2) {
    var _a;
    const files = app2.vault.getMarkdownFiles();
    const folder = this.plugin.settings.folder_RegistroTiempo;
    for (let file of files) {
      if (file.path.startsWith(folder)) {
        const metadata = app2.metadataCache.getFileCache(file);
        if (((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.estado) === "\u{1F7E2}") {
          return file;
        }
      }
    }
    return;
  }
  // Suponemos que esta función se ubicará en algún lugar donde pueda acceder a `app` de Obsidian.
  async crearObjetoRegistro(plugin) {
    const activo = plugin.app.workspace.getActiveFile();
    if (!activo) {
      console.error(
        "No hay un archivo activo para la creaci\xF3n de registro de tiempo. Se descarta para la creaci\xF3n de registro de tiempo."
      );
      return null;
    }
    const folder = plugin.settings.folder_RegistroTiempo;
    const indice = plugin.settings.indice_RegistroTiempo;
    let maxId = 0;
    const files = app.vault.getMarkdownFiles();
    const registrosExistentes = files.filter(
      (file) => file.path.startsWith(folder)
    );
    registrosExistentes.forEach((file) => {
      var _a;
      const metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (metadata && metadata.id && !isNaN(metadata.id)) {
        const id = parseInt(metadata.id);
        if (id > maxId)
          maxId = id;
      }
    });
    const nextId = maxId + 1;
    const fechaCompleta = this.formatearFecha(/* @__PURE__ */ new Date());
    return {
      activo,
      nombre: activo.basename,
      folder,
      indice,
      id: nextId,
      fecha: fechaCompleta,
      indice_DVJS: `"${indice}"`
    };
  }
  formatearFecha(fecha) {
    const offset2 = fecha.getTimezoneOffset() * 6e4;
    const fechaLocal = new Date(fecha.getTime() - offset2);
    const fechaFormato = fechaLocal.toISOString().split("T")[0];
    const dias = [
      "Domingo",
      "Lunes",
      "Martes",
      "Mi\xE9rcoles",
      "Jueves",
      "Viernes",
      "S\xE1bado"
    ];
    const diaSemana = dias[fecha.getDay()];
    const horaFormato = fecha.toTimeString().split(" ")[0].substring(0, 5);
    return `${fechaFormato} ${diaSemana} ${horaFormato}`;
  }
  // Método que verifica si hay registros ACtivos y pregunta si quiere cerrarlos.
  async verificarTareasActivas(registro, app2) {
    var _a;
    const files = app2.vault.getMarkdownFiles();
    const tareasActivas = [];
    for (let file of files) {
      if (file.path.startsWith(registro.folder)) {
        const metadata = (_a = app2.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        if ((metadata == null ? void 0 : metadata.estado) === "\u{1F7E2}") {
          tareasActivas.push({
            file,
            titulo: metadata.titulo,
            aliases: metadata.aliases || file.basename
          });
        }
      }
    }
    if (tareasActivas.length === 1) {
      const tareaActiva = tareasActivas[0];
      const deseaDetener = await this.mostrarSugerencia(
        `La tarea ${tareaActiva.aliases} est\xE1 corriendo. \xBFDesea detenerla?`
      );
      if (deseaDetener === void 0) {
        new import_obsidian20.Notice(`Creaci\xF3n de registro cancelado por el usuario.`);
        registro.detener = true;
        return;
      }
      if (deseaDetener) {
        debugger;
        const registroTiempoAPInstance = new registroTiempoAPI(this.plugin);
        await registroTiempoAPInstance.cerrarRegistro(tareaActiva.file);
        registro.detener = false;
      } else {
        new import_obsidian20.Notice(`La tarea ${tareaActiva.aliases} seguir\xE1 registr\xE1ndose.`);
        registro.detener = true;
        return;
      }
    } else if (tareasActivas.length > 1) {
      new import_obsidian20.Notice(
        "Hay un error con la cantidad de tareas corriendo en este momento."
      );
      registro.detener = true;
    } else {
      console.log("No hay m\xE1s tareas corriendo.");
      registro.detener = false;
    }
  }
  mostrarSugerencia(mensaje) {
    return new Promise((resolve, reject) => {
      let seleccionado = false;
      const modal = new import_obsidian20.Modal(app);
      modal.contentEl.createEl("h1", { text: mensaje });
      const buttonsContainer = modal.contentEl.createEl("div");
      const hacerSeleccion = (seleccion) => {
        seleccionado = true;
        modal.close();
        resolve(seleccion);
      };
      const yesButton = buttonsContainer.createEl("button", {
        text: "S\xED"
      });
      yesButton.addEventListener("click", () => hacerSeleccion(true));
      const noButton = buttonsContainer.createEl("button", {
        text: "No"
      });
      noButton.addEventListener("click", () => hacerSeleccion(false));
      modal.onClose = () => {
        if (!seleccionado) {
          reject(new Error("Modal cerrado sin selecci\xF3n"));
        }
      };
      modal.contentEl.addEventListener("keydown", (e) => {
        var _a;
        switch (e.key) {
          case "ArrowLeft":
            yesButton.focus();
            break;
          case "ArrowRight":
            noButton.focus();
            break;
          case "Enter":
            (_a = document.activeElement) == null ? void 0 : _a.click();
            break;
        }
      });
      yesButton.focus();
      modal.open();
    });
  }
  async definirTipoRegistro(registro, app2) {
    const totTareas = await this.encontrarTareasPendientes(app2);
    let opcionesTitulo, valoresOpcion;
    if (totTareas.length > 0) {
      opcionesTitulo = [registro.nombre, "Alguna tarea en Ejecuci\xF3n", "Otro"];
      valoresOpcion = ["Nota", "Tarea", "Otro"];
    } else {
      opcionesTitulo = [registro.nombre, "Otro"];
      valoresOpcion = ["Nota", "Otro"];
    }
    const placeholder = "\xBFSobre qu\xE9 es el registro de tiempo?";
    const modalMenu1 = new SeleccionModal(
      app2,
      opcionesTitulo,
      valoresOpcion,
      placeholder
    );
    try {
      const selection = await modalMenu1.openAndAwaitSelection();
      registro.tipoRegistro = selection;
      switch (registro.tipoRegistro) {
        case "Nota":
          registro.titulo = registro.nombre;
          registro.siAsunto = true;
          debugger;
          registro = this.copiarCampos(registro);
          break;
        case "Tarea":
          await this.elegirTareaParaRegistro(app2, registro, totTareas);
          break;
        default:
          let respuesta = await this.menuOtro.menuOtro(app2, registro);
          debugger;
          Object.assign(registro, respuesta);
          break;
      }
    } catch (error) {
      console.error("Error o modal cerrado sin selecci\xF3n:", error);
    }
  }
  copiarCampos(registro) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    let nombre = registro.activo.basename;
    let nota = app.metadataCache.getFileCache(registro.activo);
    if (((_a = nota.frontmatter) == null ? void 0 : _a.type) === "PQ") {
      registro.proyectoQ = nombre;
      registro.proyectoGTD = "";
      if (Array.isArray(nota.frontmatter.proyectoGTD)) {
        registro.proyectoGTD = nota.frontmatter.proyectoGTD.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
      } else if (nota.frontmatter.proyectoGTD) {
        registro.proyectoGTD = nota.frontmatter.proyectoGTD.replace(/\[\[\s*|\s*\]\]/g, "");
      }
    } else if (((_b = nota.frontmatter) == null ? void 0 : _b.type) === "PGTD") {
      registro.proyectoGTD = [nombre];
      if (Array.isArray(nota.frontmatter.proyectoGTD)) {
        registro.proyectoGTD = registro.proyectoGTD.concat(nota.frontmatter.proyectoGTD.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
      } else if (nota.frontmatter.proyectoGTD) {
        registro.proyectoGTD.push(nota.frontmatter.proyectoGTD.replace(/\[\[\s*|\s*\]\]/g, ""));
      }
      registro.proyectoQ = "";
      if (Array.isArray(nota.frontmatter.proyectoQ)) {
        registro.proyectoQ = nota.frontmatter.proyectoQ.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
      } else if (nota.frontmatter.proyectoQ) {
        registro.proyectoQ = nota.frontmatter.proyectoQ.replace(/\[\[\s*|\s*\]\]/g, "");
      }
    } else {
      registro.proyectoQ = "";
      if (Array.isArray((_c = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _c.proyectoQ)) {
        registro.proyectoQ = nota.frontmatter.proyectoQ.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
      } else if ((_d = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _d.proyectoQ) {
        registro.proyectoQ = nota.frontmatter.proyectoQ.replace(/\[\[\s*|\s*\]\]/g, "");
      }
      registro.proyectoGTD = "";
      if (Array.isArray((_e = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _e.proyectoGTD)) {
        registro.proyectoGTD = nota.frontmatter.proyectoGTD.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
      } else if ((_f = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _f.proyectoGTD) {
        registro.proyectoGTD = nota.frontmatter.proyectoGTD.replace(/\[\[\s*|\s*\]\]/g, "");
      }
    }
    registro.areaInteres = [];
    if (Array.isArray((_g = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _g.areaInteres)) {
      registro.areaInteres = registro.areaInteres.concat(nota.frontmatter.areaInteres.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
    } else {
      if ((_h = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _h.areaInteres) {
        registro.areaInteres.push(nota.frontmatter.areaInteres.replace(/\[\[\s*|\s*\]\]/g, ""));
      }
    }
    registro.areaVida = "";
    if ((_i = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _i.areaVida) {
      if (Array.isArray(nota.frontmatter.areaVida)) {
        registro.areaVida = nota.frontmatter.areaVida[0].replace(/\[\[\s*|\s*\]\]/g, "");
      } else if (typeof nota.frontmatter.areaVida === "string") {
        registro.areaVida = nota.frontmatter.areaVida.replace(/\[\[\s*|\s*\]\]/g, "");
      }
    } else {
      registro.areaVida = "No es de ning\xFAn Area de Vida";
    }
    return registro;
  }
  async encontrarTareasPendientes(app2) {
    let tareasPendientes = [];
    const archivos = app2.vault.getMarkdownFiles();
    const archivosRelevantes = archivos.filter(
      (archivo) => !archivo.path.includes("Plantillas")
    );
    for (const archivo of archivosRelevantes) {
      const contenido = await app2.vault.read(archivo);
      const coincidencias = contenido.match(/^ *- \[\/\] .*/gm) || [];
      const tareasConArchivo = coincidencias.map((tarea) => {
        return { tarea: tarea.trim(), archivo };
      });
      tareasPendientes = tareasPendientes.concat(tareasConArchivo);
    }
    return tareasPendientes;
  }
  async elegirTareaParaRegistro(app2, registro, tareasPendientes) {
    const placeholder = "Elige la tarea que vas a registrar.";
    let promesasLimpias = tareasPendientes.map(
      (tareaObj) => this.limpiarTextoTarea(tareaObj.tarea)
    );
    try {
      const tareasLimpias = await Promise.all(promesasLimpias);
      const tareasLimpiasConArchivo = tareasPendientes.map(
        (tareaObj, index) => {
          return {
            tarea: tareasLimpias[index],
            // Tarea limpia
            archivo: tareaObj.archivo
            // Referencia al archivo original
          };
        }
      );
      const longitud = tareasLimpiasConArchivo.length;
      const arregloDeIndices = Array.from(
        { length: longitud },
        (_, indice) => indice
      );
      const modalMenu = new SeleccionModal(
        app2,
        tareasLimpiasConArchivo.map((b) => b.tarea),
        arregloDeIndices,
        placeholder
      );
      try {
        const selectedIndex = await modalMenu.openAndAwaitSelection();
        const seleccion = tareasLimpiasConArchivo[selectedIndex];
        registro.titulo = seleccion.tarea;
        registro.nombre = seleccion.archivo.basename;
        registro.siAsunto = true;
      } catch (error) {
        registro.detener = true;
        console.error("Error o modal cerrado sin selecci\xF3n:", error);
      }
    } catch (error) {
      console.error("Hubo un error al limpiar las tareas:", error);
    }
  }
  limpiarTextoTarea(titulo) {
    return new Promise((resolve) => {
      let textoLimpio = titulo.split("\n")[0];
      textoLimpio = textoLimpio.replace(/#[\w-/]+/g, "");
      textoLimpio = textoLimpio.replace(/\[\w+::[^\]]+\]/g, "");
      textoLimpio = textoLimpio.replace(/^\s*-\s*\[\/\]\s*/, "");
      const caracteresNoPermitidos = /[<>:"\/\\|?*\x00-\x1F]/g;
      textoLimpio = textoLimpio.replace(caracteresNoPermitidos, "_");
      textoLimpio = textoLimpio.replace(/\s+/g, " ");
      resolve(textoLimpio.trim());
    });
  }
  async construirNombreyAlias(registro, app2) {
    let nombreBase = `${registro.folder}/RT - ${registro.id}`;
    let aliasLimpio = this.limpiarAlias(registro.titulo);
    aliasLimpio = aliasLimpio.length > 195 ? aliasLimpio.slice(0, 195) : aliasLimpio;
    const archivos = app2.vault.getFiles();
    let registrosConMismoTitulo = [];
    for (const archivo of archivos) {
      if (archivo.path.startsWith(registro.folder)) {
        const metadatos = app2.metadataCache.getFileCache(archivo);
        if (metadatos && metadatos.frontmatter && metadatos.frontmatter.titulo === registro.titulo) {
          const idSec = metadatos.frontmatter.idSec;
          if (idSec !== void 0) {
            registrosConMismoTitulo.push({ archivo, idSec });
          }
        }
      }
    }
    debugger;
    registrosConMismoTitulo.sort((b) => b.idSec, "desc");
    registro.idSec = registrosConMismoTitulo.length > 0 ? parseInt(registrosConMismoTitulo[0].idSec) + 1 : 1;
    if (registro.idSec > 1) {
      aliasLimpio += ` - ${registro.idSec}`;
    }
    registro.aliases = [];
    registro.aliases.push(`RT - ${aliasLimpio}`);
    if (registro.tipoRegistro === "Nota") {
      const archivoActivo = app2.workspace.getActiveFile();
      if (!archivoActivo)
        return;
      const metadatosActivo = app2.metadataCache.getFileCache(archivoActivo);
      const aliasesActivo = metadatosActivo && metadatosActivo.frontmatter ? metadatosActivo.frontmatter.aliases : void 0;
      if (aliasesActivo) {
        const additionalAliases = Array.isArray(aliasesActivo) ? aliasesActivo : [aliasesActivo];
        additionalAliases.forEach((alias) => {
          registro.aliases.push(`RT - ${alias}`);
        });
      }
    }
    registro.nameFile = nombreBase;
  }
  limpiarAlias(titulo) {
    const caracteresNoPermitidos = /[<>:"\/\\|?*\x00-\x1F]/g;
    let tituloLimpio = titulo.replace(caracteresNoPermitidos, "_");
    tituloLimpio = tituloLimpio.replace(/\s+/g, " ");
    return tituloLimpio.trim();
  }
};

// src/modules/moduloRegistroTiempo/API/registroTiempoAPI.ts
var import_obsidian21 = require("obsidian");
var registroTiempoAPI = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.plugin = plugin;
    this.utilsApi = new utilsAPI(plugin);
  }
  async iniciarRegistro() {
    try {
      const registro = await this.utilsApi.crearObjetoRegistro(this.plugin);
      await this.utilsApi.verificarTareasActivas(registro, this.plugin.app);
      if (registro.detener) {
        return registro;
      }
      await this.utilsApi.definirTipoRegistro(registro, this.plugin.app);
      if (registro.detener) {
        return registro;
      }
      await this.utilsApi.construirNombreyAlias(registro, this.plugin.app);
      return registro;
    } catch (error) {
      new Notice("No se pudo crear el objeto de registro.");
      return null;
    }
  }
  // Invocado desde el template de templater Paso 3 de 3
  async retomarRegistro(id) {
    var _a;
    const folder = this.plugin.settings.folder_RegistroTiempo;
    try {
      const registro = await this.utilsApi.crearObjetoRegistro(this.plugin);
      await this.utilsApi.verificarTareasActivas(registro, this.plugin.app);
      if (registro.detener) {
        return registro;
      }
      const files = app.vault.getMarkdownFiles();
      let registroAntiguo;
      for (let file of files) {
        if (file.path.startsWith(folder)) {
          const metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if ((metadata == null ? void 0 : metadata.id) === parseInt(id)) {
            registroAntiguo = { file, frontmatter: metadata };
          }
        }
      }
      debugger;
      registro.titulo = (registroAntiguo == null ? void 0 : registroAntiguo.frontmatter.titulo) ? registroAntiguo.frontmatter.titulo : "Sin Titulo";
      registro.asuntoRetomado = (registroAntiguo == null ? void 0 : registroAntiguo.frontmatter.asunto) ? registroAntiguo.frontmatter.asunto : null;
      await this.utilsApi.construirNombreyAlias(registro, this.plugin.app);
      return registro;
    } catch (error) {
      new Notice("No se pudo crear el objeto de registro.");
      return null;
    }
  }
  // Invocado para crear el template de Retomar Paso 1 de 3
  async retomarTarea(id) {
    debugger;
    const filePath = `Plantillas/${this.plugin.settings[`folder_RegistroTiempo`]}/Plt - RegistroTiempo.md`;
    const template = app.vault.getAbstractFileByPath(filePath);
    if (template instanceof import_obsidian21.TFile) {
      console.log("Archivo encontrado:", template);
    } else {
      console.log("Archivo no encontrado.");
    }
    const filename = "Retomar " + id;
    const folder = app.vault.getAbstractFileByPath("Inbox");
    const tp = this.getTp();
    let crearNota = tp.file.static_functions.get("create_new");
    await crearNota(template, filename, false, folder).basename;
  }
  // Implementación del método con unión de tipos para el parámetro id
  async cerrarRegistro(registro) {
    var _a, _b, _c;
    const folder = this.plugin.settings.folder_RegistroTiempo;
    if (typeof registro === "string") {
      registro = parseInt(registro);
    }
    if (typeof registro === "number") {
      const files = app.vault.getMarkdownFiles();
      let infoNota;
      for (let file of files) {
        if (file.path.startsWith(folder)) {
          const metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if ((metadata == null ? void 0 : metadata.id) === registro) {
            infoNota = { file };
            Object.assign(infoNota, metadata);
          }
        }
      }
      let campos = ["fecha", "horaFinal", "tiempoTrabajado"];
      let resultado = await this.plugin.YAMLUpdaterAPI.archivarNota(infoNota, campos);
      let textoResultado = Object.entries(resultado).map(([propiedad, valor]) => `${propiedad}: ${valor}`).join(", ");
      new Notice(`Tarea cerrada. Campos actualizados: ${textoResultado}`);
    } else if (registro instanceof import_obsidian21.TFile) {
      const metadata = (_b = app.metadataCache.getFileCache(registro)) == null ? void 0 : _b.frontmatter;
      let infoNota = { file: registro };
      Object.assign(infoNota, metadata);
      let campos = ["fecha", "horaFinal", "tiempoTrabajado"];
      let resultado = await this.plugin.YAMLUpdaterAPI.archivarNota(infoNota, campos);
      let textoResultado = Object.entries(resultado).map(([propiedad, valor]) => `${propiedad}: ${valor}`).join(", ");
      new Notice(`Tarea cerrada. Campos actualizados: ${textoResultado}`);
    } else {
      const registro2 = await this.utilsApi.buscarRegistrosActivos(app);
      const metadata = (_c = app.metadataCache.getFileCache(registro2)) == null ? void 0 : _c.frontmatter;
      let infoNota = { file: registro2 };
      Object.assign(infoNota, metadata);
      let campos = ["fecha", "horaFinal", "tiempoTrabajado"];
      let resultado = await this.plugin.YAMLUpdaterAPI.archivarNota(infoNota, campos);
      let textoResultado = Object.entries(resultado).map(([propiedad, valor]) => `${propiedad}: ${valor}`).join(", ");
      new Notice(`Tarea cerrada. Campos actualizados: ${textoResultado}`);
    }
  }
  // Implementación del método con unión de tipos para el parámetro id
  async detalleRegistro(registro) {
    var _a, _b, _c;
    const folder = this.plugin.settings.folder_RegistroTiempo;
    let infoNota;
    debugger;
    if (typeof registro === "string") {
      registro = parseInt(registro);
    }
    if (typeof registro === "number") {
      const files = app.vault.getMarkdownFiles();
      for (let file of files) {
        if (file.path.startsWith(folder)) {
          const metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if ((metadata == null ? void 0 : metadata.id) === registro) {
            infoNota = { file };
            Object.assign(infoNota, metadata);
          }
        }
      }
    } else if (registro instanceof import_obsidian21.TFile) {
      const metadata = (_b = app.metadataCache.getFileCache(registro)) == null ? void 0 : _b.frontmatter;
      infoNota = { file: registro };
      Object.assign(infoNota, metadata);
    } else {
      const registro2 = await this.utilsApi.buscarRegistrosActivos(app);
      const metadata = (_c = app.metadataCache.getFileCache(registro2)) == null ? void 0 : _c.frontmatter;
      infoNota = { file: registro2 };
      Object.assign(infoNota, metadata);
    }
    let campos = ["descripcion_RegistroTiempo"];
    debugger;
    let resultado = await this.plugin.YAMLUpdaterAPI.actualizarNota(infoNota, campos);
    let textoResultado = Object.entries(resultado).map(([propiedad, valor]) => `${propiedad}: ${valor}`).join(", ");
    new Notice(`Descripci\xF3n actualizada: ${textoResultado}`);
  }
  getTp() {
    if (!this.plugin || !this.plugin.app.plugins.enabledPlugins.has("templater-obsidian")) {
      console.error("El plugin Templater no est\xE1 habilitado.");
      return;
    }
    let tpGen = this.plugin.app.plugins.plugins["templater-obsidian"].templater;
    tpGen = tpGen.functions_generator.internal_functions.modules_array;
    let tp = {};
    tp.file = tpGen.find((m) => m.name == "file");
    tp.system = tpGen.find((m) => m.name == "system");
    if (!tp.file) {
      console.error("No se pudo acceder al objeto de funciones actuales de Templater.");
      return;
    }
    console.log('tp con propiedades "file" se ha cargado satisfactoriamente');
    return tp;
  }
};

// src/modules/noteLifecycleManager/API/starterAPI.ts
var import_obsidian22 = require("obsidian");
var starterAPI = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.infoSubsistema = {};
    this.nota = {};
    this.tp = this.getTp();
    this.pathCampos = this.plugin.settings.file_camposCentral + ".md";
  }
  // Crear Nota desde template
  async createNote(subsistema) {
    try {
      debugger;
      const templatePath = `Plantillas/${this.plugin.settings[`folder_${subsistema}`]}/Plt - ${subsistema}.md`;
      const templateFile = app.vault.getAbstractFileByPath(templatePath);
      if (!(templateFile instanceof import_obsidian22.TFile)) {
        throw new Error(`El template para "${subsistema}" no se encontr\xF3 o no es un archivo v\xE1lido.`);
      }
      const dtConseq = DateTime.now().toFormat("yyyy-MM-dd HHmmss");
      const filename = `${subsistema} ${dtConseq}`;
      const folder = app.vault.getAbstractFileByPath("Inbox");
      if (!folder) {
        throw new Error(`La carpeta "Inbox" no se encontr\xF3.`);
      }
      const tp = this.getTp();
      let crearNota = tp.file.static_functions.get("create_new");
      if (typeof crearNota !== "function") {
        throw new Error("La funci\xF3n para crear notas no est\xE1 disponible.");
      }
      await crearNota(templateFile, filename, true, folder).basename;
    } catch (error) {
      console.error(error);
      alert(`Error al crear la nota: ${error.message}`);
    }
  }
  // crearNota -> Llenar los campos YAML del template.
  async fillNote(infoSubsistema, campos) {
    this.nota = {};
    Object.assign(this.infoSubsistema, infoSubsistema);
    if (this.infoSubsistema.defined) {
      this.infoSubsistema.folder = this.plugin.settings[infoSubsistema.folder];
      this.infoSubsistema.indice = this.plugin.settings[infoSubsistema.indice];
      Object.assign(this.nota, infoSubsistema);
    }
    try {
      for (let campo of campos) {
        debugger;
        const functionName = `get${campo.charAt(0).toUpperCase() + campo.slice(1)}`;
        if (typeof this[functionName] === "function") {
          this.nota[campo] = await this[functionName]();
        } else {
          console.error(`La funci\xF3n ${functionName} no est\xE1 definida.`);
        }
      }
    } catch (error) {
      console.error("No se pudo crear el objeto de registro.", error);
      new import_obsidian22.Notice("No se pudo crear el objeto de registro.");
      return null;
    }
    return this.nota;
  }
  getTp() {
    if (!this.plugin || !this.plugin.app.plugins.enabledPlugins.has("templater-obsidian")) {
      console.error("El plugin Templater no est\xE1 habilitado.");
      return;
    }
    let tpGen = this.plugin.app.plugins.plugins["templater-obsidian"].templater;
    tpGen = tpGen.functions_generator.internal_functions.modules_array;
    let tp = {};
    tp.file = tpGen.find((m) => m.name == "file");
    tp.system = tpGen.find((m) => m.name == "system");
    if (!tp.system) {
      console.error("No se pudo acceder al objeto de funciones actuales de Templater.");
      return;
    }
    console.log("tp en YAMLUpdaterAPI se ha cargado satisfactoriamente");
    return tp;
  }
  // Ejemplo de función getCampo simulada. Debes definir funciones similares para 'id', 'fecha', etc.
  async getId() {
    let maxId = 0;
    const files = app.vault.getMarkdownFiles();
    let registrosExistentes = files.filter((file) => file.path.startsWith(this.infoSubsistema.folder));
    switch (this.infoSubsistema.type) {
      case "nAV":
      case "AV":
        registrosExistentes.forEach((file) => {
          var _a;
          const metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if (metadata && metadata.id && !isNaN(metadata.id) && metadata.type && metadata.type === this.infoSubsistema.type) {
            const id = parseInt(metadata.id);
            if (id > maxId)
              maxId = id;
          }
        });
        break;
      default:
        registrosExistentes.forEach((file) => {
          var _a;
          const metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if (metadata && metadata.id && !isNaN(metadata.id)) {
            const id = parseInt(metadata.id);
            if (id > maxId)
              maxId = id;
          }
        });
        break;
    }
    const nextId = maxId + 1;
    return nextId;
  }
  async getFecha() {
    let fecha;
    let prompt = this.tp.system.static_functions.get("prompt");
    switch (this.infoSubsistema.type) {
      case "Tx":
        let fechaOriginal = await prompt(`Confirma la fecha de la transacci\xF3n: `, `${DateTime.now().toFormat("yyyy-MM-dd HH:mm")}`, true);
        let fechaMoment = window.moment(fechaOriginal, "YYYY-MM-DD HH:mm");
        fecha = fechaMoment.format("YYYY-MM-DD dddd HHmmss");
      default:
        fecha = this.formatearFecha(/* @__PURE__ */ new Date());
        break;
    }
    return fecha;
  }
  formatearFecha(fecha) {
    const offset2 = fecha.getTimezoneOffset() * 6e4;
    const fechaLocal = new Date(fecha.getTime() - offset2);
    const fechaFormato = fechaLocal.toISOString().split("T")[0];
    const dias = ["Domingo", "Lunes", "Martes", "Mi\xE9rcoles", "Jueves", "Viernes", "S\xE1bado"];
    const diaSemana = dias[fecha.getDay()];
    const horaFormato = fecha.toTimeString().split(" ")[0].substring(0, 5);
    return `${fechaFormato} ${diaSemana} ${horaFormato}`;
  }
  async getSecId() {
  }
  async getTitulo() {
    let prompt = this.tp.system.static_functions.get("prompt");
    let titulo;
    switch (this.infoSubsistema.type) {
      case "Tx":
        titulo = await prompt(`Nombre de este(a) ${this.infoSubsistema.typeName}`, `${this.infoSubsistema.typeName} - ${this.nota.id}`, true);
        break;
      case "OCA":
        titulo = await prompt(`Cual es tu objetivo en ${this.nota.a\u00F1o} para ${this.nota.areaVida}?`, `Voy a `, true, true);
        break;
      default:
        titulo = await prompt(`Titulo de este(a) ${this.infoSubsistema.typeName}`, `${this.infoSubsistema.typeName} - ${this.nota.id}`, true);
        break;
    }
    if (titulo === null) {
      new import_obsidian22.Notice("Creaci\xF3n de nota cancelada por el usuario.");
      return;
    }
    return titulo;
  }
  async getDescripcion() {
    let prompt = this.tp.system.static_functions.get("prompt");
    let descripcion;
    switch (this.infoSubsistema.type) {
      case "Ax":
        descripcion = await prompt("\xBFQuieres agregar una descripci\xF3n?", ` Esta anotaci\xF3n es sobre ${this.nota.titulo}`, false, true);
        break;
      case "Tx":
        descripcion = await prompt(`\xBFQuieres agregar una descripci\xF3n de ${this.nota.titulo}?`, ` ${this.infoSubsistema.typeName} de ${this.nota.titulo}`, false, true);
        break;
      case "AV":
        descripcion = await prompt(`\xBFQuieres agregar una descripci\xF3n sobre ${this.nota.titulo}?`, " ", false, true);
        break;
      case "AI":
        descripcion = await prompt(`\xBFQuieres agregar una descripci\xF3n sobre ${this.nota.titulo}?`, " ", false, true);
        break;
      case "PGTD":
        descripcion = await prompt("\xBFSobre que es este proyecto GTD?", ` Proyecto sobre `, false, true);
        break;
      case "OCA":
        descripcion = await prompt("\xBFQuieres agregar detalles de tu objetivo?", `${this.nota.titulo}`, false, true);
        break;
      default:
        descripcion = await prompt("\xBFQuieres agregar una descripci\xF3n?", ` Esta nota es sobre ${this.nota.titulo}`, false, true);
        break;
    }
    if (descripcion === null) {
      new import_obsidian22.Notice("Creaci\xF3n de nota cancelada por el usuario.");
      return;
    }
    return descripcion;
  }
  async getAliases() {
    let nota = { aliases: [] };
    switch (this.infoSubsistema.type) {
      case "Ax":
      case "PGTD":
      case "Tx":
      case "CPE":
        nota.aliases.push(`${this.nota.titulo}`);
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.titulo}`);
        break;
      case "AI":
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.titulo}`);
        if (this.nota.areaVida != "No es de ning\xFAn Area de Vida") {
          nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.areaVida}/${this.nota.titulo}`);
        }
        break;
      case "nAV":
        nota.aliases.push(`AV/${this.nota.areaVida}`);
        nota.aliases.push(`AV/${this.nota.grupo}/${this.nota.areaVida}`);
        break;
      case "AV":
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.trimestre}/${this.nota.titulo}`);
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.grupo}/${this.nota.trimestre}/${this.nota.titulo}`);
        break;
      case "RR":
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.titulo}`);
        break;
      case "PQ":
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.trimestre}/${this.nota.titulo}`);
        nota.aliases.push(`${this.infoSubsistema.type}/${Array.isArray(this.nota.areaVida) ? this.nota.areaVida[0] : this.nota.areaVida}/${this.nota.trimestre}/${this.nota.titulo}`);
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.trimestre}/${Array.isArray(this.nota.areaVida) ? this.nota.areaVida[0] : this.nota.areaVida}/${this.nota.titulo}`);
        break;
      case "OCA":
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.a\u00F1o}/${this.nota.id}`);
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.a\u00F1o}/${this.nota.areaVida}/${this.nota.id}`);
        nota.aliases.push(`${this.infoSubsistema.type}/${this.nota.titulo}`);
        break;
      case "CAI":
        nota.aliases.push(`${this.infoSubsistema.typeName}/${this.nota.a\u00F1o}`);
        nota.aliases.push(`${this.infoSubsistema.typeName}/${this.nota.id}`);
        break;
      case "CTI":
        nota.aliases.push(`${this.infoSubsistema.typeName}/${this.nota.trimestre}`);
        nota.aliases.push(`${this.infoSubsistema.typeName}/${this.nota.id}`);
        break;
    }
    return nota.aliases;
  }
  async getAsunto() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D;
    let suggester = this.tp.system.static_functions.get("suggester");
    let tipoSistema = this.infoSubsistema.type;
    let nombreSistema = this.infoSubsistema.typeName;
    let subsistemas, padres = [];
    let activo = app.workspace.getActiveFile();
    let siAsunto = false;
    let nombre = "";
    let nota;
    if (activo != null) {
      nombre = activo.basename;
      nota = app.metadataCache.getFileCache(activo);
      nota.frontmatter = nota.frontmatter || {};
      nota.frontmatter.file = {};
      Object.assign(nota.frontmatter.file, activo);
      padres.unshift(nombre);
      switch (tipoSistema) {
        case "RR":
        case "PGTD":
        case "Ax":
        case "Tx":
        case "CPE":
          siAsunto = await suggester(["Si", "No"], [true, false], true, nombre + " es origen de " + this.nota.titulo + "?");
          if (siAsunto) {
            debugger;
            this.nota.asuntoDefinido = true;
            let nivel2;
            switch ((_a = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _a.type) {
              default:
              case "PGTD":
              case "PQ":
                if (((_b = nota.frontmatter) == null ? void 0 : _b.type) === "PQ") {
                  this.nota.proyectoQ = nombre;
                  this.nota.proyectoGTD = "";
                  if (Array.isArray(nota.frontmatter.proyectoGTD)) {
                    this.nota.proyectoGTD = nota.frontmatter.proyectoGTD.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
                  } else if (nota.frontmatter.proyectoGTD) {
                    this.nota.proyectoGTD = nota.frontmatter.proyectoGTD.replace(/\[\[\s*|\s*\]\]/g, "");
                  }
                } else if (((_c = nota.frontmatter) == null ? void 0 : _c.type) === "PGTD") {
                  this.nota.proyectoGTD = [nombre];
                  if (Array.isArray(nota.frontmatter.proyectoGTD)) {
                    this.nota.proyectoGTD = this.nota.proyectoGTD.concat(nota.frontmatter.proyectoGTD.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
                  } else if (nota.frontmatter.proyectoGTD) {
                    this.nota.proyectoGTD.push(nota.frontmatter.proyectoGTD.replace(/\[\[\s*|\s*\]\]/g, ""));
                  }
                  this.nota.proyectoQ = "";
                  if (Array.isArray(nota.frontmatter.proyectoQ)) {
                    this.nota.proyectoQ = nota.frontmatter.proyectoQ.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
                  } else if (nota.frontmatter.proyectoQ) {
                    this.nota.proyectoQ = nota.frontmatter.proyectoQ.replace(/\[\[\s*|\s*\]\]/g, "");
                  }
                } else {
                  this.nota.proyectoQ = "";
                  if (Array.isArray((_d = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _d.proyectoQ)) {
                    this.nota.proyectoQ = nota.frontmatter.proyectoQ.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
                  } else if ((_e = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _e.proyectoQ) {
                    this.nota.proyectoQ = nota.frontmatter.proyectoQ.replace(/\[\[\s*|\s*\]\]/g, "");
                  }
                  this.nota.proyectoGTD = "";
                  if (Array.isArray((_f = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _f.proyectoGTD)) {
                    this.nota.proyectoGTD = nota.frontmatter.proyectoGTD.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
                  } else if ((_g = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _g.proyectoGTD) {
                    this.nota.proyectoGTD = nota.frontmatter.proyectoGTD.replace(/\[\[\s*|\s*\]\]/g, "");
                  }
                }
                this.nota.areaInteres = [];
                if (Array.isArray((_h = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _h.areaInteres)) {
                  this.nota.areaInteres = this.nota.areaInteres.concat(nota.frontmatter.areaInteres.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
                } else {
                  if ((_i = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _i.areaInteres) {
                    this.nota.areaInteres.push(nota.frontmatter.areaInteres.replace(/\[\[\s*|\s*\]\]/g, ""));
                  }
                }
                this.nota.areaVida = "";
                if ((_j = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _j.areaVida) {
                  if (Array.isArray(nota.frontmatter.areaVida)) {
                    this.nota.areaVida = nota.frontmatter.areaVida[0].replace(/\[\[\s*|\s*\]\]/g, "");
                  } else if (typeof nota.frontmatter.areaVida === "string") {
                    this.nota.areaVida = nota.frontmatter.areaVida.replace(/\[\[\s*|\s*\]\]/g, "");
                  }
                } else {
                  this.nota.areaVida = "No es de ning\xFAn Area de Vida";
                }
                if (!isNaN(parseInt((_k = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _k.nivelP))) {
                  nivel2 = parseInt(nota.frontmatter.nivelP) + 1;
                } else {
                  nivel2 = 0;
                }
                this.nota.nivelP = nivel2;
                break;
              case "AI":
                debugger;
                if (((_l = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _l.type) === "AI") {
                  this.nota.areaInteres = [nota.frontmatter.file.basename];
                }
                if (Array.isArray((_m = nota.frontmatter) == null ? void 0 : _m.areaInteres)) {
                  this.nota.areaInteres = this.nota.areaInteres.concat(nota.frontmatter.areaInteres.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
                } else {
                  if (nota == null ? void 0 : nota.frontmatter.areaInteres) {
                    this.nota.areaInteres.push(nota.frontmatter.areaInteres.replace(/\[\[\s*|\s*\]\]/g, ""));
                  } else {
                  }
                }
              case "AV":
                if ((_n = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _n.areaVida) {
                  if (Array.isArray(nota.frontmatter.areaVida)) {
                    this.nota.areaVida = nota.frontmatter.areaVida[0].replace(/\[\[\s*|\s*\]\]/g, "");
                  } else if (typeof nota.frontmatter.areaVida === "string") {
                    this.nota.areaVida = nota.frontmatter.areaVida.replace(/\[\[\s*|\s*\]\]/g, "");
                  }
                } else {
                  this.nota.areaVida = "No es de ning\xFAn \xC1rea de Vida";
                }
                if (((_o = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _o.type) === "AI" || ((_p = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _p.type) === "AV") {
                  siAsunto = false;
                }
                if (!isNaN(parseInt((_q = nota.frontmatter) == null ? void 0 : _q.nivelP))) {
                  nivel2 = parseInt(nota.frontmatter.nivelP) + 1;
                } else {
                  nivel2 = 0;
                }
                this.nota.nivelP = nivel2;
                break;
            }
          } else {
          }
          break;
        case "PQ":
          siAsunto = await suggester(["Si", "No"], [true, false], true, nombre + " es origen de " + this.nota.titulo + "?");
          if (siAsunto) {
            debugger;
            if (((_r = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _r.areaVida) !== void 0 && nota.frontmatter.areaVida !== "") {
              if (Array.isArray(nota.frontmatter.areaVida)) {
                this.nota.areaVida = nota.frontmatter.areaVida[0].replace(/\[\[\s*|\s*\]\]/g, "");
              } else if (typeof nota.frontmatter.areaVida === "string") {
                this.nota.areaVida = nota.frontmatter.areaVida.replace(/\[\[\s*|\s*\]\]/g, "");
              }
              if (((_s = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _s.type) === "AI" || ((_t = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _t.type) === "AV") {
                siAsunto = false;
              }
              let nivel2;
              switch ((_u = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _u.type) {
                case "PGTD":
                  this.nota.proyectoGTD = [nombre];
                  if (Array.isArray(nota.frontmatter.proyectoGTD)) {
                    this.nota.proyectoGTD = this.nota.proyectoGTD.concat(nota.frontmatter.proyectoGTD.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
                  } else if (nota.frontmatter.proyectoGTD) {
                    this.nota.proyectoGTD.push(nota.frontmatter.proyectoGTD.replace(/\[\[\s*|\s*\]\]/g, ""));
                  }
                case "AI":
                  if (((_v = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _v.type) === "AI") {
                    this.nota.areaInteres = [nota.frontmatter.file.basename];
                  } else {
                    this.nota.areaInteres = [];
                  }
                  if (Array.isArray((_w = nota.frontmatter) == null ? void 0 : _w.areaInteres)) {
                    this.nota.areaInteres = this.nota.areaInteres.concat(nota.frontmatter.areaInteres.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
                  } else {
                    if (nota == null ? void 0 : nota.frontmatter.areaInteres) {
                      this.nota.areaInteres.push(nota.frontmatter.areaInteres.replace(/\[\[\s*|\s*\]\]/g, ""));
                    } else {
                      this.nota.areaInteres = "";
                    }
                  }
                case "AV":
                case "nAV":
                  if (!isNaN(parseInt((_x = nota.frontmatter) == null ? void 0 : _x.nivelP))) {
                    nivel2 = parseInt(nota.frontmatter.nivelP) + 1;
                  } else {
                    nivel2 = 0;
                  }
                  this.nota.nivelP = nivel2;
                  this.nota.asuntoDefinido = true;
                  break;
                default:
                  new import_obsidian22.Notice("Un Proyecto de Q solo puede iniciar de un AV, AI o PGTD. Asunto no definido.");
                  break;
              }
            } else {
              new import_obsidian22.Notice("Todos los proyectos de Q requieren Area de Vida. Asunto no definido.");
              siAsunto = false;
            }
          } else {
          }
          break;
        case "AI":
          let nivel;
          switch ((_y = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _y.type) {
            case "AI":
            case "AV":
            case "nAV":
              siAsunto = await suggester(["Si", "No"], [true, false], true, nombre + " es origen de " + this.nota.titulo + "?");
              if (siAsunto) {
                this.nota.asuntoDefinido = true;
                if (((_z = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _z.type) === "AI") {
                  this.nota.areaInteres = [nota.frontmatter.file.basename];
                  if (Array.isArray(nota.frontmatter.areaInteres)) {
                    this.nota.areaInteres = this.nota.areaInteres.concat(nota.frontmatter.areaInteres.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
                  } else {
                    if (nota == null ? void 0 : nota.frontmatter.areaInteres) {
                      this.nota.areaInteres.push(nota.frontmatter.areaInteres.replace(/\[\[\s*|\s*\]\]/g, ""));
                    }
                  }
                }
                if ((_A = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _A.areaVida) {
                  if (Array.isArray(nota.frontmatter.areaVida)) {
                    this.nota.areaVida = nota.frontmatter.areaVida[0].replace(/\[\[\s*|\s*\]\]/g, "");
                  } else if (typeof nota.frontmatter.areaVida === "string") {
                    this.nota.areaVida = nota.frontmatter.areaVida.replace(/\[\[\s*|\s*\]\]/g, "");
                  }
                } else {
                  this.nota.areaVida = "No es de ning\xFAn \xC1rea de Vida";
                }
                if (((_B = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _B.type) === "AI" || ((_C = nota == null ? void 0 : nota.frontmatter) == null ? void 0 : _C.type) === "AV") {
                  siAsunto = false;
                }
                if (!isNaN(parseInt((_D = nota.frontmatter) == null ? void 0 : _D.nivelAI))) {
                  nivel = parseInt(nota.frontmatter.nivelAI) + 1;
                } else {
                  nivel = 0;
                }
                this.nota.nivelAI = nivel;
              }
              break;
          }
          break;
        default:
          console.log("Dependiendo de la estructura, getAsunto deberia tener su clasificaci\xF3n. Aqui vas a tener un error.");
          break;
      }
    } else {
      siAsunto = false;
    }
    return { siAsunto, nombre: padres };
  }
  async getOtrosAsuntos(subsistemas) {
    let suggester = this.tp.system.static_functions.get("suggester");
    let campo = [];
    for (let subsistema of subsistemas) {
      let incluye = await suggester(["Si", "No"], [true, false], true, `Desea agregar algun ${subsistema} activo como origen?`);
      if (!incluye)
        continue;
      debugger;
      let recursosActivos = await this.activeStructureResources(subsistema);
      let primerAlias = recursosActivos.map((file) => {
        var _a;
        const metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        return metadata && metadata.aliases && metadata.aliases.length > 0 ? metadata.aliases[0] : null;
      }).filter((alias) => alias !== null);
      while (recursosActivos.length > 0) {
        let indiceSeleccionado;
        if (subsistema === "AreasVida" || subsistema === "AreasInteres") {
          let seleccion = await suggester(primerAlias, recursosActivos.map((b) => b.path), false, `${subsistema} activos:`);
          if (!seleccion)
            break;
          indiceSeleccionado = recursosActivos.findIndex((b) => b.path === seleccion);
        } else {
          let seleccion = await suggester(primerAlias, recursosActivos.map((b) => b.basename), false, `${subsistema} activos:`);
          if (!seleccion)
            break;
          indiceSeleccionado = recursosActivos.findIndex((b) => b.basename === seleccion);
        }
        if (indiceSeleccionado !== -1) {
          if (subsistema === "AreasVida" || subsistema === "AreasInteres") {
            campo.push(recursosActivos[indiceSeleccionado].path);
          } else {
            campo.push(recursosActivos[indiceSeleccionado].basename);
          }
          recursosActivos.splice(indiceSeleccionado, 1);
          primerAlias.splice(indiceSeleccionado, 1);
        }
        if (recursosActivos.length === 0)
          break;
        let deseaAgregarOtro = await suggester(["Si", "No"], [true, false], true, `Desea agregar otro ${subsistema} como origen?`);
        debugger;
        if (!deseaAgregarOtro)
          break;
      }
    }
    return campo;
  }
  // FUNCION QUE TRAE TODAS LAS NOTAS ACTIVAS DE LOS SISTEMAS. - Revisar en que la uso...
  async activeStructureResources(typeName) {
    try {
      const files = app.vault.getMarkdownFiles();
      switch (type) {
        case "AreasInteres":
          debugger;
          break;
        default:
          let resourceFolderName = "folder_" + typeName;
          let resourceFolder = this.plugin.settings[resourceFolderName];
          if (!resourceFolder) {
            console.error(`La carpeta "${resourceFolderName}" no existe en la configuraci\xF3n del plugin.`);
            return [];
          }
          let activeResources2 = [];
          const registrosExistentes = files.filter((file) => file.path.startsWith(resourceFolder));
          registrosExistentes.forEach((file) => {
            var _a;
            const metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
            if (metadata && metadata.estado === "\u{1F7E2}") {
              activeResources2.push(file);
            }
          });
          break;
      }
      return activeResources;
    } catch (error) {
      console.error("Error al buscar recursos activos:", error);
      return [];
    }
  }
  async getClasificacion() {
    var _a;
    let clasificacion2, tagClasificacion2, clasificacionAX, tagsClasificacionAX;
    let nuevaClasificacion2 = false;
    const file = app.vault.getAbstractFileByPath(this.pathCampos);
    const frontmatter = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (frontmatter) {
      clasificacionAX = frontmatter.tituloClasificacionAX || [];
      tagsClasificacionAX = frontmatter.tagsClasificacionAX || [];
      let suggester = this.tp.system.static_functions.get("suggester");
      tagClasificacion2 = await suggester(clasificacionAX, tagsClasificacionAX, false, "\xBFClasificar\xEDas esta nota bajo alguna de las siguientes categor\xEDas?");
      if (tagClasificacion2 === null) {
        new import_obsidian22.Notice("Creaci\xF3n de nota cancelada por el usuario.");
        return;
      } else if (tagClasificacion2 == "Nuevo") {
        let prompt = this.tp.system.static_functions.get("prompt");
        clasificacion2 = await prompt("\xBFCual es el nombre de la nueva clasificaci\xF3n que vas a ingresar?", "MiClasificaci\xF3n", true);
        if (clasificacion2 === null) {
          new import_obsidian22.Notice("Creaci\xF3n de nota cancelada por el usuario.");
          return;
        }
        tagClasificacion2 = await prompt("\xBFCual es el tag que utilizaras para " + clasificacion2 + "?. No utilices espacios en la definici\xF3n del tag.", "nuevoTag", true);
        if (tagClasificacion2 === null) {
          new import_obsidian22.Notice("Creaci\xF3n de nota cancelada por el usuario.");
          return;
        }
        nuevaClasificacion2 = true;
      } else if (tagClasificacion2 == "Ninguna") {
        tagClasificacion2 = "";
        clasificacion2 = "";
      } else {
        let indice = tagsClasificacionAX.indexOf(tagClasificacion2);
        clasificacion2 = clasificacionAX[indice];
      }
    }
    if (nuevaClasificacion2) {
      try {
        await app.fileManager.processFrontMatter(file, (frontmatter2) => {
          let newClasificacion = [...clasificacionAX, clasificacion2];
          let newTagClasificacion = [...tagsClasificacionAX, tagClasificacion2];
          frontmatter2.tituloClasificacionAX = newClasificacion;
          frontmatter2.tagsClasificacionAX = newTagClasificacion;
          console.log("Frontmatter actualizado con \xE9xito");
        });
      } catch (err) {
        console.error("Error al actualizar el frontmatter", err);
      }
    }
    if (tagClasificacion2 != "") {
      tagClasificacion2 = "cl/" + tagClasificacion2;
    }
    this.nota.clasificacionAX = clasificacion2;
    this.nota.tagClasificacionAX = tagClasificacion2;
    return { clase: clasificacion2, tag: tagClasificacion2 };
  }
  // ->
  getDuplasFijas(app2, area) {
    var _a;
    const file = app2.vault.getAbstractFileByPath(this.pathCampos);
    try {
      if (file instanceof import_obsidian22.TFile) {
        const metadata = app2.metadataCache.getFileCache(file);
        const arregloResult = ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a[area]) || [];
        const resultado = [];
        if (Array.isArray(arregloResult)) {
          arregloResult.forEach((item) => {
            if (Array.isArray(item) && item.length >= 2) {
              resultado.push({ grupo: item[0], area: item[1], texto: item[0] + "/" + item[1] });
            }
          });
        }
        return resultado;
      }
    } catch (error) {
      console.error("Error obteniendo el archivo de campos:", error);
      throw error;
    }
    return [];
  }
  // Función creda para las Areas de Vida y para las Anotaciones, para traer las que estan en plt Campos
  async getArea() {
    let area, grupo;
    let tipoArea = this.infoSubsistema.typeName;
    let nuevaArea = false;
    let areasGrupos = this.getDuplasFijas(app, tipoArea);
    let suggester = this.tp.system.static_functions.get("suggester");
    let areaGrupo = await suggester(areasGrupos.map((b) => b.texto), areasGrupos.map((b) => b.texto), false, `\xBFCu\xE1l ${tipoArea} deseas crear?`);
    if (areaGrupo === null) {
      new import_obsidian22.Notice("Creaci\xF3n de nota cancelada por el usuario.");
      return;
    } else if (areaGrupo == "Nuevo") {
      let prompt = this.tp.system.static_functions.get("prompt");
      clasificacion = await prompt("\xBFCual es el nombre de la nueva clasificaci\xF3n que vas a ingresar?", "MiClasificaci\xF3n", true);
      if (clasificacion === null) {
        new import_obsidian22.Notice("Creaci\xF3n de nota cancelada por el usuario.");
        return;
      }
      tagClasificacion = await prompt("\xBFCual es el tag que utilizaras para " + clasificacion + "?. No utilices espacios en la definici\xF3n del tag.", "nuevoTag", true);
      if (tagClasificacion === null) {
        new import_obsidian22.Notice("Creaci\xF3n de nota cancelada por el usuario.");
        return;
      }
      nuevaClasificacion = true;
    } else {
      let indice = areasGrupos.findIndex((objeto) => objeto.texto === areaGrupo);
      grupo = areasGrupos[indice].grupo;
      area = areasGrupos[indice].area;
      this.nota.grupo = grupo;
      this.nota.titulo = area;
      return { grupo, titulo: area };
    }
  }
  async getEstado() {
    let suggester = this.tp.system.static_functions.get("suggester");
    let tipoSistema = this.infoSubsistema.type;
    let nombreSistema = this.infoSubsistema.typeName;
    let campo;
    switch (tipoSistema) {
      case "Ax":
        campo = await suggester(["\u{1F535} -> Para Archivo - Informaci\xF3n", "\u{1F7E2} -> Finalizado", "\u{1F7E1} -> En desarrollo", "\u{1F534} -> No realizado"], ["\u{1F535}", "\u{1F7E2}", "\u{1F7E1}", "\u{1F534}"], false, `Estado actual ${nombreSistema}:`);
        break;
      case "PGTD":
        campo = await suggester(["\u{1F535} -> Completado - Archivo", "\u{1F7E2} -> Activo", "\u{1F7E1} -> En Pausa", "\u{1F534} -> Detenido"], ["\u{1F535}", "\u{1F7E2}", "\u{1F7E1}", "\u{1F534}"], false, `Estado actual ${nombreSistema}:`);
        break;
      case "PQ":
        campo = await suggester(["\u{1F535} -> Completado - Archivo", "\u{1F7E2} -> Activo", "\u{1F7E1} -> Por Iniciar, En Pausa", "\u{1F534} -> Cancelado"], ["\u{1F535}", "\u{1F7E2}", "\u{1F7E1}", "\u{1F534}"], false, `Estado actual ${this.nota.titulo}:`);
        break;
      case "Tx":
        campo = await suggester(["\u{1F535} -> Archivo", "\u{1F7E2} -> En Proceso", "\u{1F7E1} -> En Pausa", "\u{1F534} -> Cancelado"], ["\u{1F535}", "\u{1F7E2}", "\u{1F7E1}", "\u{1F534}"], false, `Estado de ${this.nota.titulo}:`);
        break;
      case "AI":
      case "AV":
      case "RR":
        campo = await suggester(["\u{1F535} -> Archivado", "\u{1F7E2} -> Activo", "\u{1F7E1} -> En Pausa", "\u{1F534} -> Detenido"], ["\u{1F535}", "\u{1F7E2}", "\u{1F7E1}", "\u{1F534}"], false, `Estado actual ${this.nota.titulo}:`);
        break;
      case "AY":
        campo = await suggester(["\u{1F535} -> A\xF1o Archivado", "\u{1F7E2} -> A\xF1o activo", "\u{1F7E1} -> A\xF1o en planeaci\xF3n", "\u{1F534} -> Nota por arreglar"], ["\u{1F535}", "\u{1F7E2}", "\u{1F7E1}", "\u{1F534}"], false, `Estado del a\xF1o elegido:`);
        break;
      case "OCA":
      case "CTI":
        campo = "\u{1F7E1}";
        break;
      default:
        campo = await suggester(["\u{1F535} -> Completado - Informaci\xF3n", "\u{1F7E2} -> Finalizado", "\u{1F7E1} -> En desarrollo", "\u{1F534} -> Detenido"], ["\u{1F535}", "\u{1F7E2}", "\u{1F7E1}", "\u{1F534}"], false, "Seleccione el estado de la nota:");
    }
    if (campo === null) {
      new import_obsidian22.Notice("Modificaci\xF3n de nota cancelada por el usuario.");
      return;
    }
    return campo;
  }
  /* 
  ----------------------------------------------------------------
  Metodo que tiene dos propositos, inicialmente se creó para  devolver
  el filename de las AI, AV, nAV, Ax y PGTD y desde la plantilla 
  cambiarle el nombre al archivo. Sin embargo, se modificó y ahora sirve
  para cuando una plantilla tiene un nombre especial, porque es resultado
  de un proceso previo y se debe traer información para que se genere la
  nota de la plantilla adecuadamente.  
  ----------------------------------------------------------------
  */
  async getFilename() {
    let fileName;
    switch (this.infoSubsistema.type) {
      case "AI":
        if (this.nota.areaVida === "No es de ning\xFAn Area de Vida") {
          fileName = `${this.infoSubsistema.folder}/Otras/${this.nota.titulo}`;
        } else {
          fileName = `${this.infoSubsistema.folder}/${this.nota.areaVida}/${this.nota.titulo}`;
        }
        break;
      case "AV":
        debugger;
        if (this.infoSubsistema.hasOwnProperty("fileName")) {
          const partes2 = this.infoSubsistema.fileName.split(" -- ");
          this.nota.trimestre = partes2[0];
          this.nota.titulo = partes2[1];
          this.nota.areaVida = partes2[1];
          this.nota.grupo = partes2[2];
        }
        fileName = `${this.nota.trimestre} - ${this.nota.titulo}`;
        break;
      case "nAV":
        const partes = this.nota.fileName.split(" - ");
        this.nota.grupo = partes[0];
        this.nota.areaVida = partes[1];
        fileName = `${partes[1]}`;
        break;
      case "PGTD":
      case "PQ":
        if (this.infoSubsistema.hasOwnProperty("fileName")) {
          let regexFileName = /([^/]+)\s-\s(\d+)\.md$/;
          let partes2 = this.infoSubsistema.fileName.match(regexFileName);
          let type2 = partes2[1];
          let id = partes2[2];
          switch (type2) {
            case "Proyecto para Objetivo Compass Anual":
              let nota = await this.getOrigen("ObjCompassAnual", id);
              const regex = /\[\[\s*(.*?)\s*\]\]/;
              this.nota.areaVida = nota == null ? void 0 : nota.areaVida.match(regex)[1];
              this.nota.areaInter\u00E9s = nota.areaInteres;
              this.nota.asunto = { siAsunto: true, nombre: nota.file.basename };
              this.nota.trimestre = nota == null ? void 0 : nota.trimestre.match(regex)[1];
              this.nota.nivelP = 0;
              fileName = this.infoSubsistema.fileName;
              break;
          }
        }
        break;
    }
    return fileName;
  }
  async getTrimestre() {
    let suggester = this.tp.system.static_functions.get("suggester");
    let tipoSistema = this.infoSubsistema.type;
    let nombreSistema = this.infoSubsistema.typeName;
    let trimestre;
    let trimestres = await this.findMainFilesWithState("TQ");
    switch (tipoSistema) {
      case "AV":
      case "PQ":
        trimestre = await suggester(trimestres.map((b) => b.file.basename), trimestres.map((b) => b.file.basename), false, `Trimestre del ${nombreSistema}:`);
        break;
      case "OCA":
        trimestre = await suggester(
          ["Q1", "Q2", "Q3", "Q4"],
          [
            `${this.nota.a\u00F1o}-Q1`,
            `${this.nota.a\u00F1o}-Q2`,
            `${this.nota.a\u00F1o}-Q3`,
            `${this.nota.a\u00F1o}-Q4`
          ],
          true,
          `\xBFEn qu\xE9 trimestre del ${this.nota.a\u00F1o} consideras que se puede realizar ese objetivo?`
        );
        break;
      case "CTI":
        trimestre = await suggester(
          ["Q1", "Q2", "Q3", "Q4"],
          [
            `${this.nota.a\u00F1o}-Q1`,
            `${this.nota.a\u00F1o}-Q2`,
            `${this.nota.a\u00F1o}-Q3`,
            `${this.nota.a\u00F1o}-Q4`
          ],
          true,
          `\xBFDe qu\xE9 trimestre del ${this.nota.a\u00F1o} es esta planeaci\xF3n?`
        );
        break;
      default:
        trimestre = await suggester(trimestres.map((b) => b.file.basename), trimestres.map((b) => b.file.path), false, `Trimestre del ${nombreSistema}:`);
    }
    if (trimestre === null) {
      new import_obsidian22.Notice("Modificaci\xF3n de nota cancelada por el usuario.");
      return;
    }
    this.nota.trimestre = trimestre;
    return trimestre;
  }
  async getA\u00F1o() {
    let suggester = this.tp.system.static_functions.get("suggester");
    let tipoSistema = this.infoSubsistema.type;
    let nombreSistema = this.infoSubsistema.typeName;
    let a\u00F1o;
    let a\u00F1os = await this.findMainFilesWithState("AY");
    switch (tipoSistema) {
      case "CAC":
      case "CAI":
      case "CTI":
        a\u00F1o = await suggester(a\u00F1os.map((b) => b.file.basename), a\u00F1os.map((b) => b.file.basename), false, `Selecciona el a\xF1o que deseas para el ${nombreSistema}:`);
        break;
      case "AY":
        const a\u00F1oActual = (/* @__PURE__ */ new Date()).getFullYear();
        const arregloA\u00F1os = [a\u00F1oActual - 2, a\u00F1oActual - 1, a\u00F1oActual, a\u00F1oActual + 1, a\u00F1oActual + 2];
        a\u00F1o = await suggester(arregloA\u00F1os, arregloA\u00F1os, false, `Selecciona el a\xF1o que vamos a crear.`);
        break;
      case "OCA":
        debugger;
        let nombreArchivo = this.infoSubsistema.fileName;
        const regex = /\/(\d{4})/;
        const resultado = nombreArchivo.match(regex);
        if (resultado && resultado[1]) {
          a\u00F1o = resultado[1];
        } else {
          return null;
        }
        break;
      default:
    }
    if (a\u00F1o === null) {
      new import_obsidian22.Notice("Creaci\xF3n cancelada por el usuario.");
      return;
    }
    this.nota.a\u00F1o = a\u00F1o;
    return a\u00F1o;
  }
  async getRename() {
    let suggester = this.tp.system.static_functions.get("suggester");
    let newName, name, folder;
    debugger;
    switch (this.infoSubsistema.type) {
      case "Ax":
        newName = `${this.infoSubsistema.folder}/${this.infoSubsistema.type} - ${this.nota.id}.md`;
        name = `${this.nota.fileName}`;
        break;
      case "AI":
      case "PGTD":
        if (this.nota.areaVida === "No es de ning\xFAn Area de Vida") {
          newName = `${this.infoSubsistema.folder}/Otras/${this.infoSubsistema.type} - ${this.nota.id}.md`;
          folder = `${this.infoSubsistema.folder}/Otras`;
        } else {
          newName = `${this.infoSubsistema.folder}/${this.nota.areaVida}/${this.infoSubsistema.type} - ${this.nota.id}.md`;
          folder = `${this.infoSubsistema.folder}/${this.nota.areaVida}`;
        }
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      case "AV":
        newName = `${this.infoSubsistema.folder}/${this.nota.areaVida}/${this.nota.filename}.md`;
        name = `${this.infoSubsistema.folder}/${this.nota.areaVida}/${this.nota.fileName}.md`;
        break;
      case "RR":
        newName = `${this.infoSubsistema.folder}/${this.infoSubsistema.type} - ${this.nota.id}.md`;
        folder = `${this.infoSubsistema.folder}`;
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      case "PQ":
        debugger;
        let folderAV = Array.isArray(this.nota.areaVida) ? this.nota.areaVida[0] : this.nota.areaVida;
        newName = `${this.infoSubsistema.folder}/${this.nota.trimestre}/${folderAV}/${this.infoSubsistema.type} - ${this.nota.id}.md`;
        folder = `${this.infoSubsistema.folder}/${this.nota.trimestre}/${folderAV}`;
        debugger;
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      case "Tx":
        let fecha = window.moment(this.nota.fecha, "YYYY-MM-DD dddd HH:mm");
        let fechaY = fecha.format("YYYY");
        let fechaMes = fecha.format("MM - MMMM");
        debugger;
        newName = `${this.infoSubsistema.folder}/${fechaY}/${fechaMes}/${this.infoSubsistema.type} - ${this.nota.id}.md`;
        folder = `${this.infoSubsistema.folder}/${fechaY}/${fechaMes}`;
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      case "CAC":
        newName = `${this.infoSubsistema.folder}/${this.nota.a\u00F1o}/Desempe\xF1o ${this.nota.a\u00F1o}.md`;
        folder = `${this.infoSubsistema.folder}/${this.nota.a\u00F1o}`;
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      case "CAI":
        debugger;
        newName = `${this.infoSubsistema.folder}/${this.nota.a\u00F1o}/Planeaci\xF3n ${this.nota.a\u00F1o}.md`;
        folder = `${this.infoSubsistema.folder}/${this.nota.a\u00F1o}`;
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      case "CTI":
        newName = `${this.infoSubsistema.folder}/${this.nota.a\u00F1o}/Planeaci\xF3n ${this.nota.trimestre}.md`;
        folder = `${this.infoSubsistema.folder}/${this.nota.a\u00F1o}`;
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      case "AY":
        newName = `${this.infoSubsistema.folder}/${this.nota.a\u00F1o}.md`;
        folder = `${this.infoSubsistema.folder}`;
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      case "OCA":
        newName = `${this.infoSubsistema.folder}/${this.nota.a\u00F1o}/${this.infoSubsistema.type} - ${this.nota.id}.md`;
        folder = `${this.infoSubsistema.folder}/${this.nota.a\u00F1o}`;
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      case "CPE":
        debugger;
        newName = `${this.infoSubsistema.folder}/${this.nota.fecha.slice(0, 4)}/${this.infoSubsistema.type} - ${this.nota.id}.md`;
        folder = `${this.infoSubsistema.folder}/${this.nota.fecha.slice(0, 4)}`;
        await this.crearCarpeta(folder);
        name = `${this.nota.fileName}`;
        break;
      default:
        break;
    }
    const file = app.vault.getAbstractFileByPath(name);
    const existe = app.vault.getAbstractFileByPath(newName);
    debugger;
    try {
      if (existe instanceof import_obsidian22.TFile) {
        let nombreFile = newName == null ? void 0 : newName.split("/");
        let borrar = await suggester(
          ["Sobreescribir Archivo Actual", "Detener creaci\xF3n del archivo."],
          [
            true,
            false
          ],
          true,
          `\xBF${nombreFile.pop()} ya existe. Que deseas hacer?`
        );
        if (borrar) {
          await app.vault.delete(existe);
          if (file instanceof import_obsidian22.TFile) {
            await app.vault.rename(file, newName);
            console.log("Archivo renombrado con \xE9xito.");
            return true;
          }
        } else {
          console.log("Cancelando la creaci\xF3n del archivo.");
          this.nota.borrarNota = true;
          return false;
        }
      } else {
        if (file instanceof import_obsidian22.TFile) {
          await app.vault.rename(file, newName);
          console.log("Archivo renombrado con \xE9xito.");
          return true;
        }
      }
    } catch (error) {
      console.error("Error al cambiar el nombre", error);
      return false;
    }
  }
  async getAreaVida() {
    let suggester = this.tp.system.static_functions.get("suggester");
    let tipo = this.infoSubsistema.type;
    let nombreTipo = this.infoSubsistema.typeName;
    let areasVida2 = {};
    let areaVida;
    let noAV = {};
    noAV.file = {};
    noAV.areaVida = "No es de ning\xFAn Area de Vida";
    noAV.file.basename = "No es de ning\xFAn Area de Vida";
    debugger;
    if (!this.nota.asuntoDefinido) {
      switch (tipo) {
        case "AI":
          if (this.nota.areaInteres == "") {
            areasVida2 = await this.findMainFilesWithState("AV");
            areasVida2.push(noAV);
            areaVida = await suggester(areasVida2.map((b) => b.areaVida), areasVida2.map((b) => b.areaVida), false, `A que Area de Vida pertenece esta ${nombreTipo}:`);
          } else {
            areaVida = this.nota.areaVida;
          }
          break;
        case "PQ":
          areasVida2 = await this.findMainFilesWithState("AV", this.nota.trimestre);
          debugger;
          areaVida = await suggester(areasVida2.map((b) => b.file.basename), areasVida2.map((b) => [b.areaVida, b.file.basename]), false, `A que Area de Vida pertenece esta(e) ${nombreTipo}:`);
          this.nota.nivelP = 0;
          break;
        case "OCA":
          debugger;
          let nombreArchivo = this.infoSubsistema.fileName;
          const regex = /Objetivo para (.+)\.md$/;
          const resultado = nombreArchivo.match(regex);
          if (resultado && resultado[1]) {
            areaVida = resultado[1];
          } else {
            return null;
          }
          break;
        default:
          areasVida2 = await this.findMainFilesWithState("AV");
          debugger;
          areasVida2.push(noAV);
          areaVida = await suggester(areasVida2.map((b) => b.file.basename), areasVida2.map((b) => b.file.basename), false, `A que Area de Vida pertenece esta(e) ${nombreTipo}:`);
          break;
      }
      return areaVida;
    } else {
      return this.nota.areaVida;
    }
  }
  async getAreaInteres() {
    let suggester = this.tp.system.static_functions.get("suggester");
    let tipo = this.infoSubsistema.type;
    let nombreTipo = this.infoSubsistema.typeName;
    let areasInteres = await this.findMainFilesWithState("AI");
    let areaInteres, nivel, titulo, padreAI, arrayAI;
    if (!this.nota.asuntoDefinido) {
      switch (tipo) {
        case "AI":
          padreAI = await suggester(["Si", "No"], [true, false], false, ` ${this.nota.titulo} es hijo de otra ${nombreTipo}:`);
          if (padreAI) {
            areaInteres = await suggester(areasInteres.map((b) => b.titulo), areasInteres.map((b) => b), false, `Que Area de Inter\xE9s es padre de ${this.nota.titulo}?:`);
            if (areaInteres === null) {
              new import_obsidian22.Notice("Sin Area de Interes");
              titulo = "";
              nivel = 0;
              return;
            } else {
              debugger;
              if (areaInteres.areaVida === null) {
                this.nota.areaVida = "No es de ning\xFAn Area de Vida";
              } else {
                this.nota.areaVida = areaInteres.areaVida.replace(/\[\[\s*|\s*\]\]/g, "");
              }
              titulo = areaInteres.titulo;
              nivel = parseInt(areaInteres.nivelAI) + 1;
            }
          } else {
            titulo = "";
            nivel = 0;
          }
          break;
        case "RR":
        case "Ax":
          padreAI = await suggester(["Si", "No"], [true, false], false, ` ${this.nota.titulo} es hijo de un Area de Inter\xE9s:`);
          if (padreAI) {
            areaInteres = await suggester(areasInteres.map((b) => b.titulo), areasInteres.map((b) => b), false, `Que Area de Inter\xE9s es padre de ${this.nota.titulo}?:`);
            if (areaInteres === null) {
              new import_obsidian22.Notice("Sin Area de Interes");
              titulo = "";
              nivel = 0;
              return;
            } else {
              debugger;
              titulo = [areaInteres.titulo];
              if (Array.isArray(areaInteres == null ? void 0 : areaInteres.areaInteres)) {
                titulo = titulo.concat(areaInteres.areaInteres.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
              } else {
                if (areaInteres == null ? void 0 : areaInteres.areaInteres) {
                  titulo.push(areaInteres.areaInteres.replace(/\[\[\s*|\s*\]\]/g, ""));
                }
              }
              if (areaInteres == null ? void 0 : areaInteres.areaVida) {
                if (Array.isArray(areaInteres.areaVida)) {
                  this.nota.areaVida = areaInteres.areaVida[0].replace(/\[\[\s*|\s*\]\]/g, "");
                } else if (typeof areaInteres.areaVida === "string") {
                  this.nota.areaVida = areaInteres.areaVida.replace(/\[\[\s*|\s*\]\]/g, "");
                }
              } else {
                this.nota.areaVida = "No es de ning\xFAn \xC1rea de Vida";
              }
              this.nota.asuntoDefinido = true;
              nivel = parseInt(areaInteres.nivelAI);
            }
          } else {
            titulo = "";
            nivel = 0;
          }
          break;
        case "PQ":
          debugger;
          padreAI = await suggester(["Si", "No"], [true, false], false, ` ${this.nota.titulo} es hijo de un Area de Inter\xE9s:`);
          if (padreAI) {
            areaInteres = await suggester(areasInteres.map((b) => b.titulo), areasInteres.map((b) => b), false, `Que Area de Inter\xE9s es padre de ${this.nota.titulo}?:`);
            if (areaInteres === null) {
              new import_obsidian22.Notice("Sin Area de Interes");
              titulo = "";
              nivel = 0;
              return;
            } else {
              if (areaInteres.areaVida === null) {
                this.nota.areaVida = "No es de ning\xFAn Area de Vida";
              } else {
                this.nota.areaVida = [];
                this.nota.areaVida[0] = (areaInteres == null ? void 0 : areaInteres.areaVida) ? areaInteres.areaVida.replace(/\[\[\s*|\s*\]\]/g, "") : "No es de ning\xFAn Area de Vida";
                this.nota.areaVida[1] = `${this.nota.trimestre} - ${this.nota.areaVida[0]}`;
              }
              this.nota.nivelP = 0;
              this.nota.asuntoDefinido = true;
              arrayAI = [areaInteres.titulo];
              if (Array.isArray(areaInteres.areaInteres)) {
                this.nota.areaInteres = arrayAI.concat(areaInteres.areaInteres.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
              } else {
                if (areaInteres == null ? void 0 : areaInteres.areaInteres) {
                  arrayAI.push(areaInteres.areaInteres.replace(/\[\[\s*|\s*\]\]/g, ""));
                }
              }
            }
          } else {
            arrayAI = "";
          }
          return arrayAI;
          break;
        default:
          areaInteres = await suggester(areasInteres.map((b) => b.file.basename), areasVida.map((b) => b.file.basename), false, `A que Area de Vida pertenece esta ${nombreTipo}:`);
          break;
      }
      debugger;
      this.nota.nivelAI = nivel;
      return titulo;
    } else {
      return this.nota.areaInteres;
    }
  }
  async getProyectoGTD() {
    let suggester = this.tp.system.static_functions.get("suggester");
    let tipo = this.infoSubsistema.type;
    let nombreTipo = this.infoSubsistema.typeName;
    let notasF = await this.findMainFilesWithState("PGTD");
    let notaF, nivel, titulo;
    if (!this.nota.asuntoDefinido) {
      switch (tipo) {
        case "RR":
        case "Ax":
          let padrePGTD = await suggester(["Si", "No"], [true, false], false, ` ${this.nota.titulo} es hijo de un Proyecto GTD?`);
          if (padrePGTD) {
            notaF = await suggester(notasF.map((b) => b.titulo), notasF.map((b) => b), false, `Que Proyecto GTD es padre de ${this.nota.titulo}?:`);
            if (notaF === null) {
              new import_obsidian22.Notice("Sin proyecto GTD definido.");
              titulo = "";
              return;
            } else {
              debugger;
              this.nota.areaInteres = [];
              if (Array.isArray(notaF == null ? void 0 : notaF.areaInteres)) {
                this.nota.areaInteres = this.nota.areaInteres.concat(notaF.areaInteres.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
              } else {
                if (notaF == null ? void 0 : notaF.areaInteres) {
                  this.nota.areaInteres.push(notaF.areaInteres.replace(/\[\[\s*|\s*\]\]/g, ""));
                }
              }
              this.nota.areaVida = [];
              if (notaF == null ? void 0 : notaF.areaVida) {
                if (Array.isArray(notaF.areaVida)) {
                  this.nota.areaVida = notaF.areaVida[0].replace(/\[\[\s*|\s*\]\]/g, "");
                } else if (typeof notaF.areaVida === "string") {
                  this.nota.areaVida = notaF.areaVida.replace(/\[\[\s*|\s*\]\]/g, "");
                }
              } else {
                this.nota.areaVida = "No es de ning\xFAn Area de Vida";
              }
              this.nota.proyectoQ = "";
              if (Array.isArray(notaF == null ? void 0 : notaF.proyectoQ)) {
                this.nota.proyectoQ = notaF.proyectoQ.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
              } else if (notaF == null ? void 0 : notaF.proyectoQ) {
                this.nota.proyectoQ = notaF.proyectoQ.replace(/\[\[\s*|\s*\]\]/g, "");
              }
              titulo = [notaF.titulo];
              if (Array.isArray(notaF == null ? void 0 : notaF.proyectoGTD)) {
                titulo = titulo.concat(notaF.proyectoGTD.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
              } else if (notaF == null ? void 0 : notaF.proyectoGTD) {
                titulo.push(notaF.proyectoGTD.replace(/\[\[\s*|\s*\]\]/g, ""));
              }
              this.nota.asuntoDefinido = true;
            }
          } else {
            titulo = "";
            nivel = 0;
          }
          break;
        default:
          break;
      }
      return titulo;
    } else {
      return this.nota.proyectoGTD;
    }
  }
  async getProyectoQ() {
    let suggester = this.tp.system.static_functions.get("suggester");
    let tipo = this.infoSubsistema.type;
    let nombreTipo = this.infoSubsistema.typeName;
    let notasF = await this.findMainFilesWithState("PQ");
    let notaF, nivel, titulo;
    if (!this.nota.asuntoDefinido) {
      switch (tipo) {
        case "RR":
        case "Ax":
          let padreQ = await suggester(["Si", "No"], [true, false], false, ` ${this.nota.titulo} es hijo de un Proyecto Q?`);
          if (padreQ) {
            notaF = await suggester(notasF.map((b) => b.titulo), notasF.map((b) => b), false, `Que Proyecto Q es padre de ${this.nota.titulo}?:`);
            if (notaF === null) {
              new import_obsidian22.Notice("Sin proyecto Q definido.");
              titulo = "";
              return;
            } else {
              this.nota.areaInteres = [];
              if (Array.isArray(notaF == null ? void 0 : notaF.areaInteres)) {
                this.nota.areaInteres = this.nota.areaInteres.concat(notaF.areaInteres.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, "")));
              } else {
                if (notaF == null ? void 0 : notaF.areaInteres) {
                  this.nota.areaInteres.push(notaF.areaInteres.replace(/\[\[\s*|\s*\]\]/g, ""));
                }
              }
              this.nota.areaVida = [];
              if (notaF == null ? void 0 : notaF.areaVida) {
                if (Array.isArray(notaF.areaVida)) {
                  this.nota.areaVida = notaF.areaVida[0].replace(/\[\[\s*|\s*\]\]/g, "");
                } else if (typeof notaF.areaVida === "string") {
                  this.nota.areaVida = notaF.areaVida.replace(/\[\[\s*|\s*\]\]/g, "");
                }
              } else {
                this.nota.areaVida = "No es de ning\xFAn Area de Vida";
              }
              debugger;
              titulo = [notaF == null ? void 0 : notaF.titulo];
              this.nota.proyectoGTD = "";
              if (Array.isArray(notaF == null ? void 0 : notaF.proyectoGTD)) {
                this.nota.proyectoGTD = notaF.proyectoGTD.map((elemento) => elemento.replace(/\[\[\s*|\s*\]\]/g, ""));
              } else if (notaF == null ? void 0 : notaF.proyectoGTD) {
                this.nota.proyectoGTD = notaF.proyectoGTD.replace(/\[\[\s*|\s*\]\]/g, "");
              }
              this.nota.asuntoDefinido = true;
            }
          } else {
            titulo = "";
            nivel = 0;
          }
          break;
        default:
          break;
      }
      return titulo;
    } else {
      return this.nota.proyectoQ;
    }
  }
  // Esta función encuentra los archivos de subsistemas y cuyo estado es 🟢
  // Esta función sale de menuOtro, de registro Tiempo. Revisar si debo sincronizarlas.
  async findMainFilesWithState(tipo, parametro) {
    var _a, _b, _c;
    const propertiesTipo = {
      AV: {
        folder: this.plugin.settings.folder_AreasVida
      },
      AI: {
        folder: this.plugin.settings.folder_AreasInteres
      },
      PQ: {
        folder: this.plugin.settings.folder_ProyectosQ
      },
      PGTD: {
        folder: this.plugin.settings.folder_ProyectosGTD
      },
      TI: {
        folder: this.plugin.settings.folder_TemasInteres
      },
      RR: {
        folder: this.plugin.settings.folder_RecursosRecurrentes
      },
      TQ: {
        folder: this.plugin.settings.folder_Trimestral
      },
      AY: {
        folder: this.plugin.settings.folder_Anual
      }
      // Puedes continuar añadiendo más casos aquí
    };
    const activeFilesWithFrontmatter = [];
    let files, trimestre;
    const folder = propertiesTipo[tipo].folder;
    switch (tipo) {
      case "AV":
        debugger;
        if (!parametro) {
          trimestre = DateTime.now().toFormat("yyyy-Qq");
        } else {
          trimestre = parametro;
        }
        files = app.vault.getMarkdownFiles().filter((file) => file.path.includes(folder) && !file.path.includes("Plantillas") && !file.path.includes("Archivo") && file.name.startsWith(trimestre));
        for (let file of files) {
          let metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if ((metadata == null ? void 0 : metadata.estado) === "\u{1F7E2}") {
            let activeFile = Object.assign({}, metadata);
            activeFile.file = file;
            activeFilesWithFrontmatter.push(activeFile);
          }
        }
        break;
      case "AI":
      case "TQ":
      case "AY":
        files = app.vault.getMarkdownFiles().filter((file) => file.path.includes(folder) && !file.path.includes("Plantillas") && !file.path.includes("Archivo"));
        for (let file of files) {
          let metadata = (_b = app.metadataCache.getFileCache(file)) == null ? void 0 : _b.frontmatter;
          if ((metadata == null ? void 0 : metadata.estado) === "\u{1F7E2}") {
            let activeFile = Object.assign({}, metadata);
            activeFile.file = file;
            activeFilesWithFrontmatter.push(activeFile);
          }
        }
        break;
      default:
        files = app.vault.getMarkdownFiles().filter((file) => file.path.includes(folder) && !file.path.includes("Plantillas") && !file.path.includes("Archivo"));
        for (let file of files) {
          let metadata = (_c = app.metadataCache.getFileCache(file)) == null ? void 0 : _c.frontmatter;
          if ((metadata == null ? void 0 : metadata.estado) === "\u{1F7E2}") {
            let activeFile = Object.assign({}, metadata);
            activeFile.file = file;
            activeFilesWithFrontmatter.push(activeFile);
          }
        }
        break;
    }
    return activeFilesWithFrontmatter;
  }
  async crearCarpeta(folderPath) {
    try {
      debugger;
      const carpetaExistente = app.vault.getAbstractFileByPath(folderPath);
      if (carpetaExistente instanceof import_obsidian22.TFolder) {
        console.log(`La carpeta '${folderPath}' ya existe.`);
        return;
      }
      await app.vault.createFolder(folderPath);
      console.log(`Carpeta '${folderPath}' creada exitosamente.`);
    } catch (error) {
      console.error(`Error al crear la carpeta '${folderPath}':`, error);
    }
  }
  /* 
  ----------------------------------------------------------------
  Metodo con el cual puedo desde el método fileName obtener la nota 
  de origen de la plantilla que estoy creando, para contar con toda 
  la información que requiero en la creación.
  ----------------------------------------------------------------
  */
  async getOrigen(typeName, id) {
    var _a;
    debugger;
    let folder = this.plugin.settings[`folder_${typeName}`];
    let files = app.vault.getMarkdownFiles().filter((file) => file.path.includes(folder) && !file.path.includes("Plantillas") && !file.path.includes("Archivo"));
    for (let file of files) {
      let metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if ((metadata == null ? void 0 : metadata.id) === +id) {
        let activeFile = Object.assign({}, metadata);
        activeFile.file = file;
        return activeFile;
      }
    }
  }
};

// src/modules/noteLifecycleManager/API/addOnsAPI.ts
var addOnsAPI = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  crearPrevNext(paginas, pagIndice, dv) {
    let pagina = dv.current();
    let indice;
    for (let a = 0; a < paginas.length; a++) {
      if (paginas[a].file.name == pagina.file.name) {
        indice = a;
      }
    }
    let links = [];
    if (indice == 0 && paginas.length == 1) {
      links[0] = "";
      links[1] = "";
    } else if (indice == 0) {
      links[0] = "";
      links[1] = "\u27A1\uFE0F " + dv.func.link(paginas[indice + 1].file.path, this.determinarTextoEnlace(paginas[indice + 1]));
    } else if (indice == paginas.length - 1) {
      links[0] = dv.func.link(paginas[indice - 1].file.path, this.determinarTextoEnlace(paginas[indice - 1])) + " \u2B05\uFE0F";
      links[1] = "";
    } else {
      links[0] = dv.func.link(paginas[indice - 1].file.path, this.determinarTextoEnlace(paginas[indice - 1])) + " \u2B05\uFE0F";
      links[1] = "\u27A1\uFE0F " + dv.func.link(paginas[indice + 1].file.path, this.determinarTextoEnlace(paginas[indice + 1]));
    }
    dv.paragraph(links[0] + " ==" + dv.func.link(pagIndice.file.path, pagIndice.titulo || pagIndice.file.name) + "== " + links[1]);
  }
  determinarTextoEnlace(pagina) {
    if (pagina.titulo) {
      return pagina.titulo;
    } else if (pagina.aliases && pagina.aliases.length > 0) {
      return pagina.aliases[0];
    } else {
      return pagina.file.name;
    }
  }
};

// src/modules/noteLifecycleManager/API/YAMLUpdaterAPI.ts
var import_obsidian24 = require("obsidian");

// src/modules/moduloRegistroTiempo/modals/cambioHF.ts
var import_obsidian23 = require("obsidian");
var modal_cambioHF = class extends import_obsidian23.Modal {
  constructor(plugin, file) {
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
  }
  async onOpen() {
    var _a, _b;
    debugger;
    this.containerEl.classList.add("modalInbox");
    const { contentEl } = this;
    debugger;
    const metadata = this.plugin.app.metadataCache.getFileCache(this.file.file);
    const aliases = ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.aliases) || "Actividad sin alias";
    const horaFinStr = ((_b = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _b.horaFinal) ? window.moment(metadata.frontmatter.horaFinal, "YYYY-MM-DD dddd HH:mm").format("YYYY-MM-DDTHH:mm") : "";
    contentEl.createEl("h2", { text: `Cambio hora cierre de registro.` });
    contentEl.createEl("p", { text: `Tarea: "${aliases[0]}"` });
    contentEl.createEl("p", { text: "Hora de cierre registro:" });
    this.horaFinalInput = contentEl.createEl("input", {
      type: "datetime-local",
      value: horaFinStr
    });
    const saveButton = contentEl.createEl("button", { text: "Guardar cambios" });
    saveButton.onclick = () => this.guardarCambios();
  }
  async guardarCambios() {
    const nuevaHoraFinalLocal = this.horaFinalInput.value;
    if (!nuevaHoraFinalLocal) {
      new import_obsidian23.Notice("Por favor, seleccione una hora de cierre.");
      return;
    }
    const nuevaHoraFinal = window.moment(nuevaHoraFinalLocal).format("YYYY-MM-DD dddd HH:mm");
    try {
      debugger;
      let campos = ["fecha", `horaFinal_${nuevaHoraFinal}`, `tiempoTrabajado_${nuevaHoraFinal}`, "estado_\u{1F535}"];
      let resultado = await this.plugin.YAMLUpdaterAPI.actualizarNota(this.file, campos);
      this.close();
      new import_obsidian23.Notice("Hora de Finalizaci\xF3n actualizada correctamente.");
    } catch (error) {
      console.error("Error al guardar cambios en la nota:", error);
      new import_obsidian23.Notice("Error al guardar los cambios en la nota.");
    }
  }
};

// src/modules/noteLifecycleManager/API/YAMLUpdaterAPI.ts
var YAMLUpdaterAPI2 = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.infoNota = {};
    this.nota = {};
    this.tp = this.getTp();
    this.pathCampos = this.plugin.settings.file_camposCentral + ".md";
  }
  async actualizarNota(infoNota, campos) {
    var _a;
    let nota = {};
    Object.assign(this.infoNota, infoNota);
    try {
      for (let campo of campos) {
        const partes = campo.split("_");
        let campoName, functionName;
        let parametro = null;
        if (partes.length > 1) {
          functionName = `get${partes[0].charAt(0).toUpperCase() + partes[0].slice(1)}`;
          campoName = partes[0];
          parametro = partes[1];
        } else {
          campoName = partes[0];
          functionName = `get${campo.charAt(0).toUpperCase() + campo.slice(1)}`;
        }
        let metadata = (_a = app.metadataCache.getFileCache(this.infoNota.file)) == null ? void 0 : _a.frontmatter;
        let valorActualCampo = metadata[campoName] || "Sin definir";
        if (typeof this[functionName] === "function") {
          if (parametro !== null) {
            nota[campoName] = await this[functionName](parametro, valorActualCampo);
          } else {
            nota[campoName] = await this[functionName]();
          }
        } else {
          console.error(`La funci\xF3n ${functionName} no est\xE1 definida.`);
        }
      }
      if (Object.keys(nota).length > 0) {
        await this.updateYAMLFields(nota, infoNota.file.path);
      } else {
      }
    } catch (error) {
      console.error("No se pudo crear el objeto de registro.", error);
      new import_obsidian24.Notice("No se pudo crear el objeto de registro.");
      return null;
    }
    return nota;
  }
  async archivarNota(infoNota, campos) {
    let nota = {};
    Object.assign(this.infoNota, infoNota);
    try {
      for (let campo of campos) {
        const functionName = `get${campo.charAt(0).toUpperCase() + campo.slice(1)}`;
        if (typeof this[functionName] === "function") {
          nota[campo] = await this[functionName]();
        } else {
          console.error(`La funci\xF3n ${functionName} no est\xE1 definida.`);
        }
      }
      debugger;
      nota.estado = "\u{1F535}";
      if (Object.keys(nota).length > 0) {
        await this.updateYAMLFields(nota, infoNota.file.path);
      } else {
      }
    } catch (error) {
      console.error("No se pudo crear el objeto de registro.", error);
      new import_obsidian24.Notice("No se pudo crear el objeto de registro.");
      return null;
    }
    return nota;
  }
  async updateYAMLFields(nota, ruta) {
    try {
      const file = app.vault.getAbstractFileByPath(ruta);
      await app.fileManager.processFrontMatter(file, (frontmatter) => {
        for (const campo in nota) {
          if (frontmatter.hasOwnProperty(campo)) {
            frontmatter[campo] = nota[campo];
          }
        }
      });
      console.log("Frontmatter actualizado con \xE9xito");
    } catch (err) {
      console.error("Error al actualizar el frontmatter", err);
    }
  }
  getTp() {
    if (!this.plugin || !this.plugin.app.plugins.enabledPlugins.has("templater-obsidian")) {
      console.error("El plugin Templater no est\xE1 habilitado.");
      return;
    }
    let tpGen = this.plugin.app.plugins.plugins["templater-obsidian"].templater;
    tpGen = tpGen.functions_generator.internal_functions.modules_array;
    let tp = {};
    tp.system = tpGen.find((m) => m.name == "system");
    if (!tp.system) {
      console.error("No se pudo acceder al objeto de funciones actuales de Templater.");
      return;
    }
    console.log("tp en YAMLUpdaterAPI se ha cargado satisfactoriamente");
    return tp;
  }
  async getFecha(flag, actual) {
    return this.formatearFecha(/* @__PURE__ */ new Date());
  }
  formatearFecha(fecha) {
    const offset2 = fecha.getTimezoneOffset() * 6e4;
    const fechaLocal = new Date(fecha.getTime() - offset2);
    const fechaFormato = fechaLocal.toISOString().split("T")[0];
    const dias = ["Domingo", "Lunes", "Martes", "Mi\xE9rcoles", "Jueves", "Viernes", "S\xE1bado"];
    const diaSemana = dias[fecha.getDay()];
    const horaFormato = fecha.toTimeString().split(" ")[0].substring(0, 5);
    return `${fechaFormato} ${diaSemana} ${horaFormato}`;
  }
  async getHoraFinal(parametro, actual) {
    debugger;
    if (parametro === void 0) {
      return this.formatearFecha(/* @__PURE__ */ new Date());
    } else {
      return parametro;
    }
  }
  async getTiempoTrabajado(parametro, actual) {
    debugger;
    let horaInicioStr = this.infoNota.horaInicio;
    let cierre;
    let [fecha, , hora] = horaInicioStr.split(" ");
    let fechaHoraISO = `${fecha}T${hora}`;
    let horaInicio = new Date(fechaHoraISO);
    if (parametro == void 0) {
      cierre = /* @__PURE__ */ new Date();
    } else {
      let [fechaCierre, , horaCierre] = parametro.split(" ");
      let fechaHoraCierreISO = `${fechaCierre}T${horaCierre}`;
      cierre = new Date(fechaHoraCierreISO);
    }
    let diferenciaEnMilisegundos = cierre - horaInicio;
    return diferenciaEnMilisegundos;
  }
  async getSecId(flag, actual) {
  }
  async getTitulo(flag, actual) {
    let titulo = await this.tp.system.prompt(`Titulo de este(a) ${this.infoSubsistema.name}`, `${this.infoSubsistema.name} - ${this.nota.id}`, true);
    if (titulo === null) {
      new import_obsidian24.Notice("Creaci\xF3n de nota cancelada por el usuario.");
      return;
    }
    this.nota.titulo = titulo;
    return titulo;
  }
  async getDescripcion(flag, actual) {
    let prompt = this.tp.system.static_functions.get("prompt");
    let descripcion;
    switch (flag) {
      case "RegistroTiempo":
        descripcion = await prompt("\xBFDetalle del Registro Tiempo:", actual, false, true);
        break;
      default:
        descripcion = await prompt("\xBFQuieres agregar una descripci\xF3n?", ` Esta nota es sobre ${this.nota.titulo}`, false, true);
        break;
    }
    if (descripcion === null) {
      new import_obsidian24.Notice("Creaci\xF3n de nota cancelada por el usuario.");
      return;
    }
    this.nota.descripcion = descripcion;
    return descripcion;
  }
  async getAliases(flag, actual) {
    this.nota.aliases = [];
    switch (this.infoSubsistema.type) {
      case "Ax":
        this.nota.aliases.push(`${this.nota.titulo}`);
        this.nota.aliases.push(`${this.infoSubsistema.type} - ${this.nota.titulo}`);
        break;
      case "AV":
      case "AI":
        break;
    }
    return this.nota.aliases;
  }
  async getAsunto(flag, actual) {
    let siAsunto, nombre;
    let activo = app.workspace.getActiveFile();
    if (activo != null) {
      nombre = activo.basename;
      const nota = app.metadataCache.getFileCache(activo);
      siAsunto = await this.tp.system.suggester(["Si", "No"], [true, false], true, nombre + " es origen de " + this.nota.titulo + "?");
    } else {
      siAsunto = false;
      nombre = "";
    }
    this.nota.asunto = {};
    this.nota.asunto.siAsunto = siAsunto;
    this.nota.asunto.nombre = nombre;
    return { siAsunto, nombre };
  }
  async getClasificacion(flag, actual) {
    var _a;
    let clasificacion2, tagClasificacion2, clasificacionAX, tagsClasificacionAX;
    let nuevaClasificacion2 = false;
    const file = app.vault.getAbstractFileByPath(this.pathCampos);
    const frontmatter = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (frontmatter) {
      clasificacionAX = frontmatter.tituloClasificacionAX || [];
      tagsClasificacionAX = frontmatter.tagsClasificacionAX || [];
      tagClasificacion2 = await this.tp.system.suggester(clasificacionAX, tagsClasificacionAX, false, "\xBFClasificar\xEDas esta nota bajo alguna de las siguientes categor\xEDas?");
      if (tagClasificacion2 === null) {
        new import_obsidian24.Notice("Creaci\xF3n de nota cancelada por el usuario.");
        return;
      } else if (tagClasificacion2 == "Nuevo") {
        clasificacion2 = await this.tp.system.prompt("\xBFCual es el nombre de la nueva clasificaci\xF3n que vas a ingresar?", "MiClasificaci\xF3n", true);
        if (clasificacion2 === null) {
          new import_obsidian24.Notice("Creaci\xF3n de nota cancelada por el usuario.");
          return;
        }
        tagClasificacion2 = await this.tp.system.prompt("\xBFCual es el tag que utilizaras para " + clasificacion2 + "?. No utilices espacios en la definici\xF3n del tag.", "nuevoTag", true);
        if (tagClasificacion2 === null) {
          new import_obsidian24.Notice("Creaci\xF3n de nota cancelada por el usuario.");
          return;
        }
        nuevaClasificacion2 = true;
      } else if (tagClasificacion2 == "Ninguna") {
        tagClasificacion2 = "";
        clasificacion2 = "";
      } else {
        let indice = tagsClasificacionAX.indexOf(tagClasificacion2);
        clasificacion2 = clasificacionAX[indice];
      }
    }
    if (nuevaClasificacion2) {
      try {
        await app.fileManager.processFrontMatter(file, (frontmatter2) => {
          let newClasificacion = [...clasificacionAX, clasificacion2];
          let newTagClasificacion = [...tagsClasificacionAX, tagClasificacion2];
          frontmatter2.tituloClasificacionAX = newClasificacion;
          frontmatter2.tagsClasificacionAX = newTagClasificacion;
          console.log("Frontmatter actualizado con \xE9xito");
        });
      } catch (err) {
        console.error("Error al actualizar el frontmatter", err);
      }
    }
    if (tagClasificacion2 != "") {
      tagClasificacion2 = "cl/" + tagClasificacion2;
    }
    this.nota.clasificacionAX = clasificacion2;
    this.nota.tagClasificacionAX = tagClasificacion2;
    return { clase: clasificacion2, tag: tagClasificacion2 };
  }
  // ->
  async getEstado(parametro, actual) {
    debugger;
    let campo;
    if (parametro == void 0) {
      let suggester = this.tp.system.static_functions.get("suggester");
      campo = await suggester(["\u{1F535} -> Completado - Informaci\xF3n", "\u{1F7E2} -> Finalizado", "\u{1F7E1} -> En ejecuci\xF3n", "\u{1F534} -> Detenido"], ["\u{1F535}", "\u{1F7E2}", "\u{1F7E1}", "\u{1F534}"], false, "Seleccione el nuevo estado:");
      if (campo === null) {
        new import_obsidian24.Notice("Modificaci\xF3n de nota cancelada por el usuario.");
        return;
      }
    } else {
      campo = parametro;
    }
    this.nota.estado = campo;
    return campo;
  }
  async getFilename(flag, actual) {
    switch (this.infoSubsistema.type) {
      case "AV":
      case "AI":
        this.nota.fileName = `${this.infoSubsistema.folder}/${this.nota.titulo}/index${this.infoSubsistema.type}`;
        break;
      case "Ax":
        this.nota.fileName = `${this.infoSubsistema.folder}/${this.infoSubsistema.type} - ${this.nota.id}`;
        break;
    }
    return this.nota.fileName;
  }
  async modalCambioHF(nota) {
    debugger;
    let modal = new modal_cambioHF(this.plugin, nota);
    modal.open();
  }
};

// src/modules/noteLifecycleManager/API/menuDiarioAPI.ts
var import_obsidian25 = require("obsidian");
var menuHoyAPI = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.registroTiempoAPI = new registroTiempoAPI(this.plugin);
  }
  // Función para crear y mostrar el botón inicial "Menú hoy"
  async mostrarMenu(dv) {
    dv.container.innerHTML = "";
    const botonMenuHoy = document.createElement("button");
    botonMenuHoy.textContent = "Men\xFA hoy";
    dv.container.appendChild(botonMenuHoy);
    botonMenuHoy.onclick = async () => {
      await this.mostrarBotones(dv);
    };
  }
  // Método modificado para adaptarse al contexto del plugin
  async mostrarBotones(dv) {
    dv.container.innerHTML = "";
    const botones = [
      "H\xE1bitos",
      "Balance",
      "Registro de Tareas",
      "Notas d\xEDa",
      "Personales"
    ];
    botones.forEach((textoBoton) => {
      const boton = document.createElement("button");
      boton.textContent = textoBoton;
      boton.onclick = async () => {
        switch (textoBoton) {
          case "Balance":
            await this.mostrarBotonBalancePersonal(dv);
            break;
          case "H\xE1bitos":
            await this.mostrarFormularioHabitos(dv);
            break;
          case "Registro de Tareas":
            await this.mostrarBotonRegistroTareas(dv);
            break;
          case "Notas d\xEDa":
            await this.mostrarBotonesNotasD\u00EDa(dv);
            break;
          case "Personales":
            await this.mostrarBotonesNotasPersonales(dv);
            break;
          default:
            console.log(`${textoBoton} presionado.`);
            break;
        }
      };
      dv.container.appendChild(boton);
    });
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
  }
  // Método para agregar el botón de recarga y su lógica (Ejemplo adaptado)
  agregarBotonSalir(dv) {
    const botonRecarga = document.createElement("button");
    botonRecarga.textContent = "Salir";
    botonRecarga.onclick = async () => {
      await this.mostrarMenu(dv);
    };
    return botonRecarga;
  }
  // Método para actualizar campos YAML
  async updateYAMLFields(filePath, YAMLfield, valor) {
    try {
      const file = app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian25.TFile) {
        try {
          await app.fileManager.processFrontMatter(file, (frontmatter) => {
            frontmatter[YAMLfield] = valor;
          });
          new import_obsidian25.Notice("YAML actualizado con \xE9xito.");
        } catch (err) {
          console.error("Error al actualizar el frontmatter", err);
        }
      }
    } catch (err) {
      console.error("Archivo no encontrado", err);
      new import_obsidian25.Notice("Error al actualizar el YAML.");
    }
  }
  // Método adaptado para mostrarBotonBalancePersonal
  async mostrarBotonBalancePersonal(dv) {
    var _a;
    dv.container.innerHTML = "";
    const mensaje = document.createElement("h2");
    mensaje.textContent = "Eval\xFAa el balance de tu vida hoy";
    dv.container.appendChild(mensaje);
    const instrucciones = document.createElement("p");
    instrucciones.textContent = "Eval\xFAa de 1 a 5 cada \xE1rea:";
    dv.container.appendChild(instrucciones);
    const areas = [
      "Productividad",
      "Espiritual",
      "Salud",
      "Rutinas",
      "Vida Social",
      "Familiar",
      "Aprendizajes",
      "Creatividad"
    ];
    const file = app.workspace.getActiveFile();
    let metadata;
    if (file instanceof import_obsidian25.TFile) {
      metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    }
    areas.forEach((area) => {
      const safeName = area.toLowerCase().replace(/ /g, "_");
      const currentVal = metadata && metadata[safeName] ? metadata[safeName] : 0;
      const contenedorArea = document.createElement("div");
      contenedorArea.classList.add("area-evaluacion");
      const label = document.createElement("label");
      label.textContent = area + ": ";
      label.htmlFor = safeName;
      const input = document.createElement("input");
      input.type = "range";
      input.id = safeName;
      input.name = safeName;
      input.min = "1";
      input.max = "5";
      input.value = currentVal.toString();
      const valorLabel = document.createElement("span");
      valorLabel.textContent = input.value;
      input.oninput = () => valorLabel.textContent = input.value;
      contenedorArea.appendChild(label);
      contenedorArea.appendChild(input);
      contenedorArea.appendChild(valorLabel);
      dv.container.appendChild(contenedorArea);
    });
    const botonGuardar = document.createElement("button");
    botonGuardar.textContent = "Guardar";
    botonGuardar.onclick = async () => {
      if (file instanceof import_obsidian25.TFile) {
        for (const area of areas) {
          const safeName = area.toLowerCase().replace(/ /g, "_");
          const inputElement = document.getElementById(safeName);
          const valor = parseInt(inputElement.value, 10);
          await this.updateYAMLFields(file.path, safeName, valor);
        }
        new import_obsidian25.Notice("Balances actualizados con \xE9xito.");
      } else {
        new import_obsidian25.Notice("No se pudo obtener el archivo actual.");
      }
    };
    dv.container.appendChild(botonGuardar);
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
  }
  async mostrarFormularioHabitos(dv) {
    dv.container.innerHTML = "";
    const habitos = [
      "Club 5am",
      "Registro Ak\xE1shiko",
      "Gimnasio",
      "Comer Saludable",
      "Leer libro",
      "Escribir bit\xE1cora el mismo d\xEDa",
      "Crear plan d\xEDa siguiente",
      "Me fu\xED a dormir antes de las 10:30pm"
    ];
    const cargarCheckboxesSeleccionados = async () => {
      var _a;
      const file = app.workspace.getActiveFile();
      const fileContent = await app.vault.read(file);
      const frontMatter = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const existingHabits = (frontMatter == null ? void 0 : frontMatter.habitos) || [];
      habitos.forEach((habito) => {
        const container = document.createElement("div");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = habito;
        checkbox.name = "habitos";
        checkbox.value = habito;
        checkbox.checked = existingHabits.includes(habito);
        const label = document.createElement("label");
        label.htmlFor = habito;
        label.textContent = habito;
        container.appendChild(checkbox);
        container.appendChild(label);
        dv.container.appendChild(container);
      });
    };
    await cargarCheckboxesSeleccionados();
    const guardarBtn = document.createElement("button");
    guardarBtn.textContent = "Guardar";
    guardarBtn.onclick = async () => {
      const file = app.workspace.getActiveFile();
      const checkboxes = Array.from(document.querySelectorAll('input[name="habitos"]:checked'));
      const selectedHabits = checkboxes.map((checkbox) => checkbox.value);
      await this.updateYAMLFields(file.path, "habitos", selectedHabits);
    };
    dv.container.appendChild(guardarBtn);
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
  }
  // Método adaptado para mostrarBotonBalancePersonal
  async mostrarBotonRegistroTareas(dv) {
    dv.container.innerHTML = "";
    let botones;
    const utilsAPInstance = new utilsAPI(this.plugin);
    const activo = await utilsAPInstance.buscarRegistrosActivos(app);
    if (activo instanceof import_obsidian25.TFile) {
      botones = ["Cerradas Hoy", "Registros Hoy", "Nuevo Registro Tiempo", "Cerrar Registro Tiempo"];
    } else {
      botones = ["Cerradas Hoy", "Registros Hoy", "Nuevo Registro Tiempo"];
    }
    botones.forEach((textoBoton) => {
      const boton = document.createElement("button");
      boton.textContent = textoBoton;
      boton.onclick = async () => {
        switch (textoBoton) {
          case "Cerradas Hoy":
            await this.mostrarCerradasHoy(dv);
            break;
          case "Registros Hoy":
            await this.mostrarRegistrosHoy(dv);
            break;
          case "Cerrar Registro Tiempo":
            debugger;
            await this.registroTiempoAPI.cerrarRegistro(activo);
            break;
          case "Nuevo Registro Tiempo":
            const starterAPInstance = new starterAPI(this.plugin);
            await starterAPInstance.createNote("RegistroTiempo");
            break;
          default:
            console.log(`${textoBoton} presionado.`);
            break;
        }
      };
      dv.container.appendChild(boton);
    });
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
  }
  async mostrarCerradasHoy(dv) {
    dv.container.innerHTML = "";
    const activo = app.workspace.getActiveFile();
    let fechaActivo = activo == null ? void 0 : activo.basename.split(" ")[0];
    const hoy = new Date(fechaActivo).setHours(0, 0, 0, 0);
    const files = app.vault.getMarkdownFiles();
    let tareasPromesas = files.map(async (file) => {
      var _a;
      let contenido = await app.vault.read(file);
      let tareasExtraidas = extraerTareas(contenido);
      const frontMatter = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const alias = (frontMatter == null ? void 0 : frontMatter.aliases) ? frontMatter.aliases[0] : null;
      const filePath = file.path;
      return {
        filePath,
        alias,
        tareas: tareasExtraidas.filter((tarea) => {
          let fechaTarea = new Date(tarea.completionDate).setHours(0, 0, 0, 0);
          return tarea.completed && tarea.completionDate && fechaTarea === hoy;
        })
      };
    });
    let resultados = await Promise.all(tareasPromesas);
    let totalTareasCerradas = resultados.reduce((total, { tareas }) => total + tareas.length, 0);
    if (totalTareasCerradas > 0) {
      dv.header(3, `Hoy se han cerrado ${totalTareasCerradas} tareas.`);
      const table = document.createElement("table");
      table.classList.add("table");
      table.style.width = "100%";
      const headerRow = document.createElement("tr");
      let headers = ["Nota", "Tareas Cerradas"];
      headers.forEach((headerText) => {
        let header = document.createElement("th");
        header.textContent = headerText;
        header.style.textAlign = "center";
        headerRow.appendChild(header);
      });
      table.appendChild(headerRow);
      resultados.forEach(({ filePath, alias, tareas }) => {
        if (tareas.length > 0) {
          let row = document.createElement("tr");
          let linkCell = document.createElement("td");
          linkCell.style.verticalAlign = "middle";
          let a = document.createElement("a");
          a.setAttribute("href", `obsidian://open?vault=${app.vault.getName()}&file=${encodeURIComponent(filePath)}`);
          a.textContent = alias || filePath;
          linkCell.appendChild(a);
          row.appendChild(linkCell);
          let tasksCell = document.createElement("td");
          let tasksList = document.createElement("ul");
          tareas.forEach((tarea) => {
            let li = document.createElement("li");
            li.textContent = tarea.text;
            tasksList.appendChild(li);
          });
          tasksCell.appendChild(tasksList);
          row.appendChild(tasksCell);
          table.appendChild(row);
        }
      });
      dv.container.appendChild(table);
    } else {
      dv.paragraph("No hay tareas cerradas hoy.");
    }
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
    function extraerTareas(contenido) {
      const tareas = [];
      const lineas = contenido.split("\n");
      for (const linea of lineas) {
        const tareaRegex = /^\s*-\s*\[(x|X| )\]\s*(.+)$/;
        const match2 = tareaRegex.exec(linea);
        if (match2) {
          const completada = match2[1].toLowerCase() === "x";
          let textoTarea = match2[2];
          let fechaCompletitud = null;
          const fechaRegex = /\[completion:: (\d{4}-\d{2}-\d{2})\]/;
          const fechaMatch = fechaRegex.exec(textoTarea);
          if (fechaMatch) {
            fechaCompletitud = fechaMatch[1];
            textoTarea = textoTarea.replace(fechaRegex, "").trim();
          }
          tareas.push({
            text: textoTarea,
            completed: completada,
            completionDate: fechaCompletitud
          });
        }
      }
      return tareas;
    }
  }
  async mostrarRegistrosHoy(dv) {
    var _a, _b;
    const activeLeaf = app.workspace.activeLeaf;
    const currentFilePath = (_b = (_a = activeLeaf.view) == null ? void 0 : _a.file) == null ? void 0 : _b.path;
    const newLeaf = await app.workspace.splitActiveLeaf("vertical");
    await newLeaf.setViewState({
      type: "vista-registro-diario"
    });
    app.workspace.revealLeaf(newLeaf);
  }
  createButtonTable(buttonText, onClickCallback) {
    const button = document.createElement("button");
    button.textContent = buttonText;
    button.type = "button";
    button.classList.add("your-button-class");
    button.addEventListener("click", onClickCallback);
    return button;
  }
  // Crea la nota desde el templater de RegistroTiempo
  async retomarTarea(id) {
    debugger;
    const filePath = `Plantillas/${this.plugin.settings[`folder_RegistroTiempo`]}/Plt - RegistroTiempo.md`;
    const template = app.vault.getAbstractFileByPath(filePath);
    if (template instanceof import_obsidian25.TFile) {
      console.log("Archivo encontrado:", template);
    } else {
      console.log("Archivo no encontrado.");
    }
    const filename = "Retomar " + id;
    const folder = app.vault.getAbstractFileByPath("Inbox");
    const tp = this.getTp();
    let crearNota = tp.file.static_functions.get("create_new");
    await crearNota(template, filename, false, folder).basename;
  }
  getTp() {
    if (!this.plugin || !this.plugin.app.plugins.enabledPlugins.has("templater-obsidian")) {
      console.error("El plugin Templater no est\xE1 habilitado.");
      return;
    }
    let tpGen = this.plugin.app.plugins.plugins["templater-obsidian"].templater;
    tpGen = tpGen.functions_generator.internal_functions.modules_array;
    let tp = {};
    tp.file = tpGen.find((m) => m.name == "file");
    tp.system = tpGen.find((m) => m.name == "system");
    if (!tp.file) {
      console.error("No se pudo acceder al objeto de funciones actuales de Templater.");
      return;
    }
    console.log('tp con propiedades "file" se ha cargado satisfactoriamente');
    return tp;
  }
};

// src/modules/noteLifecycleManager/API/menuSemanalAPI.ts
var import_obsidian27 = require("obsidian");

// src/modules/noteLifecycleManager/views/vistaResumenSemanal.ts
var import_obsidian26 = require("obsidian");
var VistaResumenSemanal = class extends import_obsidian26.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return "vista-resumen-semanal";
  }
  getDisplayText() {
    return "Resumen Semanal";
  }
  getIcon() {
    return "history";
  }
  async onOpen() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      this.contentEl.setText("No hay un archivo activo.");
      return;
    }
    const fileCache = this.app.metadataCache.getFileCache(activeFile);
    await this.actualizarVista(fileCache);
    this.intervalId = window.setInterval(async () => {
      await this.actualizarVista(fileCache);
    }, 1e4);
  }
  onClose() {
    clearInterval(this.intervalId);
  }
  async actualizarVista(fileCache) {
    var _a;
    this.contentEl.empty();
    const inicioWStr = (_a = fileCache.frontmatter) == null ? void 0 : _a.inicioW;
    if (!inicioWStr) {
      this.contentEl.setText("La configuraci\xF3n de inicioW no est\xE1 establecida.");
      return;
    }
    const folderDiario = "Estructura/Journal/Diario/Notas";
    const inicioW = DateTime.fromFormat(inicioWStr, "yyyy-MM-dd EEEE", { locale: "es" });
    const finW = inicioW.plus({ days: 6 });
    const archivosDiario = this.app.vault.getFiles().filter((file) => file.path.startsWith(folderDiario) && file.extension === "md");
    const bitacoras = archivosDiario.map((file) => {
      var _a2;
      const fechaArchivo = DateTime.fromISO(file.basename.substring(0, 10));
      const datos = (_a2 = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a2.frontmatter;
      return {
        archivo: file.basename,
        path: file.path,
        fechaArchivo,
        datos
      };
    }).filter(({ fechaArchivo }) => fechaArchivo >= inicioW && fechaArchivo <= finW).sort((a, b) => a.fechaArchivo.toMillis() - b.fechaArchivo.toMillis());
    let trim = finW.quarter;
    let sem = finW.weekNumber - (finW.quarter - 1) * 13;
    if (sem == 0) {
      sem = 13;
    }
    const titulo = this.contentEl.createEl("h2", { text: `Resumen de la semana ${sem} - Q${trim} / W${finW.toFormat("WW")}.` });
    const subtitulo = this.contentEl.createEl("h3", { text: `Desde el ${inicioW.toFormat("EEEE, DD")} al ${finW.toFormat("EEEE, DD")}` });
    titulo.style.textAlign = "center";
    subtitulo.style.textAlign = "center";
    const table = document.createElement("table");
    table.className = "table-resumenSemanal";
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    ["D\xEDa", "Resumen"].forEach((headerText) => {
      const th = document.createElement("th");
      th.textContent = headerText;
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);
    const tbody = document.createElement("tbody");
    bitacoras.forEach(({ archivo, path, datos }) => {
      const tr = document.createElement("tr");
      const tdArchivo = document.createElement("td");
      const linkEl = document.createElement("a");
      linkEl.textContent = archivo;
      linkEl.href = path;
      linkEl.onclick = async (ev) => {
        ev.preventDefault();
        const file = this.app.vault.getAbstractFileByPath(path);
        if (file instanceof import_obsidian26.TFile) {
          await this.app.workspace.getLeaf(false).openFile(file, { eState: { focus: true } });
        }
      };
      tdArchivo.appendChild(linkEl);
      const tdResumen = document.createElement("td");
      const ul = document.createElement("ul");
      (datos.titulo || ["Sin t\xEDtulo"]).forEach((titulo2) => {
        const li = document.createElement("li");
        li.textContent = titulo2;
        ul.appendChild(li);
      });
      tdResumen.appendChild(ul);
      tr.appendChild(tdArchivo);
      tr.appendChild(tdResumen);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    this.contentEl.appendChild(table);
  }
  // Opcional: Implementa onClose si necesitas limpieza al cerrar la vista.
};

// src/modules/noteLifecycleManager/API/menuSemanalAPI.ts
var menuSemanalAPI = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
  }
  // Función para crear y mostrar el botón inicial "Menú hoy"
  async mostrarMenu(dv) {
    dv.container.innerHTML = "";
    const botonMenuHoy = document.createElement("button");
    botonMenuHoy.textContent = "Men\xFA Semanal";
    dv.container.appendChild(botonMenuHoy);
    botonMenuHoy.onclick = async () => {
      await this.mostrarBotones(dv);
    };
  }
  // Método modificado para adaptarse al contexto del plugin
  async mostrarBotones(dv) {
    dv.container.innerHTML = "";
    const botones = [
      "Resumen diario",
      "Agradecimientos",
      "Creadas",
      "Modificadas",
      "x Fecha",
      "Tareas Cerradas"
    ];
    botones.forEach((textoBoton) => {
      const boton = document.createElement("button");
      boton.textContent = textoBoton;
      boton.onclick = async () => {
        switch (textoBoton) {
          case "Resumen diario":
            await this.mostrarResumenDiario(dv);
            break;
          case "Agradecimientos":
            await this.mostrarAgradecimientos(dv);
            break;
          case "Creadas":
            await this.mostrarCreadas(dv);
            break;
          case "Modificadas":
            await this.mostrarModificadas(dv);
            break;
          case "x Fecha":
            await this.mostrarxFecha(dv);
            break;
          case "Tareas Cerradas":
            await this.mostrarTareasCerradas(dv);
            break;
          default:
            console.log(`${textoBoton} presionado.`);
            break;
        }
      };
      dv.container.appendChild(boton);
    });
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
  }
  // Método para agregar el botón de recarga y su lógica (Ejemplo adaptado)
  agregarBotonSalir(dv) {
    const botonRecarga = document.createElement("button");
    botonRecarga.textContent = "Salir";
    botonRecarga.onclick = async () => {
      await this.mostrarMenu(dv);
    };
    return botonRecarga;
  }
  // Método para actualizar campos YAML
  async updateYAMLFields(filePath, YAMLfield, valor) {
    try {
      const file = app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian27.TFile) {
        try {
          await app.fileManager.processFrontMatter(file, (frontmatter) => {
            frontmatter[YAMLfield] = valor;
          });
          new import_obsidian27.Notice("YAML actualizado con \xE9xito.");
        } catch (err) {
          console.error("Error al actualizar el frontmatter", err);
        }
      }
    } catch (err) {
      console.error("Archivo no encontrado", err);
      new import_obsidian27.Notice("Error al actualizar el YAML.");
    }
  }
  async mostrarResumenDiario(dv) {
    var _a, _b;
    debugger;
    const activeLeaf = app.workspace.activeLeaf;
    const currentFilePath = (_b = (_a = activeLeaf.view) == null ? void 0 : _a.file) == null ? void 0 : _b.path;
    const newLeaf = await app.workspace.splitActiveLeaf("vertical");
    await newLeaf.setViewState({
      type: "vista-resumen-semanal"
    });
    app.workspace.revealLeaf(newLeaf);
  }
  // Método adaptado para mostrarBotonBalancePersonal
  async mostrarBotonBalancePersonal(dv) {
    var _a;
    dv.container.innerHTML = "";
    const mensaje = document.createElement("h2");
    mensaje.textContent = "Eval\xFAa el balance de tu vida hoy";
    dv.container.appendChild(mensaje);
    const instrucciones = document.createElement("p");
    instrucciones.textContent = "Eval\xFAa de 1 a 5 cada \xE1rea:";
    dv.container.appendChild(instrucciones);
    const areas = [
      "Productividad",
      "Espiritual",
      "Salud",
      "Rutinas",
      "Vida Social",
      "Familiar",
      "Aprendizajes",
      "Creatividad"
    ];
    const file = app.workspace.getActiveFile();
    let metadata;
    if (file instanceof import_obsidian27.TFile) {
      metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    }
    areas.forEach((area) => {
      const safeName = area.toLowerCase().replace(/ /g, "_");
      const currentVal = metadata && metadata[safeName] ? metadata[safeName] : 0;
      const contenedorArea = document.createElement("div");
      contenedorArea.classList.add("area-evaluacion");
      const label = document.createElement("label");
      label.textContent = area + ": ";
      label.htmlFor = safeName;
      const input = document.createElement("input");
      input.type = "range";
      input.id = safeName;
      input.name = safeName;
      input.min = "1";
      input.max = "5";
      input.value = currentVal.toString();
      const valorLabel = document.createElement("span");
      valorLabel.textContent = input.value;
      input.oninput = () => valorLabel.textContent = input.value;
      contenedorArea.appendChild(label);
      contenedorArea.appendChild(input);
      contenedorArea.appendChild(valorLabel);
      dv.container.appendChild(contenedorArea);
    });
    const botonGuardar = document.createElement("button");
    botonGuardar.textContent = "Guardar";
    botonGuardar.onclick = async () => {
      if (file instanceof import_obsidian27.TFile) {
        for (const area of areas) {
          const safeName = area.toLowerCase().replace(/ /g, "_");
          const inputElement = document.getElementById(safeName);
          const valor = parseInt(inputElement.value, 10);
          await this.updateYAMLFields(file.path, safeName, valor);
        }
        new import_obsidian27.Notice("Balances actualizados con \xE9xito.");
      } else {
        new import_obsidian27.Notice("No se pudo obtener el archivo actual.");
      }
    };
    dv.container.appendChild(botonGuardar);
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
  }
  async mostrarFormularioHabitos(dv) {
    dv.container.innerHTML = "";
    const habitos = [
      "Club 5am",
      "Registro Ak\xE1shiko",
      "Gimnasio",
      "Comer Saludable",
      "Leer libro",
      "Escribir bit\xE1cora el mismo d\xEDa",
      "Crear plan d\xEDa siguiente",
      "Me fu\xED a dormir antes de las 10:30pm"
    ];
    const cargarCheckboxesSeleccionados = async () => {
      var _a;
      const file = app.workspace.getActiveFile();
      const fileContent = await app.vault.read(file);
      const frontMatter = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const existingHabits = (frontMatter == null ? void 0 : frontMatter.habitos) || [];
      habitos.forEach((habito) => {
        const container = document.createElement("div");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = habito;
        checkbox.name = "habitos";
        checkbox.value = habito;
        checkbox.checked = existingHabits.includes(habito);
        const label = document.createElement("label");
        label.htmlFor = habito;
        label.textContent = habito;
        container.appendChild(checkbox);
        container.appendChild(label);
        dv.container.appendChild(container);
      });
    };
    await cargarCheckboxesSeleccionados();
    const guardarBtn = document.createElement("button");
    guardarBtn.textContent = "Guardar";
    guardarBtn.onclick = async () => {
      const file = app.workspace.getActiveFile();
      const checkboxes = Array.from(document.querySelectorAll('input[name="habitos"]:checked'));
      const selectedHabits = checkboxes.map((checkbox) => checkbox.value);
      await this.updateYAMLFields(file.path, "habitos", selectedHabits);
    };
    dv.container.appendChild(guardarBtn);
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
  }
  // Método adaptado para mostrarBotonBalancePersonal
  async mostrarBotonRegistroTareas(dv) {
    dv.container.innerHTML = "";
    let botones;
    const utilsAPInstance = new utilsAPI(this.plugin);
    const activo = await utilsAPInstance.buscarRegistrosActivos(app);
    if (activo instanceof import_obsidian27.TFile) {
      botones = ["Cerradas Hoy", "Registros Hoy", "Nuevo Registro Tiempo", "Cerrar Registro Tiempo"];
    } else {
      botones = ["Cerradas Hoy", "Registros Hoy", "Nuevo Registro Tiempo"];
    }
    botones.forEach((textoBoton) => {
      const boton = document.createElement("button");
      boton.textContent = textoBoton;
      boton.onclick = async () => {
        switch (textoBoton) {
          case "Cerradas Hoy":
            await this.mostrarCerradasHoy(dv);
            break;
          case "Registros Hoy":
            await this.mostrarRegistrosHoy(dv);
            break;
          case "Cerrar Registro Tiempo":
            debugger;
            await this.registroTiempoAPI.cerrarRegistro(activo);
            break;
          case "Nuevo Registro Tiempo":
            const starterAPInstance = new starterAPI(this.plugin);
            await starterAPInstance.createNote("RegistroTiempo");
            break;
          default:
            console.log(`${textoBoton} presionado.`);
            break;
        }
      };
      dv.container.appendChild(boton);
    });
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
  }
  async mostrarCerradasHoy(dv) {
    dv.container.innerHTML = "";
    const activo = app.workspace.getActiveFile();
    let fechaActivo = activo == null ? void 0 : activo.basename.split(" ")[0];
    const hoy = new Date(fechaActivo).setHours(0, 0, 0, 0);
    const files = app.vault.getMarkdownFiles();
    let tareasPromesas = files.map(async (file) => {
      var _a;
      let contenido = await app.vault.read(file);
      let tareasExtraidas = extraerTareas(contenido);
      const frontMatter = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const alias = (frontMatter == null ? void 0 : frontMatter.aliases) ? frontMatter.aliases[0] : null;
      const filePath = file.path;
      return {
        filePath,
        alias,
        tareas: tareasExtraidas.filter((tarea) => {
          let fechaTarea = new Date(tarea.completionDate).setHours(0, 0, 0, 0);
          return tarea.completed && tarea.completionDate && fechaTarea === hoy;
        })
      };
    });
    let resultados = await Promise.all(tareasPromesas);
    let totalTareasCerradas = resultados.reduce((total, { tareas }) => total + tareas.length, 0);
    if (totalTareasCerradas > 0) {
      dv.header(3, `Hoy se han cerrado ${totalTareasCerradas} tareas.`);
      const table = document.createElement("table");
      table.classList.add("table");
      table.style.width = "100%";
      const headerRow = document.createElement("tr");
      let headers = ["Nota", "Tareas Cerradas"];
      headers.forEach((headerText) => {
        let header = document.createElement("th");
        header.textContent = headerText;
        header.style.textAlign = "center";
        headerRow.appendChild(header);
      });
      table.appendChild(headerRow);
      resultados.forEach(({ filePath, alias, tareas }) => {
        if (tareas.length > 0) {
          let row = document.createElement("tr");
          let linkCell = document.createElement("td");
          linkCell.style.verticalAlign = "middle";
          let a = document.createElement("a");
          a.setAttribute("href", `obsidian://open?vault=${app.vault.getName()}&file=${encodeURIComponent(filePath)}`);
          a.textContent = alias || filePath;
          linkCell.appendChild(a);
          row.appendChild(linkCell);
          let tasksCell = document.createElement("td");
          let tasksList = document.createElement("ul");
          tareas.forEach((tarea) => {
            let li = document.createElement("li");
            li.textContent = tarea.text;
            tasksList.appendChild(li);
          });
          tasksCell.appendChild(tasksList);
          row.appendChild(tasksCell);
          table.appendChild(row);
        }
      });
      dv.container.appendChild(table);
    } else {
      dv.paragraph("No hay tareas cerradas hoy.");
    }
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
    function extraerTareas(contenido) {
      const tareas = [];
      const lineas = contenido.split("\n");
      for (const linea of lineas) {
        const tareaRegex = /^\s*-\s*\[(x|X| )\]\s*(.+)$/;
        const match2 = tareaRegex.exec(linea);
        if (match2) {
          const completada = match2[1].toLowerCase() === "x";
          let textoTarea = match2[2];
          let fechaCompletitud = null;
          const fechaRegex = /\[completion:: (\d{4}-\d{2}-\d{2})\]/;
          const fechaMatch = fechaRegex.exec(textoTarea);
          if (fechaMatch) {
            fechaCompletitud = fechaMatch[1];
            textoTarea = textoTarea.replace(fechaRegex, "").trim();
          }
          tareas.push({
            text: textoTarea,
            completed: completada,
            completionDate: fechaCompletitud
          });
        }
      }
      return tareas;
    }
  }
  async mostrarRegistrosHoy(dv) {
    var _a;
    dv.container.innerHTML = "";
    const fechaHoy = DateTime.fromFormat(app.workspace.getActiveFile().basename.split(" ")[0], "yyyy-MM-dd", { locale: "es" });
    const folder = this.plugin.settings.folder_RegistroTiempo;
    const files = app.vault.getMarkdownFiles().filter((file) => file.path.includes(folder));
    let totalDia = 0;
    let registrosHoy = [];
    for (let file of files) {
      let metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (metadata == null ? void 0 : metadata.horaInicio) {
        let horaInicio = DateTime.fromFormat(metadata.horaInicio, "yyyy-MM-dd EEEE HH:mm", { locale: "es" });
        const startOfDay = horaInicio.startOf("day");
        if (startOfDay.ts === fechaHoy.startOf("day").ts) {
          registrosHoy.push({ path: file.path, frontmatter: metadata });
          totalDia += metadata.tiempoTrabajado ? parseInt(metadata.tiempoTrabajado) : 0;
        }
      }
    }
    dv.header(3, "Tiempo registrado hoy: " + Duration.fromMillis(totalDia).toFormat("hh:mm:ss"));
    registrosHoy.sort((a, b) => {
      if (typeof a.frontmatter.horaInicio === "string" && typeof b.frontmatter.horaInicio === "string") {
        try {
          const millisA = DateTime.fromFormat(a.frontmatter.horaInicio, "yyyy-MM-dd EEEE HH:mm", { locale: "es" }).toMillis();
          const millisB = DateTime.fromFormat(b.frontmatter.horaInicio, "yyyy-MM-dd EEEE HH:mm", { locale: "es" }).toMillis();
          return millisB - millisA;
        } catch (e) {
          console.error("Error parsing dates:", e);
          return 0;
        }
      } else {
        console.warn("Invalid date format for sorting:", a.horaInicio, b.horaInicio);
        return 0;
      }
    });
    if (registrosHoy.length > 0) {
      const table = dv.container.createEl("table", { cls: "dataview table" });
      table.style.width = "100%";
      const header = dv.el("tr", "", table);
      ["Registro", "Descripci\xF3n", "Hora Inicio", "Tiempo", "Estado", "Id", "Acci\xF3n"].forEach((text) => dv.el("th", text, header));
      registrosHoy.forEach((registro) => {
        const row = dv.el("tr", "", table);
        dv.el("td", dv.func.link(registro.path, registro.frontmatter.aliases[0]), row);
        dv.el("td", registro.frontmatter.descripcion ? registro.frontmatter.descripcion : "Sin descripci\xF3n", row);
        dv.el("td", DateTime.fromFormat(registro.frontmatter.horaInicio, "yyyy-MM-dd EEEE HH:mm", { locale: "es" }).toFormat("h:mm a") + " / " + DateTime.fromFormat(registro.frontmatter.horaFinal, "yyyy-MM-dd EEEE HH:mm", { locale: "es" }).toFormat("h:mm a"), row);
        if (registro.frontmatter.estado === "\u{1F7E2}") {
          let partes = registro.frontmatter.horaInicio.split(" ");
          let fechaHoraISO = `${partes[0]}T${partes[2]}`;
          let inicio = Date.parse(fechaHoraISO);
          let ahora = Date.now();
          let diferencia = ahora - inicio;
          dv.el("td", Duration.fromMillis(diferencia).toFormat("h:mm"), row);
        } else {
          dv.el("td", Duration.fromMillis(registro.frontmatter.tiempoTrabajado).toFormat("h:mm"), row);
        }
        dv.el("td", registro.frontmatter.estado, row);
        dv.el("td", registro.frontmatter.id, row);
        if (registro.frontmatter.estado === "\u{1F7E2}") {
          dv.el("td", this.createButtonTable("Cerrar", async () => {
            debugger;
            await this.registroTiempoAPI.cerrarRegistro(registro.frontmatter.id);
          }), row);
        } else {
          dv.el("td", this.createButtonTable("Retomar", () => {
            this.retomarTarea(registro.frontmatter.id);
          }), row);
        }
      });
    }
    const botonSalir = this.agregarBotonSalir(dv);
    dv.container.appendChild(botonSalir);
  }
  createButtonTable(buttonText, onClickCallback) {
    const button = document.createElement("button");
    button.textContent = buttonText;
    button.type = "button";
    button.classList.add("your-button-class");
    button.addEventListener("click", onClickCallback);
    return button;
  }
  // Crea la nota desde el templater de RegistroTiempo
  async retomarTarea(id) {
    debugger;
    const filePath = `Plantillas/${this.plugin.settings[`folder_RegistroTiempo`]}/Plt - RegistroTiempo.md`;
    const template = app.vault.getAbstractFileByPath(filePath);
    if (template instanceof import_obsidian27.TFile) {
      console.log("Archivo encontrado:", template);
    } else {
      console.log("Archivo no encontrado.");
    }
    const filename = "Retomar " + id;
    const folder = app.vault.getAbstractFileByPath("Inbox");
    const tp = this.getTp();
    let crearNota = tp.file.static_functions.get("create_new");
    await crearNota(template, filename, false, folder).basename;
  }
  getTp() {
    if (!this.plugin || !this.plugin.app.plugins.enabledPlugins.has("templater-obsidian")) {
      console.error("El plugin Templater no est\xE1 habilitado.");
      return;
    }
    let tpGen = this.plugin.app.plugins.plugins["templater-obsidian"].templater;
    tpGen = tpGen.functions_generator.internal_functions.modules_array;
    let tp = {};
    tp.file = tpGen.find((m) => m.name == "file");
    tp.system = tpGen.find((m) => m.name == "system");
    if (!tp.file) {
      console.error("No se pudo acceder al objeto de funciones actuales de Templater.");
      return;
    }
    console.log('tp con propiedades "file" se ha cargado satisfactoriamente');
    return tp;
  }
};

// src/modules/moduloRegistroTiempo/views/vistaRTActivo.ts
var import_obsidian28 = require("obsidian");
var VistaRegistroActivo = class extends import_obsidian28.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.registroTiempoAPI = new registroTiempoAPI(this.plugin);
  }
  getViewType() {
    return "vista-registro-activo";
  }
  getDisplayText() {
    return "Registro Activo";
  }
  getIcon() {
    return "checkmark";
  }
  async onOpen() {
    await this.actualizarVista();
    this.intervalId = setInterval(async () => {
      await this.actualizarVista();
    }, 5e3);
  }
  onClose() {
    clearInterval(this.intervalId);
  }
  async actualizarVista() {
    var _a, _b;
    this.containerEl.empty();
    const folder = this.plugin.settings.folder_RegistroTiempo;
    const files = app.vault.getMarkdownFiles().filter((file) => file.path.includes(folder));
    let registrosActivos = [];
    for (let file of files) {
      let metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if ((metadata == null ? void 0 : metadata.estado) === "\u{1F7E2}") {
        let registroActivo = { file };
        Object.assign(registroActivo, metadata);
        registrosActivos.push(registroActivo);
      }
    }
    if (registrosActivos.length === 0) {
      this.containerEl.createEl("p", { text: "No hay ning\xFAn registro de tiempo ejecutandose." });
      const botonCrear = this.containerEl.createEl("button");
      botonCrear.textContent = "Nuevo Registro Tiempo";
      botonCrear.onclick = async () => {
        const starterAPInstance = new starterAPI(this.plugin);
        await starterAPInstance.createNote("RegistroTiempo");
      };
      this.containerEl.createEl("div", { cls: "separador" });
      let registrosFinalizados = [];
      for (let file of files) {
        let metadata = (_b = app.metadataCache.getFileCache(file)) == null ? void 0 : _b.frontmatter;
        if ((metadata == null ? void 0 : metadata.estado) === "\u{1F535}") {
          let registroFinalizado = { file };
          Object.assign(registroFinalizado, metadata);
          registrosFinalizados.push(registroFinalizado);
        }
      }
      registrosFinalizados.sort((a, b) => b.id - a.id);
      let top5RegistrosActivos = registrosFinalizados.slice(0, 8);
      if (top5RegistrosActivos.length > 0) {
        this.containerEl.classList.add("table-container");
        const table = this.containerEl.createEl("table", { cls: "table-small" });
        table.style.width = "100%";
        const header = table.createEl("tr");
        ["Alias", "Descripci\xF3n", "Retomar"].forEach((text) => header.createEl("th", { text }));
        top5RegistrosActivos.forEach((registro) => {
          const row = table.createEl("tr");
          const aliasCell = row.createEl("td");
          const aliasLink = aliasCell.createEl("span", {
            text: registro.aliases[0],
            cls: "clickable-alias"
            // Una clase para estilizar, si es necesario
          });
          aliasLink.addEventListener("click", async () => {
            debugger;
            let file = app.vault.getAbstractFileByPath(registro.file.path);
            if (file instanceof import_obsidian28.TFile) {
              await app.workspace.getLeaf(true).openFile(file);
            }
          });
          row.createEl("td", { text: registro.descripcion || "No Definida" });
          const buttonCell = row.createEl("td");
          const button = this.createButtonTable("\u23F1\uFE0F", () => {
            this.registroTiempoAPI.retomarTarea(registro.id);
          });
          buttonCell.appendChild(button);
        });
      } else {
        this.containerEl.createEl("p", { text: "No hay registros finalizados." });
      }
    } else if (registrosActivos.length === 1) {
      this.containerEl.classList.add("vista-RT");
      let alias = registrosActivos[0].aliases ? registrosActivos[0].aliases[0] : "Sin alias";
      let descripcion = registrosActivos[0].descripcion ? registrosActivos[0].descripcion : "Sin descripcion";
      let partes = registrosActivos[0].horaInicio.split(" ");
      let fechaHoraISO = `${partes[0]}T${partes[2]}`;
      let inicio = DateTime.fromISO(fechaHoraISO);
      let ahora = DateTime.now();
      let diferencia = ahora.diff(inicio);
      let tiempo = Duration.fromMillis(diferencia.toMillis()).toFormat("h:mm");
      this.containerEl.createEl("h5", { text: "Tarea Actual" });
      this.containerEl.createEl("span", { text: "Nombre: " });
      const aliasSpan = this.containerEl.createEl("span", {
        text: alias,
        cls: "clickable-alias"
        // Asegúrate de tener esta clase para estilizar el span como un link
      });
      aliasSpan.addEventListener("click", async () => {
        let file = app.vault.getAbstractFileByPath(registrosActivos[0].file.path);
        if (file instanceof import_obsidian28.TFile) {
          await app.workspace.getLeaf(true).openFile(file);
        }
      });
      this.containerEl.createEl("span", { text: "\n" + descripcion });
      this.containerEl.createEl("p", { text: "Esta tarea lleva: " + tiempo });
      const botonera = this.containerEl.createEl("div");
      const botonCerrar = botonera.createEl("button");
      botonCerrar.textContent = "Cerrar Tarea";
      botonCerrar.onclick = async () => {
        await this.registroTiempoAPI.cerrarRegistro(registrosActivos[0].file);
      };
      const botonDetalle = botonera.createEl("button");
      botonDetalle.textContent = "Cambiar Descripci\xF3n";
      botonDetalle.onclick = async () => {
        await this.registroTiempoAPI.detalleRegistro(registrosActivos[0].file);
      };
    } else {
      this.containerEl.createEl("p", { text: " Hay un error con la cantidad de registros activos." });
    }
  }
  createButtonTable(buttonText, onClickCallback) {
    const button = document.createElement("button");
    button.textContent = buttonText;
    button.type = "button";
    button.classList.add("your-button-class");
    button.addEventListener("click", onClickCallback);
    return button;
  }
};

// src/modules/moduloGTD/index.ts
var import_obsidian31 = require("obsidian");

// src/modules/moduloGTD/inbox.ts
var import_obsidian30 = require("obsidian");

// src/modules/modales/inboxModal.ts
var import_obsidian29 = require("obsidian");
var BandejaDeEntradaModal = class extends import_obsidian29.Modal {
  constructor(app2) {
    super(app2);
  }
  onOpen() {
    this.containerEl.classList.add("modalInbox");
    let { contentEl } = this;
    this.titleEl.setText("Bandeja de Entrada");
    let textAreaDiv = contentEl.createEl("div");
    this.inputArea = textAreaDiv.createEl("textarea");
    this.inputArea.setAttribute("placeholder", "Escribe tu tarea aqu\xED...");
    this.inputArea.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey && !e.ctrlKey && !e.altKey) {
        e.preventDefault();
        this.submitForm();
      }
    });
    const activeFile = this.app.workspace.getActiveFile();
    const metadata = this.app.metadataCache.getFileCache(activeFile);
    let nameActiveFile = metadata.aliases ? metadata.aliases[0] : activeFile.basename;
    let checkBoxDiv = contentEl.createEl("div");
    this.checkBox = checkBoxDiv.createEl("input", { type: "checkbox" });
    checkBoxDiv.createEl("label", { text: `Guardar en ${nameActiveFile}` }).prepend(this.checkBox);
    const saveButton = checkBoxDiv.createEl("button", { text: "Guardar" });
    saveButton.addEventListener("click", () => this.submitForm());
  }
  submitForm() {
    const text = this.inputArea.value;
    const saveInCurrent = this.checkBox.checked;
    this.close();
    if (this.resolver) {
      this.resolver({ text, saveInCurrent });
    }
  }
  waitForInput() {
    return new Promise((resolve) => {
      this.resolver = resolve;
    });
  }
};

// src/modules/moduloGTD/inbox.ts
async function ingresarBandejaEntrada(plugin) {
  let inboxPath = `${plugin.settings.file_Inbox}.md`;
  let inboxFile = app.vault.getAbstractFileByPath(inboxPath);
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
    new import_obsidian30.Notice("No hay archivo activo");
    return;
  }
  let inbox;
  const modal = new BandejaDeEntradaModal(plugin.app);
  modal.open();
  const { text, saveInCurrent } = await modal.waitForInput();
  if (text.length < 3) {
    new import_obsidian30.Notice("Inbox cancelada");
    return;
  }
  let destino = saveInCurrent ? activeFile : inboxFile;
  let hoy = DateTime.now().toFormat("yyyy-MM-dd");
  let hora = DateTime.now().toFormat("HH:mm");
  inbox = `- [ ] \u{1F9E0} ${text} #inbox [created:: ${hoy}] a las ${hora}
`;
  if (destino instanceof import_obsidian30.TFile) {
    if (destino === inboxFile) {
      insertAtStartUsingProcess(inbox, destino).then(() => {
        new import_obsidian30.Notice("Bandeja de entrada actualizada con \xE9xito.");
      }).catch((error) => {
        debugger;
        console.error(error);
        new import_obsidian30.Notice("Error al agregar contenido al inicio del archivo: " + error.message);
      });
    } else {
      await insertInboxAtCursor(inbox);
    }
  }
}
async function insertInboxAtCursor(inbox) {
  debugger;
  const activeLeaf = app.workspace.activeLeaf;
  if (activeLeaf) {
    const editor = activeLeaf.view.sourceMode.cmEditor;
    const cursor = editor.getCursor();
    editor.replaceRange(inbox, cursor);
  }
}
async function insertAtStartUsingProcess(inbox, file) {
  if (!(file instanceof import_obsidian30.TFile))
    return;
  await app.vault.process(file, (content) => {
    const newContent = inbox + content;
    return newContent;
  });
}

// src/modules/moduloGTD/commands.ts
function registerCommands3(plugin) {
  const id1 = plugin.addCommand({
    id: "ingresar-inbox",
    name: "Ingresar Bandeja de Entrada -> Inbox",
    callback: async () => {
      await ingresarBandejaEntrada(plugin);
    }
  });
  plugin.registeredCommandIdsGTD.push(id1.id);
}
function deactivateCommands3(plugin) {
  if (!plugin.registeredCommandIdsGTD)
    return;
  plugin.registeredCommandIdsGTD.forEach((commandId) => {
    const command = plugin.app.commands.commands[commandId];
    if (command) {
      command.callback = () => new Notice("Este comando ha sido desactivado.");
    }
  });
}

// src/modules/moduloGTD/index.ts
var ModuloGTD = class {
  constructor(plugin) {
    this.moduloGTD = null;
    this.plugin = plugin;
  }
  activate() {
    if (this.moduloGTD)
      return;
    registerCommands3(this.plugin);
  }
  deactivate() {
    if (!this.moduloGTD)
      return;
    deactivateCommands3(this.plugin);
  }
};

// src/modules/noteLifecycleManager/API/subsistemasAPI.ts
var import_obsidian32 = require("obsidian");
var subsistemasAPI = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.pathCampos = this.plugin.settings.file_camposCentral + ".md";
  }
  // Función para crear y mostrar el botón inicial "Menú hoy"
  async mostrarBotonCrearAV(dv) {
    dv.container.innerHTML = "";
    const botonMenuHoy = document.createElement("button");
    botonMenuHoy.textContent = "Procesar Areas de Vida";
    dv.container.appendChild(botonMenuHoy);
    botonMenuHoy.onclick = async () => {
      await this.procesarAV(dv);
    };
  }
  async mostrarBotonCrearAVTrimestral(dv) {
    dv.container.innerHTML = "";
    const botonMenuHoy = document.createElement("button");
    botonMenuHoy.textContent = "Procesar Areas de Vida del trimestre";
    dv.container.appendChild(botonMenuHoy);
    botonMenuHoy.onclick = async () => {
      await this.procesarAVTrimestre(dv);
    };
  }
  async procesarAV(dv) {
    var _a, _b;
    const folderQ = this.plugin.settings["folder_Trimestral"];
    const filesQ = app.vault.getMarkdownFiles().filter(
      (file) => file.path.includes(folderQ) && !file.path.includes("Plantillas") && !file.path.includes("Archivo")
    );
    let qCreados = [];
    for (let file of filesQ) {
      let metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if ((metadata == null ? void 0 : metadata.type) === "TQ" && (metadata == null ? void 0 : metadata.trimestre)) {
        let qActivo = { file };
        Object.assign(qActivo, metadata);
        qCreados.push(qActivo);
      }
    }
    let suggester = this.plugin.tp.system.static_functions.get("suggester");
    let q = await suggester(
      qCreados.map((b) => b.trimestre),
      qCreados.map((b) => b),
      true,
      `De que trimestre vamos a procesar tus Areas de Vida`
    );
    const resultadoAV = [];
    const fileCampos = app.vault.getAbstractFileByPath(this.pathCampos);
    try {
      if (fileCampos instanceof import_obsidian32.TFile) {
        const metadata = app.metadataCache.getFileCache(fileCampos);
        const arregloAV = ((_b = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _b.AreasVida) || [];
        if (Array.isArray(arregloAV)) {
          arregloAV.forEach((item) => {
            if (Array.isArray(item) && item.length >= 2) {
              resultadoAV.push({
                grupo: item[0],
                av: item[1],
                texto: item[0] + " / " + item[1]
              });
            }
          });
        }
      }
    } catch (error) {
      console.error("Error obteniendo el archivo de campos:", error);
      throw error;
    }
    const allFiles = app.vault.getMarkdownFiles();
    let basePath = this.plugin.settings.folder_AreasVida;
    for (let areaVida of resultadoAV) {
      const fullFolderPath = `${basePath}/${areaVida.av}`;
      const folder = app.vault.getAbstractFileByPath(fullFolderPath);
      if (folder instanceof import_obsidian32.TFolder) {
        console.log(`La carpeta ${areaVida.av} existe dentro de ${basePath}.`);
        const instancesOfAV = app.vault.getMarkdownFiles().filter(
          (file) => file.path.includes(fullFolderPath) && !file.path.includes("Plantillas") && !file.path.includes("Archivo")
        );
        const nodeAVExists = instancesOfAV.some(
          (file) => file.basename === areaVida.av
        );
        if (nodeAVExists) {
          console.log(
            `La nota ${areaVida.av} existe dentro de la carpeta ${areaVida.av}.`
          );
          await this.validacionAVQ(fullFolderPath, q, areaVida);
        } else {
          debugger;
          console.log(
            `La nota ${areaVida.av} no existe dentro de la carpeta ${areaVida.av}.`
          );
          let nAV = await this.agregarNodoAreaVida(areaVida);
          if (nAV) {
            await this.validacionAVQ(fullFolderPath, q, areaVida);
          } else if (nAV == false) {
            continue;
          } else {
            return;
          }
        }
      } else {
        console.log(
          `La carpeta ${areaVida.av} no existe a\xFAn dentro de ${basePath}.`
        );
        let nAV = await this.agregarNodoAreaVida(areaVida);
        if (nAV) {
          await this.validacionAVQ(fullFolderPath, q, areaVida);
        } else if (nAV == false) {
          continue;
        } else {
          return;
        }
      }
    }
  }
  // Fin procesarAV()
  async procesarAVTrimestre(dv) {
    var _a;
    let q = {};
    q.trimestre = dv.current().trimestre;
    const resultadoAV = [];
    const fileCampos = app.vault.getAbstractFileByPath(this.pathCampos);
    try {
      if (fileCampos instanceof import_obsidian32.TFile) {
        const metadata = app.metadataCache.getFileCache(fileCampos);
        const arregloAV = ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.AreasVida) || [];
        if (Array.isArray(arregloAV)) {
          arregloAV.forEach((item) => {
            if (Array.isArray(item) && item.length >= 2) {
              resultadoAV.push({
                grupo: item[0],
                av: item[1],
                texto: item[0] + " / " + item[1]
              });
            }
          });
        }
      }
    } catch (error) {
      console.error("Error obteniendo el archivo de campos:", error);
      throw error;
    }
    const allFiles = app.vault.getMarkdownFiles();
    let basePath = this.plugin.settings.folder_AreasVida;
    for (let areaVida of resultadoAV) {
      const fullFolderPath = `${basePath}/${areaVida.av}`;
      const folder = app.vault.getAbstractFileByPath(fullFolderPath);
      if (folder instanceof import_obsidian32.TFolder) {
        console.log(`La carpeta ${areaVida.av} existe dentro de ${basePath}.`);
        const instancesOfAV = app.vault.getMarkdownFiles().filter(
          (file) => file.path.includes(fullFolderPath) && !file.path.includes("Plantillas") && !file.path.includes("Archivo")
        );
        const nodeAVExists = instancesOfAV.some(
          (file) => file.basename === areaVida.av
        );
        if (nodeAVExists) {
          console.log(
            `La nota ${areaVida.av} existe dentro de la carpeta ${areaVida.av}.`
          );
          await this.validacionAVQ(fullFolderPath, q, areaVida);
        } else {
          debugger;
          console.log(
            `La nota ${areaVida.av} no existe dentro de la carpeta ${areaVida.av}.`
          );
          let nAV = await this.agregarNodoAreaVida(areaVida);
          if (nAV) {
            await this.validacionAVQ(fullFolderPath, q, areaVida);
          } else if (nAV == false) {
            continue;
          } else {
            return;
          }
        }
      } else {
        console.log(
          `La carpeta ${areaVida.av} no existe a\xFAn dentro de ${basePath}.`
        );
        let nAV = await this.agregarNodoAreaVida(areaVida);
        if (nAV) {
          await this.validacionAVQ(fullFolderPath, q, areaVida);
        } else if (nAV == false) {
          continue;
        } else {
          return;
        }
      }
    }
  }
  // Fin procesarAVTrimestre()
  //P2 areaVida Q Existe?
  async validacionAVQ(fullFolderPath, q, areaVida) {
    const pathAVQ = `${fullFolderPath}/${q.trimestre} - ${areaVida.av}.md`;
    const fileAVQ = app.vault.getAbstractFileByPath(pathAVQ);
    debugger;
    if (fileAVQ instanceof import_obsidian32.TFile) {
      let suggester = this.plugin.tp.system.static_functions.get("suggester");
      let nextStep = await suggester(
        [
          "Actualizar estado del AV",
          "Borrar y Crear de nuevo el AV",
          "Dejar el AV como est\xE1 "
        ],
        ["upd", "del+cre", "continue"],
        true,
        `\xBF${q.trimestre} ${areaVida.av} ya existe. Elige una opci\xF3n:`
      );
      switch (nextStep) {
        case "upd":
          await this.actualizarAVQ(fileAVQ);
          break;
        case "del+cre":
          await this.borrarAVQ(fileAVQ);
          await this.agregarAVQ(areaVida, q.trimestre);
          break;
        case "continue":
          console.log(`Continuar sin hacer nada con ${fileAVQ.basename}`);
          break;
      }
    } else {
      debugger;
      await this.agregarAVQ(areaVida, q.trimestre);
    }
  }
  // P3 Agregar nodoAreaVida?
  async agregarNodoAreaVida(areaVida) {
    let suggester = this.plugin.tp.system.static_functions.get("suggester");
    let agregar = await suggester(
      ["Si", "No"],
      [true, false],
      true,
      `\xBFDeseas agregar ${areaVida.av} a tu sistema de gesti\xF3n?`
    );
    if (agregar) {
      const filePath = `Plantillas/${this.plugin.settings[`folder_AreasVida`]}/Plt - nodoAreasVida.md`;
      const template = app.vault.getAbstractFileByPath(filePath);
      if (template instanceof import_obsidian32.TFile) {
        console.log("Archivo nodoAreaVida template encontrado:", template);
      } else {
        console.log("Archivo template nodoAreaVida no encontrado.");
      }
      const filename = areaVida.grupo + " - " + areaVida.av;
      let folderPath = `${this.plugin.settings[`folder_AreasVida`]}/${areaVida.av}`;
      await this.crearCarpeta(folderPath);
      const folder = app.vault.getAbstractFileByPath(folderPath);
      let crearNota;
      crearNota = this.plugin.tp.file.static_functions.get("create_new");
      try {
        let nota = await crearNota(template, filename, false, folder);
        return true;
      } catch (error) {
        console.error("Error creando NodoAreaVida: ", error);
        return error;
      }
    } else {
      return false;
    }
  }
  async agregarAVQ(areaVida, trimestre) {
    const filePath = `Plantillas/${this.plugin.settings.folder_AreasVida}/Plt - AreasVida.md`;
    const template = app.vault.getAbstractFileByPath(filePath);
    if (!(template instanceof import_obsidian32.TFile)) {
      console.log("Archivo no encontrado.");
      return false;
    }
    console.log("Archivo encontrado:", template);
    const filename = `${trimestre} -- ${areaVida.av} -- ${areaVida.grupo}`;
    let folderPath = `${this.plugin.settings[`folder_AreasVida`]}/${areaVida.av}`;
    const folder = app.vault.getAbstractFileByPath(folderPath);
    let crearNota = this.plugin.tp.file.static_functions.get("create_new");
    try {
      await crearNota(template, filename, false, folder);
      return true;
    } catch (error) {
      console.error("Error creando AreaVida: ", error);
      return false;
    }
  }
  async borrarAVQ(fileAVQ) {
    console.log(`Logica de borrado de ${fileAVQ.basename}`);
    try {
      if (fileAVQ instanceof import_obsidian32.TFile) {
        await app.vault.delete(fileAVQ);
        console.log(`${fileAVQ.basename} ha sido borrado con \xE9xito.`);
      } else {
        console.error(
          `${fileAVQ.basename} no es un archivo v\xE1lido o no existe.`
        );
      }
    } catch (err) {
      console.error(`Error al intentar borrar ${fileAVQ.basename}:`, err);
    }
  }
  async actualizarAVQ(fileAVQ) {
    console.log(`Logica de actualizaci\xF3n de estado de ${fileAVQ.basename}`);
    let suggester = this.plugin.tp.system.static_functions.get("suggester");
    let metadataCache = app.metadataCache.getFileCache(fileAVQ);
    let estadoActual = "";
    let nuevoEstado = "";
    if (metadataCache.frontmatter && metadataCache.frontmatter.hasOwnProperty("estado")) {
      estadoActual = metadataCache.frontmatter.estado;
    } else {
      console.log("No se encontr\xF3 el estado actual en el frontmatter.");
      return;
    }
    try {
      nuevoEstado = await suggester(
        ["\u{1F535} -> Archivado", "\u{1F7E2} -> Activo", "\u{1F7E1} -> En Pausa", "\u{1F534} -> Detenido"],
        // opciones para mostrar
        ["\u{1F535}", "\u{1F7E2}", "\u{1F7E1}", "\u{1F534}"],
        // valores a retornar
        false,
        // permite selección múltiple
        `${fileAVQ.basename} est\xE1 ${estadoActual}. Asignar estado:`
        // mensaje
      );
      if (!nuevoEstado) {
        console.log("No se seleccion\xF3 un nuevo estado.");
        return;
      }
      await app.fileManager.processFrontMatter(fileAVQ, (frontmatter) => {
        if (frontmatter.hasOwnProperty("estado")) {
          frontmatter.estado = nuevoEstado;
          console.log("Estado actualizado con \xE9xito a:", nuevoEstado);
        }
      });
    } catch (err) {
      console.error("Error al actualizar el estado en el frontmatter:", err);
    }
  }
  async crearCarpeta(folderPath) {
    try {
      const carpetaExistente = app.vault.getAbstractFileByPath(folderPath);
      if (carpetaExistente instanceof import_obsidian32.TFolder) {
        console.log(`La carpeta '${folderPath}' ya existe.`);
        return;
      }
      await app.vault.createFolder(folderPath);
      console.log(`Carpeta '${folderPath}' creada exitosamente.`);
    } catch (error) {
      console.error(`Error al crear la carpeta '${folderPath}':`, error);
    }
  }
  // PARA PROCESAR LOS COMPASS
  // Función para crear y mostrar el botón de procesar Objetivos de las AV anuales en el proceso de Compass.
  async mostrarBotonCompassAnual(dv) {
    dv.container.innerHTML = "";
    const boton = document.createElement("button");
    boton.textContent = "Procesar Objetivos AV Anual";
    dv.container.appendChild(boton);
    boton.onclick = async () => {
      await this.procesarCompassAnual(dv);
    };
  }
  async mostrarBotonCompassTrimestral(dv) {
    dv.container.innerHTML = "";
    const boton = document.createElement("button");
    boton.textContent = "Procesar Objetivos AV Trimestrales";
    dv.container.appendChild(boton);
    boton.onclick = async () => {
      await this.procesarCompassTrimestral(dv);
    };
  }
  async procesarCompassAnual(dv) {
    var _a;
    let a\u00F1o = dv.current().a\u00F1o;
    const resultadoAV = [];
    const fileCampos = app.vault.getAbstractFileByPath(this.pathCampos);
    try {
      if (fileCampos instanceof import_obsidian32.TFile) {
        const metadata = app.metadataCache.getFileCache(fileCampos);
        const arregloAV = ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.AreasVida) || [];
        if (Array.isArray(arregloAV)) {
          arregloAV.forEach((item) => {
            if (Array.isArray(item) && item.length >= 2) {
              resultadoAV.push({
                grupo: item[0],
                av: item[1],
                texto: item[0] + " / " + item[1]
              });
            }
          });
        }
      }
    } catch (error) {
      console.error("Error obteniendo el archivo de campos:", error);
      throw error;
    }
    const allFiles = app.vault.getMarkdownFiles();
    let basePath = this.plugin.settings.folder_AreasVida;
    debugger;
    for (let areaVida of resultadoAV) {
      const fullFolderPath = `${basePath}/${areaVida.av}`;
      const folder = app.vault.getAbstractFileByPath(fullFolderPath);
      if (folder instanceof import_obsidian32.TFolder) {
        console.log(`La carpeta ${areaVida.av} existe dentro de ${basePath}.`);
        const instancesOfAV = app.vault.getMarkdownFiles().filter(
          (file) => file.path.includes(fullFolderPath) && !file.path.includes("Plantillas") && !file.path.includes("Archivo")
        );
        const nodeAVExists = instancesOfAV.some(
          (file) => file.basename === areaVida.av
        );
        if (nodeAVExists) {
          console.log(
            `La nota ${areaVida.av} existe dentro de la carpeta ${areaVida.av}.`
          );
          await this.objetivoAnual(a\u00F1o, areaVida.av);
        } else {
          console.log(
            `La nota ${areaVida.av} no existe dentro de la carpeta ${areaVida.av}.`
          );
          let nAV = await this.agregarNodoAreaVida(areaVida);
          if (nAV) {
            await this.objetivoAnual(a\u00F1o, areaVida.av);
          } else if (nAV == false) {
            continue;
          } else {
            return;
          }
        }
      } else {
        console.log(
          `La carpeta ${areaVida.av} no existe a\xFAn dentro de ${basePath}.`
        );
        let nAV = await this.agregarNodoAreaVida(areaVida);
        if (nAV) {
          await this.objetivoAnual(a\u00F1o, areaVida.av);
        } else if (nAV == false) {
          continue;
        } else {
          return;
        }
      }
    }
  }
  // Metodo Procesar Compass Anual
  async procesarCompassTrimestral(dv) {
    var _a;
    debugger;
    let trimestre = dv.current().trimestre;
    const resultadoAV = [];
    const fileCampos = app.vault.getAbstractFileByPath(this.pathCampos);
    try {
      if (fileCampos instanceof import_obsidian32.TFile) {
        const metadata = app.metadataCache.getFileCache(fileCampos);
        const arregloAV = ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.AreasVida) || [];
        if (Array.isArray(arregloAV)) {
          arregloAV.forEach((item) => {
            if (Array.isArray(item) && item.length >= 2) {
              resultadoAV.push({
                grupo: item[0],
                av: item[1],
                texto: item[0] + " / " + item[1]
              });
            }
          });
        }
      }
    } catch (error) {
      console.error("Error obteniendo el archivo de campos:", error);
      throw error;
    }
    const allFiles = app.vault.getMarkdownFiles();
    let basePath = this.plugin.settings.folder_AreasVida;
    for (let areaVida of resultadoAV) {
      const fullFolderPath = `${basePath}/${areaVida.av}`;
      const folder = app.vault.getAbstractFileByPath(fullFolderPath);
      if (folder instanceof import_obsidian32.TFolder) {
        console.log(`La carpeta ${areaVida.av} existe dentro de ${basePath}.`);
        const instancesOfAV = app.vault.getMarkdownFiles().filter(
          (file) => file.path.includes(fullFolderPath) && !file.path.includes("Plantillas") && !file.path.includes("Archivo")
        );
        const nodeAVExists = instancesOfAV.some(
          (file) => file.basename === areaVida.av
        );
        if (nodeAVExists) {
          console.log(
            `La nota ${areaVida.av} existe dentro de la carpeta ${areaVida.av}.`
          );
          await this.objetivoTrimestral(trimestre, areaVida.av);
        } else {
          console.log(
            `La nota ${areaVida.av} no existe dentro de la carpeta ${areaVida.av}.`
          );
          let nAV = await this.agregarNodoAreaVida(areaVida);
          if (nAV) {
            await this.objetivoTrimestral(trimestre, areaVida.av);
          } else if (nAV == false) {
            continue;
          } else {
            return;
          }
        }
      } else {
        console.log(
          `La carpeta ${areaVida.av} no existe a\xFAn dentro de ${basePath}.`
        );
        let nAV = await this.agregarNodoAreaVida(areaVida);
        if (nAV) {
          await this.objetivoTrimestral(trimestre, areaVida.av);
        } else if (nAV == false) {
          continue;
        } else {
          return;
        }
      }
    }
  }
  // Metodo Procesar Compass Trimestral 
  async objetivoAnual(a\u00F1o, areaVida) {
    var _a;
    const folderObj = this.plugin.settings["folder_ObjCompassAnual"];
    const filesObj = app.vault.getMarkdownFiles().filter(
      (file) => file.path.includes(folderObj) && !file.path.includes("Plantillas") && !file.path.includes("Archivo")
    );
    let objCreados = [];
    for (let file of filesObj) {
      debugger;
      let metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const regex = /\[\[\s*(.*?)\s*\]\]/;
      let fileAV = metadata == null ? void 0 : metadata.areaVida.match(regex)[1];
      const sameAV = fileAV === areaVida;
      if ((metadata == null ? void 0 : metadata.a\u00F1o) === a\u00F1o && sameAV) {
        let objActivo = { file };
        Object.assign(objActivo, metadata);
        objCreados.push(objActivo);
      }
    }
    let prompt = this.plugin.tp.system.static_functions.get("prompt");
    let suggester = this.plugin.tp.system.static_functions.get("suggester");
    let objetivos = [];
    let deseaAgregarObjetivo;
    if (objCreados.length > 0) {
      let nextStep = await suggester(
        [
          "Agregar Objetivos",
          "Borrar y Crear de nuevo los objetivos",
          "Dejar los objetivos como est\xE1n "
        ],
        ["upd", "del+cre", "continue"],
        true,
        `\xBFYa hay ${objCreados.length} objetivos creados para ${areaVida} en el ${a\u00F1o}. Elige una opci\xF3n:`
      );
      switch (nextStep) {
        case "upd":
          do {
            let objetivo = await this.crearObjetivo(areaVida, a\u00F1o);
            deseaAgregarObjetivo = await suggester(
              ["Si", "No"],
              [true, false],
              true,
              `\xBFDesea agregar otro objetivo para ${areaVida} en ${a\u00F1o}?`
            );
          } while (deseaAgregarObjetivo);
          break;
        case "del+cre":
          await this.borrarObjetivos(objCreados);
          deseaAgregarObjetivo = await suggester(
            ["Si", "No"],
            [true, false],
            true,
            `\xBFDesea agregar alg\xFAn objetivo para ${areaVida} en ${a\u00F1o}?`
          );
          while (deseaAgregarObjetivo) {
            let objetivo = await this.crearObjetivo(areaVida, a\u00F1o);
            deseaAgregarObjetivo = await suggester(
              ["Si", "No"],
              [true, false],
              true,
              `\xBFDesea agregar otro objetivo para ${areaVida} en ${a\u00F1o}?`
            );
          }
          break;
        case "continue":
          console.log(`Continuar sin hacer nada con los objetivos de ${areaVida}`);
          break;
      }
    } else {
      deseaAgregarObjetivo = await suggester(
        ["Si", "No"],
        [true, false],
        true,
        `\xBFDesea agregar alg\xFAn objetivo para ${areaVida} en ${a\u00F1o}?`
      );
      while (deseaAgregarObjetivo) {
        let objetivo = await this.crearObjetivo(areaVida, a\u00F1o);
        objetivos.push([objetivo]);
        deseaAgregarObjetivo = await suggester(
          ["Si", "No"],
          [true, false],
          true,
          `\xBFDesea agregar otro objetivo para ${areaVida} en ${a\u00F1o}?`
        );
      }
    }
  }
  // Método objetivoAnual.
  async objetivoTrimestral(trimestre, areaVida) {
    var _a, _b;
    debugger;
    const folderObj = this.plugin.settings["folder_ObjCompassAnual"];
    const filesObj = app.vault.getMarkdownFiles().filter(
      (file) => file.path.includes(folderObj) && !file.path.includes("Plantillas") && !file.path.includes("Archivo")
    );
    let objCreados = [];
    for (let file of filesObj) {
      debugger;
      let metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const regex = /\[\[\s*(.*?)\s*\]\]/;
      let fileAV = metadata == null ? void 0 : metadata.areaVida.match(regex)[1];
      const sameAV = fileAV === areaVida;
      if (((_b = metadata == null ? void 0 : metadata.trimestre) == null ? void 0 : _b.path) && typeof (metadata.trimestre.path === "string") && metadata.trimestre.path.includes(trimestre) && sameAV) {
        let objActivo = { file };
        Object.assign(objActivo, metadata);
        objCreados.push(objActivo);
      }
    }
    let prompt = this.plugin.tp.system.static_functions.get("prompt");
    let suggester = this.plugin.tp.system.static_functions.get("suggester");
    let objetivos = [];
    let deseaAgregarObjetivo;
    if (objCreados.length > 0) {
      let nextStep = await suggester(
        [
          "Agregar Objetivos",
          "Borrar y Crear de nuevo los objetivos",
          "Dejar los objetivos como est\xE1n "
        ],
        ["upd", "del+cre", "continue"],
        true,
        `\xBFYa hay ${objCreados.length} objetivos creados para ${areaVida} en el ${trimestre}. Elige una opci\xF3n:`
      );
      switch (nextStep) {
        case "upd":
          do {
            let objetivo = await this.crearObjetivoTrimestre(areaVida, trimestre);
            deseaAgregarObjetivo = await suggester(
              ["Si", "No"],
              [true, false],
              true,
              `\xBFDesea agregar otro objetivo para ${areaVida} en ${trimestre}?`
            );
          } while (deseaAgregarObjetivo);
          break;
        case "del+cre":
          await this.borrarObjetivos(objCreados);
          deseaAgregarObjetivo = await suggester(
            ["Si", "No"],
            [true, false],
            true,
            `\xBFDesea agregar alg\xFAn objetivo para ${areaVida} en ${trimestre}?`
          );
          while (deseaAgregarObjetivo) {
            let objetivo = await this.crearObjetivoTrimestre(areaVida, trimestre);
            deseaAgregarObjetivo = await suggester(
              ["Si", "No"],
              [true, false],
              true,
              `\xBFDesea agregar otro objetivo para ${areaVida} en ${trimestre}?`
            );
          }
          break;
        case "continue":
          console.log(`Continuar sin hacer nada con los objetivos de ${areaVida}`);
          break;
      }
    } else {
      deseaAgregarObjetivo = await suggester(
        ["Si", "No"],
        [true, false],
        true,
        `\xBFDesea agregar alg\xFAn objetivo para ${areaVida} en ${trimestre}?`
      );
      while (deseaAgregarObjetivo) {
        let objetivo = await this.crearObjetivoTrimestre(areaVida, trimestre);
        objetivos.push([objetivo]);
        deseaAgregarObjetivo = await suggester(
          ["Si", "No"],
          [true, false],
          true,
          `\xBFDesea agregar otro objetivo para ${areaVida} en ${trimestre}?`
        );
      }
    }
  }
  // Método objetivoTrimestral.
  /* 
  ----------------------------------------------------------------
  Método que crea el botón que se agrega en la tabla de proyectos en el 
  Compass Anual, para crear el proyecto a cada Objetivo.
  ----------------------------------------------------------------
  */
  createButtonTable(dv, objetivo) {
    const buttonContainer = dv.el("div", "");
    const button = dv.el("button", "Nuevo Proyecto");
    button.addEventListener("click", async (event) => {
      event.preventDefault();
      await this.crearProyectoObjetivo(dv, objetivo);
    });
    buttonContainer.appendChild(button);
    return buttonContainer;
  }
  /* 
  ----------------------------------------------------------------
  Metodo invocado por el boton de la tabla del compass anual "Nuevo Proyecto" 
  para crear proyecto a un objetivo anual establecido.
  ----------------------------------------------------------------
  */
  async crearProyectoObjetivo(dv, objetivo) {
    debugger;
    let suggester = this.plugin.tp.system.static_functions.get("suggester");
    let tipoProyecto = await suggester(
      ["Proyecto GTD", "Proyecto de Q"],
      [true, false],
      true,
      `\xBFEl proyecto ${objetivo.file.name} requiere un Proyecto GTD o Proyecto de Q?`
    );
    let proyecto;
    if (tipoProyecto) {
      proyecto = this.crearProyectoGTD(objetivo);
    } else {
      debugger;
      const regexTrim = /\[?\[?(\d{4}-Q[1-4])\]?\]?/g;
      const trimestre = objetivo.trimestre.path.match(regexTrim);
      const confirmaTrim = await suggester(
        ["Si", "No"],
        [true, false],
        true,
        `\xBFVamos a crear el proyecto ${objetivo.file.name} en el trimestre ${trimestre}?`
      );
      if (!confirmaTrim) {
        const q = await this.establecerTrimestre("objetivo del a\xF1o");
        debugger;
        await this.actualizarYAMLs({ trimestre: `[[${q.trimestre}]]` }, objetivo.file.path);
      }
      proyecto = await this.crearProyectoQ(objetivo);
    }
  }
  /* 
  ----------------------------------------------------------------
  Metodo que inicializa la creación de la plantilla de objetivo Compass.
  ----------------------------------------------------------------
  */
  async crearObjetivo(areaVida, a\u00F1o) {
    debugger;
    const templatePath = `Plantillas/${this.plugin.settings["folder_ObjCompassAnual"]}/Plt - ObjCompassAnual.md`;
    const template = app.vault.getAbstractFileByPath(templatePath);
    const folder = app.vault.getAbstractFileByPath("Inbox");
    let crearNota = this.plugin.tp.file.static_functions.get("create_new");
    let filename = `${a\u00F1o} - Objetivo para ${areaVida}`;
    let objetivo = await crearNota(template, filename, false, folder);
    return objetivo;
  }
  async crearObjetivoTrimestre(areaVida, trimestre) {
    debugger;
    const templatePath = `Plantillas/${this.plugin.settings["folder_ObjCompassAnual"]}/Plt - ObjCompassAnual.md`;
    const template = app.vault.getAbstractFileByPath(templatePath);
    const folder = app.vault.getAbstractFileByPath("Inbox");
    let crearNota = this.plugin.tp.file.static_functions.get("create_new");
    let filename = `Trimestre ${trimestre} - Objetivo para ${areaVida}`;
    let objetivo = await crearNota(template, filename, false, folder);
    return objetivo;
  }
  /* 
  ----------------------------------------------------------------
  Metodo invocado desde crearProyectoObjetivo(dv, objetivo)
  Esté método hace parte del proceso de Compass Anual.
  Facilita la creación del un proyecto de Q para un objetivo anual establecido.
  ----------------------------------------------------------------
  */
  async crearProyectoQ(objetivo) {
    let suggester = this.plugin.tp.system.static_functions.get("suggester");
    debugger;
    const templatePath = `Plantillas/${this.plugin.settings["folder_ProyectosQ"]}/Plt - ProyectosQ.md`;
    const template = app.vault.getAbstractFileByPath(templatePath);
    const folder = app.vault.getAbstractFileByPath("Inbox");
    let crearNota = this.plugin.tp.file.static_functions.get("create_new");
    let filename = `Proyecto para Objetivo Compass Anual - ${objetivo.id}`;
    let proyecto = await crearNota(template, filename, true, folder);
    return proyecto;
  }
  async crearProyectoGTD(objetivo) {
    debugger;
    const templatePath = `Plantillas/${this.plugin.settings["folder_ProyectosGTD"]}/Plt - ProyectosGTD.md`;
    const template = app.vault.getAbstractFileByPath(templatePath);
    const folder = app.vault.getAbstractFileByPath("Inbox");
    let crearNota = this.plugin.tp.file.static_functions.get("create_new");
    let filename = `Proyecto para Objetivo Compass Anual - ${objetivo.id}`;
    let proyecto = await crearNota(template, filename, true, folder);
    return proyecto;
  }
  /* 
  ----------------------------------------------------------------
  Metodo invocado en el proceso de Compass Anual, cuando elijo volver
  a crear todos los proyectos de un area de vida para un año.
  ----------------------------------------------------------------
  */
  async borrarObjetivos(objetivos) {
    debugger;
    for (let objetivo of objetivos) {
      try {
        await app.vault.delete(objetivo.file);
        console.log(`Archivo borrado: ${objetivo.file.path}`);
      } catch (error) {
        console.error(`Error al borrar el archivo ${objetivo.file.path}: ${error}`);
      }
    }
  }
  /* 
  ----------------------------------------------------------------
  Metodo que permite para cualquier caso en el que se requiera elegir 
  un trimestre para continuar un proceso, hacer la verificación sobre los
  trimestres que esten creados a partir de la nota TQ.  
  ----------------------------------------------------------------
  */
  async establecerTrimestre(temaTrimestre) {
    var _a;
    const folderQ = this.plugin.settings["folder_Trimestral"];
    const filesQ = app.vault.getMarkdownFiles().filter(
      (file) => file.path.includes(folderQ) && !file.path.includes("Plantillas") && !file.path.includes("Archivo")
    );
    let qCreados = [];
    for (let file of filesQ) {
      let metadata = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if ((metadata == null ? void 0 : metadata.type) === "TQ" && (metadata == null ? void 0 : metadata.trimestre)) {
        let qActivo = { file };
        Object.assign(qActivo, metadata);
        qCreados.push(qActivo);
      }
    }
    let suggester = this.plugin.tp.system.static_functions.get("suggester");
    try {
      let q = await suggester(
        qCreados.map((b) => b.trimestre),
        qCreados.map((b) => b),
        true,
        `De que trimestre vamos a procesar tus ${temaTrimestre}`
      );
      if (q === void 0) {
        console.log("Operaci\xF3n cancelada por el usuario.");
        return;
      }
      console.log("El usuario seleccion\xF3:", q);
      return q;
    } catch (error) {
      console.error("Error en el suggester:", error);
    }
  }
  /* 
  ----------------------------------------------------------------
  Con este método puedo actualizar valores en las notas ya existentes.
  Lo utilizo en esta clase, para actualizar el trimestre.
  Esta función solo actualiza, no crea el campos si no existe. 
  ----------------------------------------------------------------
  */
  async actualizarYAMLs(campos, ruta) {
    try {
      const file = app.vault.getAbstractFileByPath(ruta);
      await app.fileManager.processFrontMatter(file, (frontmatter) => {
        for (const campo in campos) {
          if (frontmatter.hasOwnProperty(campo)) {
            frontmatter[campo] = campos[campo];
          }
        }
      });
      console.log("Frontmatter actualizado con \xE9xito");
    } catch (err) {
      console.error("Error al actualizar el frontmatter", err);
    }
  }
};

// src/modules/noteLifecycleManager/views/vistaRegistroDiario.ts
var import_obsidian33 = require("obsidian");
var VistaRegistroDiario = class extends import_obsidian33.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.plugin = plugin;
    this.registroTiempoAPI = new registroTiempoAPI(this.plugin);
  }
  getViewType() {
    return "vista-registro-diario";
  }
  getDisplayText() {
    return "Registro Diario";
  }
  getIcon() {
    return "file-clock";
  }
  async onOpen() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      this.contentEl.setText("No hay un archivo activo.");
      return;
    }
    await this.actualizarVista(activeFile);
    this.intervalId = window.setInterval(async () => {
      await this.actualizarVista(activeFile);
    }, 5e3);
  }
  onClose() {
    clearInterval(this.intervalId);
  }
  async actualizarVista(activeFile) {
    var _a;
    this.contentEl.empty();
    const fechaHoy = DateTime.fromFormat(activeFile.basename.split(" ")[0], "yyyy-MM-dd", { locale: "es" });
    const folder = this.plugin.settings.folder_RegistroTiempo;
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.includes(folder));
    let totalDia = 0;
    let registrosHoy = [];
    for (let file of files) {
      let metadata = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (metadata == null ? void 0 : metadata.horaInicio) {
        let horaInicio = DateTime.fromFormat(metadata.horaInicio, "yyyy-MM-dd EEEE HH:mm", { locale: "es" });
        if (horaInicio.startOf("day").ts === fechaHoy.startOf("day").ts) {
          registrosHoy.push({ path: file.path, frontmatter: metadata });
          totalDia += parseInt(metadata.tiempoTrabajado || "0");
        }
      }
    }
    registrosHoy.sort((a, b) => {
      let fechaA = DateTime.fromFormat(a.frontmatter.horaInicio, "yyyy-MM-dd EEEE HH:mm", { locale: "es" }).ts;
      let fechaB = DateTime.fromFormat(b.frontmatter.horaInicio, "yyyy-MM-dd EEEE HH:mm", { locale: "es" }).ts;
      return fechaA - fechaB;
    });
    const titulo = this.contentEl.createEl("h2", { text: `Registros de tiempo del ${fechaHoy.toFormat("EEEE, DD")}.` });
    titulo.style.textAlign = "center";
    const table = this.contentEl.createEl("table", { cls: "table-resumenSemanal" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    ["Registro", "Descripci\xF3n", "Periodo", "Tiempo", "Estado", "Id", "Acci\xF3n"].forEach((header) => {
      headerRow.createEl("th", { text: header });
    });
    const tbody = table.createEl("tbody");
    registrosHoy.forEach((registro) => {
      const row = tbody.createEl("tr");
      this.fillRowWithData(row, registro);
    });
    this.contentEl.appendChild(table);
  }
  fillRowWithData(row, registro) {
    const tdArchivo = row.createEl("td");
    const linkEl = document.createElement("a");
    linkEl.textContent = registro.frontmatter.aliases[0];
    linkEl.href = "#";
    linkEl.addEventListener("click", async (ev) => {
      ev.preventDefault();
      const file = this.app.vault.getAbstractFileByPath(registro.path);
      if (file instanceof import_obsidian33.TFile) {
        await this.app.workspace.getLeaf(true).openFile(file, { focus: true });
      }
    });
    tdArchivo.appendChild(linkEl);
    row.createEl("td", { text: registro.frontmatter.descripcion });
    row.createEl("td", { text: `${DateTime.fromFormat(registro.frontmatter.horaInicio, "yyyy-MM-dd EEEE HH:mm", { locale: "es" }).toFormat("h:mm a")} / ${DateTime.fromFormat(registro.frontmatter.horaFinal, "yyyy-MM-dd EEEE HH:mm", { locale: "es" }).toFormat("h:mm a")}` });
    const tdPeriodo = row.createEl("td");
    if (registro.frontmatter.estado === "\u{1F7E2}") {
      let ahora = DateTime.local();
      let inicio = DateTime.fromFormat(registro.frontmatter.horaInicio, "yyyy-MM-dd EEEE HH:mm", { locale: "es" });
      let duracion = ahora.diff(inicio, ["days", "hours", "minutes"]);
      tdPeriodo.textContent = this.formatDuration(duracion);
    } else {
      let tiempoTrabajado = this.formatDuration(registro.frontmatter.tiempoTrabajado);
      tdPeriodo.textContent = tiempoTrabajado;
    }
    row.createEl("td", { text: registro.frontmatter.estado });
    row.createEl("td", { text: registro.frontmatter.id });
    const actionCell = row.createEl("td");
    if (registro.frontmatter.estado === "\u{1F7E2}") {
      actionCell.appendChild(this.createButtonTable("Cerrar", async () => {
        await this.registroTiempoAPI.cerrarRegistro(registro.frontmatter.id);
      }));
    } else {
      actionCell.appendChild(this.createButtonTable("Retomar", () => {
        this.retomarTarea(registro.frontmatter.id);
      }));
    }
  }
  // Función auxiliar para formatear la duración de Luxon a un formato legible
  formatDuration(ms) {
    if (ms === null || ms === void 0 || isNaN(ms)) {
      return "No definido";
    } else {
      let minutos = Math.floor(ms / (1e3 * 60));
      let horas = Math.floor(minutos / 60);
      minutos = minutos % 60;
      let dias = Math.floor(horas / 24);
      horas = horas % 24;
      if (dias > 0) {
        return `${dias} d ${horas} h ${minutos} min`;
      } else if (horas > 0) {
        return `${horas} h ${minutos} min`;
      } else {
        return `${minutos} min`;
      }
    }
  }
  createButtonTable(buttonText, onClickCallback) {
    const button = document.createElement("button");
    button.textContent = buttonText;
    button.type = "button";
    button.classList.add("your-button-class");
    button.addEventListener("click", onClickCallback);
    return button;
  }
  async retomarTarea(id) {
    debugger;
    const filePath = `Plantillas/${this.plugin.settings[`folder_RegistroTiempo`]}/Plt - RegistroTiempo.md`;
    const template = app.vault.getAbstractFileByPath(filePath);
    if (template instanceof import_obsidian33.TFile) {
      console.log("Archivo encontrado:", template);
    } else {
      console.log("Archivo no encontrado.");
    }
    const filename = "Retomar " + id;
    const folder = app.vault.getAbstractFileByPath("Inbox");
    const tp = this.getTp();
    let crearNota = tp.file.static_functions.get("create_new");
    await crearNota(template, filename, false, folder).basename;
  }
  getTp() {
    if (!this.plugin || !this.plugin.app.plugins.enabledPlugins.has("templater-obsidian")) {
      console.error("El plugin Templater no est\xE1 habilitado.");
      return;
    }
    let tpGen = this.plugin.app.plugins.plugins["templater-obsidian"].templater;
    tpGen = tpGen.functions_generator.internal_functions.modules_array;
    let tp = {};
    tp.file = tpGen.find((m) => m.name == "file");
    tp.system = tpGen.find((m) => m.name == "system");
    if (!tp.file) {
      console.error("No se pudo acceder al objeto de funciones actuales de Templater.");
      return;
    }
    console.log('tp con propiedades "file" se ha cargado satisfactoriamente');
    return tp;
  }
  // Opcional: Implementa onClose si necesitas limpieza al cerrar la vista.
};

// src/modules/GPThora/GPThora.ts
var import_obsidian34 = require("obsidian");
var GPThoraPlugin = class extends import_obsidian34.Plugin {
  constructor(app2) {
    super(app2);
  }
  async onload() {
    this.addCommand({
      id: "show-local-time",
      name: "Hora Local",
      callback: () => this.showLocalTimeModal()
    });
  }
  showLocalTimeModal() {
    const modal = new LocalTimeModal(this.app);
    modal.open();
  }
};
var LocalTimeModal = class extends import_obsidian34.Modal {
  constructor(app2) {
    super(app2);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const now2 = /* @__PURE__ */ new Date();
    const hours = now2.getHours() % 12 || 12;
    const minutes = now2.getMinutes().toString().padStart(2, "0");
    const ampm = now2.getHours() >= 12 ? "PM" : "AM";
    const timeString = `${hours}:${minutes} ${ampm}`;
    contentEl.createEl("h1", { text: "Hora Local" });
    contentEl.createEl("p", { text: timeString });
    contentEl.style.backgroundColor = "#2E3440";
    contentEl.style.color = "#D8DEE9";
    contentEl.style.padding = "20px";
    contentEl.style.textAlign = "center";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var ManagementPlugin = class extends import_obsidian35.Plugin {
  constructor() {
    super(...arguments);
    // Declara una propiedad `settings` para almacenar la configuración del plugin.
    this.statusBarExtension = null;
    this.moduloRegistroTiempo = null;
    this.moduloBase = null;
    this.moduloGTD = null;
    //moduloTerceros: ModuloTerceros | null = null;
    this.registeredCommandIdsRT = [];
    this.registeredCommandIdsMB = [];
    this.registeredCommandIdsGTD = [];
    this.registeredCommandIds_Terceros = [];
    this.ribbonButtonRT = null;
  }
  // Declara una propiedad para mantener una instancia de `StatusBarExtension`.
  async onload() {
    await this.loadSettings();
    this.tp = this.getTp();
    this.registerView("vista-registro-activo", (leaf) => new VistaRegistroActivo(leaf, this));
    this.registerView("vista-resumen-semanal", (leaf) => new VistaResumenSemanal(leaf, this));
    this.registerView("vista-registro-diario", (leaf) => new VistaRegistroDiario(leaf, this));
    this.registroTiempoAPI = new registroTiempoAPI(this);
    this.starterAPI = new starterAPI(this);
    this.addOnsAPI = new addOnsAPI(this);
    this.YAMLUpdaterAPI = new YAMLUpdaterAPI2(this);
    this.menuHoyAPI = new menuHoyAPI(this);
    this.menuSemanalAPI = new menuSemanalAPI(this);
    this.subsistemasAPI = new subsistemasAPI(this);
    this.newInbox = ingresarBandejaEntrada.bind(this);
    this.addSettingTab(new PluginMainSettingsTab(this));
    this.statusBarExtension = new StatusBarExtension(this);
    this.moduloRegistroTiempo = new ModuloRegistroTiempo(this);
    this.moduloBase = new ModuloBase(this);
    this.moduloGTD = new ModuloGTD(this);
    this.applyConfiguration();
    console.log("Iniciando carga de plugin de Gesti\xF3n Personal");
    this.registerGPThora();
  }
  registerGPThora() {
    const gptHora = new GPThoraPlugin(this.app);
    gptHora.onload();
  }
  applyConfiguration() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this.settings.moduloBase) {
      (_a = this.moduloBase) == null ? void 0 : _a.activate(this);
    } else {
      (_b = this.moduloBase) == null ? void 0 : _b.deactivate(this);
    }
    if (this.settings.moduloRegistroTiempo) {
      (_c = this.moduloRegistroTiempo) == null ? void 0 : _c.activate(this);
    } else {
      (_d = this.moduloRegistroTiempo) == null ? void 0 : _d.deactivate(this);
    }
    if (this.settings.moduloAliasStatusBar) {
      (_e = this.statusBarExtension) == null ? void 0 : _e.activate();
    } else {
      (_f = this.statusBarExtension) == null ? void 0 : _f.deactivate();
    }
    if (this.settings.moduloGTD) {
      (_g = this.moduloGTD) == null ? void 0 : _g.activate(this);
    } else {
      (_h = this.moduloGTD) == null ? void 0 : _h.deactivate(this);
    }
  }
  async onunload() {
    console.log("Descargando plugin Gesti\xF3n Personal");
    return Promise.resolve();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.applyConfiguration();
  }
  getTp() {
    debugger;
    if (!this.app || !this.app.plugins.enabledPlugins.has("templater-obsidian")) {
      console.error("El plugin Templater no est\xE1 habilitado.");
      return;
    }
    let tpGen = this.app.plugins.plugins["templater-obsidian"].templater;
    tpGen = tpGen.functions_generator.internal_functions.modules_array;
    let tp = {};
    tp.file = tpGen.find((m) => m.name == "file");
    tp.system = tpGen.find((m) => m.name == "system");
    if (!tp.system) {
      console.error("No se pudo acceder al objeto de funciones actuales de Templater.");
      return;
    }
    console.log("Instancia de tp cargada satisfactoriamente en Plugin");
    return tp;
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3NldHRpbmdzVGFiLnRzIiwgInNyYy9tb2R1bGVzL21vZHVsb0Jhc2UvaW5kZXgudHMiLCAic3JjL21vZHVsZXMvbW9kdWxvQmFzZS91dGlscy9jcmVhckNhcnBldGEudHMiLCAic3JjL3BsYW50aWxsYXMvQW5vdGFjaW9uZXMvUGx0IC0gQW5vdGFjaW9uZXMudHMiLCAic3JjL21vZHVsZXMvbW9kdWxvQmFzZS91dGlscy9jcmVhclBsYW50aWxsYS50cyIsICJzcmMvbW9kdWxlcy9tb2R1bG9CYXNlL3V0aWxzL2ZpbGVMaW5rTW9kYWwudHMiLCAic3JjL21vZHVsZXMvbW9kdWxvQmFzZS9jb21tYW5kcy50cyIsICJzcmMvbW9kdWxlcy9tb2R1bG9CYXNlL3V0aWxzL2NyZWF0ZU5vdGVGcm9tVGVtcGxhdGUudHMiLCAic3JjL21vZHVsZXMvTV9idXNxdWVkYUF2YW56YWRhL2FjdGl2YWRvcmVzLnRzIiwgInNyYy9tb2R1bGVzL01fYnVzcXVlZGFBdmFuemFkYS91aS9yaWJib25CdXR0b24udHMiLCAic3JjL21vZHVsZXMvTV9idXNxdWVkYUF2YW56YWRhL3VpL21vZGFsLnRzIiwgInNyYy9tb2R1bGVzL01fYnVzcXVlZGFBdmFuemFkYS9zZWFyY2gvRnV6enlOb3RlU3VnZ2VzdGVyLnRzIiwgInNyYy9tb2R1bGVzL21vZHVsb0FsaWFzU3RhdHVzQmFyL3N0YXR1c0Jhci50cyIsICJzcmMvbW9kdWxlcy9tb2R1bG9SZWdpc3Ryb1RpZW1wby9pbmRleC50cyIsICJzcmMvbW9kdWxlcy9tb2R1bG9SZWdpc3Ryb1RpZW1wby9yaWJib25NZW51LnRzIiwgInNyYy9tb2R1bGVzL21vZHVsb1JlZ2lzdHJvVGllbXBvL3V0aWxzLnRzIiwgInNyYy9tb2R1bGVzL21vZGFsZXMvc2VsZWNjaW9uTW9kYWwudHMiLCAic3JjL21vZHVsZXMvbW9kdWxvUmVnaXN0cm9UaWVtcG8vY29tbWFuZHMudHMiLCAic3JjL21vZHVsZXMvbW9kdWxvUmVnaXN0cm9UaWVtcG8vbW9kYWxzL21vZGFsX0Fob3JhLnRzIiwgInNyYy9kZWZhdWx0cy9kZWZhdWx0U2V0dGluZ3MudHMiLCAic3JjL21vZHVsZXMvbW9kdWxvUmVnaXN0cm9UaWVtcG8vQVBJL3V0aWxzQVBJLnRzIiwgInNyYy9tb2R1bGVzL21vZHVsb1JlZ2lzdHJvVGllbXBvL0FQSS9tZW51T3Ryby50cyIsICJzcmMvbW9kdWxlcy9tb2RhbGVzL2Z1enp5U2VsZWN0T3JDcmVhdGUudHMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9lcnJvcnMuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHMuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvc3lzdGVtWm9uZS5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL0lBTkFab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9maXhlZE9mZnNldFpvbmUuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9pbnZhbGlkWm9uZS5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9zZXR0aW5ncy5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvaW52YWxpZC5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3V0aWwuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2VuZ2xpc2guanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvcmVnZXhQYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ludGVydmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW5mby5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlnaXRzLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC90b2tlblBhcnNlci5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2RhdGV0aW1lLmpzIiwgInNyYy9tb2R1bGVzL21vZHVsb1JlZ2lzdHJvVGllbXBvL0FQSS9yZWdpc3Ryb1RpZW1wb0FQSS50cyIsICJzcmMvbW9kdWxlcy9ub3RlTGlmZWN5Y2xlTWFuYWdlci9BUEkvc3RhcnRlckFQSS50cyIsICJzcmMvbW9kdWxlcy9ub3RlTGlmZWN5Y2xlTWFuYWdlci9BUEkvYWRkT25zQVBJLnRzIiwgInNyYy9tb2R1bGVzL25vdGVMaWZlY3ljbGVNYW5hZ2VyL0FQSS9ZQU1MVXBkYXRlckFQSS50cyIsICJzcmMvbW9kdWxlcy9tb2R1bG9SZWdpc3Ryb1RpZW1wby9tb2RhbHMvY2FtYmlvSEYudHMiLCAic3JjL21vZHVsZXMvbm90ZUxpZmVjeWNsZU1hbmFnZXIvQVBJL21lbnVEaWFyaW9BUEkudHMiLCAic3JjL21vZHVsZXMvbm90ZUxpZmVjeWNsZU1hbmFnZXIvQVBJL21lbnVTZW1hbmFsQVBJLnRzIiwgInNyYy9tb2R1bGVzL25vdGVMaWZlY3ljbGVNYW5hZ2VyL3ZpZXdzL3Zpc3RhUmVzdW1lblNlbWFuYWwudHMiLCAic3JjL21vZHVsZXMvbW9kdWxvUmVnaXN0cm9UaWVtcG8vdmlld3MvdmlzdGFSVEFjdGl2by50cyIsICJzcmMvbW9kdWxlcy9tb2R1bG9HVEQvaW5kZXgudHMiLCAic3JjL21vZHVsZXMvbW9kdWxvR1REL2luYm94LnRzIiwgInNyYy9tb2R1bGVzL21vZGFsZXMvaW5ib3hNb2RhbC50cyIsICJzcmMvbW9kdWxlcy9tb2R1bG9HVEQvY29tbWFuZHMudHMiLCAic3JjL21vZHVsZXMvbm90ZUxpZmVjeWNsZU1hbmFnZXIvQVBJL3N1YnNpc3RlbWFzQVBJLnRzIiwgInNyYy9tb2R1bGVzL25vdGVMaWZlY3ljbGVNYW5hZ2VyL3ZpZXdzL3Zpc3RhUmVnaXN0cm9EaWFyaW8udHMiLCAic3JjL21vZHVsZXMvR1BUaG9yYS9HUFRob3JhLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIgIGltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcbiAgaW1wb3J0IHsgUGx1Z2luTWFpblNldHRpbmdzVGFiIH0gZnJvbSAnLi9zZXR0aW5nc1RhYic7XG4gIGltcG9ydCB7IE1vZHVsb0Jhc2UgfSBmcm9tIFwiLi9tb2R1bGVzL21vZHVsb0Jhc2UvaW5kZXhcIjtcbiAgaW1wb3J0IHthY3RpdmF0ZU1vZHVsb0J1c3F1ZWRhQXZhbnphZGF9IGZyb20gXCIuL21vZHVsZXMvTV9idXNxdWVkYUF2YW56YWRhL2FjdGl2YWRvcmVzXCJcbiAgaW1wb3J0IHsgU3RhdHVzQmFyRXh0ZW5zaW9uIH0gZnJvbSBcIi4vbW9kdWxlcy9tb2R1bG9BbGlhc1N0YXR1c0Jhci9zdGF0dXNCYXJcIjtcbiAgaW1wb3J0IHsgTW9kdWxvUmVnaXN0cm9UaWVtcG8gfSBmcm9tIFwiLi9tb2R1bGVzL21vZHVsb1JlZ2lzdHJvVGllbXBvL2luZGV4XCI7XG4gIGltcG9ydCB0eXBlIHsgUGx1Z2luTWFpblNldHRpbmdzIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3BsdWdpbk1haW5TZXR0aW5ncyc7XG4gIGltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL2RlZmF1bHRzL2RlZmF1bHRTZXR0aW5ncyc7XG4gIGltcG9ydCB7cmVnaXN0cm9UaWVtcG9BUEl9IGZyb20gJy4vbW9kdWxlcy9tb2R1bG9SZWdpc3Ryb1RpZW1wby9BUEkvcmVnaXN0cm9UaWVtcG9BUEknXG4gIGltcG9ydCB7IHN0YXJ0ZXJBUEl9IGZyb20gJy4vbW9kdWxlcy9ub3RlTGlmZWN5Y2xlTWFuYWdlci9BUEkvc3RhcnRlckFQSSc7XG4gIGltcG9ydCB7IGFkZE9uc0FQSSB9IGZyb20gJy4vbW9kdWxlcy9ub3RlTGlmZWN5Y2xlTWFuYWdlci9BUEkvYWRkT25zQVBJJztcbiAgaW1wb3J0IHsgWUFNTFVwZGF0ZXJBUEkgfSBmcm9tICcuL21vZHVsZXMvbm90ZUxpZmVjeWNsZU1hbmFnZXIvQVBJL1lBTUxVcGRhdGVyQVBJJztcbiAgaW1wb3J0IHsgbWVudUhveUFQSX0gZnJvbSAnLi9tb2R1bGVzL25vdGVMaWZlY3ljbGVNYW5hZ2VyL0FQSS9tZW51RGlhcmlvQVBJJ1xuICBpbXBvcnQgeyBtZW51U2VtYW5hbEFQSSB9IGZyb20gJy4vbW9kdWxlcy9ub3RlTGlmZWN5Y2xlTWFuYWdlci9BUEkvbWVudVNlbWFuYWxBUEknO1xuICBpbXBvcnQgeyBWaXN0YVJlZ2lzdHJvQWN0aXZvIH0gZnJvbSAnLi9tb2R1bGVzL21vZHVsb1JlZ2lzdHJvVGllbXBvL3ZpZXdzL3Zpc3RhUlRBY3Rpdm8nO1xuICBpbXBvcnQgeyBNb2R1bG9HVEQgfSBmcm9tICcuL21vZHVsZXMvbW9kdWxvR1REJztcbiAgLy9pbXBvcnQgeyBNb2R1bG9UZXJjZXJvcyB9IGZyb20gJy4vbW9kdWxlcy9tb2R1bG9fVGVyY2Vyb3MnO1xuICBpbXBvcnQgeyBpbmdyZXNhckJhbmRlamFFbnRyYWRhIH0gZnJvbSAnLi9tb2R1bGVzL21vZHVsb0dURC9pbmJveCc7XG4gIGltcG9ydCB7IHN1YnNpc3RlbWFzQVBJIH0gZnJvbSAnLi9tb2R1bGVzL25vdGVMaWZlY3ljbGVNYW5hZ2VyL0FQSS9zdWJzaXN0ZW1hc0FQSSc7XG4gIGltcG9ydCB7IFZpc3RhUmVzdW1lblNlbWFuYWwgfSBmcm9tICcuL21vZHVsZXMvbm90ZUxpZmVjeWNsZU1hbmFnZXIvdmlld3MvdmlzdGFSZXN1bWVuU2VtYW5hbCc7XG4gIGltcG9ydCB7IFZpc3RhUmVnaXN0cm9EaWFyaW8gfSBmcm9tICcuL21vZHVsZXMvbm90ZUxpZmVjeWNsZU1hbmFnZXIvdmlld3MvdmlzdGFSZWdpc3Ryb0RpYXJpbyc7XG4gIGltcG9ydCBHUFRob3JhUGx1Z2luIGZyb20gJy4vbW9kdWxlcy9HUFRob3JhL0dQVGhvcmEnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYW5hZ2VtZW50UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgc2V0dGluZ3M6IFBsdWdpbk1haW5TZXR0aW5ncyB8IHVuZGVmaW5lZDtcbiAgLy8gRGVjbGFyYSB1bmEgcHJvcGllZGFkIGBzZXR0aW5nc2AgcGFyYSBhbG1hY2VuYXIgbGEgY29uZmlndXJhY2lcdTAwRjNuIGRlbCBwbHVnaW4uXG4gIHN0YXR1c0JhckV4dGVuc2lvbjogU3RhdHVzQmFyRXh0ZW5zaW9uIHwgbnVsbCA9IG51bGw7XG4gIG1vZHVsb1JlZ2lzdHJvVGllbXBvOiBNb2R1bG9SZWdpc3Ryb1RpZW1wbyB8IG51bGwgPSBudWxsO1xuICBtb2R1bG9CYXNlOiBNb2R1bG9CYXNlIHwgbnVsbCA9IG51bGw7XG4gIG1vZHVsb0dURCA6IE1vZHVsb0dURCB8IG51bGwgPSBudWxsO1xuICAvL21vZHVsb1RlcmNlcm9zOiBNb2R1bG9UZXJjZXJvcyB8IG51bGwgPSBudWxsO1xuICByZWdpc3RlcmVkQ29tbWFuZElkc1JUOiBzdHJpbmdbXSA9IFtdO1xuICByZWdpc3RlcmVkQ29tbWFuZElkc01COiBzdHJpbmdbXSA9IFtdO1xuICByZWdpc3RlcmVkQ29tbWFuZElkc0dURDogc3RyaW5nW10gPSBbXTtcbiAgcmVnaXN0ZXJlZENvbW1hbmRJZHNfVGVyY2Vyb3M6IHN0cmluZ1tdID0gW107XG4gIHJpYmJvbkJ1dHRvblJUOiBSZXR1cm5UeXBlPFBsdWdpblsnYWRkUmliYm9uSWNvbiddPiB8IG51bGwgPSBudWxsO1xuICBhcHA6IGFueTtcbiAgcmVnaXN0cm9UaWVtcG9BUEk6IHJlZ2lzdHJvVGllbXBvQVBJIHwgdW5kZWZpbmVkO1xuICBzdGFydGVyQVBJOiBzdGFydGVyQVBJIHwgdW5kZWZpbmVkO1xuICBhZGRPbnNBUEk6IGFkZE9uc0FQSSB8IHVuZGVmaW5lZDtcbiAgbWVudUhveUFQSTogbWVudUhveUFQSSB8IHVuZGVmaW5lZDtcbiAgbWVudVNlbWFuYWxBUEk6IG1lbnVTZW1hbmFsQVBJIHwgdW5kZWZpbmVkO1xuICBzdWJzaXN0ZW1hc0FQSTogc3Vic2lzdGVtYXNBUEkgfCB1bmRlZmluZWQ7XG4gIG5ld0luYm94IDogYW55O1xuICB0cDogYW55O1xuICAvLyBEZWNsYXJhIHVuYSBwcm9waWVkYWQgcGFyYSBtYW50ZW5lciB1bmEgaW5zdGFuY2lhIGRlIGBTdGF0dXNCYXJFeHRlbnNpb25gLlxuICBcblxuICAgIGFzeW5jIG9ubG9hZCgpIHsgXG4gICAgICAgIFxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLnRwID0gdGhpcy5nZXRUcCgpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWdpc3RlclZpZXcoXCJ2aXN0YS1yZWdpc3Ryby1hY3Rpdm9cIiwobGVhZikgPT4gbmV3IFZpc3RhUmVnaXN0cm9BY3Rpdm8obGVhZiwgdGhpcykpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVmlldyhcInZpc3RhLXJlc3VtZW4tc2VtYW5hbFwiLCAobGVhZikgPT4gbmV3IFZpc3RhUmVzdW1lblNlbWFuYWwobGVhZiwgdGhpcykpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVmlldyhcInZpc3RhLXJlZ2lzdHJvLWRpYXJpb1wiLCAobGVhZikgPT4gbmV3IFZpc3RhUmVnaXN0cm9EaWFyaW8obGVhZiwgdGhpcykpO1xuXG4gICAgICAgIC8vIGNhcmdhciBBUEkgcmVnaXN0cm8gVGllbXBvXG4gICAgICAgIHRoaXMucmVnaXN0cm9UaWVtcG9BUEkgPSBuZXcgcmVnaXN0cm9UaWVtcG9BUEkodGhpcyk7XG4gICAgICAgIHRoaXMuc3RhcnRlckFQSSA9IG5ldyBzdGFydGVyQVBJKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZE9uc0FQSSA9IG5ldyBhZGRPbnNBUEkodGhpcyk7XG4gICAgICAgIHRoaXMuWUFNTFVwZGF0ZXJBUEkgPSBuZXcgWUFNTFVwZGF0ZXJBUEkodGhpcyk7XG4gICAgICAgIHRoaXMubWVudUhveUFQSSA9IG5ldyBtZW51SG95QVBJKHRoaXMpO1xuICAgICAgICB0aGlzLm1lbnVTZW1hbmFsQVBJID0gbmV3IG1lbnVTZW1hbmFsQVBJKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YnNpc3RlbWFzQVBJID0gbmV3IHN1YnNpc3RlbWFzQVBJKHRoaXMpO1xuICAgICAgICB0aGlzLm5ld0luYm94ID0gaW5ncmVzYXJCYW5kZWphRW50cmFkYS5iaW5kKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gQVx1MDBGMWFkZSBsYSBwZXN0YVx1MDBGMWEgZGUgY29uZmlndXJhY2lcdTAwRjNuIC0gXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgUGx1Z2luTWFpblNldHRpbmdzVGFiKHRoaXMpKTtcbiAgICAgICAgLy8gSW5pY2lhbGl6YSBsYXMgaW5zdGFuY2lhcyBkZSBsb3MgbVx1MDBGM2R1bG9zXG4gICAgICAgIHRoaXMuc3RhdHVzQmFyRXh0ZW5zaW9uID0gbmV3IFN0YXR1c0JhckV4dGVuc2lvbih0aGlzKTtcbiAgICAgICAgdGhpcy5tb2R1bG9SZWdpc3Ryb1RpZW1wbyA9IG5ldyBNb2R1bG9SZWdpc3Ryb1RpZW1wbyh0aGlzKTtcbiAgICAgICAgdGhpcy5tb2R1bG9CYXNlID0gbmV3IE1vZHVsb0Jhc2UodGhpcyk7XG4gICAgICAgIC8vdGhpcy5tb2R1bG9UZXJjZXJvcyA9IG5ldyBNb2R1bG9UZXJjZXJvcyh0aGlzKTtcbiAgICAgICAgdGhpcy5tb2R1bG9HVEQgPSBuZXcgTW9kdWxvR1REKHRoaXMpO1xuICAgICAgICB0aGlzLmFwcGx5Q29uZmlndXJhdGlvbigpO1xuICAgICAgICAvLyBBcGxpY2EgbGEgY29uZmlndXJhY2lcdTAwRjNuIGluaWNpYWwgYmFzYWRhIGVuIGxvcyBhanVzdGVzIGNhcmdhZG9zIG8gcHJlZGV0ZXJtaW5hZG9zLlxuICAgICAgICBjb25zb2xlLmxvZygnSW5pY2lhbmRvIGNhcmdhIGRlIHBsdWdpbiBkZSBHZXN0aVx1MDBGM24gUGVyc29uYWwnKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucmVnaXN0ZXJHUFRob3JhKCk7XG4gICAgICB9XG5cbiAgICAgIHJlZ2lzdGVyR1BUaG9yYSgpIHtcbiAgICAgICAgY29uc3QgZ3B0SG9yYSA9IG5ldyBHUFRob3JhUGx1Z2luKHRoaXMuYXBwKTtcbiAgICAgICAgZ3B0SG9yYS5vbmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgYXBwbHlDb25maWd1cmF0aW9uKCkge1xuICAgICAgICAvLyBNb2R1bG8gQmFzZSBlcyBlbCBtXHUwMEYzZHVsbyBzb2JyZSBlbCBxdWUgZXN0b3kgaGFjaWVuZG8gcHJ1ZWJhcyBkZSBkZXNhcnJvbGxvLlxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb2R1bG9CYXNlKSB7XG4gICAgICAgICAgdGhpcy5tb2R1bG9CYXNlPy5hY3RpdmF0ZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tb2R1bG9CYXNlPy5kZWFjdGl2YXRlKHRoaXMpO1xuICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb2R1bG9SZWdpc3Ryb1RpZW1wbykge1xuICAgICAgICAgICAgdGhpcy5tb2R1bG9SZWdpc3Ryb1RpZW1wbz8uYWN0aXZhdGUodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZHVsb1JlZ2lzdHJvVGllbXBvPy5kZWFjdGl2YXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb2R1bG9BbGlhc1N0YXR1c0Jhcikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzQmFyRXh0ZW5zaW9uPy5hY3RpdmF0ZSgpO1xuICAgICAgICAgIC8vIFNpIGxhIGNvbmZpZ3VyYWNpXHUwMEYzbiBwYXJhIGBtb2R1bG9BbGlhc1N0YXR1c0JhcmAgZXMgdmVyZGFkZXJhLCBhY3RpdmEgZWwgbVx1MDBGM2R1bG8uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXNCYXJFeHRlbnNpb24/LmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAvLyBTaSBlcyBmYWxzYSwgZGVzYWN0aXZhIGVsIG1cdTAwRjNkdWxvLlxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1vZHVsb0dURCkge1xuICAgICAgICAgIHRoaXMubW9kdWxvR1REPy5hY3RpdmF0ZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tb2R1bG9HVEQ/LmRlYWN0aXZhdGUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vdGhpcy5tb2R1bG9UZXJjZXJvcz8uYWN0aXZhdGUodGhpcyk7XG5cbiAgICB9XG4gICAgXG4gICAgICBhc3luYyBvbnVubG9hZCgpIHtcbiAgICAgICAgICAvLyBDXHUwMEYzZGlnbyBkZSBsaW1waWV6YSBhcXVcdTAwRURcbiAgICAgICAgICBjb25zb2xlLmxvZygnRGVzY2FyZ2FuZG8gcGx1Z2luIEdlc3RpXHUwMEYzbiBQZXJzb25hbCcpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICAvLyBNXHUwMEU5dG9kbyBwYXJhIGNhcmdhciBsYSBjb25maWd1cmFjaVx1MDBGM24gZGVzZGUgZWwgYWxtYWNlbmFtaWVudG8gZGUgT2JzaWRpYW4uXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgICAgICAvLyBJbnRlbnRhIGNhcmdhciBsYSBjb25maWd1cmFjaVx1MDBGM24geSBtZXpjbGEgbG9zIHZhbG9yZXMgY2FyZ2Fkb3MgY29uIGxvcyBwcmVkZXRlcm1pbmFkb3MuXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgLy8gTVx1MDBFOXRvZG8gcGFyYSBndWFyZGFyIGxhIGNvbmZpZ3VyYWNpXHUwMEYzbiBhY3R1YWwgZW4gZWwgYWxtYWNlbmFtaWVudG8gZGUgT2JzaWRpYW4uXG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIC8vIEd1YXJkYSBsYSBjb25maWd1cmFjaVx1MDBGM24gYWN0dWFsLlxuICAgICAgICBcbiAgICAgICAgdGhpcy5hcHBseUNvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgLy8gVnVlbHZlIGEgYXBsaWNhciBsYSBjb25maWd1cmFjaVx1MDBGM24gcGFyYSBhc2VndXJhcnNlIGRlIHF1ZSBsb3MgY2FtYmlvcyByZWNpZW50ZXMgc2UgcmVmbGVqZW4gaW5tZWRpYXRhbWVudGUuXG4gICAgICB9XG5cbiAgICAgIGdldFRwKCl7XG4gICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgaWYgKCF0aGlzLmFwcCB8fCAhdGhpcy5hcHAucGx1Z2lucy5lbmFibGVkUGx1Z2lucy5oYXMoJ3RlbXBsYXRlci1vYnNpZGlhbicpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VsIHBsdWdpbiBUZW1wbGF0ZXIgbm8gZXN0XHUwMEUxIGhhYmlsaXRhZG8uJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gIEZvcm1hIGRlIGFjY2VkZXIgYWwgb2JqZXRvIHRwIG5vcm1hbCBxdWUgaGUgdXNhZG8gZGVzZGUgRFZKUyBjdWFuZG8gY3VycmVudCBGdW5jdGlvbnMgZXN0YSBjYXJnYWRvLlxuICAgICAgICAgIC8vY29uc3QgdGVtcGxhdGVyUGx1Z2luID0gdGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zWyd0ZW1wbGF0ZXItb2JzaWRpYW4nXTtcbiAgICAgICAgICAvL2NvbnN0IHRwID0gdGVtcGxhdGVyUGx1Z2luLnRlbXBsYXRlci5jdXJyZW50X2Z1bmN0aW9uc19vYmplY3Q7XG4gICAgICAgICAgLy8gLT4gdmVyc2lvbiBxdWUgZmFsbGEgc2kgbm8gZXN0YSBhcnJpYmEgZWwgcGx1Z2luIHBvcnF1ZSBoYWNlIGdldCBkZWwgcGx1Z2luIGRpcmVjdG8uIGNvbnN0IHRlbXBsYXRlclBsdWdpbiA9IHRoaXMuYXBwLnBsdWdpbnMuZ2V0UGx1Z2luKCd0ZW1wbGF0ZXItb2JzaWRpYW4nKTsgICAgXG4gICAgICAgICAgbGV0IHRwR2VuID0gdGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zW1widGVtcGxhdGVyLW9ic2lkaWFuXCJdLnRlbXBsYXRlcjtcbiAgICAgICAgICB0cEdlbiA9IHRwR2VuLmZ1bmN0aW9uc19nZW5lcmF0b3IuaW50ZXJuYWxfZnVuY3Rpb25zLm1vZHVsZXNfYXJyYXk7XG4gICAgICAgICAgbGV0IHRwID0ge31cbiAgICAgICAgICAvLyBnZXQgYW4gaW5zdGFuY2Ugb2YgbW9kdWxlc1xuICAgICAgICAgIHRwLmZpbGUgPSB0cEdlbi5maW5kKG0gPT4gbS5uYW1lID09IFwiZmlsZVwiKTtcbiAgICAgICAgICB0cC5zeXN0ZW0gPSB0cEdlbi5maW5kKG0gPT4gbS5uYW1lID09IFwic3lzdGVtXCIpO1xuXG4gICAgICAgICAgaWYgKCF0cC5zeXN0ZW0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBzZSBwdWRvIGFjY2VkZXIgYWwgb2JqZXRvIGRlIGZ1bmNpb25lcyBhY3R1YWxlcyBkZSBUZW1wbGF0ZXIuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5sb2coJ0luc3RhbmNpYSBkZSB0cCBjYXJnYWRhIHNhdGlzZmFjdG9yaWFtZW50ZSBlbiBQbHVnaW4nKTtcbiAgICAgICAgICByZXR1cm4gdHA7XG4gICAgICAgIH1cbiAgfVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcblxuZXhwb3J0IGNsYXNzIFBsdWdpbk1haW5TZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogUGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBQbHVnaW4pIHtcbiAgICAgICAgc3VwZXIocGx1Z2luLmFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnQ29uZmlndXJhY2lcdTAwRjNuIGRlbCBwbHVnaW4gZGUgR2VzdGlcdTAwRjNuIFBlcnNvbmFsJyB9KTtcblxuICAgICAgICAvLyBDcmVhciBjb250ZW5lZG9yZXMgcGFyYSBsYXMgcGVzdGFcdTAwRjFhcyB5IGVsIGNvbnRlbmlkbyBkZSBsYXMgcGVzdGFcdTAwRjFhc1xuICAgICAgICBjb25zdCB0YWJDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICd0YWItY29udGFpbmVyJyB9KTtcbiAgICAgICAgY29uc3QgdGFiQ29udGVudENvbnRhaW5lciA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ3RhYi1jb250ZW50LWNvbnRhaW5lcicgfSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvcyB0XHUwMEVEdHVsb3MgZGUgbGFzIHBlc3RhXHUwMEYxYXNcbiAgICAgICAgY29uc3QgdGFiVGl0bGVzID0gWydBY3RpdmFyIE1cdTAwRjNkdWxvcycsICdEaXJlY3RvcmlvcyBTdWJzaXN0ZW1hcycsICdQZXN0YVx1MDBGMWEgMyddO1xuXG4gICAgICAgIC8vIENyZWFyIHBlc3RhXHUwMEYxYXMgeSBjb250ZW5pZG8gZXNwZWNcdTAwRURmaWNvXG4gICAgICAgIHRhYlRpdGxlcy5mb3JFYWNoKCh0aXRsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIENyZWFyIGJvdG9uZXMgZGUgcGVzdGFcdTAwRjFhXG4gICAgICAgICAgICBjb25zdCB0YWJCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIHRhYkJ1dHRvbi50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgICAgICAgICAgdGFiQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3RhYi1saW5rJyk7XG4gICAgICAgICAgICB0YWJCdXR0b24uZGF0YXNldC50YWIgPSBgdGFiJHtpbmRleH1gO1xuICAgICAgICAgICAgdGFiQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLm9wZW5UYWIoYHRhYiR7aW5kZXh9YCk7XG4gICAgICAgICAgICB0YWJDb250YWluZXIuYXBwZW5kQ2hpbGQodGFiQnV0dG9uKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXIgY29udGVuaWRvIGRlIHBlc3RhXHUwMEYxYVxuICAgICAgICAgICAgY29uc3QgdGFiQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGFiQ29udGVudC5pZCA9IGB0YWIke2luZGV4fWA7XG4gICAgICAgICAgICB0YWJDb250ZW50LmNsYXNzTGlzdC5hZGQoJ3RhYi1jb250ZW50Jyk7XG4gICAgICAgICAgICB0YWJDb250ZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHRhYkNvbnRlbnQpO1xuXG4gICAgICAgICAgICAvLyBJbmljaWFsbWVudGUgb2N1bHRhciBlbCBjb250ZW5pZG8gZGUgbGEgcGVzdGFcdTAwRjFhLCBleGNlcHRvIGVsIHByaW1lcm9cbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHRhYkNvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgICAgLy8gQ29udGVuaWRvIHBhcmEgbGEgcHJpbWVyYSBwZXN0YVx1MDBGMWFcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKHRhYkNvbnRlbnQpXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoJ1ZlciBBbGlhcyBlbiBlbCBTdGF0dXMgQmFyJylcbiAgICAgICAgICAgICAgICAuc2V0RGVzYygnRWxpZ2Ugc2kgZGVzZWFzIHZlciBlbCBBbGlhc2VzIGRlIGxhcyBub3RhcyBlbiBlbCBTdGF0dXMgQmFyLicpXG4gICAgICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlOiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tb2R1bG9BbGlhc1N0YXR1c0JhcilcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5tb2R1bG9BbGlhc1N0YXR1c0JhciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyh0YWJDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnQWN0aXZhciBNXHUwMEYzZHVsbyBSZWdpc3RybyBUaWVtcG8nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnQWN0aXZhIG8gZGVzYWN0aXZhIGVsIG1cdTAwRjNkdWxvIGRlIHJlZ2lzdHJvIGRlIHRpZW1wby4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGU6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0b2dnbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tb2R1bG9SZWdpc3Ryb1RpZW1wbylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1vZHVsb1JlZ2lzdHJvVGllbXBvID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3IFNldHRpbmcodGFiQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0FjdGl2YXIgTVx1MDBGM2R1bG8gQmFzZSAtIFBydWViYXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnQWN0aXZhIG8gZGVzYWN0aXZhIGVsIG1cdTAwRjNkdWxvIGRlIHBydWViYXMuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlOiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubW9kdWxvQmFzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1vZHVsb0Jhc2UgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udGVuaWRvIHBhcmEgbGEgc2VndW5kYSBwZXN0YVx1MDBGMWFcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEZ1bmNpXHUwMEYzbiBwYXJhIG1hbmVqYXIgZWwgY2xpYyBlbiBlbCB0XHUwMEVEdHVsbyBkZWwgYmxvcXVlIGRlc3BsZWdhYmxlXG4gICAgICAgICAgICAgICAgY29uc3QgdG9nZ2xlQ29sbGFwc2UgPSAoZXZlbnQ6IHsgdGFyZ2V0OiB7IG5leHRFbGVtZW50U2libGluZzogYW55OyBpbm5lckhUTUw6IHN0cmluZzsgZ2V0QXR0cmlidXRlOiAoYXJnMDogc3RyaW5nKSA9PiBzdHJpbmc7IH07IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnQgPSBldmVudC50YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSAnJiM5NjYwOyAnICsgZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScpOyAvLyBDYW1iaWEgZWwgaWNvbm8gYSBcImFiYWpvXCJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuaW5uZXJIVE1MID0gJyYjOTY1NDsgJyArIGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnKTsgLy8gQ2FtYmlhIGVsIGljb25vIGEgXCJkZXJlY2hhXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgIC8vIEJsb3F1ZSBkZXNwbGVnYWJsZSBwYXJhIFwiQW5vdGFjaW9uZXNcIlxuICAgICAgICAgICAgICAgIGNvbnN0IGFub3RhY2lvbmVzVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJBbm90YWNpb25lc1wiJyB9KTtcbiAgICAgICAgICAgICAgICBhbm90YWNpb25lc1RpdGxlLnNldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScsICdTdWJzaXN0ZW1hIGRlIFwiQW5vdGFjaW9uZXNcIicpO1xuICAgICAgICAgICAgICAgIGFub3RhY2lvbmVzVGl0bGUuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFub3RhY2lvbmVzQ29udGVudCA9IHRhYkNvbnRlbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgYW5vdGFjaW9uZXNDb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIE9jdWx0YSBpbmljaWFsbWVudGUgbG9zIGFqdXN0ZXNcbiAgICAgICAgICAgICAgICBhbm90YWNpb25lc1RpdGxlLm9uY2xpY2sgPSB0b2dnbGVDb2xsYXBzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGFub3RhY2lvbmVzQ29udGVudCkgLy8gVXNhbW9zIGBibG9nQ29udGVudGAgZW4gbHVnYXIgZGUgYHRhYkNvbnRlbnRgXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdDYXJwZXRhIGRlIEFub3RhY2lvbmVzJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlIGxhIGNhcnBldGEgZG9uZGUgc2UgZ3VhcmRhclx1MDBFMW4gdG9kYXMgbGFzIEFub3RhY2lvbmVzLicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9Bbm90YWNpb25lcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9Bbm90YWNpb25lcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoYW5vdGFjaW9uZXNDb250ZW50KSAvLyBVc2Ftb3MgYGJsb2dDb250ZW50YCBlbiBsdWdhciBkZSBgdGFiQ29udGVudGBcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0luZGljZSBkZSBBbm90YWNpb25lcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgbGFzIEFub3RhY2lvbmVzLicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9Bbm90YWNpb25lcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9Bbm90YWNpb25lcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQmxvcXVlIGRlc3BsZWdhYmxlIHBhcmEgXCJBcnRcdTAwRURjdWxvcyBkZSBCbG9nXCJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9nVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJBcnRcdTAwRURjdWxvcyBkZSBCbG9nXCInIH0pO1xuICAgICAgICAgICAgICAgIGJsb2dUaXRsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnLCAnU3Vic2lzdGVtYSBkZSBcIkFydFx1MDBFRGN1bG9zIGRlIEJsb2dcIicpO1xuICAgICAgICAgICAgICAgIGJsb2dUaXRsZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvZ0NvbnRlbnQgPSB0YWJDb250ZW50LmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgICAgIGJsb2dDb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIE9jdWx0YSBpbmljaWFsbWVudGUgbG9zIGFqdXN0ZXNcbiAgICAgICAgICAgICAgICBibG9nVGl0bGUub25jbGljayA9IHRvZ2dsZUNvbGxhcHNlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoYmxvZ0NvbnRlbnQpIC8vIFVzYW1vcyBgYmxvZ0NvbnRlbnRgIGVuIGx1Z2FyIGRlIGB0YWJDb250ZW50YFxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnQ2FycGV0YSBkZSBBcnRcdTAwRURjdWxvcyBkZWwgQmxvZycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZSBsYSBjYXJwZXRhIGRvbmRlIHNlIGd1YXJkYXJcdTAwRTFuIGxvcyBhcnRcdTAwRURjdWxvcyBkZWwgYmxvZy4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfQUJsb2cpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfQUJsb2cgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGJsb2dDb250ZW50KSAvLyBVc2Ftb3MgYGJsb2dDb250ZW50YCBlbiBsdWdhciBkZSBgdGFiQ29udGVudGBcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0luZGljZSBkZSBBcnRcdTAwRURjdWxvcyBkZWwgQmxvZycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgbG9zIGFydFx1MDBFRGN1bG9zIGRlbCBibG9nLicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9BQmxvZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9BQmxvZyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQmxvcXVlIGRlc3BsZWdhYmxlIHBhcmEgXCJEZXNhcnJvbGxvcyB5IGNcdTAwRjNkaWdvc1wiXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYXJyb2xsb3NUaXRsZSA9IHRhYkNvbnRlbnQuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdcdTI1QjYgU3Vic2lzdGVtYSBkZSBcIkRlc2Fycm9sbG9zIHkgY1x1MDBGM2RpZ29zXCInIH0pO1xuICAgICAgICAgICAgICAgIGRlc2Fycm9sbG9zVGl0bGUuc2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJywgJ1N1YnNpc3RlbWEgZGUgXCJEZXNhcnJvbGxvcyB5IGNcdTAwRjNkaWdvc1wiJyk7XG4gICAgICAgICAgICAgICAgZGVzYXJyb2xsb3NUaXRsZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYXJyb2xsb3NDb250ZW50ID0gdGFiQ29udGVudC5jcmVhdGVEaXYoKTtcbiAgICAgICAgICAgICAgICBkZXNhcnJvbGxvc0NvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gT2N1bHRhIGluaWNpYWxtZW50ZSBsb3MgYWp1c3Rlc1xuICAgICAgICAgICAgICAgIGRlc2Fycm9sbG9zVGl0bGUub25jbGljayA9IHRvZ2dsZUNvbGxhcHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uZmlndXJhY2lcdTAwRjNuIHBhcmEgQ2FycGV0YSBkZSBEZXNhcnJvbGxvcyB5IENcdTAwRjNkaWdvc1xuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGRlc2Fycm9sbG9zQ29udGVudCkgLy8gVXNhbW9zIGBkZXNhcnJvbGxvc0NvbnRlbnRgIGVuIGx1Z2FyIGRlIGB0YWJDb250ZW50YFxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnQ2FycGV0YSBkZSBEZXNhcnJvbGxvcyB5IENcdTAwRjNkaWdvcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZSBsYSBjYXJwZXRhIGRvbmRlIHNlIGd1YXJkYXJcdTAwRTFuIGxvcyBkZXNhcnJvbGxvcyB5IGNcdTAwRjNkaWdvcy4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfRGVzYXJyb2xsb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfRGVzYXJyb2xsb3MgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbmZpZ3VyYWNpXHUwMEYzbiBwYXJhIFx1MDBDRG5kaWNlIGRlIERlc2Fycm9sbG9zIHkgQ1x1MDBGM2RpZ29zXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZGVzYXJyb2xsb3NDb250ZW50KSAvLyBVc2Ftb3MgYGRlc2Fycm9sbG9zQ29udGVudGAgZW4gbHVnYXIgZGUgYHRhYkNvbnRlbnRgXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdcdTAwQ0RuZGljZSBkZSBEZXNhcnJvbGxvcyB5IENcdTAwRjNkaWdvcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgbG9zIGRlc2Fycm9sbG9zIHkgY1x1MDBGM2RpZ29zLicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9EZXNhcnJvbGxvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9EZXNhcnJvbGxvcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQmxvcXVlIGRlc3BsZWdhYmxlIHBhcmEgXCJFc3R1ZGlvXCJcbiAgICAgICAgICAgICAgICBjb25zdCBlc3R1ZGlvVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJFc3R1ZGlvXCInIH0pO1xuICAgICAgICAgICAgICAgIGVzdHVkaW9UaXRsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnLCAnU3Vic2lzdGVtYSBkZSBcIkVzdHVkaW9cIicpO1xuICAgICAgICAgICAgICAgIGVzdHVkaW9UaXRsZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgY29uc3QgZXN0dWRpb0NvbnRlbnQgPSB0YWJDb250ZW50LmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgICAgIGVzdHVkaW9Db250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgZXN0dWRpb1RpdGxlLm9uY2xpY2sgPSB0b2dnbGVDb2xsYXBzZTtcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGVzdHVkaW9Db250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnQ2FycGV0YSBkZSBUZW1hcyBkZSBFc3R1ZGlvJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlIGxhIGNhcnBldGEgZG9uZGUgc2UgZ3VhcmRhclx1MDBFMW4gbG9zIHRlbWFzIGRlIGVzdHVkaW8uJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX0VzdHVkaW8pXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfRXN0dWRpbyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZXN0dWRpb0NvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdcdTAwQ0RuZGljZSBkZSBFc3R1ZGlvJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlbCBcdTAwRURuZGljZSBkZSBsb3MgdGVtYXMgZGUgZXN0dWRpby4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfRXN0dWRpbylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9Fc3R1ZGlvID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCbG9xdWUgZGVzcGxlZ2FibGUgcGFyYSBcIkdURFwiXG4gICAgICAgICAgICAgICAgY29uc3QgZ3RkVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJHVERcIicgfSk7XG4gICAgICAgICAgICAgICAgZ3RkVGl0bGUuc2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJywgJ1N1YnNpc3RlbWEgZGUgXCJHVERcIicpO1xuICAgICAgICAgICAgICAgIGd0ZFRpdGxlLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICBjb25zdCBndGRDb250ZW50ID0gdGFiQ29udGVudC5jcmVhdGVEaXYoKTtcbiAgICAgICAgICAgICAgICBndGRDb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgZ3RkVGl0bGUub25jbGljayA9IHRvZ2dsZUNvbGxhcHNlO1xuXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZ3RkQ29udGVudClcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSgnQXJjaGl2byBkZSBCYW5kZWphIGRlIEVudHJhZGEuJylcbiAgICAgICAgICAgICAgICAuc2V0RGVzYygnRXN0YWJsZWNlIGxhIHJ1dGEgZGUgbGEgQmFuZGVqYSBkZSBlbnRyYWRhIEdURC4nKVxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZmlsZV9JbmJveClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5maWxlX0luYm94ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBQcm95ZWN0b3MgR1REXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZ3RkQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NhcnBldGEgZGUgUHJveWVjdG9zIEdURCcpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZSBsYSBjYXJwZXRhIHBhcmEgcHJveWVjdG9zIEdURC4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfUHJveWVjdG9zR1REKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1Byb3llY3Rvc0dURCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZ3RkQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ1x1MDBDRG5kaWNlIGRlIFByb3llY3RvcyBHVEQnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnRXN0YWJsZWNlIGxhIHJ1dGEgZGVsIFx1MDBFRG5kaWNlIHBhcmEgcHJveWVjdG9zIEdURC4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfUHJveWVjdG9zR1REKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX1Byb3llY3Rvc0dURCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV2aXNpXHUwMEYzbiBTZW1hbmFsXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZ3RkQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NhcnBldGEgZGUgUmV2aXNpb25lcyBTZW1hbmFsZXMgR1REJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlIGxhIGNhcnBldGEgcGFyYSBsYXMgcmV2aXNpb25lcyBzZW1hbmFsZXMgR1RELicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9SU0dURClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9SU0dURCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoZ3RkQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ1x1MDBDRG5kaWNlIGRlIFJldmlzaW9uZXMgU2VtYW5hbGVzIEdURCcpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgcGFyYSBsYXMgcmV2aXNpb25lcyBzZW1hbmFsZXMgR1RELicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9SU0dURClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9SU0dURCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQmxvcXVlIGRlc3BsZWdhYmxlIHBhcmEgXCJMZWN0dXJhXCJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWN0dXJhVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJMZWN0dXJhXCInIH0pO1xuICAgICAgICAgICAgICAgIGxlY3R1cmFUaXRsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnLCAnU3Vic2lzdGVtYSBkZSBcIkxlY3R1cmFcIicpO1xuICAgICAgICAgICAgICAgIGxlY3R1cmFUaXRsZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVjdHVyYUNvbnRlbnQgPSB0YWJDb250ZW50LmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgICAgIGxlY3R1cmFDb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgbGVjdHVyYVRpdGxlLm9uY2xpY2sgPSB0b2dnbGVDb2xsYXBzZTtcblxuICAgICAgICAgICAgICAgIC8vIFNlc2lvbmVzIGRlIExlY3R1cmFcbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhsZWN0dXJhQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NhcnBldGEgZGUgU2VzaW9uZXMgZGUgTGVjdHVyYScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZSBsYSBjYXJwZXRhIHBhcmEgbGFzIHNlc2lvbmVzIGRlIGxlY3R1cmEuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX0xlY3R1cmFTZXNpb25lcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9MZWN0dXJhU2VzaW9uZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGxlY3R1cmFDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnXHUwMENEbmRpY2UgZGUgU2VzaW9uZXMgZGUgTGVjdHVyYScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgcGFyYSBsYXMgc2VzaW9uZXMgZGUgbGVjdHVyYS4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfTGVjdHVyYVNlc2lvbmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX0xlY3R1cmFTZXNpb25lcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gTGlicm9zIHkgUmVzXHUwMEZBbWVuZXNcbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhsZWN0dXJhQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NhcnBldGEgZGUgUmVzXHUwMEZBbWVuZXMgZGUgTGlicm9zJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlIGxhIGNhcnBldGEgcGFyYSBsb3MgcmVzXHUwMEZBbWVuZXMgZGUgbGlicm9zLicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9MZWN0dXJhUmVzdW1lbmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX0xlY3R1cmFSZXN1bWVuZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGxlY3R1cmFDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnXHUwMENEbmRpY2UgZGUgUmVzXHUwMEZBbWVuZXMgZGUgTGlicm9zJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlbCBcdTAwRURuZGljZSBwYXJhIGxvcyByZXNcdTAwRkFtZW5lcyBkZSBsaWJyb3MuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX0xlY3R1cmFSZXN1bWVuZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfTGVjdHVyYVJlc3VtZW5lcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3VtaWVuZG8gcXVlIGVzdGFtb3MgZGVudHJvIGRlIGlmIChpbmRleCA9PT0gMSkgeyAuLi4gfVxuXG4gICAgICAgICAgICAgICAgLy8gQmxvcXVlIGRlc3BsZWdhYmxlIHBhcmEgXCJNZW50b3JcdTAwRURhc1wiXG4gICAgICAgICAgICAgICAgY29uc3QgbWVudG9yaWFzVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJNZW50b3JcdTAwRURhc1wiJyB9KTtcbiAgICAgICAgICAgICAgICBtZW50b3JpYXNUaXRsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnLCAnU3Vic2lzdGVtYSBkZSBcIk1lbnRvclx1MDBFRGFzXCInKTtcbiAgICAgICAgICAgICAgICBtZW50b3JpYXNUaXRsZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVudG9yaWFzQ29udGVudCA9IHRhYkNvbnRlbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgbWVudG9yaWFzQ29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIG1lbnRvcmlhc1RpdGxlLm9uY2xpY2sgPSB0b2dnbGVDb2xsYXBzZTtcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKG1lbnRvcmlhc0NvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdDYXJwZXRhIGRlIFNlc2lvbmVzIGRlIE1lbnRvclx1MDBFRGEnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnRXN0YWJsZWNlIGxhIHJ1dGEgZGUgbGEgY2FycGV0YSBkb25kZSBzZSBndWFyZGFyXHUwMEUxbiBsYXMgc2VzaW9uZXMgZGUgbWVudG9yXHUwMEVEYS4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfTWVudG9yaWFzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX01lbnRvcmlhcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcobWVudG9yaWFzQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ1x1MDBDRG5kaWNlIGRlIE1lbnRvclx1MDBFRGFzJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlbCBcdTAwRURuZGljZSBkZSBsYXMgc2VzaW9uZXMgZGUgbWVudG9yXHUwMEVEYS4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfTWVudG9yaWFzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX01lbnRvcmlhcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwaXRlIGVsIHBhdHJcdTAwRjNuIHBhcmEgXCJNZXJjYWRvXCIsIFwiTVx1MDBGM2R1bG9zIFNpc3RlbWEgR2VzdGlcdTAwRjNuXCIsIHkgXCJQYWdvc1wiXG5cbiAgICAgICAgICAgICAgICAvLyBCbG9xdWUgZGVzcGxlZ2FibGUgcGFyYSBcIk1lcmNhZG9cIlxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmNhZG9UaXRsZSA9IHRhYkNvbnRlbnQuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdcdTI1QjYgU3Vic2lzdGVtYSBkZSBcIk1lcmNhZG9cIicgfSk7XG4gICAgICAgICAgICAgICAgbWVyY2Fkb1RpdGxlLnNldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScsICdTdWJzaXN0ZW1hIGRlIFwiTWVyY2Fkb1wiJyk7XG4gICAgICAgICAgICAgICAgbWVyY2Fkb1RpdGxlLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJjYWRvQ29udGVudCA9IHRhYkNvbnRlbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgbWVyY2Fkb0NvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBtZXJjYWRvVGl0bGUub25jbGljayA9IHRvZ2dsZUNvbGxhcHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gQWdyZWdhIGFxdVx1MDBFRCBsYXMgY29uZmlndXJhY2lvbmVzIGVzcGVjXHUwMEVEZmljYXMgcGFyYSBcIk1lcmNhZG9cIiwgc2lndWllbmRvIGVsIHBhdHJcdTAwRjNuIGRlIGxhcyBtZW50b3JcdTAwRURhc1xuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKG1lcmNhZG9Db250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnQ2FycGV0YSBkZSBMaXN0YWRvcyBkZSBNZXJjYWRvJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlIGxhIGNhcnBldGEgZG9uZGUgc2UgZ3VhcmRhclx1MDBFMW4gbGFzIGxpc3RhcyBkZSBtZXJjYWRvLicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9NZXJjYWRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX01lcmNhZG8gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKG1lcmNhZG9Db250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnXHUwMENEbmRpY2UgZGUgbGlzdGFkb3MgZGUgbWVyY2FkbycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgbG9zIGxpc3RhZG9zIGRlIG1lcmNhZG8uJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX01lcmNhZG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfTWVyY2FkbyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEJsb3F1ZSBkZXNwbGVnYWJsZSBwYXJhIFwiTVx1MDBGM2R1bG9zIFNpc3RlbWEgR2VzdGlcdTAwRjNuXCJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bG9zVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJNXHUwMEYzZHVsb3MgU2lzdGVtYSBHZXN0aVx1MDBGM25cIicgfSk7XG4gICAgICAgICAgICAgICAgbW9kdWxvc1RpdGxlLnNldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScsICdTdWJzaXN0ZW1hIGRlIFwiTVx1MDBGM2R1bG9zIFNpc3RlbWEgR2VzdGlcdTAwRjNuXCInKTtcbiAgICAgICAgICAgICAgICBtb2R1bG9zVGl0bGUuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsb3NDb250ZW50ID0gdGFiQ29udGVudC5jcmVhdGVEaXYoKTtcbiAgICAgICAgICAgICAgICBtb2R1bG9zQ29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIG1vZHVsb3NUaXRsZS5vbmNsaWNrID0gdG9nZ2xlQ29sbGFwc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBBZ3JlZ2EgYXF1XHUwMEVEIGxhcyBjb25maWd1cmFjaW9uZXMgZXNwZWNcdTAwRURmaWNhcyBwYXJhIFwiTVx1MDBGM2R1bG9zIFNpc3RlbWEgR2VzdGlcdTAwRjNuXCJcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKG1vZHVsb3NDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnQ2FycGV0YSBkZSBNb2R1bG9zIGRlbCBTaXN0ZW1hIGRlIEdlc3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnRXN0YWJsZWNlIGxhIHJ1dGEgZGUgbGEgY2FycGV0YSBkb25kZSBzZSBndWFyZGFyXHUwMEUxbiBsb3MgbVx1MDBGM2R1bG9zIGRlbCBTaXN0ZW1hIGRlIEdlc3RpXHUwMEYzbi4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfTW9kdWxvc1Npc3RlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfTW9kdWxvc1Npc3RlbWEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKG1vZHVsb3NDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnXHUwMENEbmRpY2UgZGUgbG9zIE1vZHVsb3MgZGVsIHNpc3RlbWEgZGUgR2VzdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgbG9zIE1cdTAwRjNkdWxvcyBkZWwgc2lzdGVtYSBkZSBHZXN0aVx1MDBGM24uJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX01vZHVsb3NTaXN0ZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX01vZHVsb3NTaXN0ZW1hID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gQmxvcXVlIGRlc3BsZWdhYmxlIHBhcmEgXCJUcmFuc2FjY2lvbmVzIHkgUGFnb3NcIlxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWNjaW9uZXNUaXRsZSA9IHRhYkNvbnRlbnQuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdcdTI1QjYgU3Vic2lzdGVtYSBkZSBcIlRyYW5zYWNjaW9uZXNcIicgfSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY2Npb25lc1RpdGxlLnNldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScsICdTdWJzaXN0ZW1hIGRlIFwidHJhbnNhY2Npb25lc1wiJyk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY2Npb25lc1RpdGxlLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjY2lvbmVzQ29udGVudCA9IHRhYkNvbnRlbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY2Npb25lc0NvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0cmFuc2FjY2lvbmVzVGl0bGUub25jbGljayA9IHRvZ2dsZUNvbGxhcHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gQWdyZWdhIGFxdVx1MDBFRCBsYXMgY29uZmlndXJhY2lvbmVzIGVzcGVjXHUwMEVEZmljYXMgcGFyYSBcIlBhZ29zXCJcbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyh0cmFuc2FjY2lvbmVzQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NhcnBldGEgZGUgTW9kdWxvcyBkZWwgU2lzdGVtYSBkZSBUcmFuc2FjY2lvbmVzJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlIGxhIGNhcnBldGEgZG9uZGUgc2UgZ3VhcmRhclx1MDBFMW4gbG9zIGNvbXByb2JhbnRlcyBkZSBsYXMgdHJhbnNhY2Npb25lcy4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfVHJhbnNhY2Npb25lcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9UcmFuc2FjY2lvbmVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyh0cmFuc2FjY2lvbmVzQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ1x1MDBDRG5kaWNlIGRlIFRyYW5zYWNjaW9uZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnRXN0YWJsZWNlIGxhIHJ1dGEgZGVsIFx1MDBFRG5kaWNlIGRlIFRyYW5zYWNjaW9uZXMuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX1RyYW5zYWNjaW9uZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfVHJhbnNhY2Npb25lcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEJsb3F1ZSBkZXNwbGVnYWJsZSBwYXJhIFwiUHJlc2VudGFjaW9uZXNcIlxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXNlbnRhY2lvbmVzVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJQcmVzZW50YWNpb25lc1wiJyB9KTtcbiAgICAgICAgICAgICAgICBwcmVzZW50YWNpb25lc1RpdGxlLnNldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScsICdTdWJzaXN0ZW1hIGRlIFwiUHJlc2VudGFjaW9uZXNcIicpO1xuICAgICAgICAgICAgICAgIHByZXNlbnRhY2lvbmVzVGl0bGUuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXNlbnRhY2lvbmVzQ29udGVudCA9IHRhYkNvbnRlbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgcHJlc2VudGFjaW9uZXNDb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEluaWNpYWxtZW50ZSBvY3VsdG9cbiAgICAgICAgICAgICAgICBwcmVzZW50YWNpb25lc1RpdGxlLm9uY2xpY2sgPSB0b2dnbGVDb2xsYXBzZTtcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKHByZXNlbnRhY2lvbmVzQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NhcnBldGEgZGUgTm90YXMgZGUgUHJlc2VudGFjaW9uZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnRXN0YWJsZWNlIGxhIHJ1dGEgZGUgbGEgY2FycGV0YSBkb25kZSBzZSBndWFyZGFyXHUwMEUxbiBsYXMgbm90YXMgZGUgcHJlc2VudGFjaW9uZXMuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1ByZXNlbnRhY2lvbmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1ByZXNlbnRhY2lvbmVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhwcmVzZW50YWNpb25lc0NvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdcdTAwQ0RuZGljZSBkZSBQcmVzZW50YWNpb25lcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgcHJlc2VudGFjaW9uZXMuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX1ByZXNlbnRhY2lvbmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX1ByZXNlbnRhY2lvbmVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCbG9xdWUgZGVzcGxlZ2FibGUgcGFyYSBcIlByb3llY3RvcyBkZSBRXCJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm95ZWN0b3NRVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJQcm95ZWN0b3MgZGUgUVwiJyB9KTtcbiAgICAgICAgICAgICAgICBwcm95ZWN0b3NRVGl0bGUuc2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJywgJ1N1YnNpc3RlbWEgZGUgXCJQcm95ZWN0b3MgZGUgUVwiJyk7XG4gICAgICAgICAgICAgICAgcHJveWVjdG9zUVRpdGxlLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICBjb25zdCBwcm95ZWN0b3NRQ29udGVudCA9IHRhYkNvbnRlbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgcHJveWVjdG9zUUNvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSW5pY2lhbG1lbnRlIG9jdWx0b1xuICAgICAgICAgICAgICAgIHByb3llY3Rvc1FUaXRsZS5vbmNsaWNrID0gdG9nZ2xlQ29sbGFwc2U7XG5cbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhwcm95ZWN0b3NRQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NhcnBldGEgZGUgUHJveWVjdG9zIGRlIFEnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnRXN0YWJsZWNlIGxhIHJ1dGEgZGUgbGEgY2FycGV0YSBkb25kZSBzZSBndWFyZGFyXHUwMEUxbiBsb3MgcHJveWVjdG9zIGRlIFEuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1Byb3llY3Rvc1EpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfUHJveWVjdG9zUSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcocHJveWVjdG9zUUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdcdTAwQ0RuZGljZSBkZSBQcm95ZWN0b3MgZGUgUScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgcHJveWVjdG9zIGRlIFEuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX1Byb3llY3Rvc1EpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfUHJveWVjdG9zUSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgcXVlIGxhIGZ1bmNpXHUwMEYzbiB0b2dnbGVDb2xsYXBzZSBlc3RcdTAwRTEgZGVmaW5pZGEgY29tbyBzZSBpbmRpY1x1MDBGMyBhbnRlcmlvcm1lbnRlLlxuXG4gICAgICAgICAgICAgICAgLy8gQmxvcXVlIGRlc3BsZWdhYmxlIHBhcmEgXCJQdWJsaWNhY2lvbmVzXCJcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNhY2lvbmVzVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJQdWJsaWNhY2lvbmVzXCInIH0pO1xuICAgICAgICAgICAgICAgIHB1YmxpY2FjaW9uZXNUaXRsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnLCAnU3Vic2lzdGVtYSBkZSBcIlB1YmxpY2FjaW9uZXNcIicpO1xuICAgICAgICAgICAgICAgIHB1YmxpY2FjaW9uZXNUaXRsZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljYWNpb25lc0NvbnRlbnQgPSB0YWJDb250ZW50LmNyZWF0ZURpdigpO1xuICAgICAgICAgICAgICAgIHB1YmxpY2FjaW9uZXNDb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEluaWNpYWxtZW50ZSBvY3VsdG9cbiAgICAgICAgICAgICAgICBwdWJsaWNhY2lvbmVzVGl0bGUub25jbGljayA9IHRvZ2dsZUNvbGxhcHNlO1xuXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcocHVibGljYWNpb25lc0NvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdDYXJwZXRhIGRlIFBpZXphcyBkZSBQdWJsaWNhY2lvbmVzJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlIGxhIGNhcnBldGEgZG9uZGUgc2UgZ3VhcmRhclx1MDBFMW4gbGFzIHBpZXphcyBkZSBwdWJsaWNhY2lvbmVzLicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9QdWJsaWNhY2lvbmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1B1YmxpY2FjaW9uZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKHB1YmxpY2FjaW9uZXNDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnXHUwMENEbmRpY2UgZGUgUHVibGljYWNpb25lcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgcHVibGljYWNpb25lcy4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfUHVibGljYWNpb25lcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9QdWJsaWNhY2lvbmVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCbG9xdWUgZGVzcGxlZ2FibGUgcGFyYSBcIlJlY2V0YXNcIlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2V0YXNUaXRsZSA9IHRhYkNvbnRlbnQuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdcdTI1QjYgU3Vic2lzdGVtYSBkZSBcIlJlY2V0YXNcIicgfSk7XG4gICAgICAgICAgICAgICAgcmVjZXRhc1RpdGxlLnNldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScsICdTdWJzaXN0ZW1hIGRlIFwiUmVjZXRhc1wiJyk7XG4gICAgICAgICAgICAgICAgcmVjZXRhc1RpdGxlLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICBjb25zdCByZWNldGFzQ29udGVudCA9IHRhYkNvbnRlbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgcmVjZXRhc0NvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSW5pY2lhbG1lbnRlIG9jdWx0b1xuICAgICAgICAgICAgICAgIHJlY2V0YXNUaXRsZS5vbmNsaWNrID0gdG9nZ2xlQ29sbGFwc2U7XG5cbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhyZWNldGFzQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NhcnBldGEgZGUgUmVjZXRhcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZSBsYSBjYXJwZXRhIGRvbmRlIHNlIGd1YXJkYXJcdTAwRTFuIGxhcyByZWNldGFzLicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KCh0ZXh0OiB7IHNldFZhbHVlOiAoYXJnMDogYW55KSA9PiB7ICgpOiBhbnk7IG5ldygpOiBhbnk7IG9uQ2hhbmdlOiB7IChhcmcwOiAodmFsdWU6IGFueSkgPT4gUHJvbWlzZTx2b2lkPik6IGFueTsgbmV3KCk6IGFueTsgfTsgfTsgfSkgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9SZWNldGFzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1JlY2V0YXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKHJlY2V0YXNDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnXHUwMENEbmRpY2UgZGUgUmVjZXRhcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgcmVjZXRhcy4nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVGV4dCgodGV4dDogeyBzZXRWYWx1ZTogKGFyZzA6IGFueSkgPT4geyAoKTogYW55OyBuZXcoKTogYW55OyBvbkNoYW5nZTogeyAoYXJnMDogKHZhbHVlOiBhbnkpID0+IFByb21pc2U8dm9pZD4pOiBhbnk7IG5ldygpOiBhbnk7IH07IH07IH0pID0+IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfUmVjZXRhcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljZV9SZWNldGFzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCbG9xdWUgZGVzcGxlZ2FibGUgcGFyYSBcIlJlY3Vyc29zIFJlY3VycmVudGVzXCJcbiAgICAgICAgICAgICAgICBjb25zdCByZWN1cnNvc1JlY3VycmVudGVzVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJSZWN1cnNvcyBSZWN1cnJlbnRlc1wiJyB9KTtcbiAgICAgICAgICAgICAgICByZWN1cnNvc1JlY3VycmVudGVzVGl0bGUuc2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJywgJ1N1YnNpc3RlbWEgZGUgXCJSZWN1cnNvcyBSZWN1cnJlbnRlc1wiJyk7XG4gICAgICAgICAgICAgICAgcmVjdXJzb3NSZWN1cnJlbnRlc1RpdGxlLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICBjb25zdCByZWN1cnNvc1JlY3VycmVudGVzQ29udGVudCA9IHRhYkNvbnRlbnQuY3JlYXRlRGl2KCk7XG4gICAgICAgICAgICAgICAgcmVjdXJzb3NSZWN1cnJlbnRlc0NvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSW5pY2lhbG1lbnRlIG9jdWx0b1xuICAgICAgICAgICAgICAgIHJlY3Vyc29zUmVjdXJyZW50ZXNUaXRsZS5vbmNsaWNrID0gdG9nZ2xlQ29sbGFwc2U7XG5cbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhyZWN1cnNvc1JlY3VycmVudGVzQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0NhcnBldGEgZGUgUmVjdXJzb3MgUmVjdXJyZW50ZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnRXN0YWJsZWNlIGxhIHJ1dGEgZGUgbGEgY2FycGV0YSBkb25kZSBzZSBndWFyZGFyXHUwMEUxbiBsb3MgcmVjdXJzb3MgcmVjdXJyZW50ZXMuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1JlY3Vyc29zUmVjdXJyZW50ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfUmVjdXJzb3NSZWN1cnJlbnRlcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcocmVjdXJzb3NSZWN1cnJlbnRlc0NvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdcdTAwQ0RuZGljZSBkZSBSZWN1cnNvcyBSZWN1cnJlbnRlcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjKCdFc3RhYmxlY2UgbGEgcnV0YSBkZWwgXHUwMEVEbmRpY2UgZGUgcmVjdXJzb3MgcmVjdXJyZW50ZXMuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX1JlY3Vyc29zUmVjdXJyZW50ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmRpY2VfUmVjdXJzb3NSZWN1cnJlbnRlcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQmxvcXVlIGRlc3BsZWdhYmxlIHBhcmEgXCJSZWdpc3RybyBUaWVtcG9cIlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJvVGllbXBvVGl0bGUgPSB0YWJDb250ZW50LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnXHUyNUI2IFN1YnNpc3RlbWEgZGUgXCJSZWdpc3RybyBUaWVtcG9cIicgfSk7XG4gICAgICAgICAgICAgICAgcmVnaXN0cm9UaWVtcG9UaXRsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnLCAnU3Vic2lzdGVtYSBkZSBcIlJlZ2lzdHJvIFRpZW1wb1wiJyk7XG4gICAgICAgICAgICAgICAgcmVnaXN0cm9UaWVtcG9UaXRsZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnaXN0cm9UaWVtcG9Db250ZW50ID0gdGFiQ29udGVudC5jcmVhdGVEaXYoKTtcbiAgICAgICAgICAgICAgICByZWdpc3Ryb1RpZW1wb0NvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gSW5pY2lhbG1lbnRlIG9jdWx0b1xuICAgICAgICAgICAgICAgIHJlZ2lzdHJvVGllbXBvVGl0bGUub25jbGljayA9IHRvZ2dsZUNvbGxhcHNlO1xuXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcocmVnaXN0cm9UaWVtcG9Db250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TmFtZSgnQ2FycGV0YSBkZSBSZWdpc3Ryb3MgZGUgVGllbXBvJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0VzdGFibGVjZSBsYSBydXRhIGRlIGxhIGNhcnBldGEgZG9uZGUgc2UgZ3VhcmRhclx1MDBFMW4gbG9zIHJlZ2lzdHJvcyBkZSB0aWVtcG8uJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1JlZ2lzdHJvVGllbXBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1JlZ2lzdHJvVGllbXBvID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBuZXcgU2V0dGluZyhyZWdpc3Ryb1RpZW1wb0NvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdcdTAwQ0RuZGljZSBkZSBSZWdpc3RybyBkZSBUaWVtcG8nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnRXN0YWJsZWNlIGxhIHJ1dGEgZGVsIFx1MDBFRG5kaWNlIGRlIHJlZ2lzdHJvcyBkZSB0aWVtcG8uJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQoKHRleHQ6IHsgc2V0VmFsdWU6IChhcmcwOiBhbnkpID0+IHsgKCk6IGFueTsgbmV3KCk6IGFueTsgb25DaGFuZ2U6IHsgKGFyZzA6ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlPHZvaWQ+KTogYW55OyBuZXcoKTogYW55OyB9OyB9OyB9KSA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX1JlZ2lzdHJvVGllbXBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNlX1JlZ2lzdHJvVGllbXBvID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cblxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG5cblxuXG4gICAgICAgICAgICAvLyBDb250ZW5pZG8gcGFyYSBsYSB0ZXJjZXJhIHBlc3RhXHUwMEYxYVxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZUxhYmVsID0gdGFiQ29udGVudC5jcmVhdGVFbCgnbGFiZWwnKTtcbiAgICAgICAgICAgICAgICBkYXRlTGFiZWwudGV4dENvbnRlbnQgPSAnRmVjaGEnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVJbnB1dCA9IHRhYkNvbnRlbnQuY3JlYXRlRWwoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgZGF0ZUlucHV0LnR5cGUgPSAnZGF0ZXRpbWUtbG9jYWwnO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBXHUwMEYxYWRpciBlc3RpbG9zIENTUyBwYXJhIGVzcGFjaWFkbyB5IG9yZ2FuaXphY2lcdTAwRjNuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdzdHlsZScsIHtcbiAgICAgICAgICAgIHRleHQ6IGBcbiAgICAgICAgICAgICAgICAudGFiLWNvbnRlbnQgeyBkaXNwbGF5OiBub25lOyBwYWRkaW5nLXRvcDogMjBweDsgfSAvLyBBXHUwMEYxYWRpZG8gcGFkZGluZy10b3AgcGFyYSBlbCBlc3BhY2lvXG4gICAgICAgICAgICAgICAgLnRhYi1jb250ZW50LmFjdGl2ZSB7IGRpc3BsYXk6IGJsb2NrOyB9XG4gICAgICAgICAgICAgICAgLnRhYi1saW5rIHsgY3Vyc29yOiBwb2ludGVyOyBwYWRkaW5nOiA1cHggMTBweDsgbWFyZ2luLXJpZ2h0OiA1cHg7IGJhY2tncm91bmQ6ICNmMGYwZjA7IGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7IGJvcmRlci1yYWRpdXM6IDVweDsgfVxuICAgICAgICAgICAgICAgIC50YWItbGluay5hY3RpdmUgeyBiYWNrZ3JvdW5kOiAjZTBlMGUwOyB9XG4gICAgICAgICAgICAgICAgLnNldHRpbmctaXRlbSB7IG1hcmdpbi1ib3R0b206IDEwcHg7IH1cbiAgICAgICAgICAgIGBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuXG4gICAgICAgIC8vIEZ1bmNpXHUwMEYzbiBwYXJhIGNhbWJpYXIgbGEgcGVzdGFcdTAwRjFhIGFjdGl2YVxuICAgICAgICB0aGlzLm9wZW5UYWIgPSAodGFiTmFtZSkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRhYi1jb250ZW50JykuZm9yRWFjaChjb250ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRhYi1saW5rJykuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgICAgICAgICBsaW5rLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVUYWJDb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFiTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVUYWJMaW5rID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtdGFiPVwiJHt0YWJOYW1lfVwiXWApO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVRhYkNvbnRlbnQpIGFjdGl2ZVRhYkNvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICBpZiAoYWN0aXZlVGFiTGluaykgYWN0aXZlVGFiTGluay5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFicmlyIGxhIHByaW1lcmEgcGVzdGFcdTAwRjFhIHBvciBkZWZlY3RvXG4gICAgICAgIHRoaXMub3BlblRhYigndGFiMCcpO1xuICAgIH1cbiAgICBvcGVuVGFiKGFyZzA6IHN0cmluZyk6IGFueSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IHJlZ2lzdGVyQ29tbWFuZHMsIGRlYWN0aXZhdGVDb21tYW5kcyB9IGZyb20gXCIuL2NvbW1hbmRzXCI7XG5cbmV4cG9ydCBjbGFzcyBNb2R1bG9CYXNlIHtcbiAgICBwbHVnaW46IFBsdWdpbjtcbiAgICBtb2R1bG9CYXNlOiBNb2R1bG9CYXNlIHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFBsdWdpbikge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kdWxvQmFzZSkgcmV0dXJuOyAvLyBTaSB5YSBlc3RcdTAwRTEgYWN0aXZvLCBubyBoYWNlciBuYWRhXG5cbiAgICAgICAgcmVnaXN0ZXJDb21tYW5kcyh0aGlzLnBsdWdpbik7XG4gICAgfVxuXG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0JhcikgcmV0dXJuOyAvLyBTaSB5YSBlc3RcdTAwRTEgZGVzYWN0aXZhZG8sIG5vIGhhY2VyIG5hZGFcbiAgICAgICAgZGVhY3RpdmF0ZUNvbW1hbmRzKHRoaXMucGx1Z2luKTtcbiAgICAgICBcbiAgICB9XG5cblxufSIsICJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhckNhcnBldGEocnV0YUNhcnBldGE6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVmVyaWZpY2Egc2kgbGEgY2FycGV0YSB5YSBleGlzdGVcbiAgICAgICAgICAgIGRlYnVnZ2VyXG4gICAgICAgICAgICBjb25zdCBjYXJwZXRhRXhpc3RlbnRlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChydXRhQ2FycGV0YSk7XG4gICAgICAgICAgICBpZiAoY2FycGV0YUV4aXN0ZW50ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMYSBjYXJwZXRhICcke3J1dGFDYXJwZXRhfScgeWEgZXhpc3RlLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnZ2VyXG4gICAgICAgICAgICAvLyBDcmVhIGxhIGNhcnBldGFcbiAgICAgICAgICAgIGF3YWl0IGFwcC52YXVsdC5jcmVhdGVGb2xkZXIocnV0YUNhcnBldGEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYENhcnBldGEgJyR7cnV0YUNhcnBldGF9JyBjcmVhZGEgZXhpdG9zYW1lbnRlLmApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYWwgY3JlYXIgbGEgY2FycGV0YSAnJHtydXRhQ2FycGV0YX0nOmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuIiwgImV4cG9ydCBjb25zdCBwbGFudGlsbGEgPSBgPCUqXG5kZWJ1Z2dlclxuY29uc3QgZHYgPSB0aGlzLkRhdGF2aWV3QVBJO1xuY29uc3Qge3VwZGF0ZX0gPSB0aGlzLmFwcC5wbHVnaW5zLnBsdWdpbnNbXCJtZXRhZWRpdFwiXS5hcGlcbmNvbnN0IGZpbGVDYW1wb3MgPWR2LnBhZ2UoXCJFc3RydWN0dXJhL0NhbXBvcyBTaXN0ZW1hIEdlc3Rpb24vQ2FtcG9zIFNpc3RlbWEgQ2VudHJhbFwiKVxubGV0IGNsYXNpZmljYWNpb25BWCA9IGZpbGVDYW1wb3MudGl0dWxvQ2xhc2lmaWNhY2lvbkFYXG5sZXQgdGFnc0NsYXNpZmljYWNpb25BWCA9IGZpbGVDYW1wb3MudGFnc0NsYXNpZmljYWNpb25BWFxubGV0IGFjdGl2byA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xubGV0IGlkQXV4ID0gZHYucGFnZXMoJ1wiQW5vdGFjaW9uZXMvTm90YXNcIicpLmZpbGUuZnJvbnRtYXR0ZXIuc29ydChiPT4gYi5pZCAsICdkZXNjJykuaWQ7XG5cbi8vIENvbXBydWViYSBzaSBpZEF1eCB0aWVuZSBhbCBtZW5vcyB1biBlbGVtZW50byB5IGFzaWduYSBhICdpZCcgZWwgc2lndWllbnRlIHZhbG9yIGVuIGxhIHNlY3VlbmNpYSBvIDEgc2kgbm8gaGF5IGVsZW1lbnRvcy5cbmxldCBpZCA9IGlkQXV4Lmxlbmd0aCA+IDAgPyAoaWRBdXhbMF0gKyAxKSA6IDE7XG5cbmxldCBuZXdOYW1lLCB0aXR1bG8sIGV4aXN0ZSwgYXN1bnRvLCBub21icmVcblx0dGl0dWxvID0gYXdhaXQgdHAuc3lzdGVtLnByb21wdChcIlx1MDBCRlNvYnJlIHF1ZSBlcyBlc3RhIGFub3RhY2lcdTAwRjNuP1wiLCBcIkEtXCIrIGlkLCB0cnVlKVxuXHQvLyBWZXJpZmljYXIgc2kgZWwgdXN1YXJpbyBwcmVzaW9uXHUwMEYzIEVzYy5cbiAgICBpZiAodGl0dWxvID09PSBudWxsKSB7XG4gICAgbmV3IE5vdGljZShcIkNyZWFjaVx1MDBGM24gZGUgbm90YSBjYW5jZWxhZGEgcG9yIGVsIHVzdWFyaW8uXCIpO1xuICAgIHJldHVybjsgLy8gVGVybWluYSBsYSBlamVjdWNpXHUwMEYzbiBkZSBsYSBmdW5jaVx1MDBGM24gYXF1XHUwMEVELlxuXHR9XG5cdGlmIChhY3Rpdm8gIT0gbnVsbCl7IFxuXHRcdG5vbWJyZSA9IGFjdGl2by5iYXNlbmFtZTtcblx0XHRjb25zdCBub3RhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGFjdGl2byk7IFxuXHRcdGFzdW50byA9IGF3YWl0IHRwLnN5c3RlbS5zdWdnZXN0ZXIoW1wiU2lcIixcIk5vXCJdLFt0cnVlLCBmYWxzZV0sIHRydWUsIG5vbWJyZSArIFwiIGVzIG9yaWdlbiBkZSBcIiArIHRpdHVsbyArIFwiP1wiKVxuXHRcdH1cblx0bmV3TmFtZSA9IFwiQW5vdGFjaW9uZXMvTm90YXMvQSAtIFwiICsgaWQgIFxuYXdhaXQgdHAuZmlsZS5tb3ZlKG5ld05hbWUpO1xubGV0IGNsYXNpZmljYWNpb24sIGRlc2NyaXBjaW9uLCBlc3RhZG9cbmxldCB0YWdDbGFzaWZpY2FjaW9uID0gYXdhaXQgdHAuc3lzdGVtLnN1Z2dlc3RlcihjbGFzaWZpY2FjaW9uQVgsIHRhZ3NDbGFzaWZpY2FjaW9uQVgsIGZhbHNlLCBcIlx1MDBCRkNsYXNpZmljYXJcdTAwRURhcyBlc3RhIG5vdGEgYmFqbyBhbGd1bmEgZGUgbGFzIHNpZ3VpZW50ZXMgY2F0ZWdvclx1MDBFRGFzP1wiKVxuXHQvLyBWZXJpZmljYXIgc2kgZWwgdXN1YXJpbyBwcmVzaW9uXHUwMEYzIEVzYy5cbiAgICBpZiAodGFnQ2xhc2lmaWNhY2lvbiA9PT0gbnVsbCkge1xuICAgIG5ldyBOb3RpY2UoXCJDcmVhY2lcdTAwRjNuIGRlIG5vdGEgY2FuY2VsYWRhIHBvciBlbCB1c3VhcmlvLlwiKTtcbiAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cblx0fVxubGV0IG51ZXZhQ2xhc2lmaWNhY2lvbiA9IGZhbHNlXG5pZih0YWdDbGFzaWZpY2FjaW9uPT1cIk51ZXZvXCIpe1xuXHRjbGFzaWZpY2FjaW9uID0gYXdhaXQgdHAuc3lzdGVtLnByb21wdChcIlx1MDBCRkN1YWwgZXMgZWwgbm9tYnJlIGRlIGxhIG51ZXZhIGNsYXNpZmljYWNpXHUwMEYzbiBxdWUgdmFzIGEgaW5ncmVzYXI/XCIsIFwiTWlDbGFzaWZpY2FjaVx1MDBGM25cIiwgdHJ1ZSlcblx0Ly8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgaWYgKGNsYXNpZmljYWNpb24gPT09IG51bGwpIHtcbiAgICBuZXcgTm90aWNlKFwiQ3JlYWNpXHUwMEYzbiBkZSBub3RhIGNhbmNlbGFkYSBwb3IgZWwgdXN1YXJpby5cIik7XG4gICAgcmV0dXJuOyAvLyBUZXJtaW5hIGxhIGVqZWN1Y2lcdTAwRjNuIGRlIGxhIGZ1bmNpXHUwMEYzbiBhcXVcdTAwRUQuXG5cdH1cblx0dGFnQ2xhc2lmaWNhY2lvbiA9IGF3YWl0IHRwLnN5c3RlbS5wcm9tcHQoXCJcdTAwQkZDdWFsIGVzIGVsIHRhZyBxdWUgdXRpbGl6YXJhcyBwYXJhIFwiICsgY2xhc2lmaWNhY2lvbiArIFwiPy4gTm8gdXRpbGljZXMgZXNwYWNpb3MgZW4gbGEgZGVmaW5pY2lcdTAwRjNuIGRlbCB0YWcuXCIsIFwibnVldm9UYWdcIiwgdHJ1ZSlcblx0Ly8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgaWYgKHRhZ0NsYXNpZmljYWNpb24gPT09IG51bGwpIHtcbiAgICBuZXcgTm90aWNlKFwiQ3JlYWNpXHUwMEYzbiBkZSBub3RhIGNhbmNlbGFkYSBwb3IgZWwgdXN1YXJpby5cIik7XG4gICAgcmV0dXJuOyAvLyBUZXJtaW5hIGxhIGVqZWN1Y2lcdTAwRjNuIGRlIGxhIGZ1bmNpXHUwMEYzbiBhcXVcdTAwRUQuXG5cdH1cblx0bnVldmFDbGFzaWZpY2FjaW9uID0gdHJ1ZVxuLy8gLS0+IFZhbGlkYXIgcXVlIGVsIG5vbWJyZSBkZWwgZ3J1cG8gbm8gc2VhIGlndWFsIGFsIG5vbWJyZSBkZSBuaW5ndW5hIGFyZWEgZGUgVmlkYS5cbn1lbHNlIGlmKHRhZ0NsYXNpZmljYWNpb249PVwiTmluZ3VuYVwiKXtcblx0dGFnQ2xhc2lmaWNhY2lvbiA9IFwiXCJcblx0Y2xhc2lmaWNhY2lvbiA9IFwiXCJcdFxufWVsc2Uge1xuXHRsZXQgaW5kaWNlID0gdGFnc0NsYXNpZmljYWNpb25BWC5pbmRleE9mKHRhZ0NsYXNpZmljYWNpb24pXG5cdGNsYXNpZmljYWNpb24gPSBjbGFzaWZpY2FjaW9uQVhbaW5kaWNlXVxufVxuaWYgKG51ZXZhQ2xhc2lmaWNhY2lvbikge1xuICAgIGxldCBudWV2b0MgPSBjbGFzaWZpY2FjaW9uQVgucG9wKCk7IC8vIFx1MDBEQWx0aW1hIGNsYXNpZmljYWNpXHUwMEYzblxuICAgIGxldCBuaW5ndW5vQyA9IGNsYXNpZmljYWNpb25BWC5wb3AoKTsgLy8gUGVuXHUwMEZBbHRpbWEgY2xhc2lmaWNhY2lcdTAwRjNuXG5cbiAgICBjbGFzaWZpY2FjaW9uQVgucHVzaChjbGFzaWZpY2FjaW9uKTtcbiAgICBjbGFzaWZpY2FjaW9uQVgucHVzaChuaW5ndW5vQyk7XG4gICAgY2xhc2lmaWNhY2lvbkFYLnB1c2gobnVldm9DKTtcblxuICAgIGF3YWl0IHVwZGF0ZShcInRpdHVsb0NsYXNpZmljYWNpb25BWFwiLCBjbGFzaWZpY2FjaW9uQVgsIGZpbGVDYW1wb3MuZmlsZS5wYXRoKTtcblx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcblxuICAgIGxldCBudWV2b1RhZ0MgPSB0YWdzQ2xhc2lmaWNhY2lvbkFYLnBvcCgpOyAvLyBcdTAwREFsdGltbyB0YWdcbiAgICBsZXQgbmluZ3Vub1RhZ0MgPSB0YWdzQ2xhc2lmaWNhY2lvbkFYLnBvcCgpOyAvLyBQZW5cdTAwRkFsdGltbyB0YWdcblxuICAgIHRhZ3NDbGFzaWZpY2FjaW9uQVgucHVzaCh0YWdDbGFzaWZpY2FjaW9uKTtcbiAgICB0YWdzQ2xhc2lmaWNhY2lvbkFYLnB1c2gobmluZ3Vub1RhZ0MpO1xuICAgIHRhZ3NDbGFzaWZpY2FjaW9uQVgucHVzaChudWV2b1RhZ0MpO1xuXG4gICAgYXdhaXQgdXBkYXRlKFwidGFnc0NsYXNpZmljYWNpb25BWFwiLCB0YWdzQ2xhc2lmaWNhY2lvbkFYLCBmaWxlQ2FtcG9zLmZpbGUucGF0aCk7XG59XG5cblxuaWYgKHRhZ0NsYXNpZmljYWNpb24gIT0gXCJcIil7XG50YWdDbGFzaWZpY2FjaW9uID0gXCJjbC9cIiArIHRhZ0NsYXNpZmljYWNpb24gXG59XG5pZiAoY2xhc2lmaWNhY2lvbiA9PSBcIkZlZWRiYWNrIFNlbWFuYWxcIil7XG5cdGRlc2NyaXBjaW9uID0gW11cblx0bGV0IGF1eCA9IDBcblx0bGV0IG90cmFcblx0ZG97XG5cdFx0ZGVzY3JpcGNpb25bYXV4XSA9IGF3YWl0IHRwLnN5c3RlbS5wcm9tcHQoXCJFc2NyaWJlIHR1IGZlZWRiYWNrIGRlIFwiKyB0aXR1bG8sIFwiUFwiICsgYXV4LCBmYWxzZSwgdHJ1ZSlcblx0XHRhdXggKz0gMVxuXHRcdG90cmEgPSBhd2FpdCB0cC5zeXN0ZW0uc3VnZ2VzdGVyKFtcIlNpXCIsXCJOb1wiXSxbdHJ1ZSxmYWxzZV0sIHRydWUsIFwiXHUwMEJGQWdyZWdhciBvdHJvIHBhcnJhZm8/XCIgKVxuXHR9d2hpbGUob3RyYSlcbn1lbHNle1xuXHRkZXNjcmlwY2lvbiA9IGF3YWl0IHRwLnN5c3RlbS5wcm9tcHQoXCJcdTAwQkZRdWllcmVzIGFncmVnYXIgdW5hIGRlc2NyaXBjaVx1MDBGM24/XCIsIFwiIFwiICsgdGl0dWxvLCBmYWxzZSwgdHJ1ZSApXG5cdC8vIFZlcmlmaWNhciBzaSBlbCB1c3VhcmlvIHByZXNpb25cdTAwRjMgRXNjLlxuICAgIGlmIChkZXNjcmlwY2lvbiA9PT0gbnVsbCkge1xuICAgIG5ldyBOb3RpY2UoXCJDcmVhY2lcdTAwRjNuIGRlIG5vdGEgY2FuY2VsYWRhIHBvciBlbCB1c3VhcmlvLlwiKTtcbiAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cblx0fVxufVxuZXN0YWRvID0gYXdhaXQgdHAuc3lzdGVtLnN1Z2dlc3RlcihbXCJcdUQ4M0RcdUREMzUgLT4gQ29tcGxldGFkbyAtIEluZm9ybWFjaVx1MDBGM25cIiwgXCJcdUQ4M0RcdURGRTIgLT4gRmluYWxpemFkb1wiLFwiXHVEODNEXHVERkUxIC0+IEVuIGVqZWN1Y2lcdTAwRjNuXCIsIFwiXHVEODNEXHVERDM0IC0+IERldGVuaWRvXCJdLFtcIlx1RDgzRFx1REQzNVwiLCBcIlx1RDgzRFx1REZFMlwiLFwiXHVEODNEXHVERkUxXCIsIFwiXHVEODNEXHVERDM0XCJdLCBmYWxzZSwgXCJDdWFsIGVzIGVsIGVzdGFkbyBkZSBlc3RhIGFub3RhY2lcdTAwRjNuP1wiKVxuLy8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgaWYgKGVzdGFkbyA9PT0gbnVsbCkge1xuICAgIG5ldyBOb3RpY2UoXCJDcmVhY2lcdTAwRjNuIGRlIG5vdGEgY2FuY2VsYWRhIHBvciBlbCB1c3VhcmlvLlwiKTtcbiAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cblx0fVxuLSU+XG4tLS1cbnRpcG86IEFub3RhY2lcdTAwRjNuXG5pZHE6IDZcbmlkOiA8JSBpZCAlPiBcbmlkTWFudWFsOlxuYWxpYXNlczogXG4tIDwldGl0dWxvJT5cbmRlc2NyaXBjaW9uOiA8JSppZiAoY2xhc2lmaWNhY2lvbiAhPSBcIkZlZWRiYWNrIFNlbWFuYWxcIil7JT4gPCVkZXNjcmlwY2lvbiU+PCUqIH1lbHNleyU+Pi0gIDwlKiBmb3IgKGxldCBhPTA7IGE8ZGVzY3JpcGNpb24ubGVuZ3RoO2ErKyl7JT5cbiAgIDwlZGVzY3JpcGNpb25bYV0lPiBcbjwlKn19JT5cbnRlbWE6IDwlY2xhc2lmaWNhY2lvbiU+IFxuZXN0YWRvOiA8JSBlc3RhZG8gJT4gXG5mZWNoYTogPCUgdHAuZGF0ZS5ub3coXCJZWVlZLU1NLUREIGRkZGQgSEg6bW1cIikgJT5cbmhvcmE6IDwlIHRwLmRhdGUubm93KFwiSEhtbVwiLCAwLCklPlxudmFsb3I6ICBcbnRhZ3M6IDwldGFnQ2xhc2lmaWNhY2lvbiU+IFxuYXN1bnRvOiA8JSogaWYoYXN1bnRvKXsgJT4gXG4tIFwiW1s8JW5vbWJyZSU+XV1cIiA8JSp9JT5cbnJlbGF0ZWQ6XG4tLS1cbiMgXFxgVklFV1t7YWxpYXNlc31dXFxgIFxuPlshaW5mb10tIERlc2NyaXBjaW9uXG4+XFxgVklFV1t7ZGVzY3JpcGNpb259XVxcYFxuPiBcblxuUGxhbnRpbGxhIG9jdWx0YVxuPCUqIGlmKGNsYXNpZmljYWNpb249PVwiTWVkaXRhY2lvbmVzIGRlIGFsdGVyYWNpXHUwMEYzbiBkZSBmdXR1cm9cIil7IC0lPlxuIyMgT2JqZXRpdm8gXG5cbiMjIEV2ZW50byBpbWFnaW5hcmlvIHF1ZSBzZWd1aXJcdTAwRURhIGFsIGN1bXBsaW1pZW50byBkZWwgZGVzZW9cblxuIyMjIFF1ZSBlcyBsbyBxdWUgc2llbnRvP1xuXG4jIyMgRGV0YWxsZXMgcGFyYSBsYSB2aXN1YWxpemFjaVx1MDBGM24uXG4jIyBQcmVtaXNhcyBxdWUgYWxpbWVudGVuIGVsIGRlc2VvIGN1bXBsaWRvXG5fRnJhc2VzIHF1ZSBhcG95YW4gbWkgb2JqZXRpdm9fXG4jIyBUYXJlYXMgZGUgc2VndWltaWVudG8gZGUgbGEgbWVkaXRhY2lcdTAwRjNuXG4tIFsgXSBUb3RhbCBkZSBtZWRpdGFjaW9uZXMgZGUgPCUgdGl0dWxvICU+IFxuXHQtIFsgXSBNZWRpdGFjaVx1MDBGM24gZGUgPCUgdGl0dWxvICU+ICNjeC9NZWRpdGFjaW9uIFx1RDgzRFx1REQwMSBldmVyeSBkYXkgd2hlbiBkb25lIFx1RDgzRFx1RENDNSA8JSB0cC5kYXRlLm5vdyhcIllZWVktTU0tRERcIikgJT5cbjwlKn1lbHNlIGlmKGNsYXNpZmljYWNpb24gPT1cIkZlZWRiYWNrIFNlbWFuYWxcIil7LSU+XG4jIyBGZWVkYmFja1xuXFxgXFxgXFxgZGF0YXZpZXdqc1xuZHYucGFyYWdyYXBoKGR2LmN1cnJlbnQoKS5kZXNjcmlwY2lvbilcblxcYFxcYFxcYFxuPCUqfWVsc2UgaWYoY2xhc2lmaWNhY2lvbiA9PVwiVmlkZW8gWW91dHViZVwiKXstJT5cbiMjIFZpZGVvXG5cbj4gWyF0aXBdLSBDb21vIGNyZWFyIGVsIGxpbmsgZGVsIHZpZGVvP1xuPkVzdGFtb3MgdXRpbGl6YW5kbyBlbCBwbHVnaW4gVGltZVN0YW1wIE5vdGVzLiBQYXJhIGNyZWFyIGVsIGxpbmsgYXF1XHUwMEVELCBzb2xhbWVudGUgZGViZXMgcGVnYXIgZWwgbGluayBkZSB5b3V0dWJlLCBzZWxlY2Npb25hcmxvIHkgdXRpbGl6YXIgZWwgY29tYW5kbyBPcGVuIFZpZGVvIFBsYXllciwgbyBlbCBzaG9ydGN1dCAgXHUyMzI1IF4gT1xuIyMjIFRpbWVzdGFtcHNcbj4gWyFpbXBvcnRhbnRdLSBDcmVhciBsb3MgdGltZXN0YW1wcyBkZWwgdmlkZW9cbj4gUGFyYSBjcmVhciBsb3MgdGltZXN0YW1wcyBkZWwgdmlkZW8sIGVuIGVsIG1vbWVudG8gZW4gZWwgcXVlIGxsZWd1ZXMgYWwgdmlkZW8sIHNvbG8gZGViZXMgcHVsc2FyIGVsIHNob3J0Y3V0IFx1MjMyNSBeIDAsIG8gYnVzY2FyIGVsIGNvbWFuZG8gSW5zZXJ0IFRpbWVzdGFtcC4gXG4gXG5cbiMjIENvbWVudGFyaW9zIFBlcnNvbmFsZXNcblxuIyMgSGl0b3MgZGVsIHZpZGVvLlxuXG4jIyBSZXN1bWVuIElBXG5cbjwlKn1lbHNlIGlmKGNsYXNpZmljYWNpb24gPT1cIkdydXBvIGRlIEhvamFzIGRlIFRyYWJham9cIil7LSU+XG5cbiMjIFtbQ29tZW50YXJpb3MgYSBsYXMgcGxhbnRpbGxhcyNUZW1hcyByZWxhY2lvbmFkb3MgYSBlc3RlIGdydXBvIGRlIGhvamFzIGRlIHRyYWJham98VGVtYXMgcmVsYWNpb25hZG9zIGEgZXN0ZSBncnVwbyBkZSBob2phcyBkZSB0cmFiYWpvOl1dXG5cXGBcXGBcXGBkYXRhdmlld2pzXG5jb25zdCB7Y3JlYXJBeH0gPSBjdXN0b21KU1xubGV0IGhpam9zID0gZHYucGFnZXMoKS5maWx0ZXIoYj0+IGR2LmZ1bmMuY29udGFpbnMoYi5hc3VudG8sIGR2LmN1cnJlbnQoKS5maWxlLmxpbmspKVxubGV0IHRvdGFsSGlqb3MgPSBcbmR2LnRhYmxlKFtcIlRlbWFcIixcIlRpcG9cIixcIkZlY2hhIE1vZGlmaWNhY2lcdTAwRjNuXCIsIFwiUGVuZGllbnRlc1wiLFwiSGlqb3NcIl0sIGhpam9zLm1hcChiPT4gW2IuZmlsZS5saW5rLCBiLnRlbWEsIGIuZmVjaGEsIGIuZmlsZS50YXNrcy5maWx0ZXIoYj0+IGIuc3RhdHVzID09ICcgJyB8fCBiLnN0YXR1cyA9PSAnLycpLmxlbmd0aCwgY3JlYXJBeC5wYWdpbmFzSGlqb3MoZHYsYikubGVuZ3RoLTFdKSlcblxcYFxcYFxcYFxuXG5cbjwlKn0lPlxuXG5cbiMgRmluXG4tIFsvXSBGaW5hbGl6YWRvIGVsIGRlc2Fycm9sbG8gZGUgQW5vdGFjaVx1MDBGM24gPCVpZCU+ICNjeC9Db21wdXRhZG9yL09yZ2FuaXphck5vdGFzICBcbkVzdGFkbyBkZSBsYSBub3RhOiAgXFxgSU5QVVRbZXN0YWRvTm90YV1bOmVzdGFkb11cXGBcblxcYFxcYFxcYGRhdGF2aWV3anNcbmNvbnN0IHtjYWxsRFZ9ID0gY3VzdG9tSlNcbmNhbGxEVi5DYW1iaWFyVGl0dWxvRGVzY3JpcGNpb24oZHYpXG5cXGBcXGBcXGBcbi0tLVxuXFxgXFxgXFxgZGF0YXZpZXdqc1xuY29uc3Qge2NhbGxEVn0gPSBjdXN0b21KU1xuY2FsbERWLkNhcnJ1c2VsQW5vdGFjaW9uZXMoZHYpXG5cXGBcXGBcXGBcblxcYFxcYFxcYGRhdGF2aWV3anNcbmNvbnN0IHtjYWxsRFZ9ID0gY3VzdG9tSlNcbmNhbGxEVi5Cb3RvbmVzU3RhbmRhcihkdilcblxcYFxcYFxcYFxuXG5gIiwgImltcG9ydCB7cGxhbnRpbGxhfSBmcm9tICcuLi8uLi8uLi9wbGFudGlsbGFzL0Fub3RhY2lvbmVzL1BsdCAtIEFub3RhY2lvbmVzJztcbmltcG9ydCB7IFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXJQbGFudGlsbGEoY29udGVuaWRvOiBzdHJpbmcpOiBQcm9taXNlPFRGaWxlPiB7XG4gICAgLy8gRGVmaW5lIGxhIHJ1dGEgeSBlbCBub21icmUgZGVsIGFyY2hpdm8gdGVtcG9yYWxcbiAgICBjb25zdCBmb2xkZXIgPSAnUGxhbnRpbGxhcyc7XG4gICAgbGV0IGZpbGVuYW1lID0gXCJBcmNoaXZvIERlIFBsYW50aWxsYVwiXG4gICAgbGV0IHBhdGhUZW1wb3JhbCA9IGZvbGRlciArIFwiL1wiICsgZmlsZW5hbWUgKyBcIi5tZFwiO1xuXG4gICAgLy8gQ3JlYSBlbCBhcmNoaXZvIGVuIGxhIGJcdTAwRjN2ZWRhIHkgZ3VhcmRhIGVsIGFyY2hpdm8gY3JlYWRvIGVuIHVuYSB2YXJpYWJsZVxuICAgIGNvbnN0IGFyY2hpdm9DcmVhZG86IFRGaWxlID0gYXdhaXQgYXBwLnZhdWx0LmNyZWF0ZShwYXRoVGVtcG9yYWwsIGNvbnRlbmlkbyk7XG5cbiAgICAvLyBBcXVcdTAwRUQgbmVjZXNpdGFyXHUwMEVEYXMgcHJvY2VzYXIgZWwgYXJjaGl2byBjb24gVGVtcGxhdGVyIHNpIGVzIG5lY2VzYXJpb1xuICAgIC8vIEVzdG8gZGVwZW5kZSBkZSBjXHUwMEYzbW8gVGVtcGxhdGVyIGV4cG9uZ2Egc3UgZnVuY2lvbmFsaWRhZCBhIG90cm9zIHBsdWdpbnNcbiAgICAvLyBQb3IgZWplbXBsbywgc2kgVGVtcGxhdGVyIHRpZW5lIHVuIG1cdTAwRTl0b2RvIHBhcmEgcHJvY2VzYXIgYXJjaGl2b3MsIGxvIHVzYXJcdTAwRURhcyBhcXVcdTAwRURcblxuICAgIC8vIChPcGNpb25hbCkgRWxpbWluYSBlbCBhcmNoaXZvIGRlc3B1XHUwMEU5cyBkZSBwcm9jZXNhcmxvIHNpIG5vIGRlc2VhcyBjb25zZXJ2YXJsb1xuICAgIC8vIGF3YWl0IGFwcC52YXVsdC5kZWxldGUoYXJjaGl2b0NyZWFkbyk7XG5cbiAgICAvLyBSZXRvcm5hIGVsIGFyY2hpdm8gY3JlYWRvXG4gICAgcmV0dXJuIGFyY2hpdm9DcmVhZG87XG59XG4iLCAiaW1wb3J0IHtNb2RhbH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5jbGFzcyBGaWxlTGlua01vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIGNvbnN0cnVjdG9yKGFwcCkge1xuICAgICAgICBzdXBlcihhcHApO1xuICAgIH1cblxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgbGV0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgLy8gQXBsaWNhciBlc3RpbG9zIGZsZXhib3ggcGFyYSBjZW50cmFyIGNvbnRlbmlkb1xuICAgICAgICBjb250ZW50RWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgY29udGVudEVsLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJztcbiAgICAgICAgY29udGVudEVsLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2NlbnRlcic7XG4gICAgICAgIGNvbnRlbnRFbC5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XG4gICAgICAgIGNvbnRlbnRFbC5zdHlsZS5oZWlnaHQgPSAnNTAlJzsgIC8vIEFzZWdcdTAwRkFyYXRlIGRlIHF1ZSBlbCBtb2RhbCBvY3VwZSB0b2RvIGVsIGVzcGFjaW8gZGlzcG9uaWJsZVxuICAgICAgICBcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMScsIHtcbiAgICAgICAgICAgIHRleHQ6ICdJbnNlcnRhciBlbCBsaW5rIGRlIHVuIGFyY2hpdm8uJyxcbiAgICAgICAgICAgIGF0dHI6IHsgc3R5bGU6ICd0ZXh0LWFsaWduOiBjZW50ZXI7JyB9ICAvLyBBc2VndXJhIHF1ZSBlbCB0ZXh0byBkZWwgdFx1MDBFRHR1bG8gZXN0XHUwMEU5IGNlbnRyYWRvIHNpIGVzIG1cdTAwRTFzIGxhcmdvIHF1ZSB1bmEgbFx1MDBFRG5lYVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnRlbmVkb3IgcGFyYSBlbCBpbnB1dCB5IGVsIGJvdFx1MDBGM25cbiAgICAgICAgY29uc3QgaW5wdXRDb250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRGl2KCk7XG4gICAgICAgIGlucHV0Q29udGFpbmVyLnN0eWxlLm1hcmdpbiA9ICcxMHB4JztcbiAgICAgICAgXG4gICAgICAgIC8vIElucHV0IGRlIGFyY2hpdm8gb2N1bHRvXG4gICAgICAgIGNvbnN0IGZpbGVJbnB1dCA9IGlucHV0Q29udGFpbmVyLmNyZWF0ZUVsKCdpbnB1dCcsIHsgdHlwZTogJ2ZpbGUnIH0pO1xuICAgICAgICBmaWxlSW5wdXQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgXG4gICAgICAgIC8vIEJvdFx1MDBGM24gcGFyYSBzZWxlY2Npb25hciBhcmNoaXZvXG4gICAgICAgIGNvbnN0IGZpbGVCdXR0b24gPSBpbnB1dENvbnRhaW5lci5jcmVhdGVFbCgnYnV0dG9uJywge1xuICAgICAgICAgICAgdGV4dDogJ1NlbGVjY2lvbmUgc3UgYXJjaGl2bycsXG4gICAgICAgICAgICBjbHM6ICdtb2QtY3RhJ1xuICAgICAgICB9KTtcbiAgICAgICAgZmlsZUJ1dHRvbi5zdHlsZS5wYWRkaW5nID0gJzVweCAxMHB4JztcbiAgICAgICAgZmlsZUJ1dHRvbi5zdHlsZS5mb250U2l6ZSA9ICcxNnB4JztcbiAgICAgICAgZmlsZUJ1dHRvbi5zdHlsZS5tYXJnaW5Ub3AgPSAnNXB4JztcbiAgICAgICAgZmlsZUJ1dHRvbi5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgIGZpbGVCdXR0b24ub25jbGljayA9ICgpID0+IGZpbGVJbnB1dC5jbGljaygpO1xuICAgICAgICBcbiAgICAgICAgLy8gRXZlbnRvIHBhcmEgY3VhbmRvIHNlIHNlbGVjY2lvbmEgdW4gYXJjaGl2b1xuICAgICAgICBmaWxlSW5wdXQub25jaGFuZ2UgPSAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGUudGFyZ2V0LmZpbGVzWzBdO1xuICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydExpbmtBdEN1cnNvcihmaWxlLnBhdGgsIGZpbGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgbGV0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRMaW5rQXRDdXJzb3IoZmlsZVBhdGgsIGZpbGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZjtcbiAgICAgICAgaWYgKGFjdGl2ZUxlYWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZUxlYWYudmlldy5zb3VyY2VNb2RlLmNtRWRpdG9yO1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgY29uc3QgbGlua1RleHQgPSBgWyR7ZmlsZU5hbWV9XSg8ZmlsZTovLyR7ZmlsZVBhdGh9PilgO1xuICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VSYW5nZShsaW5rVGV4dCwgY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIEZ1bmNpXHUwMEYzbiBwYXJhIGFicmlyIGVsIG1vZGFsIHBlcnNvbmFsaXphZG9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnNlcnRGaWxlTGluayhhcHApIHtcbiAgICBuZXcgRmlsZUxpbmtNb2RhbChhcHApLm9wZW4oKTtcbn1cbiIsICJpbXBvcnQge2NyZWFyQ2FycGV0YX0gZnJvbSBcIi4vdXRpbHMvY3JlYXJDYXJwZXRhXCJcbmltcG9ydCB7Y3JlYXJQbGFudGlsbGF9IGZyb20gXCIuL3V0aWxzL2NyZWFyUGxhbnRpbGxhXCJcbmltcG9ydCB7aW5zZXJ0RmlsZUxpbmt9IGZyb20gXCIuL3V0aWxzL2ZpbGVMaW5rTW9kYWxcIlxuaW1wb3J0IHtwbGFudGlsbGF9IGZyb20gXCIuLi8uLi9wbGFudGlsbGFzL0Fub3RhY2lvbmVzL1BsdCAtIEFub3RhY2lvbmVzXCJcbmltcG9ydCB7VEZpbGUsIFRGb2xkZXJ9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQge2NyZWF0ZU5vdGVGcm9tVGVtcGxhdGV9IGZyb20gXCIuL3V0aWxzL2NyZWF0ZU5vdGVGcm9tVGVtcGxhdGVcIlxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21tYW5kcyhwbHVnaW46IFBsdWdpbik6IHZvaWQge1xuXG5cbiAgICBjb25zdCBjb21hbmRvMSA9IHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICAgICAgaWQ6IFwiQ3JlYWNpb24tQ2FycGV0YVwiLFxuICAgICAgICBuYW1lOiBcIkNyZWFjaVx1MDBGM24gZGUgQ2FycGV0YVwiLFxuICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgIGF3YWl0IGNyZWFyQ2FycGV0YSgnTWkgQ2FycGV0YSBkZSBwbHVnaW4nKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHBsdWdpbi5yZWdpc3RlcmVkQ29tbWFuZElkc01CLnB1c2goY29tYW5kbzEuaWQpO1xuXG4gICAgY29uc3QgY29tYW5kbzIgPSBwbHVnaW4uYWRkQ29tbWFuZCh7XG4gICAgICAgIGlkOiBcImNyZWFyLXRlbXBsYXRlXCIsXG4gICAgICAgIG5hbWU6IFwiQ3JlYXIgdW4gYXJjaGl2byB0ZW1wbGF0ZVwiLFxuICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYXJjaGl2byA9IGF3YWl0IGNyZWFyUGxhbnRpbGxhKHBsYW50aWxsYSk7XG4gICAgICAgICAgICBpZiAoIWFyY2hpdm8pIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gc2UgcHVkbyBjcmVhciBlbCBhcmNoaXZvLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICBcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBBbG1hY2VuYXIgZWwgSUQgZGVsIGNvbWFuZG8gZW4gcmVnaXN0ZXJlZENvbW1hbmRJZHMuXG4gICAgcGx1Z2luLnJlZ2lzdGVyZWRDb21tYW5kSWRzTUIucHVzaChjb21hbmRvMi5pZCk7XG5cblxuICAgIGNvbnN0IGNvbWFuZG8zID0gcGx1Z2luLmFkZENvbW1hbmQoe1xuICAgICAgICBpZDogXCJjcmVhci1hcmNoaXZvLXRlbXBsYXRlXCIsXG4gICAgICAgIG5hbWU6IFwiQ3JlYXIgYXJjaGl2byBkZXNkZSB0ZW1wbGF0ZVwiLFxuICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBwbHVnaW5JZCA9ICd0ZW1wbGF0ZXItb2JzaWRpYW4nO1xuICAgICAgICAgICAgY29uc3QgaXNQbHVnaW5JbnN0YWxsZWQgPSBwbHVnaW4uYXBwLnBsdWdpbnMuZW5hYmxlZFBsdWdpbnMuaGFzKHBsdWdpbklkKTtcbiAgICAgICAgICAgIC8vY29uc3QgdGVtcGxhdGVyUGx1Z2luID0gcGx1Z2luLmFwcC5wbHVnaW5zLnBsdWdpbnNbcGx1Z2luSWRdO1xuICAgICAgICAgICAgLy8gSW50ZW50YSBvYnRlbmVyIGxhIHBsYW50aWxsYSBjb21vIFRGaWxlXG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBcIlBsYW50aWxsYXMvQW5vdGFjaW9uZXMvUGx0IC0gQW5vdGFjaW9uZXMubWRcIjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSW50ZW50YSBvYnRlbmVyIGxhIGNhcnBldGEgY29tbyBURm9sZGVyXG4gICAgICAgICAgICBsZXQgZm9sZGVyT2JqID0gcGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoXCJJbmJveFwiKTtcbiAgICAgICAgICAgIGlmICghKGZvbGRlck9iaiBpbnN0YW5jZW9mIFRGb2xkZXIpKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkxhIGNhcnBldGEgZXNwZWNpZmljYWRhIG5vIGV4aXN0ZSBvIG5vIGVzIHVuYSBjYXJwZXRhLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFNhbGlyIHNpIG5vIHNlIGVuY3VlbnRyYSBsYSBjYXJwZXRhIG8gbm8gZXMgdW5hIGNhcnBldGFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGZpbGVOYW1lID0gXCJ0b0RlZmluZVwiXG4gICAgICAgICAgICBsZXQgb3Blbk5vdGUgPSB0cnVlXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGRlYnVnZ2VyXG4gICAgICAgICAgICBjb25zdCBhcmNoaXZvID0gYXdhaXQgY3JlYXRlTm90ZUZyb21UZW1wbGF0ZShwbHVnaW4sIHRlbXBsYXRlLCBmb2xkZXJPYmosIGZpbGVOYW1lLCBvcGVuTm90ZSk7XG5cbiAgICAgICAgICAgIGlmICghYXJjaGl2bykge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBzZSBwdWRvIGNyZWFyIGVsIGFyY2hpdm8uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIEFsbWFjZW5hciBlbCBJRCBkZWwgY29tYW5kbyBlbiByZWdpc3RlcmVkQ29tbWFuZElkcy5cbiAgICBwbHVnaW4ucmVnaXN0ZXJlZENvbW1hbmRJZHNNQi5wdXNoKGNvbWFuZG8zLmlkKTtcblxuXG4gICAgY29uc3QgY29tYW5kbzQgPSBwbHVnaW4uYWRkQ29tbWFuZCh7XG4gICAgICAgIGlkOiBcImNyZWFyLWxpbmstQXJjaGl2b1wiLFxuICAgICAgICBuYW1lOiBcIkNyZWFyIHVuIGxpbmsgYSBhcmNoaXZvIGRlbCBEaXNjby5cIixcbiAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBpbnNlcnRGaWxlTGluayhhcHApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIEFsbWFjZW5hciBlbCBJRCBkZWwgY29tYW5kbyBlbiByZWdpc3RlcmVkQ29tbWFuZElkcy5cbiAgICBwbHVnaW4ucmVnaXN0ZXJlZENvbW1hbmRJZHNNQi5wdXNoKGNvbWFuZG80LmlkKTtcblxuXG4gICAgLy8gQ3JlYWNpXHUwMEYzbiB5IHJlZ2lzdHJvIGRlbCBjb21hbmRvLlxuICAgIGNvbnN0IGNvbWFuZG81ID0gcGx1Z2luLmFkZENvbW1hbmQoe1xuICAgICAgICBpZDogXCJhYnJpci1ub3RhLWFjdGl2YVwiLFxuICAgICAgICBuYW1lOiBcIkFicmlyIE5vdGEgQWN0aXZhXCIsXG4gICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgIFxuICAgICAgIC8vIEFzZWd1cmEgcXVlIG5vIGhheWEgZHVwbGljYWRvcyBkZSBsYSB2aXN0YS5cbiAgICAgICBhcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShcInZpc3RhLW5vdGEtYWN0aXZhXCIpO1xuXG4gICAgICAgLy8gQWJyZSBsYSB2aXN0YSBlbiB1bmEgbnVldmEgaG9qYS5cbiAgICAgICBhd2FpdCBhcHAud29ya3NwYWNlLmdldFJpZ2h0TGVhZih0cnVlKS5zZXRWaWV3U3RhdGUoe1xuICAgICAgICAgICB0eXBlOiBcInZpc3RhLW5vdGEtYWN0aXZhXCIsXG4gICAgICAgfSk7XG5cbiAgICAgICAvLyBBY3RpdmEgbGEgbnVldmEgaG9qYSBwYXJhIGVsIHVzdWFyaW8uXG4gICAgICAgYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKFxuICAgICAgICAgICBhcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShcInZpc3RhLW5vdGEtYWN0aXZhXCIpWzBdXG4gICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHBsdWdpbi5yZWdpc3RlcmVkQ29tbWFuZElkc01CLnB1c2goY29tYW5kbzUuaWQpO1xuXG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYWN0aXZhdGVDb21tYW5kcyhwbHVnaW46IFBsdWdpbik6IHZvaWQge1xuICAgIFxuICAgIGlmICghcGx1Z2luLnJlZ2lzdGVyZWRDb21tYW5kSWRzTUIpIHJldHVybjtcbiAgICAvLyBFamVtcGxvIGRlIGNcdTAwRjNtbyBwb2RyXHUwMEVEYXMgbWFuZWphciBsYSBcImRlc2FjdGl2YWNpXHUwMEYzblwiIGRlIGNvbWFuZG9zLlxuICAgIHBsdWdpbi5yZWdpc3RlcmVkQ29tbWFuZElkc01CLmZvckVhY2goY29tbWFuZElkID0+IHtcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IHBsdWdpbi5hcHAuY29tbWFuZHMuY29tbWFuZHNbY29tbWFuZElkXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgICAgICAvLyBTb2JyZXNjcmliaXIgZWwgY2FsbGJhY2sgZGVsIGNvbWFuZG8gcGFyYSBxdWUgbm8gaGFnYSBuYWRhLlxuICAgICAgICAgICAgY29tbWFuZC5jYWxsYmFjayA9ICgpID0+IG5ldyBOb3RpY2UoXCJFc3RlIGNvbWFuZG8gaGEgc2lkbyBkZXNhY3RpdmFkby5cIik7XG4gICAgICAgICAgICAvLyBPIHNpbXBsZW1lbnRlIGVsaW1pbmFyIGVsIGNhbGxiYWNrIHNpIGVzbyBzZSBhanVzdGEgYSB0dSBsXHUwMEYzZ2ljYSBkZSBhcGxpY2FjaVx1MDBGM24uXG4gICAgICAgICAgICAvLyBkZWxldGUgY29tbWFuZC5jYWxsYmFjaztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwgImltcG9ydCB7VEZpbGUsIFRGb2xkZXJ9IGZyb20gXCJvYnNpZGlhblwiXG4vKipcbiAqIENyZWEgdW5hIG51ZXZhIG5vdGEgYSBwYXJ0aXIgZGUgdW5hIHBsYW50aWxsYSB1dGlsaXphbmRvIGVsIHBsdWdpbiBUZW1wbGF0ZXIuXG4gKiBAcGFyYW0gdGVtcGxhdGVyUGx1Z2luIFJlZmVyZW5jaWEgYWwgcGx1Z2luIFRlbXBsYXRlci5cbiAqIEBwYXJhbSB0ZW1wbGF0ZSBMYSBwbGFudGlsbGEgYSB1dGlsaXphciwgcHVlZGUgc2VyIHVuIFRGaWxlIG8gZWwgcGF0aCBjb21vIHN0cmluZy5cbiAqIEBwYXJhbSBmb2xkZXIgRWwgZm9sZGVyIGRvbmRlIHNlIGNyZWFyXHUwMEUxIGxhIG51ZXZhIG5vdGEuIE9wY2lvbmFsLlxuICogQHBhcmFtIGZpbGVuYW1lIEVsIG5vbWJyZSBkZWwgYXJjaGl2byBkZSBsYSBudWV2YSBub3RhLiBPcGNpb25hbC5cbiAqIEBwYXJhbSBvcGVuTmV3Tm90ZSBTaSBzZSBkZWJlIGFicmlyIGxhIG51ZXZhIG5vdGEgdHJhcyBjcmVhcmxhLiBQb3IgZGVmZWN0byBlcyB0cnVlLlxuICogQHJldHVybnMgUHJvbWlzZSBxdWUgcmVzdWVsdmUgYSBURmlsZSBzaSBsYSBub3RhIGZ1ZSBjcmVhZGEsIHVuZGVmaW5lZCBlbiBjYXNvIGNvbnRyYXJpby5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5vdGVGcm9tVGVtcGxhdGUoXG4gICAgcGx1Z2luOiBQbHVnaW4sIC8vIEVzdGEgZXMgdW5hIHN1cG9zaWNpXHUwMEYzbiwgbmVjZXNpdGFyXHUwMEUxcyBhanVzdGFyIHNlZ1x1MDBGQW4gY1x1MDBGM21vIGFjY2VkYXMgYSBUZW1wbGF0ZXIgZW4gdHUgcGx1Z2luXG4gICAgdGVtcGxhdGU6IFRGaWxlIHwgc3RyaW5nLFxuICAgIGZvbGRlcj86IFRGb2xkZXIsXG4gICAgZmlsZW5hbWU/OiBzdHJpbmcsXG4gICAgb3Blbk5ld05vdGU6IGJvb2xlYW4gPSB0cnVlXG4pOiBQcm9taXNlPFRGaWxlIHwgdW5kZWZpbmVkPiB7XG4gICAgLy8gQXNlZ3VyYXJzZSBkZSBxdWUgZWwgcGx1Z2luIFRlbXBsYXRlciBlc3RcdTAwRTEgaW5zdGFsYWRvIHkgaGFiaWxpdGFkb1xuICAgIGlmICghcGx1Z2luIHx8ICFwbHVnaW4uYXBwLnBsdWdpbnMuZW5hYmxlZFBsdWdpbnMuaGFzKCd0ZW1wbGF0ZXItb2JzaWRpYW4nKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFbCBwbHVnaW4gVGVtcGxhdGVyIG5vIGVzdFx1MDBFMSBoYWJpbGl0YWRvLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZvcm1hIGRlIGFjY2VkZXIgYWwgb2JqZXRvIHRwIG5vcm1hbCBxdWUgaGUgdXNhZG8gZGVzZGUgRFZKU1xuICAgIGNvbnN0IHRlbXBsYXRlclBsdWdpbiA9IHBsdWdpbi5hcHAucGx1Z2lucy5wbHVnaW5zWyd0ZW1wbGF0ZXItb2JzaWRpYW4nXTtcbiAgICBjb25zdCB0cCA9IHRlbXBsYXRlclBsdWdpbi50ZW1wbGF0ZXIuY3VycmVudF9mdW5jdGlvbnNfb2JqZWN0O1xuICAgIFxuXG4gICAgaWYgKCF0cCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJObyBzZSBwdWRvIGFjY2VkZXIgYWwgb2JqZXRvIGRlIGZ1bmNpb25lcyBhY3R1YWxlcyBkZSBUZW1wbGF0ZXIuXCIpO1xuICAgIHJldHVybjtcbn1cbiAgICAvLyB0ZW1wbGF0ZUZpbGUgcHVlZGUgc2VyIHVuIHN0cmluZyBvIGVsIHRmaWxlIG9idGVuaWRvIGRlIGVzdGEgbWFuZXJhIG8gY29uIGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoKVxuICAgIGRlYnVnZ2VyXG4gICAgbGV0IHRlbXBsYXRlRmlsZSA9IHRwLmZpbGUuZmluZF90ZmlsZSh0ZW1wbGF0ZSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3Tm90ZSA9IGF3YWl0IHRwLmZpbGUuY3JlYXRlX25ldyh0ZW1wbGF0ZUZpbGUsIGZpbGVuYW1lLCBvcGVuTmV3Tm90ZSwgZm9sZGVyKTtcbiAgICAgICAgcmV0dXJuIG5ld05vdGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgY3JlYXIgbGEgbm90YSBkZXNkZSBsYSBwbGFudGlsbGE6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufSIsICJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHJlZ2lzdGVyUmliYm9uTWVudSB9IGZyb20gXCIuL3VpL3JpYmJvbkJ1dHRvblwiO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBhY3RpdmF0ZU1vZHVsb0J1c3F1ZWRhQXZhbnphZGEocGx1Z2luOiBQbHVnaW4pOiB2b2lkIHtcbiAgICByZWdpc3RlclJpYmJvbk1lbnUocGx1Z2luKTtcbn0iLCAiaW1wb3J0IHsgQXBwLCBNZW51LCBQbHVnaW4sIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBTZWFyY2hBcmVhc0RlVmlkYU1vZGFsIH0gZnJvbSBcIi4vbW9kYWxcIjsgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgdGVuZXIgZWwgaW1wb3J0IGNvcnJlY3RvIHBhcmEgdHUgbW9kYWxcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUmliYm9uTWVudShwbHVnaW46IFBsdWdpbik6IHZvaWQge1xuICAgIC8vIEVzdGUgZXMgZWwgXHUwMEVEY29ubyBkZWwgbWVuXHUwMEZBIGVuIGVsIHJpYmJvbiwgY2FtYmlhIFwiZGljZVwiIHBvciBlbCBcdTAwRURjb25vIHF1ZSBwcmVmaWVyYXNcbiAgICBwbHVnaW4uYWRkUmliYm9uSWNvbihcImZvbGRlci1zZWFyY2gtMlwiLCBcIkJcdTAwRkFzcXVlZGEgQXZhbnphZGFcIiwgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIENyZWFyIGVsIG1lblx1MDBGQSBhbCBoYWNlciBjbGljIGVuIGVsIFx1MDBFRGNvbm9cbiAgICAgICAgY29uc3QgbWVudSA9IG5ldyBNZW51KHBsdWdpbi5hcHApO1xuXG4gICAgICAgIC8vIEFncmVnYXIgb3BjaW9uZXMgYWwgbWVuXHUwMEZBXG5cbiAgICAgICAgLy8gXHUwMEMxcmVhcyBkZSBWaWRhXG4gICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbSkgPT5cbiAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoXCJcdTAwQzFyZWFzIGRlIFZpZGFcIilcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcnJlY2NpXHUwMEYzbjogQXNlZ1x1MDBGQXJhdGUgZGUgYWJyaXIgZWwgbW9kYWwgY29ycmVjdGFtZW50ZVxuICAgICAgICAgICAgICAgICAgICBuZXcgU2VhcmNoQXJlYXNEZVZpZGFNb2RhbChwbHVnaW4uYXBwLCAoZXN0YWRvU2VsZWNjaW9uYWRvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVzdGFkbyBzZWxlY2Npb25hZG86XCIsIGVzdGFkb1NlbGVjY2lvbmFkbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcXVcdTAwRUQgcHVlZGVzIGNvbnRpbnVhciBjb24gbGEgbFx1MDBGM2dpY2EgcGFyYSBtYW5lamFyIGVsIGVzdGFkbyBzZWxlY2Npb25hZG9cbiAgICAgICAgICAgICAgICAgICAgfSkub3BlbigpOyAvLyBDb3JyZWdpZG86IEFcdTAwRjFhZGlkbyAub3BlbigpIHBhcmEgYWJyaXIgZWwgbW9kYWxcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gXHUwMEMxcmVhcyBkZSBJbnRlclx1MDBFOXNcbiAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PlxuICAgICAgICAgICAgaXRlbS5zZXRUaXRsZShcIlx1MDBDMXJlYXMgZGUgSW50ZXJcdTAwRTlzXCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcXVcdTAwRUQgbGEgbFx1MDBGM2dpY2EgcGFyYSBsYSBiXHUwMEZBc3F1ZWRhIGRlIFwiXHUwMEMxcmVhcyBkZSBJbnRlclx1MDBFOXNcIlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlx1MDBDMXJlYXMgZGUgSW50ZXJcdTAwRTlzXCIpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBBbm90YWNpXHUwMEYzblxuICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+XG4gICAgICAgICAgICBpdGVtLnNldFRpdGxlKFwiQW5vdGFjaVx1MDBGM25cIilcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFxdVx1MDBFRCBsYSBsXHUwMEYzZ2ljYSBwYXJhIGxhIGJcdTAwRkFzcXVlZGEgZGUgXCJBbm90YWNpXHUwMEYzblwiXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQW5vdGFjaVx1MDBGM25cIik7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIFJlY3Vyc28gUmVjdXJyZW50ZVxuICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+XG4gICAgICAgICAgICBpdGVtLnNldFRpdGxlKFwiUmVjdXJzbyBSZWN1cnJlbnRlXCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcXVcdTAwRUQgbGEgbFx1MDBGM2dpY2EgcGFyYSBsYSBiXHUwMEZBc3F1ZWRhIGRlIFwiUmVjdXJzbyBSZWN1cnJlbnRlXCJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZWN1cnNvIFJlY3VycmVudGVcIik7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIEdlc3RpXHUwMEYzbiBEaWFyaWFcbiAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PlxuICAgICAgICAgICAgaXRlbS5zZXRUaXRsZShcIkdlc3RpXHUwMEYzbiBEaWFyaWFcIilcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFxdVx1MDBFRCBsYSBsXHUwMEYzZ2ljYSBwYXJhIGxhIGJcdTAwRkFzcXVlZGEgZGUgXCJHZXN0aVx1MDBGM24gRGlhcmlhXCJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHZXN0aVx1MDBGM24gRGlhcmlhXCIpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBSZWdpc3RybyBkZSBUaWVtcG9cbiAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PlxuICAgICAgICAgICAgaXRlbS5zZXRUaXRsZShcIlJlZ2lzdHJvIGRlIFRpZW1wb1wiKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXF1XHUwMEVEIGxhIGxcdTAwRjNnaWNhIHBhcmEgbGEgYlx1MDBGQXNxdWVkYSBkZSBcIlJlZ2lzdHJvIGRlIFRpZW1wb1wiXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVnaXN0cm8gZGUgVGllbXBvXCIpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBNb3N0cmFyIGVsIG1lblx1MDBGQSBlbiBsYSBwb3NpY2lcdTAwRjNuIGRlbCBjdXJzb3JcbiAgICAgICAgbWVudS5zaG93QXRQb3NpdGlvbih7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9KTtcbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgRnV6enlOb3RlU3VnZ2VzdGVyIH0gZnJvbSBcIi4uL3NlYXJjaC9GdXp6eU5vdGVTdWdnZXN0ZXJcIjsgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgcXVlIGxhIHJ1dGEgZGUgaW1wb3J0YWNpXHUwMEYzbiBzZWEgY29ycmVjdGFcblxuZXhwb3J0IGNsYXNzIFNlYXJjaEFyZWFzRGVWaWRhTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgb25TZWxlY3RFc3RhZG86IChlc3RhZG86IHN0cmluZykgPT4gdm9pZDtcbiAgICBlc3RhZG9TZWxlY2Npb25hZG86IHN0cmluZyA9IFwiXHVEODNEXHVERkUyXCI7IC8vIEVzdGFkbyBwb3IgZGVmZWN0byBjb21vIGVtb2ppIGRpcmVjdGFtZW50ZVxuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIG9uU2VsZWN0RXN0YWRvOiAoZXN0YWRvOiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5vblNlbGVjdEVzdGFkbyA9IG9uU2VsZWN0RXN0YWRvO1xuICAgIH1cblxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgbGV0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcblxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiQnVzY2FyIFx1MDBDMXJlYXMgZGUgVmlkYVwiIH0pO1xuXG4gICAgICAgIC8vIFVzYW5kbyBTZXR0aW5nIHBhcmEgY3JlYXIgZWwgRHJvcGRvd25cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAgICAgLnNldE5hbWUoXCJFc3RhZG9cIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiRWxpZ2UgZWwgZXN0YWRvOlwiKVxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IHtcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb25zKHsgXCJcdUQ4M0RcdURGRTJcIjogXCJWZXJkZVwiLCBcIlx1RDgzRFx1REQzNVwiOiBcIkF6dWxcIiwgXCJcdUQ4M0RcdURGRTFcIjogXCJBbWFyaWxsb1wiLCBcIlx1RDgzRFx1REQzNFwiOiBcIlJvam9cIiB9KTtcbiAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZSh0aGlzLmVzdGFkb1NlbGVjY2lvbmFkbyk7IC8vIEVzdGFibGVjZSBlbCB2YWxvciBwb3IgZGVmZWN0b1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duLm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lc3RhZG9TZWxlY2Npb25hZG8gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEJvdFx1MDBGM24gZGUgYlx1MDBGQXNxdWVkYVxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJCdXNjYXJcIilcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90YXNGaWx0cmFkYXMgPSBhd2FpdCB0aGlzLmZpbHRyYXJOb3Rhc1BvckVzdGFkb1lEaXJlY3RvcmlvKFwiRXN0cnVjdHVyYS9BcmVhcyBkZSBWaWRhXCIsIHRoaXMuZXN0YWRvU2VsZWNjaW9uYWRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm90YXMgZmlsdHJhZGFzOlwiLCBub3Rhc0ZpbHRyYWRhcy5sZW5ndGgsIG5vdGFzRmlsdHJhZGFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGdXp6eU5vdGVTdWdnZXN0ZXIodGhpcy5hcHAsIG5vdGFzRmlsdHJhZGFzKS5vcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTVx1MDBFOXRvZG8gcGFyYSBmaWx0cmFyIG5vdGFzIHBvciBlc3RhZG8geSBkaXJlY3RvcmlvXG4gICAgYXN5bmMgZmlsdHJhck5vdGFzUG9yRXN0YWRvWURpcmVjdG9yaW8oZGlyZWN0b3Jpbzogc3RyaW5nLCBlc3RhZG86IHN0cmluZyk6IFByb21pc2U8VEZpbGVbXT4ge1xuICAgICAgICBjb25zdCBhcmNoaXZvcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgICAgICAgbGV0IG5vdGFzRmlsdHJhZGFzID0gYXJjaGl2b3MuZmlsdGVyKGFyY2hpdm8gPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGFyY2hpdm8ucGF0aDtcbiAgICAgICAgICAgIGlmICghcGF0aC5zdGFydHNXaXRoKGRpcmVjdG9yaW8pKSByZXR1cm4gZmFsc2U7IC8vIEZpbHRyYSBwb3IgZGlyZWN0b3Jpb1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBkYXRvcyA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGFyY2hpdm8pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBcmNoaXZvIHByb2Nlc2FkbzpcIiwgYXJjaGl2by5wYXRoKTtcbiAgICAgICAgICAgIC8vIEFzZWdcdTAwRkFyYXRlIGRlIHF1ZSBlbCBlc3RhZG8gZGVsIGZyb250bWF0dGVyIGNvaW5jaWRlIGNvbiBlbCBlc3RhZG8gcHJvcG9yY2lvbmFkb1xuICAgICAgICAgICAgaWYgKGRhdG9zLmZyb250bWF0dGVyICYmIGRhdG9zLmZyb250bWF0dGVyLmVzdGFkbyA9PT0gZXN0YWRvKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBcmNoaXZvIGluY2x1aWRvOlwiLCBhcmNoaXZvLnBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgLy8gT3JkZW5hIGxhcyBub3RhcyBmaWx0cmFkYXMgcG9yIGZlY2hhIGRlIG1vZGlmaWNhY2lcdTAwRjNuLCBkZSBsYSBtXHUwMEUxcyByZWNpZW50ZSBhIGxhIG1cdTAwRTFzIGFudGlndWFcbiAgICAgICAgbm90YXNGaWx0cmFkYXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGIuc3RhdC5tdGltZSAtIGEuc3RhdC5tdGltZTsgLy8gRGVzY2VuZGVudGVcbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIHJldHVybiBub3Rhc0ZpbHRyYWRhcztcbiAgICB9XG4gICAgXG59XG4iLCAiLy8gRW4gYWxnXHUwMEZBbiBsdWdhciBkZSB0dSBtXHUwMEYzZHVsbywgY29tbyBzZWFyY2gvRnV6enlOb3RlU3VnZ2VzdGVyLnRzXG5pbXBvcnQgeyBBcHAsIEZ1enp5U3VnZ2VzdE1vZGFsLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY2xhc3MgRnV6enlOb3RlU3VnZ2VzdGVyIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8VEZpbGU+IHtcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBub3RhczogVEZpbGVbXSkge1xuICAgICAgICBzdXBlcihhcHApO1xuICAgIH1cblxuICAgIGdldEl0ZW1zKCk6IFRGaWxlW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RhcztcbiAgICB9XG5cbiAgICBnZXRJdGVtVGV4dChpdGVtOiBURmlsZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBpdGVtLmJhc2VuYW1lOyAvLyBPIGN1YWxxdWllciBvdHJvIGZvcm1hdG8gcXVlIHByZWZpZXJhc1xuICAgIH1cblxuICAgIG9uQ2hvb3NlSXRlbShpdGVtOiBURmlsZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICAvLyBBcXVcdTAwRUQgZGVmaW5lcyBxdVx1MDBFOSBoYWNlciBjdWFuZG8gc2Ugc2VsZWNjaW9uYSB1bmEgbm90YS4gUG9yIGVqZW1wbG8sIGFicmlyIGxhIG5vdGE6XG4gICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKTtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLnNldEFjdGl2ZUxlYWYobGVhZiwgZmFsc2UpO1xuICAgICAgICBsZWFmLm9wZW5GaWxlKGl0ZW0pO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFN0YXR1c0JhciwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjbGFzcyBTdGF0dXNCYXJFeHRlbnNpb24ge1xuICAgIHBsdWdpbjogUGx1Z2luO1xuICAgIHN0YXR1c0JhcjogU3RhdHVzQmFyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFBsdWdpbikge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzQmFyKSByZXR1cm47IC8vIFNpIHlhIGVzdFx1MDBFMSBhY3Rpdm8sIG5vIGhhY2VyIG5hZGFcblxuICAgICAgICB0aGlzLnN0YXR1c0JhciA9IHRoaXMucGx1Z2luLmFkZFN0YXR1c0Jhckl0ZW0oKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcbiAgICAgICAgLy8gUmVnaXN0cmFyIGV2ZW50byBmaWxlLW9wZW5cbiAgICAgICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2Uub24oXCJmaWxlLW9wZW5cIiwgKGZpbGU6IFRGaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoZmlsZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0dXNCYXIpIHJldHVybjsgLy8gU2kgeWEgZXN0XHUwMEUxIGRlc2FjdGl2YWRvLCBubyBoYWNlciBuYWRhXG5cbiAgICAgICAgdGhpcy5zdGF0dXNCYXIucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzQmFyID0gbnVsbDtcbiAgICAgICAgLy8gTm8gbmVjZXNpdGFzIGRlc3VzY3JpYmlyIGVsIGV2ZW50byBhcXVcdTAwRUQgc2kgdXNhcyByZWdpc3RlckV2ZW50LCBPYnNpZGlhbiBsbyBtYW5lamEgYXV0b21cdTAwRTF0aWNhbWVudGUuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTdGF0dXNCYXIoZmlsZT86IFRGaWxlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGaWxlID0gZmlsZSB8fCB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKCFjdXJyZW50RmlsZSB8fCAhdGhpcy5zdGF0dXNCYXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQmFyPy5zZXRUZXh0KCcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVDYWNoZSA9IHRoaXMucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShjdXJyZW50RmlsZSk7XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSBmaWxlQ2FjaGUuZnJvbnRtYXR0ZXI/LmFsaWFzZXMgfHwgW107XG4gICAgICAgIHRoaXMuc3RhdHVzQmFyLnNldFRleHQoYWxpYXNlcy5sZW5ndGggPiAwID8gYEFsaWFzOiAke2FsaWFzZXNbMF19YCA6ICdObyBBbGlhcycpO1xuICAgIH1cbn1cbiIsICIvLyBNb2R1bG9SZWdpc3Ryb1RpZW1wby50c1xuXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHJlZ2lzdGVyUmliYm9uTWVudSwgZGVhY3RpdmF0ZVJpYmJvbk1lbnUgfSBmcm9tIFwiLi9yaWJib25NZW51XCI7XG5pbXBvcnQgeyByZWdpc3RlckNvbW1hbmRzLCBkZWFjdGl2YXRlQ29tbWFuZHMgfSBmcm9tIFwiLi9jb21tYW5kc1wiO1xuXG5leHBvcnQgY2xhc3MgTW9kdWxvUmVnaXN0cm9UaWVtcG8ge1xuICAgIHBsdWdpbjogUGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBQbHVnaW4pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIC8vIEFzZWdcdTAwRkFyYXRlIGRlIHF1ZSBlbCByaWJib24gc29sbyBzZSByZWdpc3RyZSBzaSBhXHUwMEZBbiBubyBoYSBzaWRvIHJlZ2lzdHJhZG9cbiAgICAgICAgaWYgKCF0aGlzLnBsdWdpbi5yaWJib25CdXR0b25SVCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJSaWJib25NZW51KHRoaXMucGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlckNvbW1hbmRzKHRoaXMucGx1Z2luKTtcbiAgICB9XG5cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICBkZWFjdGl2YXRlUmliYm9uTWVudSh0aGlzLnBsdWdpbik7XG4gICAgICAgIGRlYWN0aXZhdGVDb21tYW5kcyh0aGlzLnBsdWdpbik7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgTWVudSwgUGx1Z2luLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgY3VtcGxlQ29uZGljaW9uIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUmliYm9uTWVudShwbHVnaW46IFBsdWdpbik6IHZvaWQge1xuICAgIC8vIEVzdGUgZXMgZWwgXHUwMEVEY29ubyBkZWwgbWVuXHUwMEZBIGVuIGVsIHJpYmJvbiwgY2FtYmlhIFwiZGljZVwiIHBvciBlbCBcdTAwRURjb25vIHF1ZSBwcmVmaWVyYXNcbiAgICBcbiAgICBwbHVnaW4ucmliYm9uQnV0dG9uUlQgPSBwbHVnaW4uYWRkUmliYm9uSWNvbihcImNsb2NrXCIsIFwiUmVnaXN0cm8gZGUgVGllbXBvXCIsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXIgZWwgbWVuXHUwMEZBIGFsIGhhY2VyIGNsaWMgZW4gZWwgXHUwMEVEY29ub1xuICAgICAgICBjb25zdCBtZW51ID0gbmV3IE1lbnUocGx1Z2luLmFwcCk7XG5cbiAgICAgICAgLy8gQWdyZWdhciBvcGNpb25lcyBhbCBtZW5cdTAwRkFcbiAgICAgICAgLy8gTGEgb3BjaVx1MDBGM24gYWhvcmEsIHNvbG8gc2UgYWN0aXZhIHNpIGhheSBhbGdcdTAwRkFuIHJlZ2lzdHJvIGRlIHRpZW1wbyBlbiBlamVjdWNpXHUwMEYzbi5cbiAgICAgICAgaWYgKGF3YWl0IGN1bXBsZUNvbmRpY2lvbihwbHVnaW4uYXBwKSkge1xuICAgICAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PlxuICAgICAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoXCJBaG9yYVwiKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFob3JhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbSkgPT5cbiAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoXCJSZWdpc3RyYXIgVGllbXBvXCIpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcXVcdTAwRUQgbGEgbFx1MDBGM2dpY2EgcGFyYSBcIlJlZ2lzdHJhciBUaWVtcG9cIlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlZ2lzdHJhciBUaWVtcG9cIik7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG5cbiAgICAgICAgLy8gTGEgb3BjaVx1MDBGM24gRGV0ZW5lciBSZWdpc3Rybywgc29sbyBzZSBhY3RpdmEgc2kgaGF5IGFsZ1x1MDBGQW4gcmVnaXN0cm8gZGUgdGllbXBvIGVuIGVqZWN1Y2lcdTAwRjNuLlxuICAgICAgICBpZiAoYXdhaXQgY3VtcGxlQ29uZGljaW9uKHBsdWdpbi5hcHApKSB7XG4gICAgICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRUaXRsZShcIkRldGVuZXIgUmVnaXN0cm9cIilcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXF1XHUwMEVEIGxhIGxcdTAwRjNnaWNhIHBhcmEgXCJEZXRlbmVyIFJlZ2lzdHJvXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRGV0ZW5lciBSZWdpc3Ryb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PlxuICAgICAgICAgICAgaXRlbS5zZXRUaXRsZShcIlRhcmVhcyBlbiBwcm9ncmVzb1wiKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXF1XHUwMEVEIGxhIGxcdTAwRjNnaWNhIHBhcmEgXCJUYXJlYXMgZW4gcHJvZ3Jlc29cIlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRhcmVhcyBlbiBwcm9ncmVzb1wiKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PlxuICAgICAgICAgICAgaXRlbS5zZXRUaXRsZShcIlJlZ2lzdHJvcyBkZSBob3lcIilcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFxdVx1MDBFRCBsYSBsXHUwMEYzZ2ljYSBwYXJhIFwiUmVnaXN0cm9zIGRlIGhveVwiXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVnaXN0cm9zIGRlIGhveVwiKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gTW9zdHJhciBlbCBtZW5cdTAwRkEgZW4gbGEgcG9zaWNpXHUwMEYzbiBkZWwgY3Vyc29yXG4gICAgICAgIG1lbnUuc2hvd0F0UG9zaXRpb24oeyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVkgfSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWFjdGl2YXRlUmliYm9uTWVudShwbHVnaW46IFBsdWdpbik6IHZvaWQge1xuICAgIGlmIChwbHVnaW4ucmliYm9uQnV0dG9uUlQpIHtcbiAgICAgICAgcGx1Z2luLnJpYmJvbkJ1dHRvblJULnJlbW92ZSgpO1xuICAgICAgICBwbHVnaW4ucmliYm9uQnV0dG9uUlQgPSBudWxsO1xuICAgIH1cbn1cbiIsICJcbi8vIExcdTAwRDNHSUNBIFBBUkEgQUNDRURFUiBBIExBUyBGVU5DSU9ORVMgREVTREUgTE9TIEJPVE9ORVMgUFJPUElPUyBERSBMQSBJTlRFUkZBWiBERSBPQlNJRElBTiAtPiBSSUJCT04sIEVUQ1xuaW1wb3J0IHsgQXBwLCBURmlsZSwgVEZvbGRlciwgTW9kYWwsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7U2VsZWNjaW9uTW9kYWx9IGZyb20gXCIuLi9tb2RhbGVzL3NlbGVjY2lvbk1vZGFsXCJcblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3VtcGxlQ29uZGljaW9uKGFwcDogQXBwKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIFxuICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgaWYgKGZpbGUucGF0aC5zdGFydHNXaXRoKFwiRXN0cnVjdHVyYS9SZWdpc3RybyBUaWVtcG9cIikpIHtcbiAgICAgICAgICAgIC8vIE9idGVuZXIgbG9zIG1ldGFkYXRvcyBkZWwgYXJjaGl2byBkZXNkZSBtZXRhZGF0YUNhY2hlXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGVsIGZyb250bWF0dGVyIGNvbnRpZW5lIGVsIGNhbXBvIFwiZXN0YWRvXCIgY29uIGVsIHZhbG9yIFwiXHVEODNEXHVERkUyXCJcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YT8uZnJvbnRtYXR0ZXI/LmVzdGFkbyA9PT0gXCJcdUQ4M0RcdURGRTJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBidXNjYXJSZWdpc3Ryb3NBY3Rpdm9zKGFwcDogQXBwKTogUHJvbWlzZTxURmlsZSB8IG51bGw+IHtcbiAgICBcbiAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgIFxuICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICBpZiAoZmlsZS5wYXRoLnN0YXJ0c1dpdGgoXCJTdWJzaXN0ZW1hcy9SZWdpc3RybyBUaWVtcG8vUmVnaXN0cm9zXCIpKSB7XG4gICAgICAgICAgICAgLy8gT2J0ZW5lciBsb3MgbWV0YWRhdG9zIGRlbCBhcmNoaXZvIGRlc2RlIG1ldGFkYXRhQ2FjaGVcbiAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAvLyBWZXJpZmljYXIgc2kgZWwgZnJvbnRtYXR0ZXIgY29udGllbmUgZWwgY2FtcG8gXCJlc3RhZG9cIiBjb24gZWwgdmFsb3IgXCJcdUQ4M0RcdURGRTJcIlxuICAgICAgICAgICAgIGlmIChtZXRhZGF0YT8uZnJvbnRtYXR0ZXI/LmVzdGFkbyA9PT0gXCJcdUQ4M0RcdURGRTJcIikge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgfVxuICAgICBcbiAgICAgcmV0dXJuIDtcbiB9XG5cblxuIC8vIFN1cG9uZW1vcyBxdWUgZXN0YSBmdW5jaVx1MDBGM24gc2UgdWJpY2FyXHUwMEUxIGVuIGFsZ1x1MDBGQW4gbHVnYXIgZG9uZGUgcHVlZGEgYWNjZWRlciBhIGBhcHBgIGRlIE9ic2lkaWFuLlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWFyT2JqZXRvUmVnaXN0cm8ocGx1Z2luKSB7XG4gICAgXG4gICAgY29uc3QgYWN0aXZvID0gcGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgIGlmICghYWN0aXZvKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBoYXkgdW4gYXJjaGl2byBhY3Rpdm8gcGFyYSBsYSBjcmVhY2lcdTAwRjNuIGRlIHJlZ2lzdHJvIGRlIHRpZW1wby4gU2UgZGVzY2FydGEgcGFyYSBsYSBjcmVhY2lcdTAwRjNuIGRlIHJlZ2lzdHJvIGRlIHRpZW1wby5cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBmb2xkZXIgPSBwbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1JlZ2lzdHJvVGllbXBvXG4gICAgY29uc3QgaW5kaWNlID0gcGx1Z2luLnNldHRpbmdzLmluZGljZV9SZWdpc3Ryb1RpZW1wb1xuICAgIFxuICAgIGxldCBtYXhJZCA9IDA7XG5cbiAgICAvLyBPYnRcdTAwRTluIHRvZG9zIGxvcyBhcmNoaXZvcyBNYXJrZG93blxuICAgIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcblxuICAgIC8vIEZpbHRyYSBwb3IgbG9zIGFyY2hpdm9zIGVuIGxhIGNhcnBldGEgZGVzZWFkYVxuICAgIGNvbnN0IHJlZ2lzdHJvc0V4aXN0ZW50ZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLnBhdGguc3RhcnRzV2l0aChmb2xkZXIpKTtcbiAgICAgXG4gICAgLy8gVXNhIG1ldGFkYXRhQ2FjaGUgcGFyYSBidXNjYXIgbG9zIElEcyBlbiBlbCBmcm9udG1hdHRlclxuICAgICByZWdpc3Ryb3NFeGlzdGVudGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcbiAgICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmlkICYmICFpc05hTihtZXRhZGF0YS5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gcGFyc2VJbnQobWV0YWRhdGEuaWQpO1xuICAgICAgICAgICAgaWYgKGlkID4gbWF4SWQpIG1heElkID0gaWQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEVsIHByXHUwMEYzeGltbyBJRCBkaXNwb25pYmxlXG4gICAgY29uc3QgbmV4dElkID0gbWF4SWQgKyAxO1xuXG4gICAgLy8gRm9ybWF0ZWFyIGxhIGZlY2hhIGFjdHVhbFxuICAgIGNvbnN0IGZlY2hhQ29tcGxldGEgPSBmb3JtYXRlYXJGZWNoYShuZXcgRGF0ZSgpKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2byxcbiAgICAgICAgbm9tYnJlOiBhY3Rpdm8uYmFzZW5hbWUsXG4gICAgICAgIGZvbGRlcixcbiAgICAgICAgaW5kaWNlLFxuICAgICAgICBpZDogbmV4dElkLFxuICAgICAgICBmZWNoYTogZmVjaGFDb21wbGV0YSxcbiAgICAgICAgaW5kaWNlX0RWSlM6IGBcIiR7aW5kaWNlfVwiYCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRlYXJGZWNoYShmZWNoYTogRGF0ZSk6IHN0cmluZyB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZmVjaGEuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xuICAgIGNvbnN0IGZlY2hhTG9jYWwgPSBuZXcgRGF0ZShmZWNoYS5nZXRUaW1lKCkgLSBvZmZzZXQpO1xuICAgIGNvbnN0IGZlY2hhRm9ybWF0byA9IGZlY2hhTG9jYWwudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICAgIGNvbnN0IGRpYXMgPSBbJ0RvbWluZ28nLCAnTHVuZXMnLCAnTWFydGVzJywgJ01pXHUwMEU5cmNvbGVzJywgJ0p1ZXZlcycsICdWaWVybmVzJywgJ1NcdTAwRTFiYWRvJ107XG4gICAgY29uc3QgZGlhU2VtYW5hID0gZGlhc1tmZWNoYS5nZXREYXkoKV07XG4gICAgY29uc3QgaG9yYUZvcm1hdG8gPSBmZWNoYS50b1RpbWVTdHJpbmcoKS5zcGxpdCgnICcpWzBdLnN1YnN0cmluZygwLCA1KTtcbiAgICByZXR1cm4gYCR7ZmVjaGFGb3JtYXRvfSAke2RpYVNlbWFuYX0gJHtob3JhRm9ybWF0b31gO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZpY2FyVGFyZWFzQWN0aXZhcyhyZWdpc3RybzogYW55LCBhcHA6IEFwcCk6IFByb21pc2U8dm9pZD4ge1xuICAgIFxuICAgIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgICBjb25zdCB0YXJlYXNBY3RpdmFzID0gW107XG5cbiAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIGlmIChmaWxlLnBhdGguc3RhcnRzV2l0aChyZWdpc3Ryby5mb2xkZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGE/LmVzdGFkbyA9PT0gXCJcdUQ4M0RcdURGRTJcIikge1xuICAgICAgICAgICAgICAgIHRhcmVhc0FjdGl2YXMucHVzaCh7IGZpbGUsIGFsaWFzZXM6IG1ldGFkYXRhLmFsaWFzZXMgfHwgZmlsZS5iYXNlbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0YXJlYXNBY3RpdmFzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCB0YXJlYUFjdGl2YSA9IHRhcmVhc0FjdGl2YXNbMF07XG4gICAgICAgIGRlYnVnZ2VyXG4gICAgICAgIGNvbnN0IGRlc2VhRGV0ZW5lciA9IGF3YWl0IG1vc3RyYXJTdWdlcmVuY2lhKGBMYSB0YXJlYSAke3RhcmVhQWN0aXZhLmFsaWFzZXN9IGVzdFx1MDBFMSBjb3JyaWVuZG8uIFx1MDBCRkRlc2VhIGRldGVuZXJsYT9gKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkZXNlYURldGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgQ3JlYWNpXHUwMEYzbiBkZSByZWdpc3RybyBjYW5jZWxhZG8gcG9yIGVsIHVzdWFyaW8uYCk7XG4gICAgICAgICAgICByZWdpc3Ryby5kZXRlbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGRlc2VhRGV0ZW5lcikge1xuICAgICAgICAgICAgLy8gQVFVSSBWQSBMQSBJTVBMRU1FTlRBQ0lcdTAwRDNOIEFMIE5VRVZPIENcdTAwRDNESUdPIC0+IEVTVEEgTE9HSUNBIE1BTkVKQSBGVU5DSU9ORVMhICBcbiAgICAgICAgICAgIGF3YWl0IGRldGVuZXJUYXJlYSh0YXJlYUFjdGl2YSwgYXBwKTtcbiAgICAgICAgICAgIHJlZ2lzdHJvLmRldGVuZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYExhIHRhcmVhICR7dGFyZWFBY3RpdmEuYWxpYXNlc30gc2VndWlyXHUwMEUxIHJlZ2lzdHJcdTAwRTFuZG9zZS5gKTtcbiAgICAgICAgICAgIHJlZ2lzdHJvLmRldGVuZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0YXJlYXNBY3RpdmFzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbmV3IE5vdGljZShcIkhheSB1biBlcnJvciBjb24gbGEgY2FudGlkYWQgZGUgdGFyZWFzIGNvcnJpZW5kbyBlbiBlc3RlIG1vbWVudG8uXCIpO1xuICAgICAgICByZWdpc3Ryby5kZXRlbmVyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGhheSBtXHUwMEUxcyB0YXJlYXMgY29ycmllbmRvLlwiKTtcbiAgICAgICAgcmVnaXN0cm8uZGV0ZW5lciA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbW9zdHJhclN1Z2VyZW5jaWEobWVuc2FqZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGxldCBzZWxlY2Npb25hZG8gPSBmYWxzZTsgLy8gUmFzdHJlYSBzaSBzZSBoYSBoZWNobyB1bmEgc2VsZWNjaVx1MDBGM25cblxuICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBNb2RhbChhcHApO1xuICAgICAgICBtb2RhbC5jb250ZW50RWwuY3JlYXRlRWwoJ2gxJywgeyB0ZXh0OiBtZW5zYWplIH0pO1xuXG4gICAgICAgIC8vIENyZWFyIGNvbnRlbmVkb3IgcGFyYSBib3RvbmVzXG4gICAgICAgIGNvbnN0IGJ1dHRvbnNDb250YWluZXIgPSBtb2RhbC5jb250ZW50RWwuY3JlYXRlRWwoJ2RpdicpO1xuXG4gICAgICAgIC8vIEJvdFx1MDBGM24gU1x1MDBFRFxuICAgICAgICBjb25zdCB5ZXNCdXR0b24gPSBidXR0b25zQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7XG4gICAgICAgICAgICB0ZXh0OiAnU1x1MDBFRCcsXG4gICAgICAgIH0pO1xuICAgICAgICB5ZXNCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY2Npb25hZG8gPSB0cnVlOyAvLyBBY3R1YWxpemEgcXVlIHNlIGhhIGhlY2hvIHVuYSBzZWxlY2NpXHUwMEYzblxuICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEJvdFx1MDBGM24gTm9cbiAgICAgICAgY29uc3Qgbm9CdXR0b24gPSBidXR0b25zQ29udGFpbmVyLmNyZWF0ZUVsKCdidXR0b24nLCB7XG4gICAgICAgICAgICB0ZXh0OiAnTm8nLFxuICAgICAgICB9KTtcbiAgICAgICAgbm9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY2Npb25hZG8gPSB0cnVlOyAvLyBBY3R1YWxpemEgcXVlIHNlIGhhIGhlY2hvIHVuYSBzZWxlY2NpXHUwMEYzblxuICAgICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtb2RhbC5vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZWxlY2Npb25hZG8pIHtcbiAgICAgICAgICAgICAgICAvLyBTaSBzZSBjaWVycmEgZWwgbW9kYWwgc2luIGhhY2VyIHVuYSBzZWxlY2NpXHUwMEYzbiwgcmVzdWVsdmUgY29uIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBtb2RhbC5vcGVuKCk7XG4gICAgfSk7XG59XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlZmluaXJUaXBvUmVnaXN0cm8ocmVnaXN0cm86IGFueSwgYXBwOiBBcHApIHtcbiAgICBjb25zdCB0b3RUYXJlYXMgPSBhd2FpdCBlbmNvbnRyYXJUYXJlYXNQZW5kaWVudGVzKGFwcCk7IC8vIFBhc28gYGFwcGAgY29tbyBhcmd1bWVudG9cbiAgICBsZXQgb3BjaW9uZXNUaXR1bG8sIHZhbG9yZXNPcGNpb247XG4gICAgaWYgKHRvdFRhcmVhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wY2lvbmVzVGl0dWxvID0gW3JlZ2lzdHJvLm5vbWJyZSwgXCJBbGd1bmEgdGFyZWEgZW4gRWplY3VjaVx1MDBGM25cIiwgXCJPdHJvXCJdO1xuICAgICAgICB2YWxvcmVzT3BjaW9uID0gW1wiTm90YVwiLCBcIlRhcmVhXCIsIFwiT3Ryb1wiXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcGNpb25lc1RpdHVsbyA9IFtyZWdpc3Ryby5ub21icmUsIFwiT3Ryb1wiXTtcbiAgICAgICAgdmFsb3Jlc09wY2lvbiA9IFtcIk5vdGFcIiwgXCJPdHJvXCJdO1xuICAgIH1cbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IFwiXHUwMEJGU29icmUgcXVcdTAwRTkgZXMgZWwgcmVnaXN0cm8gZGUgdGllbXBvP1wiO1xuICAgIFxuICAgIGNvbnN0IG1vZGFsTWVudTEgPSBuZXcgU2VsZWNjaW9uTW9kYWwoYXBwLCBvcGNpb25lc1RpdHVsbywgdmFsb3Jlc09wY2lvbiwgcGxhY2Vob2xkZXIpO1xuICAgIFxuICAgIC8vIEVzcGVyYSBhc2luY3JcdTAwRjNuaWNhbWVudGUgbGEgc2VsZWNjaVx1MDBGM24gZGVsIHVzdWFyaW8gYW50ZXMgZGUgY29udGludWFyLlxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGF3YWl0IG1vZGFsTWVudTEub3BlbkFuZEF3YWl0U2VsZWN0aW9uKCk7XG4gICAgICAgIHJlZ2lzdHJvLnRpcG9SZWdpc3RybyA9IHNlbGVjdGlvbjtcbiAgICAgICAgLy8gUHJvY2VzYXIgbGEgc2VsZWNjaVx1MDBGM24gZGVsIHVzdWFyaW8gYXF1XHUwMEVELlxuICAgICAgICAvLyBFbCBjXHUwMEYzZGlnbyBzdWJzaWd1aWVudGUgZGVwZW5kZSBkZWwgdGlwbyBkZSByZWdpc3RybyBzZWxlY2Npb25hZG8uXG4gICAgICAgIHN3aXRjaChyZWdpc3Ryby50aXBvUmVnaXN0cm8pIHtcbiAgICAgICAgICAgIGNhc2UgXCJOb3RhXCI6XG4gICAgICAgICAgICAgICAgcmVnaXN0cm8udGl0dWxvID0gcmVnaXN0cm8ubm9tYnJlOyAvLyBFbCB0XHUwMEVEdHVsbyBlcyBlbCBub21icmUgZGUgbGEgbm90YSBhY3R1YWwuXG4gICAgICAgICAgICAgICAgcmVnaXN0cm8uc2lBc3VudG8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRhcmVhXCI6XG4gICAgICAgICAgICAgICAgLy8gTFx1MDBGM2dpY2EgcGFyYSBwZXJtaXRpciBhbCB1c3VhcmlvIGVsZWdpciB1bmEgdGFyZWEgZXNwZWNcdTAwRURmaWNhLlxuICAgICAgICAgICAgICAgIGF3YWl0IGVsZWdpclRhcmVhUGFyYVJlZ2lzdHJvKGFwcCwgcmVnaXN0cm8sIHRvdFRhcmVhcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFNpIGVsIHVzdWFyaW8gZWxpZ2UgXCJPdHJvXCIgbyBjdWFscXVpZXIgb3RyYSBvcGNpXHUwMEYzbi5cbiAgICAgICAgICAgICAgICByZWdpc3Ryby5zaUFzdW50byA9IHJlZ2lzdHJvLnRpdHVsb0RlZmluaWRvICE9PSBcIk90cm9cIjsgLy8gQXN1bWUgcXVlIHNpIG5vIGVzIFwiT3Ryb1wiLCBlcyB1biBhc3VudG8gZXNwZWNcdTAwRURmaWNvLlxuICAgICAgICAgICAgICAgIC8vIExcdTAwRjNnaWNhIGFkaWNpb25hbCBwYXJhIG1hbmVqYXIgXCJPdHJvXCIgbyBjYXNvcyBubyBlc3BlY2lmaWNhZG9zLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG8gbW9kYWwgY2VycmFkbyBzaW4gc2VsZWNjaVx1MDBGM246XCIsIGVycm9yKTtcbiAgICAgICAgLy8gTWFuZWpvIGRlIGVycm9yZXMgbyBjaWVycmUgZGVsIG1vZGFsIHNpbiBzZWxlY2NpXHUwMEYzbi5cbiAgICAgICAgLy8gUG9yIGVqZW1wbG8sIHBvZHJcdTAwRURhcyBlc3RhYmxlY2VyIHVuIHZhbG9yIHByZWRldGVybWluYWRvIHBhcmEgcmVnaXN0cm8uZGV0ZW5lciBhcXVcdTAwRUQuXG4gICAgfVxufVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBlbmNvbnRyYXJUYXJlYXNQZW5kaWVudGVzKGFwcDogQXBwKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBsZXQgdGFyZWFzUGVuZGllbnRlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgYXJjaGl2b3MgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgICAgICBjb25zdCBhcmNoaXZvc1JlbGV2YW50ZXMgPSBhcmNoaXZvcy5maWx0ZXIoYXJjaGl2byA9PiAhYXJjaGl2by5wYXRoLmluY2x1ZGVzKFwiUGxhbnRpbGxhc1wiKSk7XG4gICAgXG4gICAgICAgIGZvciAoY29uc3QgYXJjaGl2byBvZiBhcmNoaXZvc1JlbGV2YW50ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbmlkbyA9IGF3YWl0IGFwcC52YXVsdC5yZWFkKGFyY2hpdm8pO1xuICAgICAgICAgICAgY29uc3QgY29pbmNpZGVuY2lhcyA9IGNvbnRlbmlkby5tYXRjaCgvXiAqLSBcXFtcXC9cXF0gLiovZ20pIHx8IFtdO1xuICAgIFxuICAgICAgICAgICAgLy8gRWxpbWluYSBsb3MgZXNwYWNpb3MgYWwgaW5pY2lvIGRlIGNhZGEgY29pbmNpZGVuY2lhIGFudGVzIGRlIGFncmVnYXJsYSBhbCBhcnJlZ2xvXG4gICAgICAgICAgICBjb25zdCB0YXJlYXNMaW1waWFzID0gY29pbmNpZGVuY2lhcy5tYXAodGFyZWEgPT4gdGFyZWEudHJpbSgpKTtcbiAgICAgICAgICAgIHRhcmVhc1BlbmRpZW50ZXMgPSB0YXJlYXNQZW5kaWVudGVzLmNvbmNhdCh0YXJlYXNMaW1waWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZWFzUGVuZGllbnRlcztcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBlbGVnaXJUYXJlYVBhcmFSZWdpc3RybyhhcHA6IEFwcCwgcmVnaXN0cm86IGFueSwgdGFyZWFzUGVuZGllbnRlczogc3RyaW5nW10pIHtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gXCJFbGlnZSBsYSB0YXJlYSBxdWUgdmFzIGEgcmVnaXN0cmFyLlwiO1xuICAgICAgICAgICAgXG4gICAgICAgIC8vIENyZWFyIHVuIGFycmVnbG8gZGUgcHJvbWVzYXMgdXNhbmRvIG1hcCBwYXJhIHBhc2FyIGNhZGEgdGFyZWEgcG9yIGxpbXBpYXJUZXh0b1RhcmVhXG4gICAgICAgIGxldCBwcm9tZXNhc0xpbXBpYXMgPSB0YXJlYXNQZW5kaWVudGVzLm1hcCh0YXJlYSA9PiBsaW1waWFyVGV4dG9UYXJlYSh0YXJlYSkpO1xuXG4gICAgICAgIC8vIFVzYXIgUHJvbWlzZS5hbGwgcGFyYSBlc3BlcmFyIGEgcXVlIHRvZGFzIGxhcyB0YXJlYXMgc2VhbiBwcm9jZXNhZGFzXG4gICAgICAgIFByb21pc2UuYWxsKHByb21lc2FzTGltcGlhcykudGhlbih0YXJlYXNMaW1waWFzID0+IHtcbiAgICAgICAgICAgIC8vIEVuIGVzdGUgcHVudG8sIHRhcmVhc0xpbXBpYXMgZXMgdW4gYXJyZWdsbyBjb24gdG9kYXMgbGFzIHRhcmVhcyBkZXNwdVx1MDBFOXMgZGUgc2VyIGxpbXBpYWRhc1xuICAgICAgICAgICAgLy8gQWhvcmEgcHVlZGVzIHVzYXIgdGFyZWFzTGltcGlhcyBlbiBvdHJhIGZ1bmNpXHUwMEYzblxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBtb2RhbE1lbnUgPSBuZXcgU2VsZWNjaW9uTW9kYWwoYXBwLCB0YXJlYXNMaW1waWFzLCB0YXJlYXNMaW1waWFzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICBtb2RhbE1lbnUub3BlbkFuZEF3YWl0U2VsZWN0aW9uKCkudGhlbihzZWxlY3Rpb24gPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyXG4gICAgICAgICAgICAgICAgcmVnaXN0cm8udGl0dWxvID0gbGltcGlhclRleHRvVGFyZWEgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAvL25ldyBOb3RpY2Uoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICByZWdpc3Ryby5kZXRlbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbyBtb2RhbCBjZXJyYWRvIHNpbiBzZWxlY2NpXHUwMEYzbjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIC8vIE1hbmVqYXIgcG9zaWJsZXMgZXJyb3Jlc1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkh1Ym8gdW4gZXJyb3IgYWwgbGltcGlhciBsYXMgdGFyZWFzOlwiLCBlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGltcGlhclRleHRvVGFyZWEodGl0dWxvOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAvLyBFbGltaW5hIHRvZG8gZGVzcHVcdTAwRTlzIGRlbCBwcmltZXIgc2FsdG8gZGUgbFx1MDBFRG5lYS5cbiAgICAgICAgICAgIGxldCB0ZXh0b0xpbXBpbyA9IHRpdHVsby5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gRWxpbWluYSBsb3MgdGFncyBkZSBlc3RpbG8gTWFya2Rvd24uXG4gICAgICAgICAgICB0ZXh0b0xpbXBpbyA9IHRleHRvTGltcGlvLnJlcGxhY2UoLyNbXFx3LS9dKy9nLCAnJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gRWxpbWluYSBsb3MgY2FtcG9zIGRlIGVzdGlsbyBEYXRhdmlldy5cbiAgICAgICAgICAgIHRleHRvTGltcGlvID0gdGV4dG9MaW1waW8ucmVwbGFjZSgvXFxbXFx3Kzo6W15cXF1dK1xcXS9nLCAnJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gRWxpbWluYSBlbCBwYXRyXHUwMEYzbiBcIiAtIFsvXVwiIGFsIGluaWNpbyBkZSBsYSBjYWRlbmEsIGluY2x1eWVuZG8gcG9zaWJsZXMgZXNwYWNpb3MgYW50ZXMgbyBkZXNwdVx1MDBFOXMuXG4gICAgICAgICAgICB0ZXh0b0xpbXBpbyA9IHRleHRvTGltcGlvLnJlcGxhY2UoL15cXHMqLVxccypcXFtcXC9cXF1cXHMqLywgJycpO1xuXG4gICAgICAgICAgICAvLyBSZWVtcGxhemEgY2FyYWN0ZXJlcyBubyBwZXJtaXRpZG9zIGVuIG5vbWJyZXMgZGUgYXJjaGl2byBjb24gdW4gZ3Vpb24gYmFqbyBvIGFsZ1x1MDBGQW4gb3RybyBjYXJhY3RlciBzZWd1cm8uICAgIFxuICAgICAgICAgICAgY29uc3QgY2FyYWN0ZXJlc05vUGVybWl0aWRvcyA9IC9bPD46XCJcXC9cXFxcfD8qXFx4MDAtXFx4MUZdL2c7XG4gICAgICAgICAgICB0ZXh0b0xpbXBpbyA9IHRleHRvTGltcGlvLnJlcGxhY2UoY2FyYWN0ZXJlc05vUGVybWl0aWRvcywgJ18nKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBSZWVtcGxhemEgZXNwYWNpb3MgbVx1MDBGQWx0aXBsZXMgcG9yIHVuIFx1MDBGQW5pY28gZXNwYWNpbyBwYXJhIGV2aXRhciBub21icmVzIGRlIGFyY2hpdm8gZXhjZXNpdmFtZW50ZSBsYXJnb3MuXG4gICAgICAgICAgICB0ZXh0b0xpbXBpbyA9IHRleHRvTGltcGlvLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBSZXRvcm5hIGVsIHRleHRvIGxpbXBpbywgYWhvcmEgZW52dWVsdG8gZW4gdW5hIHByb21lc2EuXG4gICAgICAgICAgICByZXNvbHZlKHRleHRvTGltcGlvLnRyaW0oKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBcbiAgICAgICAgXG5cbmFzeW5jIGZ1bmN0aW9uIGRldGVuZXJUYXJlYSh0YXJlYUFjdGl2YTogeyBmaWxlOiBURmlsZTsgdGl0dWxvOiBzdHJpbmcgfSwgYXBwOiBBcHApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBBcXVcdTAwRUQgaXJcdTAwRURhIGxhIGxcdTAwRjNnaWNhIHBhcmEgbWFyY2FyIGxhIHRhcmVhIGNvbW8gbm8gYWN0aXZhLCBwcm9iYWJsZW1lbnRlIGFjdHVhbGl6YW5kbyBzdSBmcm9udG1hdHRlclxuICAgIGNvbnNvbGUubG9nKGBEZXRlbmllbmRvIGxhIHRhcmVhOiAke3RhcmVhQWN0aXZhLnRpdHVsb31gKTtcbiAgICAvLyBFamVtcGxvIGRlIGNcdTAwRjNtbyBzZSBwb2RyXHUwMEVEYSBhY3R1YWxpemFyIGVsIGZyb250bWF0dGVyIHBhcmEgZGV0ZW5lciBsYSB0YXJlYVxuICAgIC8vIEVzdGEgZXMgdW5hIHNpbXBsaWZpY2FjaVx1MDBGM247IGxhIGltcGxlbWVudGFjaVx1MDBGM24gcmVhbCBkZXBlbmRlclx1MDBFRGEgZGUgY1x1MDBGM21vIGVzdFx1MDBFOXMgbWFuZWphbmRvIGVsIGNvbnRlbmlkbyBkZWwgYXJjaGl2b1xuICAgIGNvbnN0IGZpbGVDb250ZW50cyA9IGF3YWl0IGFwcC52YXVsdC5yZWFkKHRhcmVhQWN0aXZhLmZpbGUpO1xuICAgIGNvbnN0IG5ld0NvbnRlbnRzID0gZmlsZUNvbnRlbnRzLnJlcGxhY2UoJ2VzdGFkbzogXHVEODNEXHVERkUyJywgJ2VzdGFkbzogXHVEODNEXHVERDM1Jyk7IC8vIENhbWJpYXIgYSBlc3RhZG8gbm8gYWN0aXZvXG4gICAgYXdhaXQgYXBwLnZhdWx0Lm1vZGlmeSh0YXJlYUFjdGl2YS5maWxlLCBuZXdDb250ZW50cyk7XG59XG5cblxuXG5cblxuXG4gXG4iLCAiLy8gSW1wb3J0YWNpXHUwMEYzbiBkZSBjbGFzZXMgbmVjZXNhcmlhcyBkZXNkZSBsYSBsaWJyZXJcdTAwRURhIGRlIE9ic2lkaWFuLlxuaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG4vLyBEZWZpbmljaVx1MDBGM24gZGUgbGEgY2xhc2UgU2VsZWNjaW9uTW9kYWwgcXVlIGV4dGllbmRlIGRlIEZ1enp5U3VnZ2VzdE1vZGFsIHBhcmEgbWFuZWphciBzZWxlY2Npb25lcyBkZSBzdHJpbmdzLlxuZXhwb3J0IGNsYXNzIFNlbGVjY2lvbk1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG4gICAgdGl0bGVzOiBzdHJpbmdbXTsgLy8gQXJyYXkgZGUgdFx1MDBFRHR1bG9zIHBhcmEgbGFzIG9wY2lvbmVzIGRlbCBtb2RhbC5cbiAgICB2YWx1ZXM6IHN0cmluZ1tdOyAvLyBBcnJheSBkZSB2YWxvcmVzIGFzb2NpYWRvcyBhIGNhZGEgdFx1MDBFRHR1bG8uXG4gICAgdmFsdWVNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47IC8vIE9iamV0byBwYXJhIG1hcGVhciB0XHUwMEVEdHVsb3MgYSB2YWxvcmVzLlxuICAgIHByaXZhdGUgc2VsZWNjaW9uSGVjaGE6IGJvb2xlYW4gPSBmYWxzZTsgLy8gRmxhZyBwYXJhIGRldGVybWluYXIgc2kgc2UgaGEgaGVjaG8gdW5hIHNlbGVjY2lcdTAwRjNuLlxuXG4gICAgLy8gQ29uc3RydWN0b3IgZGUgbGEgY2xhc2UuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHRpdGxlczogc3RyaW5nW10sIHZhbHVlczogc3RyaW5nW10sIHBsYWNlaG9sZGVyOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoYXBwKTsgLy8gTGxhbWFkYSBhbCBjb25zdHJ1Y3RvciBkZSBsYSBjbGFzZSBiYXNlIGNvbiBsYSBpbnN0YW5jaWEgZGUgQXBwIGRlIE9ic2lkaWFuLlxuICAgICAgICB0aGlzLnRpdGxlcyA9IHRpdGxlczsgLy8gSW5pY2lhbGl6YWNpXHUwMEYzbiBkZWwgYXJyYXkgZGUgdFx1MDBFRHR1bG9zLlxuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlczsgLy8gSW5pY2lhbGl6YWNpXHUwMEYzbiBkZWwgYXJyYXkgZGUgdmFsb3Jlcy5cbiAgICAgICAgLy8gQ3JlYWNpXHUwMEYzbiBkZWwgbWFwZW8gZGUgdFx1MDBFRHR1bG9zIGEgdmFsb3Jlcy5cbiAgICAgICAgdGhpcy52YWx1ZU1hcCA9IHRpdGxlcy5yZWR1Y2UoKGFjYywgdGl0bGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhY2NbdGl0bGVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlcik7IC8vIEVzdGFibGVjaW1pZW50byBkZWwgdGV4dG8gZGUgcGxhY2Vob2xkZXIgcGFyYSBlbCBjYW1wbyBkZSBiXHUwMEZBc3F1ZWRhIGVuIGVsIG1vZGFsLlxuICAgIH1cblxuICAgIC8vIE1cdTAwRTl0b2RvIHBhcmEgb2J0ZW5lciBsb3MgXHUwMEVEdGVtcyAodFx1MDBFRHR1bG9zKSBxdWUgc2UgbW9zdHJhclx1MDBFMW4gZW4gZWwgbW9kYWwuXG4gICAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy50aXRsZXM7XG4gICAgfVxuXG4gICAgLy8gTVx1MDBFOXRvZG8gcGFyYSBvYnRlbmVyIGVsIHRleHRvIHF1ZSBzZSBtb3N0cmFyXHUwMEUxIHBhcmEgY2FkYSBcdTAwRUR0ZW0gZW4gZWwgbW9kYWwuXG4gICAgZ2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLy8gTVx1MDBFOXRvZG8gcXVlIHNlIGxsYW1hIGFsIGNlcnJhciBlbCBtb2RhbC5cbiAgICBvbkNsb3NlKCk6IHZvaWQge1xuICAgICAgICAvLyBTaSBlbCBtb2RhbCBzZSBjaWVycmEgc2luIHF1ZSBzZSBoYXlhIGhlY2hvIHVuYSBzZWxlY2NpXHUwMEYzbiwgc2UgcmVjaGF6YSBsYSBwcm9tZXNhLlxuICAgICAgICBpZiAoIXRoaXMuc2VsZWNjaW9uSGVjaGEpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KG5ldyBFcnJvcignTW9kYWwgY2VycmFkbyBzaW4gc2VsZWNjaVx1MDBGM24nKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNXHUwMEU5dG9kbyBwYXJhIG1hbmVqYXIgbGEgc2VsZWNjaVx1MDBGM24gZGUgdW4gXHUwMEVEdGVtLlxuICAgIHNlbGVjdFN1Z2dlc3Rpb24oaXRlbTogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2VsZWNjaW9uSGVjaGEgPSB0cnVlOyAvLyBNYXJjYXIgcXVlIHNlIGhhIGhlY2hvIHVuYSBzZWxlY2NpXHUwMEYzbi5cbiAgICAgICAgc3VwZXIuc2VsZWN0U3VnZ2VzdGlvbihpdGVtLCBldnQpOyAvLyBMbGFtYXIgYWwgbVx1MDBFOXRvZG8gY29ycmVzcG9uZGllbnRlIGRlIGxhIGNsYXNlIGJhc2UgcGFyYSBtYW5lamFyIGxhIHNlbGVjY2lcdTAwRjNuLlxuICAgIH1cblxuICAgIC8vIE1cdTAwRTl0b2RvIHF1ZSBzZSBsbGFtYSBhbCBlbGVnaXIgdW4gXHUwMEVEdGVtLCBkb25kZSBzZSByZXN1ZWx2ZSBsYSBwcm9tZXNhIGNvbiBlbCB2YWxvciBhc29jaWFkbyBhbCBcdTAwRUR0ZW0gc2VsZWNjaW9uYWRvLlxuICAgIG9uQ2hvb3NlSXRlbShpdGVtOiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlTWFwW2l0ZW1dOyAvLyBPYnRlbmVyIGVsIHZhbG9yIGFzb2NpYWRvIGFsIFx1MDBFRHRlbSBzZWxlY2Npb25hZG8uXG4gICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7IC8vIFJlc29sdmVyIGxhIHByb21lc2EgY29uIGVsIHZhbG9yIHNlbGVjY2lvbmFkby5cbiAgICB9XG5cbiAgICAvLyBNXHUwMEU5dG9kbyBwYXJhIGFicmlyIGVsIG1vZGFsIHkgZXNwZXJhciBhIHF1ZSBlbCB1c3VhcmlvIGhhZ2EgdW5hIHNlbGVjY2lcdTAwRjNuLCBkZXZvbHZpZW5kbyB1bmEgcHJvbWVzYSBjb24gZWwgdmFsb3Igc2VsZWNjaW9uYWRvLlxuICAgIG9wZW5BbmRBd2FpdFNlbGVjdGlvbigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlOyAvLyBHdWFyZGFyIGxhIGZ1bmNpXHUwMEYzbiByZXNvbHZlIGRlIGxhIHByb21lc2EgcGFyYSB1c2FybGEgYWwgc2VsZWNjaW9uYXIgdW4gXHUwMEVEdGVtLlxuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7IC8vIEd1YXJkYXIgbGEgZnVuY2lcdTAwRjNuIHJlamVjdCBkZSBsYSBwcm9tZXNhIHBhcmEgdXNhcmxhIHNpIHNlIGNpZXJyYSBlbCBtb2RhbCBzaW4gc2VsZWNjaVx1MDBGM24uXG4gICAgICAgICAgICB0aGlzLm9wZW4oKTsgLy8gQWJyaXIgZWwgbW9kYWwuXG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCAiaW1wb3J0IHsgUGx1Z2luLCBOb3RpY2UsIE1vZGFsLCBURmlsZSwgVEZvbGRlciB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgYnVzY2FyUmVnaXN0cm9zQWN0aXZvcywgY3JlYXJPYmpldG9SZWdpc3RybywgdmVyaWZpY2FyVGFyZWFzQWN0aXZhcywgZGVmaW5pclRpcG9SZWdpc3RybyB9IGZyb20gXCIuL3V0aWxzXCJcbmltcG9ydCB7bW9kYWxfQWhvcmF9IGZyb20gXCIuL21vZGFscy9tb2RhbF9BaG9yYVwiXG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbW1hbmRzKHBsdWdpbjogUGx1Z2luKTogdm9pZCB7XG4gICAgXG4gICAgY29uc3QgaWQxID0gcGx1Z2luLmFkZENvbW1hbmQoe1xuICAgICAgICBpZDogXCJyZWdpc3Ryb3MtZGUtdGllbXBvLWRlbC1kaWFcIixcbiAgICAgICAgbmFtZTogXCJSZWdpc3Ryb3MgZGUgdGllbXBvIGRlbCBkXHUwMEVEYVwiLFxuICAgICAgICBjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUxlYWYgPSBwbHVnaW4uYXBwLndvcmtzcGFjZS5hY3RpdmVMZWFmO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZUxlYWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGFjdGl2ZUxlYWYudmlldy5maWxlPy5wYXRoIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVQYXRoLnN0YXJ0c1dpdGgoXCJFc3RydWN0dXJhL1BlcmlvZG9zL0RpYXJpby9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXF1XHUwMEVEIGlyXHUwMEVEYSBsYSBsXHUwMEYzZ2ljYSBkZWwgY29tYW5kb1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZWdpc3Ryb3MgZGUgdGllbXBvIGRlbCBkXHUwMEVEYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBbG1hY2VuYXIgZWwgSUQgZGVsIGNvbWFuZG8gZW4gcmVnaXN0ZXJlZENvbW1hbmRJZHMuXG5cbiAgICBwbHVnaW4ucmVnaXN0ZXJlZENvbW1hbmRJZHNSVC5wdXNoKGlkMS5pZCk7XG5cbiAgICBjb25zdCBpZDIgPSBwbHVnaW4uYWRkQ29tbWFuZCh7XG4gICAgICAgIGlkOiBcImFob3JhLVJlZ2lzdHJvVGllbXBvXCIsXG4gICAgICAgIG5hbWU6IFwiVGFyZWEgYWN0aXZhIGVuIHJlZ2lzdHJvIGRlIHRpZW1wb1wiLFxuICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZhID0gYXdhaXQgYnVzY2FyUmVnaXN0cm9zQWN0aXZvcyhwbHVnaW4uYXBwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFhY3RpdmEpIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gaGF5IG5vdGFzIGFjdGl2YXNcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENyZWEgeSBtdWVzdHJhIGVsIG1vZGFsIHBlcnNvbmFsaXphZG8gY29uIGxhIG5vdGEgYWN0aXZhXG4gICAgICAgICAgICAgICAgbGV0IG1vZGFsID0gbmV3IG1vZGFsX0Fob3JhKHBsdWdpbi5hcHAsIGFjdGl2YSk7XG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIEFsbWFjZW5hciBlbCBJRCBkZWwgY29tYW5kbyBlbiByZWdpc3RlcmVkQ29tbWFuZElkcy5cbiAgICBwbHVnaW4ucmVnaXN0ZXJlZENvbW1hbmRJZHNSVC5wdXNoKGlkMi5pZCk7XG4gICAgXG4gICAgY29uc3QgaWQzID0gcGx1Z2luLmFkZENvbW1hbmQoe1xuICAgICAgICBpZDogXCJjcmVhci1yZWdpc3Ryby10aWVtcG9cIixcbiAgICAgICAgbmFtZTogXCJDcmVhciBSZWdpc3RybyBkZSBUaWVtcG9cIixcbiAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJvID0gYXdhaXQgY3JlYXJPYmpldG9SZWdpc3RybyhwbHVnaW4pO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcmVnaXN0cm8pIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gc2UgcHVkbyBjcmVhciBlbCBvYmpldG8gZGUgcmVnaXN0cm8uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHZlcmlmaWNhclRhcmVhc0FjdGl2YXMocmVnaXN0cm8sIHBsdWdpbi5hcHApXG4gICAgICAgICAgICBhd2FpdCBkZWZpbmlyVGlwb1JlZ2lzdHJvKHJlZ2lzdHJvLHBsdWdpbi5hcHApXG4gICAgICAgICAgICAvLyBBc3VtaWVuZG8gcXVlIHNlIHRpZW5lIHVuYSBmdW5jaVx1MDBGM24gbyBtXHUwMEU5dG9kbyBwYXJhIHByb2Nlc2FyIGVsIG9iamV0byBgcmVnaXN0cm9gXG4gICAgICAgICAgICAvLyBQb3IgZWplbXBsbywgcG9kclx1MDBFRGEgc2VyIGNyZWFyIHVuYSBudWV2YSBub3RhIGNvbiBsYSBpbmZvcm1hY2lcdTAwRjNuIGRlIGByZWdpc3Ryb2BcbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIEFsbWFjZW5hciBlbCBJRCBkZWwgY29tYW5kbyBlbiByZWdpc3RlcmVkQ29tbWFuZElkcy5cbiAgICBwbHVnaW4ucmVnaXN0ZXJlZENvbW1hbmRJZHNSVC5wdXNoKGlkMy5pZCk7XG5cbiAgICBcbmNvbnN0IGlkNCA9IHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICBpZDogXCJ2aXN0YS1yZWdpc3Ryby10aWVtcG8tYWN0aXZhXCIsXG4gICAgbmFtZTogXCJNb3N0cmFyIFJUIEFjdGl2b1wiLFxuICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFzZWd1cmEgcXVlIG5vIGhheWEgZHVwbGljYWRvcyBkZSBsYSB2aXN0YS5cbiAgICAgICAgYXBwLndvcmtzcGFjZS5kZXRhY2hMZWF2ZXNPZlR5cGUoXCJ2aXN0YS1yZWdpc3Ryby1hY3Rpdm9cIik7XG5cbiAgICAgICAgLy8gQWJyZSBsYSB2aXN0YSBlbiB1bmEgbnVldmEgaG9qYS5cbiAgICAgICAgYXdhaXQgYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYodHJ1ZSkuc2V0Vmlld1N0YXRlKHtcbiAgICAgICAgICAgIHR5cGU6IFwidmlzdGEtcmVnaXN0cm8tYWN0aXZvXCIsXG4gICAgICAgIH0pO1xuIFxuICAgICAgICAvLyBBY3RpdmEgbGEgbnVldmEgaG9qYSBwYXJhIGVsIHVzdWFyaW8uXG4gICAgICAgIGFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihcbiAgICAgICAgICAgIGFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFwidmlzdGEtcmVnaXN0cm8tYWN0aXZvXCIpWzBdXG4gICAgICAgICk7XG4gICAgICAgICBcbiAgICAgICAgXG4gICAgfSxcbn0pO1xuLy8gQWxtYWNlbmFyIGVsIElEIGRlbCBjb21hbmRvIGVuIHJlZ2lzdGVyZWRDb21tYW5kSWRzLlxucGx1Z2luLnJlZ2lzdGVyZWRDb21tYW5kSWRzUlQucHVzaChpZDQuaWQpO1xuXG59XG5cblxuLy8gRXN0YSBwYXJ0ZSBkZWwgY1x1MDBGM2RpZ28gc2VyXHUwMEVEYSBoaXBvdFx1MDBFOXRpY2EgeSBkZXBlbmRlIGRlIGNcdTAwRjNtbyBnZXN0aW9uYXMgZWwgZXN0YWRvIHkgZWwgY2ljbG8gZGUgdmlkYSBkZSBsb3MgY29tYW5kb3MgZW4gdHUgcGx1Z2luLlxuZXhwb3J0IGZ1bmN0aW9uIGRlYWN0aXZhdGVDb21tYW5kcyhwbHVnaW46IFBsdWdpbik6IHZvaWQge1xuICAgIFxuICAgIGlmICghcGx1Z2luLnJlZ2lzdGVyZWRDb21tYW5kSWRzUlQpIHJldHVybjtcbiAgICAvLyBFamVtcGxvIGRlIGNcdTAwRjNtbyBwb2RyXHUwMEVEYXMgbWFuZWphciBsYSBcImRlc2FjdGl2YWNpXHUwMEYzblwiIGRlIGNvbWFuZG9zLlxuICAgIHBsdWdpbi5yZWdpc3RlcmVkQ29tbWFuZElkc1JULmZvckVhY2goKGNvbW1hbmRJZDogc3RyaW5nIHwgbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSBwbHVnaW4uYXBwLmNvbW1hbmRzLmNvbW1hbmRzW2NvbW1hbmRJZF07XG4gICAgICAgIFxuICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgLy8gU29icmVzY3JpYmlyIGVsIGNhbGxiYWNrIGRlbCBjb21hbmRvIHBhcmEgcXVlIG5vIGhhZ2EgbmFkYS5cbiAgICAgICAgICAgIGNvbW1hbmQuY2FsbGJhY2sgPSAoKSA9PiBuZXcgTm90aWNlKFwiRXN0ZSBjb21hbmRvIGhhIHNpZG8gZGVzYWN0aXZhZG8uXCIpO1xuICAgICAgICAgICAgLy8gTyBzaW1wbGVtZW50ZSBlbGltaW5hciBlbCBjYWxsYmFjayBzaSBlc28gc2UgYWp1c3RhIGEgdHUgbFx1MDBGM2dpY2EgZGUgYXBsaWNhY2lcdTAwRjNuLlxuICAgICAgICAgICAgLy8gZGVsZXRlIGNvbW1hbmQuY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuIiwgImltcG9ydCB7IE1vZGFsLCBBcHAsIFRGaWxlLCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjbGFzcyBtb2RhbF9BaG9yYSBleHRlbmRzIE1vZGFsIHtcbiAgICBmaWxlOiBURmlsZTtcbiAgICBhcHA6IEFwcDtcbiAgICBob3JhSW5pY2lvSW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZmlsZTogVEZpbGUpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgfVxuXG4gICAgYXN5bmMgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSh0aGlzLmZpbGUpO1xuICAgICAgICBjb25zdCBhbGlhc2VzID0gbWV0YWRhdGE/LmZyb250bWF0dGVyPy5hbGlhc2VzIHx8IFwiQWN0aXZpZGFkIHNpbiBhbGlhc1wiO1xuICAgICAgICAvLyBDb252ZXJ0aXIgaG9yYUluaWNpb1N0ciBhIGZvcm1hdG8gXCJZWVlZLU1NLUREVEhIOk1NXCIgcGFyYSBkYXRldGltZS1sb2NhbFxuICAgICAgICBjb25zdCBob3JhSW5pY2lvU3RyID0gbWV0YWRhdGE/LmZyb250bWF0dGVyPy5ob3JhSW5pY2lvID8gd2luZG93Lm1vbWVudChtZXRhZGF0YS5mcm9udG1hdHRlci5ob3JhSW5pY2lvLCBcIllZWVktTU0tREQgZGRkZCBISDptbVwiKS5mb3JtYXQoXCJZWVlZLU1NLUREVEhIOm1tXCIpIDogJyc7XG5cbiAgICAgICAgLy8gQ29uZmlndXJhIGVsIHRcdTAwRUR0dWxvIGRlbCBtb2RhbCB5IG11ZXN0cmEgZWwgYWxpYXMgZGUgbGEgdGFyZWFcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogYFJlZ2lzdHJvIGRlIGFjdGl2aWRhZC5gIH0pO1xuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBUYXJlYTogXCIke2FsaWFzZXN9XCJgIH0pO1xuICAgICAgICBpZiAoaG9yYUluaWNpb1N0cikge1xuICAgICAgICAgICAgLy8gVXNhciBtb21lbnQgcGFyYSBwYXJzZWFyIGxhIGZlY2hhIGRlIGluaWNpbyB5IGNhbGN1bGFyIGxhIGRpZmVyZW5jaWFcbiAgICAgICAgICAgIGNvbnN0IGhvcmFJbmljaW8gPSB3aW5kb3cubW9tZW50KGhvcmFJbmljaW9TdHIsIFwiWVlZWS1NTS1ERCBkZGRkIEhIOm1tXCIpO1xuICAgICAgICAgICAgY29uc3QgYWhvcmEgPSB3aW5kb3cubW9tZW50KCk7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gYWhvcmEuZGlmZihob3JhSW5pY2lvKTtcbiAgICAgICAgICAgIGNvbnN0IGR1cmFjaW9uID0gd2luZG93Lm1vbWVudC5kdXJhdGlvbihkaWZmKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZGb3JtYXR0ZWQgPSBgJHtkdXJhY2lvbi5ob3VycygpfWggJHtkdXJhY2lvbi5taW51dGVzKCl9bWA7XG5cbiAgICAgICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogYEVzdGEgYWN0aXZpZGFkIGxsZXZhICR7ZGlmZkZvcm1hdHRlZH0gZW4gZWplY3VjaVx1MDBGM24uYCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogXCJObyBzZSBwdWRvIGRldGVybWluYXIgZWwgdGllbXBvIGRlIGluaWNpbyBkZSBsYSBhY3RpdmlkYWQuXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5wdXQgcGFyYSBsYSBob3JhIGRlIGluaWNpbyBjb24gdGlwbyBkYXRldGltZS1sb2NhbFxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdIb3JhIGRlIGluaWNpbzonIH0pO1xuICAgICAgICB0aGlzLmhvcmFJbmljaW9JbnB1dCA9IGNvbnRlbnRFbC5jcmVhdGVFbCgnaW5wdXQnLCB7XG4gICAgICAgICAgICB0eXBlOiAnZGF0ZXRpbWUtbG9jYWwnLFxuICAgICAgICAgICAgdmFsdWU6IGhvcmFJbmljaW9TdHJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQm90XHUwMEYzbiBwYXJhIGd1YXJkYXIgY2FtYmlvc1xuICAgICAgICBjb25zdCBzYXZlQnV0dG9uID0gY29udGVudEVsLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdHdWFyZGFyIGNhbWJpb3MnIH0pO1xuICAgICAgICBzYXZlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLmd1YXJkYXJDYW1iaW9zKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ3VhcmRhckNhbWJpb3MoKSB7XG4gICAgICAgIGNvbnN0IG51ZXZhSG9yYUluaWNpb0xvY2FsID0gdGhpcy5ob3JhSW5pY2lvSW5wdXQudmFsdWU7XG4gICAgICAgIC8vIEFzZWd1cmFyIHF1ZSBsYSBudWV2YSBob3JhIHRpZW5lIHZhbG9yIGFudGVzIGRlIGludGVudGFyIGZvcm1hdGVhclxuICAgICAgICBpZiAoIW51ZXZhSG9yYUluaWNpb0xvY2FsKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiUG9yIGZhdm9yLCBzZWxlY2Npb25lIHVuYSBob3JhIGRlIGluaWNpby5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0aXIgZGUgXCJZWVlZLU1NLUREVEhIOk1NXCIgYSBcIllZWVktTU0tREQgZGRkZCBISDptbVwiXG4gICAgICAgIGNvbnN0IG51ZXZhSG9yYUluaWNpbyA9IHdpbmRvdy5tb21lbnQobnVldmFIb3JhSW5pY2lvTG9jYWwpLmZvcm1hdChcIllZWVktTU0tREQgZGRkZCBISDptbVwiKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGVlciBlbCBjb250ZW5pZG8gYWN0dWFsIGRlbCBhcmNoaXZvXG4gICAgICAgICAgICBjb25zdCBjb250ZW5pZG9PcmlnaW5hbCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQodGhpcy5maWxlKTtcbiAgICAgICAgICAgIC8vIFJlZW1wbGF6YXIgbGEgbFx1MDBFRG5lYSBkZSBob3JhSW5pY2lvIGNvbiBlbCBudWV2byB2YWxvciBmb3JtYXRlYWRvXG4gICAgICAgICAgICBjb25zdCBjb250ZW5pZG9BY3R1YWxpemFkbyA9IGNvbnRlbmlkb09yaWdpbmFsLnJlcGxhY2UoLyhob3JhSW5pY2lvOiApLiovLCBgJDEke251ZXZhSG9yYUluaWNpb31gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR3VhcmRhciBsb3MgY2FtYmlvcyBlbiBlbCBhcmNoaXZvXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkodGhpcy5maWxlLCBjb250ZW5pZG9BY3R1YWxpemFkbyk7XG5cbiAgICAgICAgICAgIC8vIENlcnJhciBlbCBtb2RhbCBkZXNwdVx1MDBFOXMgZGUgZ3VhcmRhciBsb3MgY2FtYmlvc1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkhvcmEgZGUgaW5pY2lvIGFjdHVhbGl6YWRhIGNvcnJlY3RhbWVudGUuXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGd1YXJkYXIgY2FtYmlvcyBlbiBsYSBub3RhOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRXJyb3IgYWwgZ3VhcmRhciBsb3MgY2FtYmlvcyBlbiBsYSBub3RhLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICIvLyBzcmMvZGVmYXVsdHMvZGVmYXVsdFNldHRpbmdzLnRzXG5pbXBvcnQgdHlwZSB7IFBsdWdpbk1haW5TZXR0aW5ncyB9IGZyb20gJy4uL2ludGVyZmFjZXMvcGx1Z2luTWFpblNldHRpbmdzJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBsdWdpbk1haW5TZXR0aW5ncyA9IHtcbiAgbW9kdWxvUmVnaXN0cm9UaWVtcG86IHRydWUsXG4gIG1vZHVsb0FsaWFzU3RhdHVzQmFyOiB0cnVlLFxuICBtb2R1bG9CYXNlOiB0cnVlLFxuICBtb2R1bG9HVEQ6IHRydWUsXG4gIGZpbGVfY2FtcG9zQ2VudHJhbCA6XCJFc3RydWN0dXJhL0NhbXBvcyBTaXN0ZW1hIEdlc3Rpb24vQ2FtcG9zIFNpc3RlbWEgQ2VudHJhbFwiLCBcbiAgZm9sZGVyX0Fub3RhY2lvbmVzOiBcIkFub3RhY2lvbmVzL05vdGFzXCIsXG4gIGluZGljZV9Bbm90YWNpb25lczogXCJBbm90YWNpb25lcy9JbmRpY2UgQW5vdGFjaW9uZXNcIixcbiAgZm9sZGVyX0FCbG9nOiBcIlN1YnNpc3RlbWFzL0FydGljdWxvcyBCbG9nL0FydGljdWxvc1wiLFxuICBpbmRpY2VfQUJsb2c6IFwiU3Vic2lzdGVtYXMvQXJ0aWN1bG9zIEJsb2cvSW5kaWNlIEFydGljdWxvcyBCbG9nXCIsXG4gIGZvbGRlcl9EZXNhcnJvbGxvczogXCJTdWJzaXN0ZW1hcy9EZXNhcnJvbGxvcy9Db2RpZ29zXCIsXG4gIGluZGljZV9EZXNhcnJvbGxvczogXCJTdWJzaXN0ZW1hcy9EZXNhcnJvbGxvcy9JbmRpY2UgRGVzYXJyb2xsb1wiLFxuICBmb2xkZXJfRXN0dWRpbzogXCJTdWJzaXN0ZW1hcy9Fc3R1ZGlvL1RlbWFzXCIsXG4gIGluZGljZV9Fc3R1ZGlvOiBcIlN1YnNpc3RlbWFzL0VzdHVkaW8vSW5kaWNlIEVzdHVkaW9cIixcbiAgZm9sZGVyX0xlY3R1cmFTZXNpb25lczogXCJTdWJzaXN0ZW1hcy9MZWN0dXJhL1Nlc2lvbmVzIGRlIExlY3R1cmEvU2VzaW9uZXNcIixcbiAgaW5kaWNlX0xlY3R1cmFTZXNpb25lczogXCJTdWJzaXN0ZW1hcy9MZWN0dXJhL1Nlc2lvbmVzIGRlIExlY3R1cmEvSW5kaWNlIFNlc2lvbmVzIExlY3R1cmFcIixcbiAgZm9sZGVyX0xlY3R1cmFSZXN1bWVuZXM6IFwiU3Vic2lzdGVtYXMvTGVjdHVyYS9MaWJyb3MvUmVzdW1lbmVzXCIsXG4gIGluZGljZV9MZWN0dXJhUmVzdW1lbmVzOiBcIlN1YnNpc3RlbWFzL0xlY3R1cmEvTGlicm9zL0luZGljZSBSZXN1bWVuZXNcIixcbiAgZm9sZGVyX01lbnRvcmlhczogXCJTdWJzaXN0ZW1hcy9NZW50b3JpYXMvU2VzaW9uZXMgTWVudG9yaWFcIixcbiAgaW5kaWNlX01lbnRvcmlhczogXCJTdWJzaXN0ZW1hcy9NZW50b3JpYXMvSW5kaWNlIE1lbnRvcmlhc1wiLFxuICBmb2xkZXJfTWVyY2FkbzogXCJTdWJzaXN0ZW1hcy9NZXJjYWRvL0xpc3Rhc1wiLFxuICBpbmRpY2VfTWVyY2FkbzogXCJTdWJzaXN0ZW1hcy9NZXJjYWRvL0luZGljZSBNZXJjYWRvXCIsXG4gIGZvbGRlcl9Nb2R1bG9zU2lzdGVtYTogXCJTdWJzaXN0ZW1hcy9Nb2R1bG9zIFNpc3RlbWEgR2VzdGlvbi9Nb2R1bG9zXCIsXG4gIGluZGljZV9Nb2R1bG9zU2lzdGVtYTogXCJTdWJzaXN0ZW1hcy9Nb2R1bG9zIFNpc3RlbWEgR2VzdGlvbi9JbmRpY2UgTW9kdWxvc1wiLFxuICBmb2xkZXJfVHJhbnNhY2Npb25lczogXCJTdWJzaXN0ZW1hcy9UcmFuc2FjY2lvbmVzXCIsXG4gIGluZGljZV9UcmFuc2FjY2lvbmVzOiBcIlN1YnNpc3RlbWFzL1RyYW5zYWNjaW9uZXMvSW5kaWNlIFRyYW5zYWNjaW9uZXNcIixcbiAgZm9sZGVyX1ByZXNlbnRhY2lvbmVzOiBcIlN1YnNpc3RlbWFzL1ByZXNlbnRhY2lvbmVzL05vdGFzXCIsXG4gIGluZGljZV9QcmVzZW50YWNpb25lczogXCJTdWJzaXN0ZW1hcy9QcmVzZW50YWNpb25lcy9JbmRpY2UgUHJlc2VudGFjaW9uZXNcIixcbiAgZm9sZGVyX1B1YmxpY2FjaW9uZXM6IFwiU3Vic2lzdGVtYXMvUHVibGljYWNpb25lcy9QaWV6YXNcIixcbiAgaW5kaWNlX1B1YmxpY2FjaW9uZXM6IFwiU3Vic2lzdGVtYXMvUHVibGljYWNpb25lcy9JbmRpY2UgUHVibGljYWNpb25lc1wiLFxuICBmb2xkZXJfUmVjZXRhczogXCJTdWJzaXN0ZW1hcy9SZWNldGFzL1JlY2V0YXNcIixcbiAgaW5kaWNlX1JlY2V0YXM6IFwiU3Vic2lzdGVtYXMvUmVjZXRhcy9JbmRpY2UgUmVjZXRhc1wiLFxuICBmb2xkZXJfUmVnaXN0cm9UaWVtcG86IFwiU3Vic2lzdGVtYXMvUmVnaXN0cm8gVGllbXBvL1JlZ2lzdHJvc1wiLFxuICBpbmRpY2VfUmVnaXN0cm9UaWVtcG86IFwiU3Vic2lzdGVtYXMvUmVnaXN0cm8gVGllbXBvL0luZGljZSBSZWdpc3RybyBUaWVtcG9cIixcbiAgZm9sZGVyX0NvbnRlbmlkb1BhcmFFc3R1ZGlvOiBcIlN1YnNpc3RlbWFzL0NvbnRlbmlkbyBwYXJhIEVzdHVkaW8vQ29udGVuaWRvXCIsXG4gIGluZGljZV9Db250ZW5pZG9QYXJhRXN0dWRpbzogXCJTdWJzaXN0ZW1hcy9Db250ZW5pZG8gcGFyYSBFc3R1ZGlvL0luZGljZSBDb250ZW5pZG8gcGFyYSBFc3R1ZGlvXCIsXG5cblxuICAvLyBFc3RydWN0dXJhXG4gIGZvbGRlcl9BcmVhc1ZpZGE6IFwiRXN0cnVjdHVyYS9BcmVhcyBkZSBWaWRhXCIsXG4gIGluZGljZV9BcmVhc1ZpZGE6IFwiRXN0cnVjdHVyYS9BcmVhcyBkZSBWaWRhL0luZGljZSBBcmVhcyBkZSBWaWRhXCIsXG4gIGZvbGRlcl9BcmVhc0ludGVyZXM6IFwiRXN0cnVjdHVyYS9BcmVhcyBkZSBJbnRlcmVzXCIsXG4gIGluZGljZV9BcmVhc0ludGVyZXM6IFwiRXN0cnVjdHVyYS9BcmVhcyBkZSBJbnRlcmVzL0luZGljZSBBcmVhcyBkZSBJbnRlcmVzXCIsXG4gIGZvbGRlcl9UZW1hc0ludGVyZXM6IFwiRXN0cnVjdHVyYS9UZW1hcyBkZSBJbnRlcmVzXCIsXG4gIGluZGljZV9UZW1hc0ludGVyZXM6IFwiRXN0cnVjdHVyYS9UZW1hcyBkZSBJbnRlcmVzL0luZGljZSBUZW1hcyBkZSBJbnRlcmVzXCIsXG4gIGZvbGRlcl9SZWN1cnNvc1JlY3VycmVudGVzOiBcIkVzdHJ1Y3R1cmEvUmVjdXJzb3MgUmVjdXJyZW50ZXMvUmVjdXJzb3NcIixcbiAgaW5kaWNlX1JlY3Vyc29zUmVjdXJyZW50ZXM6IFwiRXN0cnVjdHVyYS9SZWN1cnNvcyBSZWN1cnJlbnRlcy9JbmRpY2UgUmVjdXJzb3MgUmVjdXJyZW50ZXNcIixcbiAgZm9sZGVyX1Byb3llY3Rvc1E6IFwiRXN0cnVjdHVyYS9Qcm95ZWN0b3MgZGUgUVwiLFxuICBpbmRpY2VfUHJveWVjdG9zUTogXCJFc3RydWN0dXJhL1Byb3llY3RvcyBkZSBRL0luZGljZSBQcm95ZWN0b3MgZGUgUVwiLFxuXG5cbiAgZmlsZV9JbmJveDogXCJFc3RydWN0dXJhL0dURC9CYW5kZWphIGRlIEVudHJhZGEvQmFuZGVqYSBkZSBFbnRyYWRhXCIsXG4gIGZvbGRlcl9Qcm95ZWN0b3NHVEQ6IFwiRXN0cnVjdHVyYS9HVEQvUHJveWVjdG9zIEdURC9Qcm95ZWN0b3NcIixcbiAgaW5kaWNlX1Byb3llY3Rvc0dURDogXCJFc3RydWN0dXJhL0dURC9Qcm95ZWN0b3MgR1REL0luZGljZSBQcm95ZWN0b3MgR1REXCIsXG4gIGZvbGRlcl9SU0dURDogXCJFc3RydWN0dXJhL0dURC9SZXZpc2lvbiBTZW1hbmFsL1JldmlzaW9uZXNcIixcbiAgaW5kaWNlX1JTR1REOiBcIkVzdHJ1Y3R1cmEvR1REL1JldmlzaW9uIFNlbWFuYWwvSW5kaWNlIFJldmlzaW9uIFNlbWFuYWxcIixcblxuICAvLyBKb3VybmFsXG4gIGZvbGRlcl9EaWFyaW86IFwiRXN0cnVjdHVyYS9Kb3VybmFsL0RpYXJpby9Ob3Rhc1wiLFxuICBpbmRpY2VfRGlhcmlvOiBcIkVzdHJ1Y3R1cmEvSm91cm5hbC9EaWFyaW8vSW5kaWNlIERpYXJpb1wiLFxuICBmb2xkZXJfU2VtYW5hbDogXCJFc3RydWN0dXJhL0pvdXJuYWwvU2VtYW5hbC9Ob3Rhc1wiLFxuICBpbmRpY2VfU2VtYW5hbDogXCJFc3RydWN0dXJhL0pvdXJuYWwvU2VtYW5hbC9JbmRpY2UgU2VtYW5hbFwiLFxuICBmb2xkZXJfTWVuc3VhbDogXCJFc3RydWN0dXJhL0pvdXJuYWwvTWVuc3VhbC9Ob3Rhc1wiLFxuICBpbmRpY2VfTWVuc3VhbDogXCJFc3RydWN0dXJhL0pvdXJuYWwvTWVuc3VhbC9JbmRpY2UgTWVuc3VhbFwiLFxuICBmb2xkZXJfVHJpbWVzdHJhbDogXCJFc3RydWN0dXJhL0pvdXJuYWwvVHJpbWVzdHJhbC9Ob3Rhc1wiLFxuICBpbmRpY2VfVHJpbWVzdHJhbDogXCJFc3RydWN0dXJhL0pvdXJuYWwvVHJpbWVzdHJhbC9JbmRpY2UgVHJpbWVzdHJhbFwiLFxuICBmb2xkZXJfQW51YWw6IFwiRXN0cnVjdHVyYS9Kb3VybmFsL0FudWFsL05vdGFzXCIsXG4gIGluZGljZV9BbnVhbDogXCJFc3RydWN0dXJhL0pvdXJuYWwvQW51YWwvSW5kaWNlIEFudWFsXCIsXG5cbiAgLy8gQ09NUEFTU1xuICBmb2xkZXJfQ29tcGFzc0FudWFsOiBcIkVzdHJ1Y3R1cmEvQ29tcGFzcy9SZXBvcnRlcy9BbnVhbFwiLFxuICBpbmRpY2VfQ29tcGFzc0FudWFsOiBcIkVzdHJ1Y3R1cmEvQ29tcGFzcy9SZXBvcnRlcy9JbmRpY2UgQ29tcGFzcyBBbnVhbFwiLFxuICBmb2xkZXJfQ29tcGFzc1RyaW1lc3RyYWw6IFwiRXN0cnVjdHVyYS9Db21wYXNzL1JlcG9ydGVzL1RyaW1lc3RyYWxcIixcbiAgaW5kaWNlX0NvbXBhc3NUcmltZXN0cmFsOiBcIkVzdHJ1Y3R1cmEvQ29tcGFzcy9SZXBvcnRlcy9JbmRpY2UgQ29tcGFzcyB0cmltZXN0cmFsXCIsXG4gIGZvbGRlcl9PYmpDb21wYXNzQW51YWw6IFwiRXN0cnVjdHVyYS9Db21wYXNzL09iamV0aXZvcy9BbnVhbFwiLFxuICBpbmRpY2VfT2JqQ29tcGFzc0FudWFsOiBcIkVzdHJ1Y3R1cmEvQ29tcGFzcy9PYmpldGl2b3MvSW5kaWNlIENvbXBhc3MgQW51YWxcIixcbiAgZm9sZGVyX09iakNvbXBhc3NUcmltZXN0cmFsOiBcIkVzdHJ1Y3R1cmEvQ29tcGFzcy9PYmpldGl2b3MvVHJpbWVzdHJhbFwiLFxuICBpbmRpY2VfT2JqQ29tcGFzc1RyaW1lc3RyYWw6IFwiRXN0cnVjdHVyYS9Db21wYXNzL09iamV0aXZvcy9JbmRpY2UgQ29tcGFzcyB0cmltZXN0cmFsXCIsXG59O1xuXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSwgVEZvbGRlciwgTW9kYWwsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7U2VsZWNjaW9uTW9kYWx9IGZyb20gXCIuLi8uLi9tb2RhbGVzL3NlbGVjY2lvbk1vZGFsXCJcbmltcG9ydCB7bWVudU90cm99IGZyb20gJy4vbWVudU90cm8nXG5pbXBvcnQgeyByZWdpc3Ryb1RpZW1wb0FQSSB9IGZyb20gXCIuL3JlZ2lzdHJvVGllbXBvQVBJXCI7XG5cbmV4cG9ydCBjbGFzcyB1dGlsc0FQSSB7XG4gIHByaXZhdGUgbWVudU90cm86IG1lbnVPdHJvO1xuICBwbHVnaW46IFBsdWdpbjtcblxuICBjb25zdHJ1Y3RvcihwbHVnaW46IFBsdWdpbikge1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIHRoaXMubWVudU90cm8gPSBuZXcgbWVudU90cm8ocGx1Z2luKTtcbiAgfVxuICAvLyBMYSBkZWNsYXJhY2lcdTAwRjNuIGRlbCBtXHUwMEU5dG9kbyBlc3RhYmEgYXNpOiBidXNjYXJSZWdpc3Ryb3NBY3Rpdm9zKGFwcDogQXBwLCByZWdpc3RybzogYW55KVxuICAvLyBEZXZ1ZWx2ZSBlbCBmaWxlIGRlbCByZWdpc3RybyBhY3Rpdm8uIFV0aWxpemFkbyBwYXJhIGN1YW5kbyBuZWNlc2l0byBvYnRlbmVyIGVsIGRhdG8gc29sYW1lbnRlIGRlIHNpIGhheSBhbGdcdTAwRkFuIHJlZ2lzdHJvIGFjdGl2by5cbiAgYXN5bmMgYnVzY2FyUmVnaXN0cm9zQWN0aXZvcyhhcHA6IEFwcCk6IFByb21pc2U8VEZpbGUgfCBudWxsPiB7XG4gICAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIGNvbnN0IGZvbGRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9SZWdpc3Ryb1RpZW1wbztcbiAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoZmlsZS5wYXRoLnN0YXJ0c1dpdGgoZm9sZGVyKSkge1xuICAgICAgICAvLyBPYnRlbmVyIGxvcyBtZXRhZGF0b3MgZGVsIGFyY2hpdm8gZGVzZGUgbWV0YWRhdGFDYWNoZVxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcblxuICAgICAgICAvLyBWZXJpZmljYXIgc2kgZWwgZnJvbnRtYXR0ZXIgY29udGllbmUgZWwgY2FtcG8gXCJlc3RhZG9cIiBjb24gZWwgdmFsb3IgXCJcdUQ4M0RcdURGRTJcIlxuICAgICAgICBpZiAobWV0YWRhdGE/LmZyb250bWF0dGVyPy5lc3RhZG8gPT09IFwiXHVEODNEXHVERkUyXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTdXBvbmVtb3MgcXVlIGVzdGEgZnVuY2lcdTAwRjNuIHNlIHViaWNhclx1MDBFMSBlbiBhbGdcdTAwRkFuIGx1Z2FyIGRvbmRlIHB1ZWRhIGFjY2VkZXIgYSBgYXBwYCBkZSBPYnNpZGlhbi5cbiAgYXN5bmMgY3JlYXJPYmpldG9SZWdpc3RybyhwbHVnaW46IFBsdWdpbikge1xuICAgIGNvbnN0IGFjdGl2byA9IHBsdWdpbi5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICBpZiAoIWFjdGl2bykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJObyBoYXkgdW4gYXJjaGl2byBhY3Rpdm8gcGFyYSBsYSBjcmVhY2lcdTAwRjNuIGRlIHJlZ2lzdHJvIGRlIHRpZW1wby4gU2UgZGVzY2FydGEgcGFyYSBsYSBjcmVhY2lcdTAwRjNuIGRlIHJlZ2lzdHJvIGRlIHRpZW1wby5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbGRlciA9IHBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfUmVnaXN0cm9UaWVtcG87XG4gICAgY29uc3QgaW5kaWNlID0gcGx1Z2luLnNldHRpbmdzLmluZGljZV9SZWdpc3Ryb1RpZW1wbztcblxuICAgIGxldCBtYXhJZCA9IDA7XG5cbiAgICAvLyBPYnRcdTAwRTluIHRvZG9zIGxvcyBhcmNoaXZvcyBNYXJrZG93blxuICAgIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcblxuICAgIC8vIEZpbHRyYSBwb3IgbG9zIGFyY2hpdm9zIGVuIGxhIGNhcnBldGEgZGVzZWFkYVxuICAgIGNvbnN0IHJlZ2lzdHJvc0V4aXN0ZW50ZXMgPSBmaWxlcy5maWx0ZXIoKGZpbGU6IHsgcGF0aDogc3RyaW5nIH0pID0+XG4gICAgICBmaWxlLnBhdGguc3RhcnRzV2l0aChmb2xkZXIpXG4gICAgKTtcblxuICAgIC8vIFVzYSBtZXRhZGF0YUNhY2hlIHBhcmEgYnVzY2FyIGxvcyBJRHMgZW4gZWwgZnJvbnRtYXR0ZXJcbiAgICByZWdpc3Ryb3NFeGlzdGVudGVzLmZvckVhY2goKGZpbGU6IGFueSkgPT4ge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmlkICYmICFpc05hTihtZXRhZGF0YS5pZCkpIHtcbiAgICAgICAgY29uc3QgaWQgPSBwYXJzZUludChtZXRhZGF0YS5pZCk7XG4gICAgICAgIGlmIChpZCA+IG1heElkKSBtYXhJZCA9IGlkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRWwgcHJcdTAwRjN4aW1vIElEIGRpc3BvbmlibGVcbiAgICBjb25zdCBuZXh0SWQgPSBtYXhJZCArIDE7XG5cbiAgICAvLyBGb3JtYXRlYXIgbGEgZmVjaGEgYWN0dWFsXG4gICAgY29uc3QgZmVjaGFDb21wbGV0YSA9IHRoaXMuZm9ybWF0ZWFyRmVjaGEobmV3IERhdGUoKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWN0aXZvLFxuICAgICAgbm9tYnJlOiBhY3Rpdm8uYmFzZW5hbWUsXG4gICAgICBmb2xkZXIsXG4gICAgICBpbmRpY2UsXG4gICAgICBpZDogbmV4dElkLFxuICAgICAgZmVjaGE6IGZlY2hhQ29tcGxldGEsXG4gICAgICBpbmRpY2VfRFZKUzogYFwiJHtpbmRpY2V9XCJgLFxuICAgIH07XG4gIH1cblxuICBmb3JtYXRlYXJGZWNoYShmZWNoYTogRGF0ZSk6IHN0cmluZyB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZmVjaGEuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xuICAgIGNvbnN0IGZlY2hhTG9jYWwgPSBuZXcgRGF0ZShmZWNoYS5nZXRUaW1lKCkgLSBvZmZzZXQpO1xuICAgIGNvbnN0IGZlY2hhRm9ybWF0byA9IGZlY2hhTG9jYWwudG9JU09TdHJpbmcoKS5zcGxpdChcIlRcIilbMF07XG4gICAgY29uc3QgZGlhcyA9IFtcbiAgICAgIFwiRG9taW5nb1wiLFxuICAgICAgXCJMdW5lc1wiLFxuICAgICAgXCJNYXJ0ZXNcIixcbiAgICAgIFwiTWlcdTAwRTlyY29sZXNcIixcbiAgICAgIFwiSnVldmVzXCIsXG4gICAgICBcIlZpZXJuZXNcIixcbiAgICAgIFwiU1x1MDBFMWJhZG9cIixcbiAgICBdO1xuICAgIGNvbnN0IGRpYVNlbWFuYSA9IGRpYXNbZmVjaGEuZ2V0RGF5KCldO1xuICAgIGNvbnN0IGhvcmFGb3JtYXRvID0gZmVjaGEudG9UaW1lU3RyaW5nKCkuc3BsaXQoXCIgXCIpWzBdLnN1YnN0cmluZygwLCA1KTtcbiAgICByZXR1cm4gYCR7ZmVjaGFGb3JtYXRvfSAke2RpYVNlbWFuYX0gJHtob3JhRm9ybWF0b31gO1xuICB9XG5cbiAgLy8gTVx1MDBFOXRvZG8gcXVlIHZlcmlmaWNhIHNpIGhheSByZWdpc3Ryb3MgQUN0aXZvcyB5IHByZWd1bnRhIHNpIHF1aWVyZSBjZXJyYXJsb3MuXG4gIGFzeW5jIHZlcmlmaWNhclRhcmVhc0FjdGl2YXMocmVnaXN0cm86IGFueSwgYXBwOiBBcHApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgY29uc3QgdGFyZWFzQWN0aXZhcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgaWYgKGZpbGUucGF0aC5zdGFydHNXaXRoKHJlZ2lzdHJvLmZvbGRlcikpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgICBpZiAobWV0YWRhdGE/LmVzdGFkbyA9PT0gXCJcdUQ4M0RcdURGRTJcIikge1xuICAgICAgICAgIHRhcmVhc0FjdGl2YXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgdGl0dWxvOiBtZXRhZGF0YS50aXR1bG8sXG4gICAgICAgICAgICBhbGlhc2VzOiBtZXRhZGF0YS5hbGlhc2VzIHx8IGZpbGUuYmFzZW5hbWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFyZWFzQWN0aXZhcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHRhcmVhQWN0aXZhID0gdGFyZWFzQWN0aXZhc1swXTtcbiAgICAgIGNvbnN0IGRlc2VhRGV0ZW5lciA9IGF3YWl0IHRoaXMubW9zdHJhclN1Z2VyZW5jaWEoXG4gICAgICAgIGBMYSB0YXJlYSAke3RhcmVhQWN0aXZhLmFsaWFzZXN9IGVzdFx1MDBFMSBjb3JyaWVuZG8uIFx1MDBCRkRlc2VhIGRldGVuZXJsYT9gXG4gICAgICApO1xuICAgICAgaWYgKGRlc2VhRGV0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYENyZWFjaVx1MDBGM24gZGUgcmVnaXN0cm8gY2FuY2VsYWRvIHBvciBlbCB1c3VhcmlvLmApO1xuICAgICAgICByZWdpc3Ryby5kZXRlbmVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVzZWFEZXRlbmVyKSB7XG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBjb25zdCByZWdpc3Ryb1RpZW1wb0FQSW5zdGFuY2UgPSBuZXcgcmVnaXN0cm9UaWVtcG9BUEkodGhpcy5wbHVnaW4pO1xuICAgICAgICBhd2FpdCByZWdpc3Ryb1RpZW1wb0FQSW5zdGFuY2UuY2VycmFyUmVnaXN0cm8odGFyZWFBY3RpdmEuZmlsZSk7XG4gICAgICAgIHJlZ2lzdHJvLmRldGVuZXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYExhIHRhcmVhICR7dGFyZWFBY3RpdmEuYWxpYXNlc30gc2VndWlyXHUwMEUxIHJlZ2lzdHJcdTAwRTFuZG9zZS5gKTtcbiAgICAgICAgcmVnaXN0cm8uZGV0ZW5lciA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhcmVhc0FjdGl2YXMubGVuZ3RoID4gMSkge1xuICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgXCJIYXkgdW4gZXJyb3IgY29uIGxhIGNhbnRpZGFkIGRlIHRhcmVhcyBjb3JyaWVuZG8gZW4gZXN0ZSBtb21lbnRvLlwiXG4gICAgICApO1xuICAgICAgcmVnaXN0cm8uZGV0ZW5lciA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiTm8gaGF5IG1cdTAwRTFzIHRhcmVhcyBjb3JyaWVuZG8uXCIpO1xuICAgICAgcmVnaXN0cm8uZGV0ZW5lciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG1vc3RyYXJTdWdlcmVuY2lhKG1lbnNhamU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc2VsZWNjaW9uYWRvID0gZmFsc2U7IC8vIEluZGljYSBzaSBzZSBoYSBoZWNobyB1bmEgc2VsZWNjaVx1MDBGM25cblxuICAgICAgY29uc3QgbW9kYWwgPSBuZXcgTW9kYWwoYXBwKTtcbiAgICAgIG1vZGFsLmNvbnRlbnRFbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogbWVuc2FqZSB9KTtcblxuICAgICAgLy8gQ3JlYXIgY29udGVuZWRvciBwYXJhIGJvdG9uZXNcbiAgICAgIGNvbnN0IGJ1dHRvbnNDb250YWluZXIgPSBtb2RhbC5jb250ZW50RWwuY3JlYXRlRWwoXCJkaXZcIik7XG5cbiAgICAgIC8vIEZ1bmNpXHUwMEYzbiBhdXhpbGlhciBwYXJhIG1hbmVqYXIgc2VsZWNjaW9uZXMgeSBjZXJyYXIgZWwgbW9kYWwgYWRlY3VhZGFtZW50ZVxuICAgICAgY29uc3QgaGFjZXJTZWxlY2Npb24gPSAoc2VsZWNjaW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHNlbGVjY2lvbmFkbyA9IHRydWU7IC8vIE1hcmNhciBxdWUgc2UgaGEgaGVjaG8gdW5hIHNlbGVjY2lcdTAwRjNuXG4gICAgICAgIG1vZGFsLmNsb3NlKCk7IC8vIENlcnJhciBlbCBtb2RhbFxuICAgICAgICByZXNvbHZlKHNlbGVjY2lvbik7IC8vIFJlc29sdmVyIGxhIHByb21lc2EgY29uIGxhIHNlbGVjY2lcdTAwRjNuXG4gICAgICB9O1xuXG4gICAgICAvLyBCb3RcdTAwRjNuIFNcdTAwRURcbiAgICAgIGNvbnN0IHllc0J1dHRvbiA9IGJ1dHRvbnNDb250YWluZXIuY3JlYXRlRWwoXCJidXR0b25cIiwge1xuICAgICAgICB0ZXh0OiBcIlNcdTAwRURcIixcbiAgICAgIH0pO1xuICAgICAgeWVzQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiBoYWNlclNlbGVjY2lvbih0cnVlKSk7XG5cbiAgICAgIC8vIEJvdFx1MDBGM24gTm9cbiAgICAgIGNvbnN0IG5vQnV0dG9uID0gYnV0dG9uc0NvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiLCB7XG4gICAgICAgIHRleHQ6IFwiTm9cIixcbiAgICAgIH0pO1xuICAgICAgbm9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IGhhY2VyU2VsZWNjaW9uKGZhbHNlKSk7XG5cbiAgICAgIG1vZGFsLm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc2VsZWNjaW9uYWRvKSB7XG4gICAgICAgICAgLy8gU2kgZWwgbW9kYWwgc2UgY2llcnJhIHNpbiBxdWUgc2UgaGF5YSBoZWNobyB1bmEgc2VsZWNjaVx1MDBGM24sIHJlY2hhemFyIGxhIHByb21lc2FcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTW9kYWwgY2VycmFkbyBzaW4gc2VsZWNjaVx1MDBGM25cIikpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBBZ3JlZ2FyIGVzY3VjaGFzIGRlIGV2ZW50b3MgZGUgdGVjbGFkbyBwYXJhIHBlcm1pdGlyIGxhIG5hdmVnYWNpXHUwMEYzbiBjb24gZWwgdGVjbGFkb1xuICAgICAgbW9kYWwuY29udGVudEVsLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlOiB7IGtleTogYW55IH0pID0+IHtcbiAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICAgIHllc0J1dHRvbi5mb2N1cygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgICAgIG5vQnV0dG9uLmZvY3VzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgIC8vIFNpbXVsYSBjbGljIGVuIGVsIGJvdFx1MDBGM24gZW5mb2NhZG9cbiAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ/LmNsaWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEVuZm9jYXIgaW5pY2lhbG1lbnRlIGVsIGJvdFx1MDBGM24gJ1NcdTAwRUQnIHBhcmEgcGVybWl0aXIgbGEgbmF2ZWdhY2lcdTAwRjNuIGNvbiB0ZWNsYWRvIGRlc2RlIGVsIGluaWNpb1xuICAgICAgeWVzQnV0dG9uLmZvY3VzKCk7XG5cbiAgICAgIG1vZGFsLm9wZW4oKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGRlZmluaXJUaXBvUmVnaXN0cm8ocmVnaXN0cm86IGFueSwgYXBwOiBBcHApIHtcbiAgICBjb25zdCB0b3RUYXJlYXMgPSBhd2FpdCB0aGlzLmVuY29udHJhclRhcmVhc1BlbmRpZW50ZXMoYXBwKTsgLy8gUGFzbyBgYXBwYCBjb21vIGFyZ3VtZW50b1xuXG4gICAgbGV0IG9wY2lvbmVzVGl0dWxvLCB2YWxvcmVzT3BjaW9uO1xuICAgIGlmICh0b3RUYXJlYXMubGVuZ3RoID4gMCkge1xuICAgICAgb3BjaW9uZXNUaXR1bG8gPSBbcmVnaXN0cm8ubm9tYnJlLCBcIkFsZ3VuYSB0YXJlYSBlbiBFamVjdWNpXHUwMEYzblwiLCBcIk90cm9cIl07XG4gICAgICB2YWxvcmVzT3BjaW9uID0gW1wiTm90YVwiLCBcIlRhcmVhXCIsIFwiT3Ryb1wiXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BjaW9uZXNUaXR1bG8gPSBbcmVnaXN0cm8ubm9tYnJlLCBcIk90cm9cIl07XG4gICAgICB2YWxvcmVzT3BjaW9uID0gW1wiTm90YVwiLCBcIk90cm9cIl07XG4gICAgfVxuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gXCJcdTAwQkZTb2JyZSBxdVx1MDBFOSBlcyBlbCByZWdpc3RybyBkZSB0aWVtcG8/XCI7XG5cbiAgICBjb25zdCBtb2RhbE1lbnUxID0gbmV3IFNlbGVjY2lvbk1vZGFsKFxuICAgICAgYXBwLFxuICAgICAgb3BjaW9uZXNUaXR1bG8sXG4gICAgICB2YWxvcmVzT3BjaW9uLFxuICAgICAgcGxhY2Vob2xkZXJcbiAgICApO1xuXG4gICAgLy8gRXNwZXJhIGFzaW5jclx1MDBGM25pY2FtZW50ZSBsYSBzZWxlY2NpXHUwMEYzbiBkZWwgdXN1YXJpbyBhbnRlcyBkZSBjb250aW51YXIuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGF3YWl0IG1vZGFsTWVudTEub3BlbkFuZEF3YWl0U2VsZWN0aW9uKCk7XG4gICAgICByZWdpc3Ryby50aXBvUmVnaXN0cm8gPSBzZWxlY3Rpb247XG4gICAgICAvLyBQcm9jZXNhciBsYSBzZWxlY2NpXHUwMEYzbiBkZWwgdXN1YXJpbyBhcXVcdTAwRUQuXG4gICAgICAvLyBFbCBjXHUwMEYzZGlnbyBzdWJzaWd1aWVudGUgZGVwZW5kZSBkZWwgdGlwbyBkZSByZWdpc3RybyBzZWxlY2Npb25hZG8uXG4gICAgICBzd2l0Y2ggKHJlZ2lzdHJvLnRpcG9SZWdpc3Rybykge1xuICAgICAgICBjYXNlIFwiTm90YVwiOlxuICAgICAgICAgIHJlZ2lzdHJvLnRpdHVsbyA9IHJlZ2lzdHJvLm5vbWJyZTsgLy8gRWwgdFx1MDBFRHR1bG8gZXMgZWwgbm9tYnJlIGRlIGxhIG5vdGEgYWN0dWFsLlxuICAgICAgICAgIHJlZ2lzdHJvLnNpQXN1bnRvID0gdHJ1ZTtcbiAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICByZWdpc3RybyA9IHRoaXMuY29waWFyQ2FtcG9zKHJlZ2lzdHJvKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRhcmVhXCI6XG4gICAgICAgICAgLy8gTFx1MDBGM2dpY2EgcGFyYSBwZXJtaXRpciBhbCB1c3VhcmlvIGVsZWdpciB1bmEgdGFyZWEgZXNwZWNcdTAwRURmaWNhLlxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5lbGVnaXJUYXJlYVBhcmFSZWdpc3RybyhhcHAsIHJlZ2lzdHJvLCB0b3RUYXJlYXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFNpIGVsIHVzdWFyaW8gZWxpZ2UgXCJPdHJvXCIgbyBjdWFscXVpZXIgb3RyYSBvcGNpXHUwMEYzbi5cbiAgICAgICAgICBsZXQgcmVzcHVlc3RhID0gYXdhaXQgdGhpcy5tZW51T3Ryby5tZW51T3RybyhhcHAsIHJlZ2lzdHJvKTtcbiAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHJlZ2lzdHJvLCByZXNwdWVzdGEpOyAvLyB0aXR1bG8sIHNpQXN1bnRvLCBub21icmVcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG8gbW9kYWwgY2VycmFkbyBzaW4gc2VsZWNjaVx1MDBGM246XCIsIGVycm9yKTtcbiAgICAgIC8vIE1hbmVqbyBkZSBlcnJvcmVzIG8gY2llcnJlIGRlbCBtb2RhbCBzaW4gc2VsZWNjaVx1MDBGM24uXG4gICAgICAvLyBQb3IgZWplbXBsbywgcG9kclx1MDBFRGFzIGVzdGFibGVjZXIgdW4gdmFsb3IgcHJlZGV0ZXJtaW5hZG8gcGFyYSByZWdpc3Ryby5kZXRlbmVyIGFxdVx1MDBFRC5cbiAgICB9XG4gIH1cblxuICBjb3BpYXJDYW1wb3MocmVnaXN0cm8pe1xuICAgIGxldCBub21icmUgPSByZWdpc3Ryby5hY3Rpdm8uYmFzZW5hbWU7XG4gICAgbGV0IG5vdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUocmVnaXN0cm8uYWN0aXZvKTtcbiAgICAgICAgLy8gVkVSSUZJQ0FDSU9OIERFIFBST1lFQ1RPUyBERSBRIFkgUFJPWUVDVE8gR1REXG4gICAgICAgIGlmIChub3RhLmZyb250bWF0dGVyPy50eXBlID09PSBcIlBRXCIpeyBcbiAgICAgICAgICAvLyBDVUFORE8gTEEgTk9UQSBBQ1RJVkEgRVMgVU4gUFEuXG4gICAgICAgICAgcmVnaXN0cm8ucHJveWVjdG9RID0gbm9tYnJlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgLy8gVkVSSUZJQ0FDSU9OIERFIFBST1lFQ1RPU0dURFxuICAgICAgICAgIC8vIEluaWNpYWxpemFtb3MgcmVnaXN0cm8ucHJveWVjdG9HVEQgY29uIHVuIHZhbG9yIHByZWRldGVybWluYWRvIGRlIGNhZGVuYSB2YWNcdTAwRURhXG4gICAgICAgICAgcmVnaXN0cm8ucHJveWVjdG9HVEQgPSBcIlwiO1xuICAgICAgICAgIC8vIFZlcmlmaWNhbW9zIHNpIG5vdGEucHJveWVjdG9HVEQgZXhpc3RlIHkgZXMgdW4gYXJyZWdsb1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQpKSB7XG4gICAgICAgICAgICAgIC8vIFNpIGVzIHVuIGFycmVnbG8sIGl0ZXJhbW9zIHNvYnJlIGNhZGEgZWxlbWVudG9cbiAgICAgICAgICAgICAgcmVnaXN0cm8ucHJveWVjdG9HVEQgPSBub3RhLmZyb250bWF0dGVyLnByb3llY3RvR1RELm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnRvLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURCkge1xuICAgICAgICAgICAgICAvLyBTaSBleGlzdGUgcGVybyBubyBlcyB1biBhcnJlZ2xvLCBhcGxpY2Ftb3MgZWwgcmVnZXggZGlyZWN0YW1lbnRlXG4gICAgICAgICAgICAgIHJlZ2lzdHJvLnByb3llY3RvR1REID0gbm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURC5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaSBub3RhLnByb3llY3RvR1REIG5vIGV4aXN0ZSwgcmVnaXN0cm8ucHJveWVjdG9HVEQgeWEgZXN0XHUwMEUxIGVzdGFibGVjaWRvIGVuIFwiXCIgcG9yIGRlZmVjdG9cbiAgICAgICAgICAvLyBPYnRlbmVyIFByb3llY3RvUSB5IFByb3llY3RvIEdURCBjdWFuZG8gbGEgbm90YSBlcyBQcm95ZWN0b0dURC5cbiAgICAgICAgICAgfSBlbHNlIGlmIChub3RhLmZyb250bWF0dGVyPy50eXBlID09PSBcIlBHVERcIil7XG4gICAgICAgICAgIFxuICAgICAgICAgICAvLyBDVUFORE8gTEEgTk9UQSBBQ1RJVkEgRVMgVU4gR1RELlxuICAgICAgICAgICAvLyBWRVJJRklDQUNJT04gREUgUFJPWUVDVE9TR1REXG4gICAgICAgICAgIHJlZ2lzdHJvLnByb3llY3RvR1REID0gW25vbWJyZV07XG5cbiAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURCkpIHtcbiAgICAgICAgICAgICAgIC8vIFNpIGVzIHVuIGFycmVnbG8sIHV0aWxpemFtb3MgY29uY2F0IHBhcmEgYVx1MDBGMWFkaXIgbG9zIGVsZW1lbnRvcyB5YSBwcm9jZXNhZG9zIGNvbiBlbCByZWdleCBhbCBhcnJlZ2xvIHJlZ2lzdHJvLnByb3llY3RvR1REXG4gICAgICAgICAgICAgICByZWdpc3Ryby5wcm95ZWN0b0dURCA9IHJlZ2lzdHJvLnByb3llY3RvR1RELmNvbmNhdChub3RhLmZyb250bWF0dGVyLnByb3llY3RvR1RELm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgICBlbGVtZW50by5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpKSk7XG4gICAgICAgICAgIH0gZWxzZSBpZiAobm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURCkge1xuICAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlIHBlcm8gbm8gZXMgdW4gYXJyZWdsbywgYXBsaWNhbW9zIGVsIHJlZ2V4IGRpcmVjdGFtZW50ZSB5IHVzYW1vcyBwdXNoIHBhcmEgYWdyZWdhcmxvIGEgcmVnaXN0cm8ucHJveWVjdG9HVERcbiAgICAgICAgICAgICAgIHJlZ2lzdHJvLnByb3llY3RvR1RELnB1c2gobm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURC5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBcbiAgICAgICAgICAgLy8gU2kgbm90YS5wcm95ZWN0b0dURCBubyBleGlzdGUsIHJlZ2lzdHJvLnByb3llY3RvR1REIHlhIGVzdFx1MDBFMSBlc3RhYmxlY2lkbyBlbiBcIlwiIHBvciBkZWZlY3RvXG4gICAgICAgICAgIHJlZ2lzdHJvLnByb3llY3RvUSA9IFwiXCI7XG4gICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9RKSkge1xuICAgICAgICAgICAgICAvLyBTaSBlcyB1biBhcnJlZ2xvLCBpdGVyYW1vcyBzb2JyZSBjYWRhIGVsZW1lbnRvXG4gICAgICAgICAgICAgIHJlZ2lzdHJvLnByb3llY3RvUSA9IG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9RLm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnRvLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm90YS5mcm9udG1hdHRlci5wcm95ZWN0b1EpIHtcbiAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlIHBlcm8gbm8gZXMgdW4gYXJyZWdsbywgYXBsaWNhbW9zIGVsIHJlZ2V4IGRpcmVjdGFtZW50ZVxuICAgICAgICAgICAgICByZWdpc3Ryby5wcm95ZWN0b1EgPSBub3RhLmZyb250bWF0dGVyLnByb3llY3RvUS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gT2J0ZW5lciBQcm95ZWN0b1EgeSBQcm95ZWN0byBHVEQgY3VhbmRvIGxhIG5vdGEgZXMgb3RyYSBjb3NhIHF1ZSBubyBlcyBwcm95ZWN0b1xuICAgICAgICAgICBlbHNle1xuXG4gICAgICAgICAgICAgIHJlZ2lzdHJvLnByb3llY3RvUSA9IFwiXCI7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGE/LmZyb250bWF0dGVyPy5wcm95ZWN0b1EpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTaSBlcyB1biBhcnJlZ2xvLCBpdGVyYW1vcyBzb2JyZSBjYWRhIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICByZWdpc3Ryby5wcm95ZWN0b1EgPSBub3RhLmZyb250bWF0dGVyLnByb3llY3RvUS5tYXAoZWxlbWVudG8gPT4gXG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobm90YT8uZnJvbnRtYXR0ZXI/LnByb3llY3RvUSkge1xuICAgICAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlIHBlcm8gbm8gZXMgdW4gYXJyZWdsbywgYXBsaWNhbW9zIGVsIHJlZ2V4IGRpcmVjdGFtZW50ZVxuICAgICAgICAgICAgICAgICAgcmVnaXN0cm8ucHJveWVjdG9RID0gbm90YS5mcm9udG1hdHRlci5wcm95ZWN0b1EucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlZ2lzdHJvLnByb3llY3RvR1REID0gXCJcIjtcbiAgICAgICAgICAgICAgLy8gVmVyaWZpY2Ftb3Mgc2kgbm90YS5wcm95ZWN0b0dURCBleGlzdGUgeSBlcyB1biBhcnJlZ2xvXG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGE/LmZyb250bWF0dGVyPy5wcm95ZWN0b0dURCkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNpIGVzIHVuIGFycmVnbG8sIGl0ZXJhbW9zIHNvYnJlIGNhZGEgZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgIHJlZ2lzdHJvLnByb3llY3RvR1REID0gbm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURC5tYXAoZWxlbWVudG8gPT4gXG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobm90YT8uZnJvbnRtYXR0ZXI/LnByb3llY3RvR1REKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTaSBleGlzdGUgcGVybyBubyBlcyB1biBhcnJlZ2xvLCBhcGxpY2Ftb3MgZWwgcmVnZXggZGlyZWN0YW1lbnRlXG4gICAgICAgICAgICAgICAgICByZWdpc3Ryby5wcm95ZWN0b0dURCA9IG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFZlcmlmaWNhbW9zIGFyZWFJbnRlcmVzIFxuICAgICAgICAgIHJlZ2lzdHJvLmFyZWFJbnRlcmVzID0gW107XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm90YT8uZnJvbnRtYXR0ZXI/LmFyZWFJbnRlcmVzKSkge1xuICAgICAgICAgICAgICAvLyBTaSBlcyB1biBhcnJlZ2xvLCBpdGVyYW1vcyBzb2JyZSBjYWRhIGVsZW1lbnRvIChleGNsdXllbmRvIGVsIHByaW1lciBlbGVtZW50byB5YSBhZ3JlZ2FkbyBxdWUgZXMgbm90YS50aXR1bG8pXG4gICAgICAgICAgICAgIC8vIHkgYXBsaWNhbW9zIGVsIHJlZ2V4IGEgY2FkYSBlbGVtZW50by4gTHVlZ28gY29uY2F0ZW5hbW9zIGNvbiBlbCBhcnJheSBleGlzdGVudGUuXG4gICAgICAgICAgICAgIHJlZ2lzdHJvLmFyZWFJbnRlcmVzID0gcmVnaXN0cm8uYXJlYUludGVyZXMuY29uY2F0KG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMubWFwKGVsZW1lbnRvID0+IFxuICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNpIG5vIGVzIHVuIGFycmVnbG8sIHJldmlzYW1vcyBzaSBub3RhLmZyb250bWF0dGVyLmFyZWFJbnRlcmVzIGV4aXN0ZVxuICAgICAgICAgICAgICBpZiAobm90YT8uZnJvbnRtYXR0ZXI/LmFyZWFJbnRlcmVzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTaSBleGlzdGUsIGFwbGljYW1vcyBlbCByZWdleCB5IGxvIGFcdTAwRjFhZGltb3MgY29tbyBzZWd1bmRvIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICByZWdpc3Ryby5hcmVhSW50ZXJlcy5wdXNoKG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVmVyaWZpY2Ftb3MgQXJlYVZpZGFcbiAgICAgICAgICByZWdpc3Ryby5hcmVhVmlkYSA9IFwiXCI7XG4gICAgICAgICAgaWYgKG5vdGE/LmZyb250bWF0dGVyPy5hcmVhVmlkYSkge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub3RhLmZyb250bWF0dGVyLmFyZWFWaWRhKSkge1xuICAgICAgICAgICAgICAgICAgLy8gRXMgdW4gYXJyZWdsbywgdXNhIGVsIHByaW1lciBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgcmVnaXN0cm8uYXJlYVZpZGEgPSBub3RhLmZyb250bWF0dGVyLmFyZWFWaWRhWzBdLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vdGEuZnJvbnRtYXR0ZXIuYXJlYVZpZGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBFcyB1biBzdHJpbmdcbiAgICAgICAgICAgICAgICAgIHJlZ2lzdHJvLmFyZWFWaWRhID0gbm90YS5mcm9udG1hdHRlci5hcmVhVmlkYS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm8gZXN0XHUwMEUxIGRlZmluaWRvIG8gZXN0XHUwMEUxIHZhY1x1MDBFRG9cbiAgICAgICAgICAgICAgcmVnaXN0cm8uYXJlYVZpZGEgPSBcIk5vIGVzIGRlIG5pbmdcdTAwRkFuIEFyZWEgZGUgVmlkYVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVnaXN0cm87XG4gIH1cblxuICBhc3luYyBlbmNvbnRyYXJUYXJlYXNQZW5kaWVudGVzKFxuICAgIGFwcDogQXBwXG4gICk6IFByb21pc2U8eyB0YXJlYTogc3RyaW5nOyBhcmNoaXZvOiBURmlsZSB9W10+IHtcbiAgICBsZXQgdGFyZWFzUGVuZGllbnRlczogeyB0YXJlYTogc3RyaW5nOyBhcmNoaXZvOiBURmlsZSB9W10gPSBbXTtcbiAgICBjb25zdCBhcmNoaXZvcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgY29uc3QgYXJjaGl2b3NSZWxldmFudGVzID0gYXJjaGl2b3MuZmlsdGVyKFxuICAgICAgKGFyY2hpdm86IHsgcGF0aDogc3RyaW5nIH0pID0+ICFhcmNoaXZvLnBhdGguaW5jbHVkZXMoXCJQbGFudGlsbGFzXCIpXG4gICAgKTtcblxuICAgIGZvciAoY29uc3QgYXJjaGl2byBvZiBhcmNoaXZvc1JlbGV2YW50ZXMpIHtcbiAgICAgIGNvbnN0IGNvbnRlbmlkbyA9IGF3YWl0IGFwcC52YXVsdC5yZWFkKGFyY2hpdm8pO1xuICAgICAgY29uc3QgY29pbmNpZGVuY2lhcyA9IGNvbnRlbmlkby5tYXRjaCgvXiAqLSBcXFtcXC9cXF0gLiovZ20pIHx8IFtdO1xuXG4gICAgICAvLyBQYXJhIGNhZGEgdGFyZWEgZW5jb250cmFkYSwgY3JlYSB1biBvYmpldG8gY29uIGxhIHRhcmVhIGxpbXBpYSB5IGVsIGFyY2hpdm8gYWN0dWFsLCB5IGxvIGFncmVnYSBhbCBhcnJlZ2xvXG4gICAgICBjb25zdCB0YXJlYXNDb25BcmNoaXZvID0gY29pbmNpZGVuY2lhcy5tYXAoKHRhcmVhOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZWE6IHRhcmVhLnRyaW0oKSwgYXJjaGl2bzogYXJjaGl2byB9O1xuICAgICAgfSk7XG4gICAgICB0YXJlYXNQZW5kaWVudGVzID0gdGFyZWFzUGVuZGllbnRlcy5jb25jYXQodGFyZWFzQ29uQXJjaGl2byk7XG4gICAgfVxuICAgIHJldHVybiB0YXJlYXNQZW5kaWVudGVzO1xuICB9XG5cbiAgYXN5bmMgZWxlZ2lyVGFyZWFQYXJhUmVnaXN0cm8oXG4gICAgYXBwOiBBcHAsXG4gICAgcmVnaXN0cm86IGFueSxcbiAgICB0YXJlYXNQZW5kaWVudGVzOiBhbnlcbiAgKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSBcIkVsaWdlIGxhIHRhcmVhIHF1ZSB2YXMgYSByZWdpc3RyYXIuXCI7XG5cbiAgICAvLyBNYXAgcGFyYSBleHRyYWVyIHkgbGltcGlhciBzb2xvIGxhcyB0YXJlYXNcbiAgICBsZXQgcHJvbWVzYXNMaW1waWFzID0gdGFyZWFzUGVuZGllbnRlcy5tYXAoKHRhcmVhT2JqOiB7IHRhcmVhOiBzdHJpbmcgfSkgPT5cbiAgICAgIHRoaXMubGltcGlhclRleHRvVGFyZWEodGFyZWFPYmoudGFyZWEpXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBFc3BlcmEgYSBxdWUgdG9kYXMgbGFzIHByb21lc2FzIGVuIHByb21lc2FzTGltcGlhcyBzZSByZXN1ZWx2YW5cbiAgICAgIGNvbnN0IHRhcmVhc0xpbXBpYXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9tZXNhc0xpbXBpYXMpO1xuXG4gICAgICAvLyBSZWNvbnN0cnVpciBsb3Mgb2JqZXRvcyBjb24gbGFzIHRhcmVhcyBsaW1waWFzIG1hbnRlbmllbmRvIGxhIHJlZmVyZW5jaWEgYWwgYXJjaGl2b1xuICAgICAgY29uc3QgdGFyZWFzTGltcGlhc0NvbkFyY2hpdm8gPSB0YXJlYXNQZW5kaWVudGVzLm1hcChcbiAgICAgICAgKHRhcmVhT2JqOiB7IGFyY2hpdm86IGFueSB9LCBpbmRleDogc3RyaW5nIHwgbnVtYmVyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmVhOiB0YXJlYXNMaW1waWFzW2luZGV4XSwgLy8gVGFyZWEgbGltcGlhXG4gICAgICAgICAgICBhcmNoaXZvOiB0YXJlYU9iai5hcmNoaXZvLCAvLyBSZWZlcmVuY2lhIGFsIGFyY2hpdm8gb3JpZ2luYWxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAvLyBFc3RhcyBkb3MgbFx1MDBFRG5lYXMgbWUgZ2VuZXJhbiB1biBhcnJlZ2xvIGRlIGluZGljZXMgcGFyYSBzdW1pbmlzdHJhciBlbCB2YWxvciBhbCBtb2RhbC5cbiAgICAgIGNvbnN0IGxvbmdpdHVkID0gdGFyZWFzTGltcGlhc0NvbkFyY2hpdm8ubGVuZ3RoO1xuICAgICAgY29uc3QgYXJyZWdsb0RlSW5kaWNlcyA9IEFycmF5LmZyb20oXG4gICAgICAgIHsgbGVuZ3RoOiBsb25naXR1ZCB9LFxuICAgICAgICAoXywgaW5kaWNlKSA9PiBpbmRpY2VcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG1vZGFsTWVudSA9IG5ldyBTZWxlY2Npb25Nb2RhbChcbiAgICAgICAgYXBwLFxuICAgICAgICB0YXJlYXNMaW1waWFzQ29uQXJjaGl2by5tYXAoKGI6IHsgdGFyZWE6IGFueSB9KSA9PiBiLnRhcmVhKSxcbiAgICAgICAgYXJyZWdsb0RlSW5kaWNlcyxcbiAgICAgICAgcGxhY2Vob2xkZXJcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBFc3BlcmEgYSBxdWUgZWwgdXN1YXJpbyBoYWdhIHVuYSBzZWxlY2NpXHUwMEYzbiBlbiBlbCBtb2RhbFxuICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gYXdhaXQgbW9kYWxNZW51Lm9wZW5BbmRBd2FpdFNlbGVjdGlvbigpO1xuXG4gICAgICAgIC8vIEFzZWdcdTAwRkFyYXRlIGRlIHF1ZSBsYSBzZWxlY2NpXHUwMEYzbiBjb3JyZXNwb25kYSBhbCBcdTAwRURuZGljZSBjb3JyZWN0byBlbiB0YXJlYXNMaW1waWFzQ29uQXJjaGl2b1xuICAgICAgICBjb25zdCBzZWxlY2Npb24gPSB0YXJlYXNMaW1waWFzQ29uQXJjaGl2b1tzZWxlY3RlZEluZGV4XTtcbiAgICAgICAgcmVnaXN0cm8udGl0dWxvID0gc2VsZWNjaW9uLnRhcmVhOyAvLyBvIGNcdTAwRjNtbyBoYXlhcyBkZWNpZGlkbyBtYW5lamFyIGxhIHNlbGVjY2lcdTAwRjNuIGxpbXBpYVxuICAgICAgICByZWdpc3Ryby5ub21icmUgPSBzZWxlY2Npb24uYXJjaGl2by5iYXNlbmFtZTtcbiAgICAgICAgcmVnaXN0cm8uc2lBc3VudG8gPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gRXN0ZSBibG9xdWUgY2F0Y2ggbWFuZWphIGVycm9yZXMgbyBjaWVycmUgZGVsIG1vZGFsIHNpbiBzZWxlY2NpXHUwMEYzblxuICAgICAgICByZWdpc3Ryby5kZXRlbmVyID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG8gbW9kYWwgY2VycmFkbyBzaW4gc2VsZWNjaVx1MDBGM246XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRXN0ZSBibG9xdWUgY2F0Y2ggbWFuZWphIGVycm9yZXMgZW4gbGEgbGltcGllemEgZGUgdGFyZWFzXG4gICAgICBjb25zb2xlLmVycm9yKFwiSHVibyB1biBlcnJvciBhbCBsaW1waWFyIGxhcyB0YXJlYXM6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBsaW1waWFyVGV4dG9UYXJlYSh0aXR1bG86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyBFbGltaW5hIHRvZG8gZGVzcHVcdTAwRTlzIGRlbCBwcmltZXIgc2FsdG8gZGUgbFx1MDBFRG5lYS5cbiAgICAgIGxldCB0ZXh0b0xpbXBpbyA9IHRpdHVsby5zcGxpdChcIlxcblwiKVswXTtcblxuICAgICAgLy8gRWxpbWluYSBsb3MgdGFncyBkZSBlc3RpbG8gTWFya2Rvd24uXG4gICAgICB0ZXh0b0xpbXBpbyA9IHRleHRvTGltcGlvLnJlcGxhY2UoLyNbXFx3LS9dKy9nLCBcIlwiKTtcblxuICAgICAgLy8gRWxpbWluYSBsb3MgY2FtcG9zIGRlIGVzdGlsbyBEYXRhdmlldy5cbiAgICAgIHRleHRvTGltcGlvID0gdGV4dG9MaW1waW8ucmVwbGFjZSgvXFxbXFx3Kzo6W15cXF1dK1xcXS9nLCBcIlwiKTtcblxuICAgICAgLy8gRWxpbWluYSBlbCBwYXRyXHUwMEYzbiBcIiAtIFsvXVwiIGFsIGluaWNpbyBkZSBsYSBjYWRlbmEsIGluY2x1eWVuZG8gcG9zaWJsZXMgZXNwYWNpb3MgYW50ZXMgbyBkZXNwdVx1MDBFOXMuXG4gICAgICB0ZXh0b0xpbXBpbyA9IHRleHRvTGltcGlvLnJlcGxhY2UoL15cXHMqLVxccypcXFtcXC9cXF1cXHMqLywgXCJcIik7XG5cbiAgICAgIC8vIFJlZW1wbGF6YSBjYXJhY3RlcmVzIG5vIHBlcm1pdGlkb3MgZW4gbm9tYnJlcyBkZSBhcmNoaXZvIGNvbiB1biBndWlvbiBiYWpvIG8gYWxnXHUwMEZBbiBvdHJvIGNhcmFjdGVyIHNlZ3Vyby5cbiAgICAgIGNvbnN0IGNhcmFjdGVyZXNOb1Blcm1pdGlkb3MgPSAvWzw+OlwiXFwvXFxcXHw/KlxceDAwLVxceDFGXS9nO1xuICAgICAgdGV4dG9MaW1waW8gPSB0ZXh0b0xpbXBpby5yZXBsYWNlKGNhcmFjdGVyZXNOb1Blcm1pdGlkb3MsIFwiX1wiKTtcblxuICAgICAgLy8gUmVlbXBsYXphIGVzcGFjaW9zIG1cdTAwRkFsdGlwbGVzIHBvciB1biBcdTAwRkFuaWNvIGVzcGFjaW8gcGFyYSBldml0YXIgbm9tYnJlcyBkZSBhcmNoaXZvIGV4Y2VzaXZhbWVudGUgbGFyZ29zLlxuICAgICAgdGV4dG9MaW1waW8gPSB0ZXh0b0xpbXBpby5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcblxuICAgICAgLy8gUmV0b3JuYSBlbCB0ZXh0byBsaW1waW8sIGFob3JhIGVudnVlbHRvIGVuIHVuYSBwcm9tZXNhLlxuICAgICAgcmVzb2x2ZSh0ZXh0b0xpbXBpby50cmltKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgY29uc3RydWlyTm9tYnJleUFsaWFzKHJlZ2lzdHJvOiBhbnksIGFwcDogQXBwKSB7XG4gICAgbGV0IG5vbWJyZUJhc2UgPSBgJHtyZWdpc3Ryby5mb2xkZXJ9L1JUIC0gJHtyZWdpc3Ryby5pZH1gO1xuXG4gICAgbGV0IGFsaWFzTGltcGlvID0gdGhpcy5saW1waWFyQWxpYXMocmVnaXN0cm8udGl0dWxvKTtcbiAgICBhbGlhc0xpbXBpbyA9XG4gICAgICBhbGlhc0xpbXBpby5sZW5ndGggPiAxOTUgPyBhbGlhc0xpbXBpby5zbGljZSgwLCAxOTUpIDogYWxpYXNMaW1waW87XG5cbiAgICBjb25zdCBhcmNoaXZvcyA9IGFwcC52YXVsdC5nZXRGaWxlcygpO1xuICAgIGxldCByZWdpc3Ryb3NDb25NaXNtb1RpdHVsbyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBhcmNoaXZvIG9mIGFyY2hpdm9zKSB7XG4gICAgICBpZiAoYXJjaGl2by5wYXRoLnN0YXJ0c1dpdGgocmVnaXN0cm8uZm9sZGVyKSkge1xuICAgICAgICAvLyBVc2Ftb3MgbWV0YWRhdGFDYWNoZSBwYXJhIG9idGVuZXIgbG9zIG1ldGFkYXRvcyBkZSBsYSBub3RhXG4gICAgICAgIGNvbnN0IG1ldGFkYXRvcyA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShhcmNoaXZvKTtcbiAgICAgICAgLy8gQXNlZ3VyYW1vcyBxdWUgbWV0YWRhdG9zLmZyb250bWF0dGVyIGNvbnRlbmdhIGxvcyBjYW1wb3MgbmVjZXNhcmlvc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbWV0YWRhdG9zICYmXG4gICAgICAgICAgbWV0YWRhdG9zLmZyb250bWF0dGVyICYmXG4gICAgICAgICAgbWV0YWRhdG9zLmZyb250bWF0dGVyLnRpdHVsbyA9PT0gcmVnaXN0cm8udGl0dWxvXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGlkU2VjID0gbWV0YWRhdG9zLmZyb250bWF0dGVyLmlkU2VjO1xuICAgICAgICAgIGlmIChpZFNlYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWdpc3Ryb3NDb25NaXNtb1RpdHVsby5wdXNoKHsgYXJjaGl2bywgaWRTZWMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnZ2VyO1xuICAgIC8vIE9yZGVuYW1vcyBsb3MgcmVzdWx0YWRvcyBwb3IgaWRTZWMgZW4gb3JkZW4gZGVzY2VuZGVudGVcbiAgICByZWdpc3Ryb3NDb25NaXNtb1RpdHVsby5zb3J0KChiKSA9PiBiLmlkU2VjLCBcImRlc2NcIik7XG5cbiAgICByZWdpc3Ryby5pZFNlYyA9XG4gICAgICByZWdpc3Ryb3NDb25NaXNtb1RpdHVsby5sZW5ndGggPiAwXG4gICAgICAgID8gcGFyc2VJbnQocmVnaXN0cm9zQ29uTWlzbW9UaXR1bG9bMF0uaWRTZWMpICsgMVxuICAgICAgICA6IDE7XG5cbiAgICBpZiAocmVnaXN0cm8uaWRTZWMgPiAxKSB7XG4gICAgICBhbGlhc0xpbXBpbyArPSBgIC0gJHtyZWdpc3Ryby5pZFNlY31gO1xuICAgIH1cblxuICAgIC8vIEluaWNpYWxpemEgcmVnaXN0cm8uYWxpYXNlcyBjb21vIHVuIGFycmVnbG8gdmFjXHUwMEVEb1xuICAgIHJlZ2lzdHJvLmFsaWFzZXMgPSBbXTtcblxuICAgIC8vIEFncmVnYSBlbCBhbGlhcyBsaW1waW8gY29uIGVsIHByZWZpam9cbiAgICByZWdpc3Ryby5hbGlhc2VzLnB1c2goYFJUIC0gJHthbGlhc0xpbXBpb31gKTtcblxuICAgIGlmIChyZWdpc3Ryby50aXBvUmVnaXN0cm8gPT09IFwiTm90YVwiKSB7XG4gICAgICAvLyBPYnRcdTAwRTluIGVsIGFyY2hpdm8gYWN0aXZvXG4gICAgICBjb25zdCBhcmNoaXZvQWN0aXZvID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICBpZiAoIWFyY2hpdm9BY3Rpdm8pIHJldHVybjsgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgcXVlIGhheWEgdW4gYXJjaGl2byBhY3Rpdm9cblxuICAgICAgLy8gT2J0XHUwMEU5biBsb3MgbWV0YWRhdG9zIGRlbCBhcmNoaXZvIGFjdGl2b1xuICAgICAgY29uc3QgbWV0YWRhdG9zQWN0aXZvID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGFyY2hpdm9BY3Rpdm8pO1xuXG4gICAgICAvLyBFeHRyYWUgYWxpYXNlcyBkZWwgZnJvbnRtYXR0ZXIsIGFzZWd1clx1MDBFMW5kb3RlIGRlIHF1ZSBleGlzdGFuIHkgYWNjZWRpZW5kbyBjb3JyZWN0YW1lbnRlXG4gICAgICBjb25zdCBhbGlhc2VzQWN0aXZvID1cbiAgICAgICAgbWV0YWRhdG9zQWN0aXZvICYmIG1ldGFkYXRvc0FjdGl2by5mcm9udG1hdHRlclxuICAgICAgICAgID8gbWV0YWRhdG9zQWN0aXZvLmZyb250bWF0dGVyLmFsaWFzZXNcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgLy8gVmVyaWZpY2Egc2kgYWxpYXNlc0FjdGl2byBleGlzdGUgeSBkZXRlcm1pbmEgc2kgZXMgdW4gYXJyZWdsbyBvIHVuYSBjYWRlbmFcbiAgICAgIGlmIChhbGlhc2VzQWN0aXZvKSB7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxBbGlhc2VzID0gQXJyYXkuaXNBcnJheShhbGlhc2VzQWN0aXZvKVxuICAgICAgICAgID8gYWxpYXNlc0FjdGl2b1xuICAgICAgICAgIDogW2FsaWFzZXNBY3Rpdm9dOyAvLyBDb252aWVydGUgYSBhcnJlZ2xvIHNpIGVzIHVuYSBjYWRlbmFcblxuICAgICAgICAvLyBBXHUwMEYxYWRlIGNhZGEgYWxpYXMgYWRpY2lvbmFsIGNvbiBlbCBwcmVmaWpvIFwiUlQgLSBcIlxuICAgICAgICBhZGRpdGlvbmFsQWxpYXNlcy5mb3JFYWNoKChhbGlhcykgPT4ge1xuICAgICAgICAgIHJlZ2lzdHJvLmFsaWFzZXMucHVzaChgUlQgLSAke2FsaWFzfWApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3Ryby5uYW1lRmlsZSA9IG5vbWJyZUJhc2U7XG4gIH1cblxuICBsaW1waWFyQWxpYXModGl0dWxvOiBzdHJpbmcpIHtcbiAgICAvLyBSZWVtcGxhemEgY2FyYWN0ZXJlcyBubyBwZXJtaXRpZG9zIGVuIG5vbWJyZXMgZGUgYXJjaGl2byBjb24gdW4gZ3Vpb24gYmFqbyBvIGFsZ1x1MDBGQW4gb3RybyBjYXJhY3RlciBzZWd1cm8uXG4gICAgY29uc3QgY2FyYWN0ZXJlc05vUGVybWl0aWRvcyA9IC9bPD46XCJcXC9cXFxcfD8qXFx4MDAtXFx4MUZdL2c7XG4gICAgbGV0IHRpdHVsb0xpbXBpbyA9IHRpdHVsby5yZXBsYWNlKGNhcmFjdGVyZXNOb1Blcm1pdGlkb3MsIFwiX1wiKTtcblxuICAgIC8vIFJlZW1wbGF6YSBlc3BhY2lvcyBtXHUwMEZBbHRpcGxlcyBwb3IgdW4gXHUwMEZBbmljbyBlc3BhY2lvIHBhcmEgZXZpdGFyIG5vbWJyZXMgZGUgYXJjaGl2byBleGNlc2l2YW1lbnRlIGxhcmdvcy5cbiAgICB0aXR1bG9MaW1waW8gPSB0aXR1bG9MaW1waW8ucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG5cbiAgICByZXR1cm4gdGl0dWxvTGltcGlvLnRyaW0oKTtcbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIFRGaWxlLCBURm9sZGVyLCBNb2RhbCwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHtTZWxlY2Npb25Nb2RhbH0gZnJvbSBcIi4uLy4uL21vZGFsZXMvc2VsZWNjaW9uTW9kYWxcIjtcbmltcG9ydCB7ZnV6enlTZWxlY3RPckNyZWF0ZX0gZnJvbSBcIi4uLy4uL21vZGFsZXMvZnV6enlTZWxlY3RPckNyZWF0ZVwiO1xuaW1wb3J0IHtEYXRlVGltZX0gZnJvbSAnbHV4b24nXG5cbmludGVyZmFjZSBHcnVwb0FjdGl2aWRhZCB7XG4gICAgZ3J1cG86IHN0cmluZztcbiAgICBhY3RpdmlkYWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIG1lbnVPdHJvIHtcbiAgICBcbiAgICBwYXRoQ2FtcG9zOiBzdHJpbmcgPSBcIkVzdHJ1Y3R1cmEvQ2FtcG9zIFNpc3RlbWEgR2VzdGlvbi9DYW1wb3MgUmVnaXN0cm8gVGllbXBvLm1kXCI7XG4gICAgc2VsZWN0ZWRBY3Rpdml0eTogc3RyaW5nID1cIlwiO1xuICAgIHNlbGVjdGVkR3JvdXA6IHN0cmluZyA9IFwiXCI7XG4gICAgcGx1Z2luOiBQbHVnaW47XG4gICAgXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBQbHVnaW4pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMuZnV6enlTZWxlY3RPckMgPSBuZXcgZnV6enlTZWxlY3RPckNyZWF0ZSh0aGlzLmFwcCwgcGx1Z2luKTtcbiAgICAgIH1cbiAgICBcbiAgICAgIGFzeW5jIG1lbnVPdHJvIChhcHA6IEFwcCwgcmVnaXN0cm86IGFueSl7XG4gICAgICAgIGNvbnN0IG9wY2lvbmVzT3RybyA9IFtcIlByb3BpYXNcIiwgXCJBcmVhcyBkZSBWaWRhXCIsIFwiQXJlYXMgZGUgSW50ZXJcdTAwRTlzXCIsIFwiUHJveWVjdG9zIGRlIFFcIiwgXCJQcm95ZWN0b3MgR1REXCIsIFwiVGVtYSBkZSBJbnRlclx1MDBFOXNcIiwgXCJSZWN1cnNvIFJlY3VycmVudGVcIl0gO1xuICAgICAgICBjb25zdCB2YWxvcmVzT3RybyA9IFtcImhhYlwiLCBcImFjdHNBVlwiLCBcImFjdHNBSVwiLCBcImFjdHNQUVwiLCBcImFjdHNQR1REXCIsIFwiYWN0c1RJXCIsIFwiYWN0c1JSXCJdO1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlck90cm8gPSBcIlx1MDBCRlF1ZSBjYXRlZ29yaWE/XCI7XG4gICAgICAgIGNvbnN0IG1vZGFsT3RybyA9IG5ldyBTZWxlY2Npb25Nb2RhbChhcHAsIG9wY2lvbmVzT3RybywgdmFsb3Jlc090cm8sIHBsYWNlaG9sZGVyT3Rybyk7XG4gICAgICAgIGxldCB0ZW1hT3Rybzp7Z3J1cG86c3RyaW5nO2FjdGl2aWRhZDpzdHJpbmcsbm9tYnJlOnN0cmluZ307XG4gICAgICAgIGxldCBzaUFzdW50bzogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uT3RybyA9IGF3YWl0IG1vZGFsT3Ryby5vcGVuQW5kQXdhaXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHN3aXRjaChzZWxlY3Rpb25PdHJvKSB7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYXNlIFwiaGFiXCI6XG4gICAgICAgICAgICAgICAgICAgIHRlbWFPdHJvID0gYXdhaXQgdGhpcy5oYWJpdHVhbChhcHApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWN0c0FWXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImFjdHNBSVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJhY3RzUFFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWN0c1BHVERcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWN0c1RJXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImFjdHNSUlwiOlxuICAgICAgICAgICAgICAgICAgICB0ZW1hT3RybyA9IGF3YWl0IHRoaXMuZWxlbVNHKGFwcCxzZWxlY3Rpb25PdHJvKTsgXG4gICAgICAgICAgICAgICAgICAgIHNpQXN1bnRvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJ1c1wiOlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG8gbW9kYWwgY2VycmFkbyBzaW4gc2VsZWNjaVx1MDBGM246XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJlZ2lzdHJvLmRldGVuZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgIHJldHVybiB7dGl0dWxvOiB0ZW1hT3Ryby5hY3RpdmlkYWQgKyBcIiAvIFwiICsgdGVtYU90cm8uZ3J1cG8sIHNpQXN1bnRvICxub21icmU6IHRlbWFPdHJvLmdydXBvLCBhcmVhVmlkYTogdGVtYU90cm8uZ3J1cG99XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBoYWJpdHVhbCAoYXBwOiBBcHApe1xuICAgICAgICAgICAgY29uc3QgZ3J1cG9zID0gYXdhaXQgdGhpcy5nZXRGcm9udG1hdHRlckZpZWxkKGFwcCx0aGlzLnBhdGhDYW1wb3MsIFwidGVtYXNcIik7XG4gICAgICAgICAgICBjb25zdCBhY3RzR3J1cG9zID0gYXdhaXQgdGhpcy5yZXN1bHRZYW1sKGFwcCxcImFjdHNUZW1hc1wiKVxuICAgICAgICAgICAgLy8gRmlsdHJhciB5IHByZXBhcmFyIGxhcyBhY3RpdmlkYWRlcyBleGlzdGVudGVzIHBhcmEgbGEgYlx1MDBGQXNxdWVkYVxuICAgICAgICAgICAgbGV0IGl0ZW1zRm9yU2VhcmNoID0gYWN0c0dydXBvc1xuICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gZ3J1cG9zLmluY2x1ZGVzKGl0ZW0uZ3J1cG8pKSAvLyBVc2EgbGEgcHJvcGllZGFkICdncnVwbycgZW4gbHVnYXIgZGUgaXRlbVswXVxuICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYCR7aXRlbS5hY3RpdmlkYWR9IC8gJHtpdGVtLmdydXBvfWAsIC8vIENhbWJpYSBlbCBvcmRlbiBzaSBlcyBuZWNlc2FyaW9cbiAgICAgICAgICAgICAgICBhY3Rpdml0eTogaXRlbS5hY3RpdmlkYWQsIC8vIFVzYSBsYSBwcm9waWVkYWQgJ2FjdGl2aWRhZCcgZW4gbHVnYXIgZGUgaXRlbVsxXVxuICAgICAgICAgICAgICAgIGdyb3VwOiBpdGVtLmdydXBvLFxuICAgICAgICAgICAgICAgIC8vIFVzYSBsYSBwcm9waWVkYWQgJ2dydXBvJyBlbiBsdWdhciBkZSBpdGVtWzBdXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsZXQgZWxlY2Npb24gPSBhd2FpdCB0aGlzLmZ1enp5U2VsZWN0T3JDLnNob3dGdXp6eVNlYXJjaE1vZGFsKGl0ZW1zRm9yU2VhcmNoLCBncnVwb3MpO1xuICAgICAgICAgICAgbGV0IG9iakVsZWNjaW9uID0ge2dydXBvOiBlbGVjY2lvblsxXSwgYWN0aXZpZGFkOiBlbGVjY2lvblswXSwgbm9tYnJlOiBcIlwifTtcbiAgICAgICAgICAgIHJldHVybiBvYmpFbGVjY2lvbjsgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIG5pbmd1bm8gKGFwcDogQXBwKXtcblxuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgIGVsZW1TRyAoYXBwOiBBcHAsIHRpcG8gOiBzdHJpbmcpOiBQcm9taXNlPGFueT57XG4gICAgICAgICAgICBjb25zdCBhY3RpdmlkYWRlcyA9IGF3YWl0IHRoaXMucmVzdWx0WWFtbChhcHAsIHRpcG8pXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVTRyA9IGF3YWl0IHRoaXMuZmluZE1haW5GaWxlc1dpdGhTdGF0ZShhcHAsdGlwbylcbiAgICAgICAgICAgIC8vIEV4dHJhZSBlbCBwcmltZXIgYWxpYXMgZGUgY2FkYSBub3RhIGVuY29udHJhZGEgeSBsb3MgYWxtYWNlbmEgZW4gdW4gYXJyYXlcbiAgICAgICAgICAgIGxldCBncm91cHM7XG4gICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIHN3aXRjaCAodGlwbyl7XG4gICAgICAgICAgICBjYXNlIFwiYWN0c0FWXCI6XG4gICAgICAgICAgICAgICAgZ3JvdXBzID0gYWN0aXZlU0cubWFwKHBhZ2UgPT4gcGFnZS5mcm9udG1hdHRlci5hcmVhVmlkYSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGdyb3VwcyA9IGFjdGl2ZVNHLm1hcChwYWdlID0+IHBhZ2UuZnJvbnRtYXR0ZXIuYWxpYXNlcyA/IHBhZ2UuZnJvbnRtYXR0ZXIuYWxpYXNlc1swXSA6IG51bGwpLmZpbHRlcihhbGlhcyA9PiBhbGlhcyAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZpbHRyYXIgeSBwcmVwYXJhciBsYXMgYWN0aXZpZGFkZXMgZXhpc3RlbnRlcyBwYXJhIGxhIGJcdTAwRkFzcXVlZGFcbiAgICAgICAgICAgIGxldCBpdGVtc0ZvclNlYXJjaCA9IGFjdGl2aWRhZGVzXG4gICAgICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBncm91cHMuaW5jbHVkZXMoaXRlbS5ncnVwbykpIC8vIFVzYSBsYSBwcm9waWVkYWQgJ2dydXBvJyBlbiBsdWdhciBkZSBpdGVtWzBdXG4gICAgICAgICAgICAubWFwKChpdGVtKSA9PiAoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtpdGVtLmFjdGl2aWRhZH0gLyAke2l0ZW0uZ3J1cG99YCwgLy8gQ2FtYmlhIGVsIG9yZGVuIHNpIGVzIG5lY2VzYXJpb1xuICAgICAgICAgICAgICAgIGFjdGl2aXR5OiBpdGVtLmFjdGl2aWRhZCwgLy8gVXNhIGxhIHByb3BpZWRhZCAnYWN0aXZpZGFkJyBlbiBsdWdhciBkZSBpdGVtWzFdXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGl0ZW0uZ3J1cG8sXG4gICAgICAgICAgICAgICAgLy8gVXNhIGxhIHByb3BpZWRhZCAnZ3J1cG8nIGVuIGx1Z2FyIGRlIGl0ZW1bMF1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIE1vc3RyYW1vcyBlbCBtb2RhbCBjb24gbGFzIG9wY2lvbmVzIGRlIGJcdTAwRkFzcXVlZGFcblxuICAgICAgICAgICAgbGV0IGVsZWNjaW9uID0gYXdhaXQgdGhpcy5mdXp6eVNlbGVjdE9yQy5zaG93RnV6enlTZWFyY2hNb2RhbChpdGVtc0ZvclNlYXJjaCwgZ3JvdXBzLCB0aXBvKTtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kRWxlbWVudCA9IGFjdGl2ZVNHLmZpbmQoYiA9PiBiLmZyb250bWF0dGVyLmFsaWFzZXNbMF0gPT09IGVsZWNjaW9uWzFdKTtcbiAgICAgICAgICAgIC8vIFNpIHNlIGVuY3VlbnRyYSBlbCBlbGVtZW50bywgZGV2b2x2ZXIgZnJvbnRtYXR0ZXIuYWxpYXNlc1sxXVxuICAgICAgICAgICAgbGV0IGFsaWFzID0gZm91bmRFbGVtZW50Py5maWxlLnBhdGg7XG4gICAgICAgICAgICBsZXQgb2JqRWxlY2Npb24gPSB7Z3J1cG86IGVsZWNjaW9uWzFdLCBhY3RpdmlkYWQ6IGVsZWNjaW9uWzBdLCBub21icmU6IGFsaWFzfTtcbiAgICAgICAgICAgIHJldHVybiBvYmpFbGVjY2lvbjsgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgYnVzY2FyIChhcHA6IEFwcCl7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jICByZXN1bHRZYW1sKGFwcDogQXBwLCB0ZW1hOiBzdHJpbmcpOiBQcm9taXNlPEdydXBvQWN0aXZpZGFkW10+IHtcbiAgICAgICAgICAgIC8vIEVuY3VlbnRyYSBlbCBhcmNoaXZvIHBvciBzdSBydXRhXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnBhdGhDYW1wb3MpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzYSBtZXRhZGF0YUNhY2hlIHBhcmEgb2J0ZW5lciBsb3MgbWV0YWRhdG9zIGRlbCBhcmNoaXZvXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY2VkZSBhbCBmcm9udCBtYXR0ZXIgKFlBTUwpIGRlbCBhcmNoaXZvIHkgb2J0aWVuZSBlbCBhcnJlZ2xvIGJhc2FkbyBlbiBlbCB0ZW1hXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmVnbG9SZXN1bHQgPSBtZXRhZGF0YT8uZnJvbnRtYXR0ZXI/Llt0ZW1hXSB8fCBbXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1eWUgZWwgYXJyZWdsbyBkZSBvYmpldG9zIHJlc3VsdGFkbyBiYXNhZG8gZW4gbGEgZXN0cnVjdHVyYSBkZSBHcnVwb0FjdGl2aWRhZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRhZG86IEdydXBvQWN0aXZpZGFkW10gPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWxsZW5hIGVsIGFycmVnbG8gY29uIGxvcyBkYXRvcyBkZWwgYXJyZWdsb1Jlc3VsdFxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJlZ2xvUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyZWdsb1Jlc3VsdC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pICYmIGl0ZW0ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0YWRvLnB1c2goeyBncnVwbzogaXRlbVswXSwgYWN0aXZpZGFkOiBpdGVtWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0YWRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9idGVuaWVuZG8gZWwgYXJjaGl2byBkZSBjYW1wb3M6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBBcXVcdTAwRUQgbWFuZWphclx1MDBFRGFzIGVsIGVycm9yIGNvbW8gc2VhIGFwcm9waWFkbyBwYXJhIHR1IGFwbGljYWNpXHUwMEYzblxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yOyAvLyBPIGRldm9sdmVyIHVuIGFycmVnbG8gdmFjXHUwMEVEbyBjb21vIHJlc3VsdGFkbyBkZSBlcnJvclxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXZ1ZWx2ZSB1biBhcnJlZ2xvIHZhY1x1MDBFRG8gc2kgbm8gc2UgZW5jdWVudHJhIGVsIGFyY2hpdm8gbyBzaSBvY3VycmUgY3VhbHF1aWVyIG90cm8gcHJvYmxlbWFcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGdldEZyb250bWF0dGVyRmllbGQoYXBwOiBBcHAsIGZpbGU6IHN0cmluZywgZmllbGQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRGaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlKTtcbiAgICAgICAgICAgICAgICBpZiAodEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSh0RmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gY2FjaGU/LmZyb250bWF0dGVyO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb250bWF0dGVyICYmIGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGZyb250bWF0dGVyW2ZpZWxkXTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGZpZWxkVmFsdWUgPT09IG51bGwgfHwgZmllbGRWYWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRWwgY2FtcG8gZXN0XHUwMEUxIHZhY1x1MDBFRG8gbyBubyBleGlzdGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBPIG1hbmVqYXIgc2VnXHUwMEZBbiBsbyBuZWNlc2l0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGcm9udG1hdHRlciBjb25zdWx0YWRvIGNvbiBcdTAwRTl4aXRvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlOyAvLyBEZXZ1ZWx2ZSBlbCB2YWxvciBkZWwgY2FtcG9cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRWwgY2FtcG8gbm8gZXhpc3RlIGVuIGVsIGZyb250bWF0dGVyLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBPIG1hbmVqYXIgc2VnXHUwMEZBbiBsbyBuZWNlc2l0ZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFbCBhcmNoaXZvIG5vIGV4aXN0ZSBvIG5vIGVzIHVuIGFyY2hpdm8gZGUgdGV4dG8uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gTyBtYW5lamFyIHNlZ1x1MDBGQW4gbG8gbmVjZXNpdGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGNvbnN1bHRhciBlbCBmcm9udG1hdHRlclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBPIG1hbmVqYXIgc2VnXHUwMEZBbiBsbyBuZWNlc2l0ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcblxuICAgICAgICAvLyBFc3RhIGZ1bmNpXHUwMEYzbiBlbmN1ZW50cmEgbG9zIGFyY2hpdm9zIGRlIHN1YnNpc3RlbWFzIHkgY3V5byBlc3RhZG8gZXMgXHVEODNEXHVERkUyXG4gICAgICAgIGFzeW5jIGZpbmRNYWluRmlsZXNXaXRoU3RhdGUoYXBwLCB0aXBvKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXNUaXBvID0ge1xuICAgICAgICAgICAgICAgIGFjdHNBVjoge1xuICAgICAgICAgICAgICAgICAgZm9sZGVyOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfQXJlYXNWaWRhLFxuICAgICAgICAgICAgICAgICAgc2FtZU5hbWU6IGZhbHNlLCBcbiAgICAgICAgICAgICAgICAgIG5hbWVGaWxlOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5uYW1lRmlsZV9BcmVhc1ZpZGFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdHNBSToge1xuICAgICAgICAgICAgICAgICAgICBmb2xkZXI6IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9BcmVhc0ludGVyZXMsXG4gICAgICAgICAgICAgICAgICAgIHNhbWVOYW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lRmlsZTogdGhpcy5wbHVnaW4uc2V0dGluZ3MubmFtZUZpbGVfQXJlYXNJbnRlcmVzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdHNQUToge1xuICAgICAgICAgICAgICAgICAgZm9sZGVyOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfUHJveWVjdG9zUSxcbiAgICAgICAgICAgICAgICAgIHNhbWVOYW1lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIG5hbWVGaWxlOiBcIlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhY3RzUEdURDoge1xuICAgICAgICAgICAgICAgICAgICBmb2xkZXI6IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9Qcm95ZWN0b3NHVEQsXG4gICAgICAgICAgICAgICAgICAgIHNhbWVOYW1lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZUZpbGU6IFwiXCJcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWN0c1RJOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9sZGVyOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfVGVtYXNJbnRlcmVzLFxuICAgICAgICAgICAgICAgICAgICAgIHNhbWVOYW1lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lRmlsZTogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdHNSUjoge1xuICAgICAgICAgICAgICAgICAgICBmb2xkZXI6IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9SZWN1cnNvc1JlY3VycmVudGVzLFxuICAgICAgICAgICAgICAgICAgICBzYW1lTmFtZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVGaWxlOiBcIlwiXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFB1ZWRlcyBjb250aW51YXIgYVx1MDBGMWFkaWVuZG8gbVx1MDBFMXMgY2Fzb3MgYXF1XHUwMEVEXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAvLyBBc2VnXHUwMEZBcmF0ZSBkZSBxdWUgdGlwbyBlcyB1bmEgcHJvcGllZGFkIHZcdTAwRTFsaWRhIGFudGVzIGRlIGRlc2VzdHJ1Y3R1cmFyXG4gICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgICBjb25zdCBhY3RpdmVGaWxlc1dpdGhGcm9udG1hdHRlciA9IFtdO1xuICAgICAgICAgICAgIHN3aXRjaCAodGlwbyl7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFjdHNBVlwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZvbGRlciwgc2FtZU5hbWUsIG5hbWVGaWxlIH0gPSBwcm9wZXJ0aWVzVGlwb1t0aXBvXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFob3JhID0gRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoXCJ5eXl5LVFxXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkuZmlsdGVyKGZpbGUgPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnBhdGguaW5jbHVkZXMoZm9sZGVyKSAmJiAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiUGxhbnRpbGxhc1wiKSAmJiBmaWxlLm5hbWUuc3RhcnRzV2l0aChhaG9yYSkpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhPy5lc3RhZG8gPT09IFwiXHVEODNEXHVERkUyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVGaWxlc1dpdGhGcm9udG1hdHRlci5wdXNoKHsgZmlsZTogZmlsZSwgZnJvbnRtYXR0ZXI6IG1ldGFkYXRhIH0pOyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzVGlwby5oYXNPd25Qcm9wZXJ0eSh0aXBvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmb2xkZXIsIHNhbWVOYW1lLCBuYW1lRmlsZSB9ID0gcHJvcGVydGllc1RpcG9bdGlwb107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlc0luRm9sZGVyID0gYXBwLnZhdWx0LmdldEZpbGVzKCkuZmlsdGVyKGZpbGUgPT4gZmlsZS5wYXRoLnN0YXJ0c1dpdGgoZm9sZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlc0luRm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzYW1lTmFtZSAmJiBmaWxlLmJhc2VuYW1lID09PSBuYW1lRmlsZSkgfHwgIXNhbWVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEuZnJvbnRtYXR0ZXIgJiYgbWV0YWRhdGEuZnJvbnRtYXR0ZXIuZXN0YWRvID09PSBcIlx1RDgzRFx1REZFMlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVGaWxlc1dpdGhGcm9udG1hdHRlci5wdXNoKHsgZmlsZTogZmlsZSwgZnJvbnRtYXR0ZXI6IG1ldGFkYXRhLmZyb250bWF0dGVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2VsZWNjaVx1MDBGM24gbm8gcmVjb25vY2lkYTpcIiwgdGlwbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107IC8vIE1hbmVqYXIgc2VnXHUwMEZBbiB0dSBsXHUwMEYzZ2ljYSBkZSBhcGxpY2FjaVx1MDBGM25cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZUZpbGVzV2l0aEZyb250bWF0dGVyO1xuICAgICAgICAgfVxuXG59XG4iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHtTZWxlY2Npb25Nb2RhbH0gZnJvbSBcIi4vc2VsZWNjaW9uTW9kYWxcIjtcblxuZXhwb3J0IGNsYXNzIGZ1enp5U2VsZWN0T3JDcmVhdGUge1xuICBhcHA6IEFwcDtcbiAgcGx1Z2luOiBQbHVnaW47XG4gIHBhdGhDYW1wb3M6IHN0cmluZyA9IFwiRXN0cnVjdHVyYS9DYW1wb3MgU2lzdGVtYSBHZXN0aW9uL0NhbXBvcyBSZWdpc3RybyBUaWVtcG8ubWRcIjtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBQbHVnaW4pIHtcbiAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgfVxuXG4gIGNyZWF0ZU1vZGFsKCkge1xuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImZ1enp5U2VhcmNoTW9kYWxcIik7XG4gICAgbW9kYWwuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgbW9kYWwuc3R5bGUudG9wID0gXCI1MCVcIjtcbiAgICBtb2RhbC5zdHlsZS5sZWZ0ID0gXCI1MCVcIjtcbiAgICBtb2RhbC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZSgtNTAlLCAtNTAlKVwiO1xuICAgIG1vZGFsLnN0eWxlLnpJbmRleCA9IFwiMTAwMFwiO1xuICAgIG1vZGFsLnN0eWxlLnBhZGRpbmcgPSBcIjIwcHhcIjtcbiAgICBtb2RhbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIndoaXRlXCI7XG4gICAgbW9kYWwuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgI2NjY1wiO1xuICAgIG1vZGFsLnN0eWxlLmJvcmRlclJhZGl1cyA9IFwiNXB4XCI7XG4gICAgbW9kYWwuc3R5bGUuYm94U2hhZG93ID0gXCIwIDRweCA2cHggcmdiYSgwLDAsMCwuMSlcIjtcbiAgICBtb2RhbC5zdHlsZS53aWR0aCA9IFwiMzAwcHhcIjtcbiAgXG4gICAgY29uc3QgY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGNsb3NlQnV0dG9uLnRleHRDb250ZW50ID0gXCJcdTAwRDdcIjtcbiAgICBjbG9zZUJ1dHRvbi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBjbG9zZUJ1dHRvbi5zdHlsZS50b3AgPSBcIjVweFwiO1xuICAgIGNsb3NlQnV0dG9uLnN0eWxlLnJpZ2h0ID0gXCI1cHhcIjtcbiAgICBjbG9zZUJ1dHRvbi5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIjtcbiAgICBjbG9zZUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kID0gXCJub25lXCI7XG4gICAgY2xvc2VCdXR0b24uc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgY2xvc2VCdXR0b24uc3R5bGUuZm9udFNpemUgPSBcIjE2cHhcIjtcbiAgICBjbG9zZUJ1dHRvbi5zdHlsZS5mb250V2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgY2xvc2VCdXR0b24uc3R5bGUucGFkZGluZyA9IFwiMHB4IDRweFwiO1xuICAgIGNsb3NlQnV0dG9uLnN0eWxlLmJvcmRlclJhZGl1cyA9IFwiMTBweFwiO1xuICAgIGNsb3NlQnV0dG9uLnN0eWxlLm91dGxpbmUgPSBcIm5vbmVcIjtcbiAgICBjbG9zZUJ1dHRvbi5zdHlsZS5ib3hTaGFkb3cgPSBcIm5vbmVcIjtcbiAgICBjbG9zZUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4gbW9kYWwucmVtb3ZlKCk7XG4gIFxuICAgIG1vZGFsLmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uKTtcbiAgICByZXR1cm4gbW9kYWw7XG4gIH1cblxuICBmaWx0ZXJJdGVtcyhxdWVyeTogc3RyaW5nLCBpdGVtczogYW55W10pIHtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtOiB7IHZhbHVlOiBzdHJpbmc7IH0pID0+XG4gICAgICBpdGVtLnZhbHVlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSlcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlWUFNTEZpZWxkcyh0aXBvOiBzdHJpbmcgfCBudW1iZXIsIHNlbGVjdGVkVmFsdWU6IGFueSwgc2VsZWN0ZWRHcm91cDogYW55KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVidWdnZXJcbiAgICAgICAgY29uc3QgZmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5wYXRoQ2FtcG9zKTtcbiAgICAgICAgYXdhaXQgYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCAoZnJvbnRtYXR0ZXI6IHsgW3g6IHN0cmluZ106IGFueVtdOyB9KSA9PiB7XG4gICAgICAgICAgICAvLyBBc3VtaWVuZG8gcXVlICdhY3RzVGVtYXMnIGVzIGVsIGNhbXBvIGEgbW9kaWZpY2FyXG4gICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIGxldCBjdXJyZW50QWN0cyA9IGZyb250bWF0dGVyW3RpcG9dIHx8IFtdO1xuICAgICAgICAgICAgbGV0IG5ld1ZhbHVlRm9yQWN0cyA9IFsuLi5jdXJyZW50QWN0cywgW3NlbGVjdGVkR3JvdXAsIHNlbGVjdGVkVmFsdWVdXTtcbiAgICAgICAgICAgIGZyb250bWF0dGVyW3RpcG9dID0gbmV3VmFsdWVGb3JBY3RzO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRnJvbnRtYXR0ZXIgYWN0dWFsaXphZG8gY29uIFx1MDBFOXhpdG9cIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgYWN0dWFsaXphciBlbCBmcm9udG1hdHRlclwiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgYXN5bmMgc2hvd0Z1enp5U2VhcmNoTW9kYWwoaXRlbXM6IGFueSwgZ3JvdXBzOiBhbnlbXSwgdGlwbzogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IHNlbGVjdGVkVmFsdWUgPSBcIlwiOyAvLyBWYXJpYWJsZSBwYXJhIGd1YXJkYXIgbGEgb3BjaVx1MDBGM24gc2VsZWNjaW9uYWRhIG8gaW5ncmVzYWRhIHBvciBlbCB1c3VhcmlvXG4gICAgICAgIGxldCBzZWxlY3RlZEdyb3VwID0gXCJcIjtcbiAgICAgICAgY29uc3QgbW9kYWwgPSB0aGlzLmNyZWF0ZU1vZGFsKCk7XG4gICAgICBcblxuICAgICAgICAvLyBDcmVhciB5IGNvbmZpZ3VyYXIgZWwgdFx1MDBFRHR1bG8gZGVsIG1vZGFsXG4gICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgyXCIpO1xuICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9IFwiQnVzY2EgbyBjcmVhIHR1IGFjdGl2aWRhZFwiO1xuICAgICAgICB0aXRsZS5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiOyAvLyBDZW50cmFyIGVsIHRcdTAwRUR0dWxvLCBhanVzdGEgbG9zIGVzdGlsb3Mgc2VnXHUwMEZBbiBzZWEgbmVjZXNhcmlvXG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKHRpdGxlKTtcblxuICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICBpbnB1dC5wbGFjZWhvbGRlciA9IFwiRXNjcmliZSB0dSBhY3RpdmlkYWQuLi5cIjtcbiAgICAgICAgLy8gRXN0YWJsZWNlIGVsIGFuY2hvIGRlbCBpbnB1dCBhIHVuIHBvcmNlbnRhamUgZGVsIGNvbnRlbmVkb3IgcGFyYSBoYWNlcmxvIG1cdTAwRTFzIGFuY2hvLlxuICAgICAgICBpbnB1dC5zdHlsZS53aWR0aCA9IFwiODAlXCI7XG4gICAgICAgIC8vIENlbnRyYXIgZWwgdGV4dG8gZGVudHJvIGRlbCBpbnB1dFxuICAgICAgICBpbnB1dC5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAvLyBDZW50cmFyIGVsIGlucHV0IGRlbnRybyBkZWwgbW9kYWwgKHNpIGVsIG1vZGFsIHRpZW5lIHVuIGRpc3BsYXkgZmxleClcbiAgICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgICAgICBtb2RhbC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW5cIjtcbiAgICAgICAgbW9kYWwuc3R5bGUuYWxpZ25JdGVtcyA9IFwiY2VudGVyXCI7XG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGlucHV0KTtcblxuXG4gICAgICAgIC8vIENyZWFyIHkgYWdyZWdhciB1biBlc3BhY2lvIGVudHJlIGVsIGlucHV0IHkgcmVzdWx0c0RpdlxuICAgICAgICBjb25zdCBzcGFjZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzcGFjZXIuc3R5bGUuaGVpZ2h0ID0gXCIxNnB4XCI7IC8vIEFqdXN0YSBlc3RhIGFsdHVyYSBzZWdcdTAwRkFuIG5lY2VzaXRlcyBwYXJhIGVsIGVzcGFjaW9cbiAgICAgICAgbW9kYWwuYXBwZW5kQ2hpbGQoc3BhY2VyKTtcbiAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHRzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgbW9kYWwuYXBwZW5kQ2hpbGQocmVzdWx0c0Rpdik7XG4gICAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUmVzdWx0c0Rpc3BsYXkoZmlsdGVyZWRSZXN1bHRzOiBhbnlbXSwgbWVudU90cm86IHRoaXMpIHtcbiAgICAgICAgICByZXN1bHRzRGl2LmlubmVySFRNTCA9IFwiXCI7IC8vIExpbXBpYXIgcmVzdWx0YWRvcyBwcmV2aW9zXG4gICAgICAgICAgZmlsdGVyZWRSZXN1bHRzLmZvckVhY2goKHJlc3VsdDogeyB2YWx1ZTogc3RyaW5nIHwgbnVsbDsgYWN0aXZpdHk6IHN0cmluZzsgZ3JvdXA6IHN0cmluZzsgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGRpdi50ZXh0Q29udGVudCA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAgICAgICAgIGRpdi5vbm1vdXNlb3ZlciA9ICgpID0+IChkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjZjBmMGYwXCIpO1xuICAgICAgICAgICAgZGl2Lm9ubW91c2VvdXQgPSAoKSA9PiAoZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwidHJhbnNwYXJlbnRcIik7XG4gICAgICAgICAgICBkaXYub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZSA9IHJlc3VsdC5hY3Rpdml0eTsgLy8gR3VhcmRhciBlbCB2YWxvciBzZWxlY2Npb25hZG9cbiAgICAgICAgICAgICAgc2VsZWN0ZWRHcm91cCA9IHJlc3VsdC5ncm91cDsgLy8gR3VhcmRhciBlbCBncnVwbyBzZWxlY2Npb25hZG9cbiAgICAgICAgICAgICAgLy9kaXNwbGF5U2VsZWN0ZWRWYWx1ZShzZWxlY3RlZFZhbHVlLCBzZWxlY3RlZEdyb3VwKTsgLy8gTW9zdHJhciBsYSBzZWxlY2NpXHUwMEYzbiBhbCB1c3VhcmlvXG4gICAgICAgICAgICAgIG1vZGFsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICByZXNvbHZlKFtzZWxlY3RlZFZhbHVlLCBzZWxlY3RlZEdyb3VwXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0c0Rpdi5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgIH0pO1xuICAgICAgXG4gICAgICAgICAgLy8gU2kgbm8gaGF5IHJlc3VsdGFkb3MgeSBlbCB1c3VhcmlvIGhhIGluZ3Jlc2FkbyB1biB0ZXh0bywgb2ZyZWNlciBsYSBjcmVhY2lcdTAwRjNuIGRlIHVuYSBudWV2YSBhY3RpdmlkYWRcbiAgICAgICAgICBpZiAoZmlsdGVyZWRSZXN1bHRzLmxlbmd0aCA9PT0gMCAmJiBpbnB1dC52YWx1ZS50cmltKCkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZU5ld0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjcmVhdGVOZXdEaXYudGV4dENvbnRlbnQgPSBgQ3JlYXIgbnVldmEgYWN0aXZpZGFkOiBcIiR7aW5wdXQudmFsdWV9XCJgO1xuICAgICAgICAgICAgY3JlYXRlTmV3RGl2LnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgICAgICAgY3JlYXRlTmV3RGl2LnN0eWxlLmNvbG9yID0gXCJibHVlXCI7XG4gICAgICAgICAgICBjcmVhdGVOZXdEaXYub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZSA9IGlucHV0LnZhbHVlOyAvLyBHdWFyZGFyIGxhIG51ZXZhIGFjdGl2aWRhZFxuICAgICAgICAgICAgICBkZWJ1Z2dlclxuICAgICAgICAgICAgICBpZiAodGlwbz09IHVuZGVmaW5lZCl7IHRpcG8gPSBcImFjdHNUZW1hc1wifVxuICAgICAgICAgICAgICBzZWxlY3RHcm91cEZvck5ld0FjdGl2aXR5KG1lbnVPdHJvLCB0aXBvKTsgLy8gUHJvY2VkZXIgYSBzZWxlY2Npb25hciB1biBncnVwb1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdHNEaXYuYXBwZW5kQ2hpbGQoY3JlYXRlTmV3RGl2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICBmdW5jdGlvbiBzZWxlY3RHcm91cEZvck5ld0FjdGl2aXR5KG1lbnVPdHJvOiB7IGVzUmVjdXJyZW50ZTogKGFyZzA6IHN0cmluZykgPT4gYW55OyB1cGRhdGVZQU1MRmllbGRzOiAoYXJnMDogYW55LCBhcmcxOiBzdHJpbmcsIGFyZzI6IHN0cmluZykgPT4gYW55OyB9LCB0aXBvOiBhbnkpIHtcbiAgICAgICAgICByZXN1bHRzRGl2LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgaW5wdXQucmVtb3ZlKCk7XG4gICAgICAgICAgc3BhY2VyLnJlbW92ZSgpO1xuICAgICAgICAgIHRpdGxlLnJlbW92ZSgpO1xuXG4gICAgICAgICAgY29uc3QgdGV4dG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICAgICAgICB0ZXh0by50ZXh0Q29udGVudCA9IGBWYW1vcyBhIGNyZWFyIGxhIGFjdGl2aWRhZDogXCIke3NlbGVjdGVkVmFsdWV9XCIuIFNlbGVjY2lvbmEgdW4gZ3J1cG86YDs7XG4gICAgICAgICAgdGV4dG8uc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjsgLy8gQ2VudHJhciBlbCB0XHUwMEVEdHVsbywgYWp1c3RhIGxvcyBlc3RpbG9zIHNlZ1x1MDBGQW4gc2VhIG5lY2VzYXJpb1xuICAgICAgICAgIHJlc3VsdHNEaXYuYXBwZW5kQ2hpbGQodGV4dG8pOyBcbiAgICAgIFxuICAgICAgICAgIGdyb3Vwcy5mb3JFYWNoKChncm91cDogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZ3JvdXBEaXYudGV4dENvbnRlbnQgPSBncm91cDtcbiAgICAgICAgICAgIGdyb3VwRGl2LnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgICAgICAgZ3JvdXBEaXYub25tb3VzZW92ZXIgPSAoKSA9PiAoZ3JvdXBEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjZjBmMGYwXCIpO1xuICAgICAgICAgICAgZ3JvdXBEaXYub25tb3VzZW91dCA9ICgpID0+IChncm91cERpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgICAgICAgZ3JvdXBEaXYub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRHcm91cCA9IGdyb3VwOyAvLyBHdWFyZGFyIGVsIGdydXBvIHNlbGVjY2lvbmFkb1xuICAgICAgICAgICAgICAvL2Rpc3BsYXlTZWxlY3RlZFZhbHVlKHNlbGVjdGVkVmFsdWUsIHNlbGVjdGVkR3JvdXApOyAvLyBNb3N0cmFyIGxhIGFjdGl2aWRhZCB5IGVsIGdydXBvIHNlbGVjY2lvbmFkb1xuICAgICAgICAgICAgICBtb2RhbC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgbGV0IHJlY3VycmVudGUgPSBhd2FpdCBtZW51T3Ryby5lc1JlY3VycmVudGUoc2VsZWN0ZWRWYWx1ZSlcbiAgICAgICAgICAgICAgaWYgKHJlY3VycmVudGUpe1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lbnVPdHJvLnVwZGF0ZVlBTUxGaWVsZHModGlwbywgc2VsZWN0ZWRWYWx1ZSwgc2VsZWN0ZWRHcm91cCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShbc2VsZWN0ZWRWYWx1ZSwgc2VsZWN0ZWRHcm91cF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdHNEaXYuYXBwZW5kQ2hpbGQoZ3JvdXBEaXYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBcbiAgICAgICAgZnVuY3Rpb24gZGlzcGxheVNlbGVjdGVkVmFsdWUoYWN0aXZpdHk6IGFueSwgZ3JvdXA6IGFueSkge1xuICAgICAgICAgIHJlc3VsdHNEaXYuaW5uZXJIVE1MID0gYFNlbGVjY2lvbmFkbzogJHthY3Rpdml0eX0gLyAke2dyb3VwfWA7XG4gICAgICAgICAgLy8gQXF1XHUwMEVEIHB1ZWRlcyBjZXJyYXIgZWwgbW9kYWwgbyBwZXJtaXRpciBhbCB1c3VhcmlvIGhhY2VyIG1cdTAwRTFzIGFjY2lvbmVzXG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICBpbnB1dC5vbmlucHV0ID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkSXRlbXMgPSB0aGlzLmZpbHRlckl0ZW1zKGlucHV0LnZhbHVlLCBpdGVtcyk7XG4gICAgICAgICAgdXBkYXRlUmVzdWx0c0Rpc3BsYXkoZmlsdGVyZWRJdGVtcywgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICBcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtb2RhbCk7XG4gICAgICAgXG4gICAgfSk7ICAgXG59XG5cbmFzeW5jIGVzUmVjdXJyZW50ZSh0YXJlYTpzdHJpbmcpOlByb21pc2U8Ym9vbGVhbj57XG4gIGNvbnN0IG9wY2lvbmVzID0gW1wiU2lcIixcIk5vXCJdIDtcbiAgY29uc3QgdmFsb3JlcyA9IFt0cnVlLGZhbHNlXTtcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSBgJHt0YXJlYX0gZXMgdGFyZWEgcmVjdXJyZW50ZT9gO1xuICBjb25zdCBtb2RhbCA9IG5ldyBTZWxlY2Npb25Nb2RhbChhcHAsIG9wY2lvbmVzLCB2YWxvcmVzLCBwbGFjZWhvbGRlcik7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IG1vZGFsLm9wZW5BbmRBd2FpdFNlbGVjdGlvbigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvIG1vZGFsIGNlcnJhZG8gc2luIHNlbGVjY2lcdTAwRjNuOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxufSIsICIvLyB0aGVzZSBhcmVuJ3QgcmVhbGx5IHByaXZhdGUsIGJ1dCBub3IgYXJlIHRoZXkgcmVhbGx5IHVzZWZ1bCB0byBkb2N1bWVudFxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEx1eG9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRGF0ZVRpbWVFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEYXRlVGltZTogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEludGVydmFsRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgSW50ZXJ2YWw6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREdXJhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIER1cmF0aW9uOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFVuaXRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih1bml0KSB7XG4gICAgc3VwZXIoYEludmFsaWQgdW5pdCAke3VuaXR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFpvbmVJc0Fic3RyYWN0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJab25lIGlzIGFuIGFic3RyYWN0IGNsYXNzXCIpO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IG4gPSBcIm51bWVyaWNcIixcbiAgcyA9IFwic2hvcnRcIixcbiAgbCA9IFwibG9uZ1wiO1xuXG5leHBvcnQgY29uc3QgREFURV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRF9XSVRIX1dFRUtEQVkgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NFQ09ORFMgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuIiwgImltcG9ydCB7IFpvbmVJc0Fic3RyYWN0RXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcblxuLyoqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFpvbmUge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2Ygem9uZVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhpcyB6b25lLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICBnZXQgaWFuYU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIG9mZnNldCBpcyBrbm93biB0byBiZSBmaXhlZCBmb3IgdGhlIHdob2xlIHllYXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIGNvbW1vbiBuYW1lIChzdWNoIGFzIEVTVCkgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXBcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBhZmZlY3QgdGhlIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5mb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uIEFjY2VwdHMgJ2xvbmcnIG9yICdzaG9ydCcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmxvY2FsZSAtIFdoYXQgbG9jYWxlIHRvIHJldHVybiB0aGUgb2Zmc2V0IG5hbWUgaW4uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIG9mZnNldE5hbWUodHMsIG9wdHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCdzIHZhbHVlIGFzIGEgc3RyaW5nXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgb2Zmc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBXaGF0IHN0eWxlIG9mIG9mZnNldCB0byByZXR1cm4uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRzICduYXJyb3cnLCAnc2hvcnQnLCBvciAndGVjaGllJy4gUmV0dXJuaW5nICcrNicsICcrMDY6MDAnLCBvciAnKzA2MDAnIHJlc3BlY3RpdmVseVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBvZmZzZXQgaW4gbWludXRlcyBmb3IgdGhpcyB6b25lIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBjb21wdXRlIHRoZSBvZmZzZXRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgZXF1YWwgdG8gYW5vdGhlciB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge1pvbmV9IG90aGVyWm9uZSAtIHRoZSB6b25lIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyB2YWxpZC5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IGZvcm1hdE9mZnNldCwgcGFyc2Vab25lSW5mbyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBzaW5nbGV0b24gPSBudWxsO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGxvY2FsIHpvbmUgZm9yIHRoaXMgSmF2YVNjcmlwdCBlbnZpcm9ubWVudC5cbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeXN0ZW1ab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGxvY2FsIHpvbmVcbiAgICogQHJldHVybiB7U3lzdGVtWm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgaW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IFN5c3RlbVpvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcInN5c3RlbVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSh0cywgeyBmb3JtYXQsIGxvY2FsZSB9KSB7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQodHMpIHtcbiAgICByZXR1cm4gLW5ldyBEYXRlKHRzKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJzeXN0ZW1cIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvLCBpc1VuZGVmaW5lZCwgb2JqVG9Mb2NhbFRTIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IGR0ZkNhY2hlID0ge307XG5mdW5jdGlvbiBtYWtlRFRGKHpvbmUpIHtcbiAgaWYgKCFkdGZDYWNoZVt6b25lXSkge1xuICAgIGR0ZkNhY2hlW3pvbmVdID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7XG4gICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgdGltZVpvbmU6IHpvbmUsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICBzZWNvbmQ6IFwiMi1kaWdpdFwiLFxuICAgICAgZXJhOiBcInNob3J0XCIsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGR0ZkNhY2hlW3pvbmVdO1xufVxuXG5jb25zdCB0eXBlVG9Qb3MgPSB7XG4gIHllYXI6IDAsXG4gIG1vbnRoOiAxLFxuICBkYXk6IDIsXG4gIGVyYTogMyxcbiAgaG91cjogNCxcbiAgbWludXRlOiA1LFxuICBzZWNvbmQ6IDYsXG59O1xuXG5mdW5jdGlvbiBoYWNreU9mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdChkYXRlKS5yZXBsYWNlKC9cXHUyMDBFL2csIFwiXCIpLFxuICAgIHBhcnNlZCA9IC8oXFxkKylcXC8oXFxkKylcXC8oXFxkKykgKEFEfEJDKSw/IChcXGQrKTooXFxkKyk6KFxcZCspLy5leGVjKGZvcm1hdHRlZCksXG4gICAgWywgZk1vbnRoLCBmRGF5LCBmWWVhciwgZmFkT3JCYywgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdID0gcGFyc2VkO1xuICByZXR1cm4gW2ZZZWFyLCBmTW9udGgsIGZEYXksIGZhZE9yQmMsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXTtcbn1cblxuZnVuY3Rpb24gcGFydHNPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXRUb1BhcnRzKGRhdGUpO1xuICBjb25zdCBmaWxsZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBmb3JtYXR0ZWRbaV07XG4gICAgY29uc3QgcG9zID0gdHlwZVRvUG9zW3R5cGVdO1xuXG4gICAgaWYgKHR5cGUgPT09IFwiZXJhXCIpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQocG9zKSkge1xuICAgICAgZmlsbGVkW3Bvc10gPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsbGVkO1xufVxuXG5sZXQgaWFuYVpvbmVDYWNoZSA9IHt9O1xuLyoqXG4gKiBBIHpvbmUgaWRlbnRpZmllZCBieSBhbiBJQU5BIGlkZW50aWZpZXIsIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElBTkFab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFpvbmUgbmFtZVxuICAgKiBAcmV0dXJuIHtJQU5BWm9uZX1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUobmFtZSkge1xuICAgIGlmICghaWFuYVpvbmVDYWNoZVtuYW1lXSkge1xuICAgICAgaWFuYVpvbmVDYWNoZVtuYW1lXSA9IG5ldyBJQU5BWm9uZShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGlhbmFab25lQ2FjaGVbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgbG9jYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBpYW5hWm9uZUNhY2hlID0ge307XG4gICAgZHRmQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBhIHZhbGlkIHNwZWNpZmllci4gVGhpcyBvbmx5IGNoZWNrcyB0aGUgc3RyaW5nJ3MgZm9ybWF0LCBub3QgdGhhdCB0aGUgc3BlY2lmaWVyIGlkZW50aWZpZXMgYSBrbm93biB6b25lOyBzZWUgaXNWYWxpZFpvbmUgZm9yIHRoYXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIHN0cmluZyB0byBjaGVjayB2YWxpZGl0eSBvblxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIHJldHVybnMgZmFsc2UgZm9yIHNvbWUgdmFsaWQgSUFOQSBuYW1lcy4gVXNlIGlzVmFsaWRab25lIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZFNwZWNpZmllcihzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFpvbmUocyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaWRlbnRpZmllcyBhIHJlYWwgem9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gem9uZSAtIFRoZSBzdHJpbmcgdG8gY2hlY2tcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkZhbnRhc2lhL0Nhc3RsZVwiKSAvLz0+IGZhbHNlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkWm9uZSh6b25lKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgdGltZVpvbmU6IHpvbmUgfSkuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMuem9uZU5hbWUgPSBuYW1lO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLnZhbGlkID0gSUFOQVpvbmUuaXNWYWxpZFpvbmUobmFtZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpYW5hXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUsIHRoaXMubmFtZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKTtcblxuICAgIGlmIChpc05hTihkYXRlKSkgcmV0dXJuIE5hTjtcblxuICAgIGNvbnN0IGR0ZiA9IG1ha2VEVEYodGhpcy5uYW1lKTtcbiAgICBsZXQgW3llYXIsIG1vbnRoLCBkYXksIGFkT3JCYywgaG91ciwgbWludXRlLCBzZWNvbmRdID0gZHRmLmZvcm1hdFRvUGFydHNcbiAgICAgID8gcGFydHNPZmZzZXQoZHRmLCBkYXRlKVxuICAgICAgOiBoYWNreU9mZnNldChkdGYsIGRhdGUpO1xuXG4gICAgaWYgKGFkT3JCYyA9PT0gXCJCQ1wiKSB7XG4gICAgICB5ZWFyID0gLU1hdGguYWJzKHllYXIpICsgMTtcbiAgICB9XG5cbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHVzaW5nIGhvdXIxMiBhbmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAyNTU2NCZjYW49MiZxPSUyMjI0JTNBMDAlMjIlMjBkYXRldGltZWZvcm1hdFxuICAgIGNvbnN0IGFkanVzdGVkSG91ciA9IGhvdXIgPT09IDI0ID8gMCA6IGhvdXI7XG5cbiAgICBjb25zdCBhc1VUQyA9IG9ialRvTG9jYWxUUyh7XG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXksXG4gICAgICBob3VyOiBhZGp1c3RlZEhvdXIsXG4gICAgICBtaW51dGUsXG4gICAgICBzZWNvbmQsXG4gICAgICBtaWxsaXNlY29uZDogMCxcbiAgICB9KTtcblxuICAgIGxldCBhc1RTID0gK2RhdGU7XG4gICAgY29uc3Qgb3ZlciA9IGFzVFMgJSAxMDAwO1xuICAgIGFzVFMgLT0gb3ZlciA+PSAwID8gb3ZlciA6IDEwMDAgKyBvdmVyO1xuICAgIHJldHVybiAoYXNVVEMgLSBhc1RTKSAvICg2MCAqIDEwMDApO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJpYW5hXCIgJiYgb3RoZXJab25lLm5hbWUgPT09IHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgaGFzTG9jYWxlV2Vla0luZm8sIGhhc1JlbGF0aXZlLCBwYWRTdGFydCwgcm91bmRUbywgdmFsaWRhdGVXZWVrU2V0dGluZ3MgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcblxuLy8gdG9kbyAtIHJlbWFwIGNhY2hpbmdcblxubGV0IGludGxMRkNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRMRihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsTEZDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTEZDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsRFRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkRFRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxEVENhY2hlW2tleV07XG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsRFRDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsTnVtQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZElORihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsTnVtQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTnVtQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgaW50bFJlbENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRSVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYXNlLCAuLi5jYWNoZUtleU9wdHMgfSA9IG9wdHM7IC8vIGV4Y2x1ZGUgYGJhc2VgIGZyb20gdGhlIG9wdGlvbnNcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgY2FjaGVLZXlPcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsUmVsQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsUmVsQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gc3lzdGVtTG9jYWxlKCkge1xuICBpZiAoc3lzTG9jYWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH1cbn1cblxubGV0IHdlZWtJbmZvQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZFdlZWtJbmZvKGxvY1N0cmluZykge1xuICBsZXQgZGF0YSA9IHdlZWtJbmZvQ2FjaGVbbG9jU3RyaW5nXTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgY29uc3QgbG9jYWxlID0gbmV3IEludGwuTG9jYWxlKGxvY1N0cmluZyk7XG4gICAgLy8gYnJvd3NlcnMgY3VycmVudGx5IGltcGxlbWVudCB0aGlzIGFzIGEgcHJvcGVydHksIGJ1dCBzcGVjIHNheXMgaXQgc2hvdWxkIGJlIGEgZ2V0dGVyIGZ1bmN0aW9uXG4gICAgZGF0YSA9IFwiZ2V0V2Vla0luZm9cIiBpbiBsb2NhbGUgPyBsb2NhbGUuZ2V0V2Vla0luZm8oKSA6IGxvY2FsZS53ZWVrSW5mbztcbiAgICB3ZWVrSW5mb0NhY2hlW2xvY1N0cmluZ10gPSBkYXRhO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxvY2FsZVN0cmluZyhsb2NhbGVTdHIpIHtcbiAgLy8gSSByZWFsbHkgd2FudCB0byBhdm9pZCB3cml0aW5nIGEgQkNQIDQ3IHBhcnNlclxuICAvLyBzZWUsIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9iY3AtNDdcbiAgLy8gSW5zdGVhZCwgd2UnbGwgZG8gdGhpczpcblxuICAvLyBhKSBpZiB0aGUgc3RyaW5nIGhhcyBubyAtdSBleHRlbnNpb25zLCBqdXN0IGxlYXZlIGl0IGFsb25lXG4gIC8vIGIpIGlmIGl0IGRvZXMsIHVzZSBJbnRsIHRvIHJlc29sdmUgZXZlcnl0aGluZ1xuICAvLyBjKSBpZiBJbnRsIGZhaWxzLCB0cnkgYWdhaW4gd2l0aG91dCB0aGUgLXVcblxuICAvLyBwcml2YXRlIHN1YnRhZ3MgYW5kIHVuaWNvZGUgc3VidGFncyBoYXZlIG9yZGVyaW5nIHJlcXVpcmVtZW50cyxcbiAgLy8gYW5kIHdlJ3JlIG5vdCBwcm9wZXJseSBwYXJzaW5nIHRoaXMsIHNvIGp1c3Qgc3RyaXAgb3V0IHRoZVxuICAvLyBwcml2YXRlIG9uZXMgaWYgdGhleSBleGlzdC5cbiAgY29uc3QgeEluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCIteC1cIik7XG4gIGlmICh4SW5kZXggIT09IC0xKSB7XG4gICAgbG9jYWxlU3RyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB4SW5kZXgpO1xuICB9XG5cbiAgY29uc3QgdUluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCItdS1cIik7XG4gIGlmICh1SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIFtsb2NhbGVTdHJdO1xuICB9IGVsc2Uge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGxldCBzZWxlY3RlZFN0cjtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihsb2NhbGVTdHIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgc2VsZWN0ZWRTdHIgPSBsb2NhbGVTdHI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3Qgc21hbGxlciA9IGxvY2FsZVN0ci5zdWJzdHJpbmcoMCwgdUluZGV4KTtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYoc21hbGxlcikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICBzZWxlY3RlZFN0ciA9IHNtYWxsZXI7XG4gICAgfVxuXG4gICAgY29uc3QgeyBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBbc2VsZWN0ZWRTdHIsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGxDb25maWdTdHJpbmcobG9jYWxlU3RyLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSB7XG4gIGlmIChvdXRwdXRDYWxlbmRhciB8fCBudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBpZiAoIWxvY2FsZVN0ci5pbmNsdWRlcyhcIi11LVwiKSkge1xuICAgICAgbG9jYWxlU3RyICs9IFwiLXVcIjtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICAgIGxvY2FsZVN0ciArPSBgLWNhLSR7b3V0cHV0Q2FsZW5kYXJ9YDtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1udS0ke251bWJlcmluZ1N5c3RlbX1gO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb2NhbGVTdHI7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwTW9udGhzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTI7IGkrKykge1xuICAgIGNvbnN0IGR0ID0gRGF0ZVRpbWUudXRjKDIwMDksIGksIDEpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbWFwV2Vla2RheXMoZikge1xuICBjb25zdCBtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSA3OyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMgKyBpKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIGxpc3RTdHVmZihsb2MsIGxlbmd0aCwgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgY29uc3QgbW9kZSA9IGxvYy5saXN0aW5nTW9kZSgpO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fFxuICAgICAgIWxvYy5sb2NhbGUgfHxcbiAgICAgIGxvYy5sb2NhbGUuc3RhcnRzV2l0aChcImVuXCIpIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2MuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIlxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlOdW1iZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBjb25zdCB7IHBhZFRvLCBmbG9vciwgLi4ub3RoZXJPcHRzIH0gPSBvcHRzO1xuXG4gICAgaWYgKCFmb3JjZVNpbXBsZSB8fCBPYmplY3Qua2V5cyhvdGhlck9wdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGludGxPcHRzID0geyB1c2VHcm91cGluZzogZmFsc2UsIC4uLm9wdHMgfTtcbiAgICAgIGlmIChvcHRzLnBhZFRvID4gMCkgaW50bE9wdHMubWluaW11bUludGVnZXJEaWdpdHMgPSBvcHRzLnBhZFRvO1xuICAgICAgdGhpcy5pbmYgPSBnZXRDYWNoZWRJTkYoaW50bCwgaW50bE9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChpKSB7XG4gICAgaWYgKHRoaXMuaW5mKSB7XG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogaTtcbiAgICAgIHJldHVybiB0aGlzLmluZi5mb3JtYXQoZml4ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0byBtYXRjaCB0aGUgYnJvd3NlcidzIG51bWJlcmZvcm1hdHRlciBkZWZhdWx0c1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IHJvdW5kVG8oaSwgMyk7XG4gICAgICByZXR1cm4gcGFkU3RhcnQoZml4ZWQsIHRoaXMucGFkVG8pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seURhdGVGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihkdCwgaW50bCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5vcmlnaW5hbFpvbmUgPSB1bmRlZmluZWQ7XG5cbiAgICBsZXQgeiA9IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5vcHRzLnRpbWVab25lKSB7XG4gICAgICAvLyBEb24ndCBhcHBseSBhbnkgd29ya2Fyb3VuZHMgaWYgYSB0aW1lWm9uZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIG9wdHNcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAvLyBVVEMtOCBvciBFdGMvVVRDLTggYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YSwgb25seSBFdGMvR01UKzggYW5kIHRoZSBsaWtlLlxuICAgICAgLy8gVGhhdCBpcyB3aHkgZml4ZWQtb2Zmc2V0IFRaIGlzIHNldCB0byB0aGF0IHVubGVzcyBpdCBpczpcbiAgICAgIC8vIDEuIFJlcHJlc2VudGluZyBvZmZzZXQgMCB3aGVuIFVUQyBpcyB1c2VkIHRvIG1haW50YWluIHByZXZpb3VzIGJlaGF2aW9yIGFuZCBkb2VzIG5vdCBiZWNvbWUgR01ULlxuICAgICAgLy8gMi4gVW5zdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXI6XG4gICAgICAvLyAgICAtIHNvbWUgZG8gbm90IHN1cHBvcnQgRXRjL1xuICAgICAgLy8gICAgLSA8IEV0Yy9HTVQtMTQsID4gRXRjL0dNVCsxMiwgYW5kIDMwLW1pbnV0ZSBvciA0NS1taW51dGUgb2Zmc2V0cyBhcmUgbm90IHBhcnQgb2YgdHpkYXRhXG4gICAgICBjb25zdCBnbXRPZmZzZXQgPSAtMSAqIChkdC5vZmZzZXQgLyA2MCk7XG4gICAgICBjb25zdCBvZmZzZXRaID0gZ210T2Zmc2V0ID49IDAgPyBgRXRjL0dNVCske2dtdE9mZnNldH1gIDogYEV0Yy9HTVQke2dtdE9mZnNldH1gO1xuICAgICAgaWYgKGR0Lm9mZnNldCAhPT0gMCAmJiBJQU5BWm9uZS5jcmVhdGUob2Zmc2V0WikudmFsaWQpIHtcbiAgICAgICAgeiA9IG9mZnNldFo7XG4gICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBhbGwgZml4ZWQtb2Zmc2V0IHpvbmVzIGxpa2UgRXRjLys0OjMwIGFyZSBwcmVzZW50IGluIHR6ZGF0YSBzb1xuICAgICAgICAvLyB3ZSBtYW51YWxseSBhcHBseSB0aGUgb2Zmc2V0IGFuZCBzdWJzdGl0dXRlIHRoZSB6b25lIGFzIG5lZWRlZC5cbiAgICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICAgIHRoaXMuZHQgPSBkdC5vZmZzZXQgPT09IDAgPyBkdCA6IGR0LnNldFpvbmUoXCJVVENcIikucGx1cyh7IG1pbnV0ZXM6IGR0Lm9mZnNldCB9KTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFpvbmUgPSBkdC56b25lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwiaWFuYVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB6ID0gZHQuem9uZS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDdXN0b20gem9uZXMgY2FuIGhhdmUgYW55IG9mZnNldCAvIG9mZnNldE5hbWUgc28gd2UganVzdCBtYW51YWxseVxuICAgICAgLy8gYXBwbHkgdGhlIG9mZnNldCBhbmQgc3Vic3RpdHV0ZSB0aGUgem9uZSBhcyBuZWVkZWQuXG4gICAgICB6ID0gXCJVVENcIjtcbiAgICAgIHRoaXMuZHQgPSBkdC5zZXRab25lKFwiVVRDXCIpLnBsdXMoeyBtaW51dGVzOiBkdC5vZmZzZXQgfSk7XG4gICAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IGR0LnpvbmU7XG4gICAgfVxuXG4gICAgY29uc3QgaW50bE9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGludGxPcHRzLnRpbWVab25lID0gaW50bE9wdHMudGltZVpvbmUgfHwgejtcbiAgICB0aGlzLmR0ZiA9IGdldENhY2hlZERURihpbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICBmb3JtYXQoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxab25lKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHRvIHN1YnN0aXR1dGUgaW4gdGhlIGFjdHVhbCB6b25lIG5hbWUsIHdlIGhhdmUgdG8gdXNlXG4gICAgICAvLyBmb3JtYXRUb1BhcnRzIHNvIHRoYXQgdGhlIHRpbWV6b25lIGNhbiBiZSByZXBsYWNlZC5cbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdFRvUGFydHMoKVxuICAgICAgICAubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKVxuICAgICAgICAuam9pbihcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZHRmLmZvcm1hdCh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cygpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuZHRmLmZvcm1hdFRvUGFydHModGhpcy5kdC50b0pTRGF0ZSgpKTtcbiAgICBpZiAodGhpcy5vcmlnaW5hbFpvbmUpIHtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0aW1lWm9uZU5hbWVcIikge1xuICAgICAgICAgIGNvbnN0IG9mZnNldE5hbWUgPSB0aGlzLm9yaWdpbmFsWm9uZS5vZmZzZXROYW1lKHRoaXMuZHQudHMsIHtcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5kdC5sb2NhbGUsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMub3B0cy50aW1lWm9uZU5hbWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnBhcnQsXG4gICAgICAgICAgICB2YWx1ZTogb2Zmc2V0TmFtZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmR0Zi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFBvbHlSZWxGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBpc0VuZ2xpc2gsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7IHN0eWxlOiBcImxvbmdcIiwgLi4ub3B0cyB9O1xuICAgIGlmICghaXNFbmdsaXNoICYmIGhhc1JlbGF0aXZlKCkpIHtcbiAgICAgIHRoaXMucnRmID0gZ2V0Q2FjaGVkUlRGKGludGwsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFbmdsaXNoLmZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgdGhpcy5vcHRzLm51bWVyaWMsIHRoaXMub3B0cy5zdHlsZSAhPT0gXCJsb25nXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBmYWxsYmFja1dlZWtTZXR0aW5ncyA9IHtcbiAgZmlyc3REYXk6IDEsXG4gIG1pbmltYWxEYXlzOiA0LFxuICB3ZWVrZW5kOiBbNiwgN10sXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxlIHtcbiAgc3RhdGljIGZyb21PcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgIG9wdHMubG9jYWxlLFxuICAgICAgb3B0cy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICBvcHRzLm91dHB1dENhbGVuZGFyLFxuICAgICAgb3B0cy53ZWVrU2V0dGluZ3MsXG4gICAgICBvcHRzLmRlZmF1bHRUb0VOXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyLCB3ZWVrU2V0dGluZ3MsIGRlZmF1bHRUb0VOID0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGVjaWZpZWRMb2NhbGUgPSBsb2NhbGUgfHwgU2V0dGluZ3MuZGVmYXVsdExvY2FsZTtcbiAgICAvLyB0aGUgc3lzdGVtIGxvY2FsZSBpcyB1c2VmdWwgZm9yIGh1bWFuIHJlYWRhYmxlIHN0cmluZ3MgYnV0IGFubm95aW5nIGZvciBwYXJzaW5nL2Zvcm1hdHRpbmcga25vd24gZm9ybWF0c1xuICAgIGNvbnN0IGxvY2FsZVIgPSBzcGVjaWZpZWRMb2NhbGUgfHwgKGRlZmF1bHRUb0VOID8gXCJlbi1VU1wiIDogc3lzdGVtTG9jYWxlKCkpO1xuICAgIGNvbnN0IG51bWJlcmluZ1N5c3RlbVIgPSBudW1iZXJpbmdTeXN0ZW0gfHwgU2V0dGluZ3MuZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgICBjb25zdCBvdXRwdXRDYWxlbmRhclIgPSBvdXRwdXRDYWxlbmRhciB8fCBTZXR0aW5ncy5kZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gICAgY29uc3Qgd2Vla1NldHRpbmdzUiA9IHZhbGlkYXRlV2Vla1NldHRpbmdzKHdlZWtTZXR0aW5ncykgfHwgU2V0dGluZ3MuZGVmYXVsdFdlZWtTZXR0aW5ncztcbiAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGVSLCBudW1iZXJpbmdTeXN0ZW1SLCBvdXRwdXRDYWxlbmRhclIsIHdlZWtTZXR0aW5nc1IsIHNwZWNpZmllZExvY2FsZSk7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUgPSB7fTtcbiAgICBpbnRsTnVtQ2FjaGUgPSB7fTtcbiAgICBpbnRsUmVsQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT2JqZWN0KHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyLCB3ZWVrU2V0dGluZ3MgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyLCB3ZWVrU2V0dGluZ3MpO1xuICB9XG5cbiAgY29uc3RydWN0b3IobG9jYWxlLCBudW1iZXJpbmcsIG91dHB1dENhbGVuZGFyLCB3ZWVrU2V0dGluZ3MsIHNwZWNpZmllZExvY2FsZSkge1xuICAgIGNvbnN0IFtwYXJzZWRMb2NhbGUsIHBhcnNlZE51bWJlcmluZ1N5c3RlbSwgcGFyc2VkT3V0cHV0Q2FsZW5kYXJdID0gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlKTtcblxuICAgIHRoaXMubG9jYWxlID0gcGFyc2VkTG9jYWxlO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nIHx8IHBhcnNlZE51bWJlcmluZ1N5c3RlbSB8fCBudWxsO1xuICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhciB8fCBwYXJzZWRPdXRwdXRDYWxlbmRhciB8fCBudWxsO1xuICAgIHRoaXMud2Vla1NldHRpbmdzID0gd2Vla1NldHRpbmdzO1xuICAgIHRoaXMuaW50bCA9IGludGxDb25maWdTdHJpbmcodGhpcy5sb2NhbGUsIHRoaXMubnVtYmVyaW5nU3lzdGVtLCB0aGlzLm91dHB1dENhbGVuZGFyKTtcblxuICAgIHRoaXMud2Vla2RheXNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1vbnRoc0NhY2hlID0geyBmb3JtYXQ6IHt9LCBzdGFuZGFsb25lOiB7fSB9O1xuICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5lcmFDYWNoZSA9IHt9O1xuXG4gICAgdGhpcy5zcGVjaWZpZWRMb2NhbGUgPSBzcGVjaWZpZWRMb2NhbGU7XG4gICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IG51bGw7XG4gIH1cblxuICBnZXQgZmFzdE51bWJlcnMoKSB7XG4gICAgaWYgKHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IHN1cHBvcnRzRmFzdE51bWJlcnModGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQ7XG4gIH1cblxuICBsaXN0aW5nTW9kZSgpIHtcbiAgICBjb25zdCBpc0FjdHVhbGx5RW4gPSB0aGlzLmlzRW5nbGlzaCgpO1xuICAgIGNvbnN0IGhhc05vV2VpcmRuZXNzID1cbiAgICAgICh0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gbnVsbCB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIpICYmXG4gICAgICAodGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gbnVsbCB8fCB0aGlzLm91dHB1dENhbGVuZGFyID09PSBcImdyZWdvcnlcIik7XG4gICAgcmV0dXJuIGlzQWN0dWFsbHlFbiAmJiBoYXNOb1dlaXJkbmVzcyA/IFwiZW5cIiA6IFwiaW50bFwiO1xuICB9XG5cbiAgY2xvbmUoYWx0cykge1xuICAgIGlmICghYWx0cyB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhbHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgICAgYWx0cy5sb2NhbGUgfHwgdGhpcy5zcGVjaWZpZWRMb2NhbGUsXG4gICAgICAgIGFsdHMubnVtYmVyaW5nU3lzdGVtIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBhbHRzLm91dHB1dENhbGVuZGFyIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIsXG4gICAgICAgIHZhbGlkYXRlV2Vla1NldHRpbmdzKGFsdHMud2Vla1NldHRpbmdzKSB8fCB0aGlzLndlZWtTZXR0aW5ncyxcbiAgICAgICAgYWx0cy5kZWZhdWx0VG9FTiB8fCBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZWRlZmF1bHRUb0VOKGFsdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKHsgLi4uYWx0cywgZGVmYXVsdFRvRU46IHRydWUgfSk7XG4gIH1cblxuICByZWRlZmF1bHRUb1N5c3RlbShhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiBmYWxzZSB9KTtcbiAgfVxuXG4gIG1vbnRocyhsZW5ndGgsIGZvcm1hdCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2gubW9udGhzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0ID8geyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0gOiB7IG1vbnRoOiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcE1vbnRocygoZHQpID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJtb250aFwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICB3ZWVrZGF5cyhsZW5ndGgsIGZvcm1hdCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2gud2Vla2RheXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSBmb3JtYXRcbiAgICAgICAgICA/IHsgd2Vla2RheTogbGVuZ3RoLCB5ZWFyOiBcIm51bWVyaWNcIiwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH1cbiAgICAgICAgICA6IHsgd2Vla2RheTogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwV2Vla2RheXMoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJ3ZWVrZGF5XCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIG1lcmlkaWVtcygpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKFxuICAgICAgdGhpcyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgICgpID0+IEVuZ2xpc2gubWVyaWRpZW1zLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBJbiB0aGVvcnkgdGhlcmUgY291bGQgYmUgYXJpYml0cmFyeSBkYXkgcGVyaW9kcy4gV2UncmUgZ29ubmEgYXNzdW1lIHRoZXJlIGFyZSBleGFjdGx5IHR3b1xuICAgICAgICAvLyBmb3IgQU0gYW5kIFBNLiBUaGlzIGlzIHByb2JhYmx5IHdyb25nLCBidXQgaXQncyBtYWtlcyBwYXJzaW5nIHdheSBlYXNpZXIuXG4gICAgICAgIGlmICghdGhpcy5tZXJpZGllbUNhY2hlKSB7XG4gICAgICAgICAgY29uc3QgaW50bCA9IHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9O1xuICAgICAgICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IFtEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzLCA5KSwgRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgMTkpXS5tYXAoXG4gICAgICAgICAgICAoZHQpID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJkYXlwZXJpb2RcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWVyaWRpZW1DYWNoZTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgZXJhcyhsZW5ndGgpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgRW5nbGlzaC5lcmFzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0geyBlcmE6IGxlbmd0aCB9O1xuXG4gICAgICAvLyBUaGlzIGlzIHByb2JsZW1hdGljLiBEaWZmZXJlbnQgY2FsZW5kYXJzIGFyZSBnb2luZyB0byBkZWZpbmUgZXJhcyB0b3RhbGx5IGRpZmZlcmVudGx5LiBXaGF0IEkgbmVlZCBpcyB0aGUgbWluaW11bSBzZXQgb2YgZGF0ZXNcbiAgICAgIC8vIHRvIGRlZmluaXRlbHkgZW51bWVyYXRlIHRoZW0uXG4gICAgICBpZiAoIXRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLmVyYUNhY2hlW2xlbmd0aF0gPSBbRGF0ZVRpbWUudXRjKC00MCwgMSwgMSksIERhdGVUaW1lLnV0YygyMDE3LCAxLCAxKV0ubWFwKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZXJhXCIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVyYUNhY2hlW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBleHRyYWN0KGR0LCBpbnRsT3B0cywgZmllbGQpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzKSxcbiAgICAgIHJlc3VsdHMgPSBkZi5mb3JtYXRUb1BhcnRzKCksXG4gICAgICBtYXRjaGluZyA9IHJlc3VsdHMuZmluZCgobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IGZpZWxkKTtcbiAgICByZXR1cm4gbWF0Y2hpbmcgPyBtYXRjaGluZy52YWx1ZSA6IG51bGw7XG4gIH1cblxuICBudW1iZXJGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgLy8gdGhpcyBmb3JjZXNpbXBsZSBvcHRpb24gaXMgbmV2ZXIgdXNlZCAodGhlIG9ubHkgY2FsbGVyIHNob3J0LWNpcmN1aXRzIG9uIGl0LCBidXQgaXQgc2VlbXMgc2FmZXIgdG8gbGVhdmUpXG4gICAgLy8gKGluIGNvbnRyYXN0LCB0aGUgcmVzdCBvZiB0aGUgY29uZGl0aW9uIGlzIHVzZWQgaGVhdmlseSlcbiAgICByZXR1cm4gbmV3IFBvbHlOdW1iZXJGb3JtYXR0ZXIodGhpcy5pbnRsLCBvcHRzLmZvcmNlU2ltcGxlIHx8IHRoaXMuZmFzdE51bWJlcnMsIG9wdHMpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlEYXRlRm9ybWF0dGVyKGR0LCB0aGlzLmludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIHJlbEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlSZWxGb3JtYXR0ZXIodGhpcy5pbnRsLCB0aGlzLmlzRW5nbGlzaCgpLCBvcHRzKTtcbiAgfVxuXG4gIGxpc3RGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIGdldENhY2hlZExGKHRoaXMuaW50bCwgb3B0cyk7XG4gIH1cblxuICBpc0VuZ2xpc2goKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBcImVuXCIgfHxcbiAgICAgIHRoaXMubG9jYWxlLnRvTG93ZXJDYXNlKCkgPT09IFwiZW4tdXNcIiB8fFxuICAgICAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5pbnRsKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGUuc3RhcnRzV2l0aChcImVuLXVzXCIpXG4gICAgKTtcbiAgfVxuXG4gIGdldFdlZWtTZXR0aW5ncygpIHtcbiAgICBpZiAodGhpcy53ZWVrU2V0dGluZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLndlZWtTZXR0aW5ncztcbiAgICB9IGVsc2UgaWYgKCFoYXNMb2NhbGVXZWVrSW5mbygpKSB7XG4gICAgICByZXR1cm4gZmFsbGJhY2tXZWVrU2V0dGluZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRDYWNoZWRXZWVrSW5mbyh0aGlzLmxvY2FsZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhcnRPZldlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2Vla1NldHRpbmdzKCkuZmlyc3REYXk7XG4gIH1cblxuICBnZXRNaW5EYXlzSW5GaXJzdFdlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2Vla1NldHRpbmdzKCkubWluaW1hbERheXM7XG4gIH1cblxuICBnZXRXZWVrZW5kRGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRXZWVrU2V0dGluZ3MoKS53ZWVrZW5kO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBvdGhlci5sb2NhbGUgJiZcbiAgICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBvdGhlci5udW1iZXJpbmdTeXN0ZW0gJiZcbiAgICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG90aGVyLm91dHB1dENhbGVuZGFyXG4gICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IGZvcm1hdE9mZnNldCwgc2lnbmVkT2Zmc2V0IH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogQSB6b25lIHdpdGggYSBmaXhlZCBvZmZzZXQgKG1lYW5pbmcgbm8gRFNUKVxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkT2Zmc2V0Wm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIFVUQ1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHV0Y0luc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBGaXhlZE9mZnNldFpvbmUoMCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGluIG1pbnV0ZXNcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGluc3RhbmNlKG9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgPT09IDAgPyBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2UgOiBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIGEgVVRDIG9mZnNldCBzdHJpbmcsIGxpa2UgXCJVVEMrNlwiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIG9mZnNldCBzdHJpbmcgdG8gcGFyc2VcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzA2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQy02OjAwXCIpXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBwYXJzZVNwZWNpZmllcihzKSB7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IHIgPSBzLm1hdGNoKC9edXRjKD86KFsrLV1cXGR7MSwyfSkoPzo6KFxcZHsyfSkpPyk/JC9pKTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRPZmZzZXRab25lKHNpZ25lZE9mZnNldChyWzFdLCByWzJdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob2Zmc2V0KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy5maXhlZCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImZpeGVkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZCA9PT0gMCA/IFwiVVRDXCIgOiBgVVRDJHtmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgfVxuXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICBpZiAodGhpcy5maXhlZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiRXRjL1VUQ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYEV0Yy9HTVQke2Zvcm1hdE9mZnNldCgtdGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiZml4ZWRcIiAmJiBvdGhlclpvbmUuZml4ZWQgPT09IHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwgImltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbi8qKlxuICogQSB6b25lIHRoYXQgZmFpbGVkIHRvIHBhcnNlLiBZb3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkWm9uZSBleHRlbmRzIFpvbmUge1xuICBjb25zdHJ1Y3Rvcih6b25lTmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqICBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuem9uZU5hbWUgPSB6b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImludmFsaWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IEludmFsaWRab25lIGZyb20gXCIuLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuXG5pbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNTdHJpbmcsIGlzTnVtYmVyIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4uL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIGRlZmF1bHRab25lKSB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChpc1VuZGVmaW5lZChpbnB1dCkgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFpvbmU7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBab25lKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlucHV0KSkge1xuICAgIGNvbnN0IGxvd2VyZWQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlcmVkID09PSBcImRlZmF1bHRcIikgcmV0dXJuIGRlZmF1bHRab25lO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwibG9jYWxcIiB8fCBsb3dlcmVkID09PSBcInN5c3RlbVwiKSByZXR1cm4gU3lzdGVtWm9uZS5pbnN0YW5jZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcInV0Y1wiIHx8IGxvd2VyZWQgPT09IFwiZ210XCIpIHJldHVybiBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgZWxzZSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKGxvd2VyZWQpIHx8IElBTkFab25lLmNyZWF0ZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmIFwib2Zmc2V0XCIgaW4gaW5wdXQgJiYgdHlwZW9mIGlucHV0Lm9mZnNldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gVGhpcyBpcyBkdW1iLCBidXQgdGhlIGluc3RhbmNlb2YgY2hlY2sgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHJlYWxseSB3b3JrXG4gICAgLy8gc28gd2UncmUgZHVjayBjaGVja2luZyBpdFxuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRab25lKGlucHV0KTtcbiAgfVxufVxuIiwgImltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuXG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVXZWVrU2V0dGluZ3MgfSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcblxubGV0IG5vdyA9ICgpID0+IERhdGUubm93KCksXG4gIGRlZmF1bHRab25lID0gXCJzeXN0ZW1cIixcbiAgZGVmYXVsdExvY2FsZSA9IG51bGwsXG4gIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudWxsLFxuICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBudWxsLFxuICB0d29EaWdpdEN1dG9mZlllYXIgPSA2MCxcbiAgdGhyb3dPbkludmFsaWQsXG4gIGRlZmF1bHRXZWVrU2V0dGluZ3MgPSBudWxsO1xuXG4vKipcbiAqIFNldHRpbmdzIGNvbnRhaW5zIHN0YXRpYyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgY29udHJvbCBMdXhvbidzIG92ZXJhbGwgYmVoYXZpb3IuIEx1eG9uIGlzIGEgc2ltcGxlIGxpYnJhcnkgd2l0aCBmZXcgb3B0aW9ucywgYnV0IHRoZSBvbmVzIGl0IGRvZXMgaGF2ZSBsaXZlIGhlcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldHRpbmdzIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgbm93KCkge1xuICAgIHJldHVybiBub3c7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXIsIHdoaWNoIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYW4gRXBvY2ggbWlsbGlzZWNvbmQgY291bnRcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiBEYXRlLm5vdygpICsgMzAwMCAvLyBwcmV0ZW5kIGl0IGlzIDMgc2Vjb25kcyBpbiB0aGUgZnV0dXJlXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IDAgLy8gYWx3YXlzIHByZXRlbmQgaXQncyBKYW4gMSwgMTk3MCBhdCBtaWRuaWdodCBpbiBVVEMgdGltZVxuICAgKi9cbiAgc3RhdGljIHNldCBub3cobikge1xuICAgIG5vdyA9IG47XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSB0byBjcmVhdGUgRGF0ZVRpbWVzIGluLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBVc2UgdGhlIHZhbHVlIFwic3lzdGVtXCIgdG8gcmVzZXQgdGhpcyB2YWx1ZSB0byB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0Wm9uZSh6b25lKSB7XG4gICAgZGVmYXVsdFpvbmUgPSB6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgb2JqZWN0IGN1cnJlbnRseSB1c2VkIHRvIGNyZWF0ZSBEYXRlVGltZXMuIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUgKHRoZSBvbmUgc2V0IG9uIHRoZSBtYWNoaW5lIHRoYXQgcnVucyB0aGlzIGNvZGUpLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdFpvbmUoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoZGVmYXVsdFpvbmUsIFN5c3RlbVpvbmUuaW5zdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TG9jYWxlKCkge1xuICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TG9jYWxlKGxvY2FsZSkge1xuICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbShudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKG91dHB1dENhbGVuZGFyKSB7XG4gICAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gV2Vla1NldHRpbmdzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXJzdERheVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluaW1hbERheXNcbiAgICogQHByb3BlcnR5IHtudW1iZXJbXX0gd2Vla2VuZFxuICAgKi9cblxuICAvKipcbiAgICogQHJldHVybiB7V2Vla1NldHRpbmdzfG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRXZWVrU2V0dGluZ3MoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXZWVrU2V0dGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgbG9jYWxlIHdlZWsgc2V0dGluZ3MsIGkuZS4gdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLCB0aGUgd2Vla2VuZCBhbmRcbiAgICogaG93IG1hbnkgZGF5cyBhcmUgcmVxdWlyZWQgaW4gdGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyLlxuICAgKiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlZWtTZXR0aW5nc3xudWxsfSB3ZWVrU2V0dGluZ3NcbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdFdlZWtTZXR0aW5ncyh3ZWVrU2V0dGluZ3MpIHtcbiAgICBkZWZhdWx0V2Vla1NldHRpbmdzID0gdmFsaWRhdGVXZWVrU2V0dGluZ3Mod2Vla1NldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1dG9mZiB5ZWFyIGFmdGVyIHdoaWNoIGEgc3RyaW5nIGVuY29kaW5nIGEgeWVhciBhcyB0d28gZGlnaXRzIGlzIGludGVycHJldGVkIHRvIG9jY3VyIGluIHRoZSBjdXJyZW50IGNlbnR1cnkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHR3b0RpZ2l0Q3V0b2ZmWWVhcigpIHtcbiAgICByZXR1cm4gdHdvRGlnaXRDdXRvZmZZZWFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3V0b2ZmIHllYXIgYWZ0ZXIgd2hpY2ggYSBzdHJpbmcgZW5jb2RpbmcgYSB5ZWFyIGFzIHR3byBkaWdpdHMgaXMgaW50ZXJwcmV0ZWQgdG8gb2NjdXIgaW4gdGhlIGN1cnJlbnQgY2VudHVyeS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMCAvLyBjdXQtb2ZmIHllYXIgaXMgMCwgc28gYWxsICd5eScgYXJlIGludGVycHJldGVkIGFzIGN1cnJlbnQgY2VudHVyeVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSA1MCAvLyAnNDknIC0+IDE5NDk7ICc1MCcgLT4gMjA1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAxOTUwIC8vIGludGVycHJldGVkIGFzIDUwXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDIwNTAgLy8gQUxTTyBpbnRlcnByZXRlZCBhcyA1MFxuICAgKi9cbiAgc3RhdGljIHNldCB0d29EaWdpdEN1dG9mZlllYXIoY3V0b2ZmWWVhcikge1xuICAgIHR3b0RpZ2l0Q3V0b2ZmWWVhciA9IGN1dG9mZlllYXIgJSAxMDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCB0aHJvd09uSW52YWxpZCgpIHtcbiAgICByZXR1cm4gdGhyb3dPbkludmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgTHV4b24gd2lsbCB0aHJvdyB3aGVuIGl0IGVuY291bnRlcnMgaW52YWxpZCBEYXRlVGltZXMsIER1cmF0aW9ucywgb3IgSW50ZXJ2YWxzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldCB0aHJvd09uSW52YWxpZCh0KSB7XG4gICAgdGhyb3dPbkludmFsaWQgPSB0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IEx1eG9uJ3MgZ2xvYmFsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGVzKCkge1xuICAgIExvY2FsZS5yZXNldENhY2hlKCk7XG4gICAgSUFOQVpvbmUucmVzZXRDYWNoZSgpO1xuICB9XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZCB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb247XG4gIH1cblxuICB0b01lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGFuYXRpb24pIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnJlYXNvbn06ICR7dGhpcy5leHBsYW5hdGlvbn1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgaW50ZWdlckJldHdlZW4sXG4gIGlzTGVhcFllYXIsXG4gIHRpbWVPYmplY3QsXG4gIGRheXNJblllYXIsXG4gIGRheXNJbk1vbnRoLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIGlzSW50ZWdlcixcbiAgaXNVbmRlZmluZWQsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ludmFsaWQuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBub25MZWFwTGFkZGVyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XSxcbiAgbGVhcExhZGRlciA9IFswLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNV07XG5cbmZ1bmN0aW9uIHVuaXRPdXRPZlJhbmdlKHVuaXQsIHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcbiAgICBcInVuaXQgb3V0IG9mIHJhbmdlXCIsXG4gICAgYHlvdSBzcGVjaWZpZWQgJHt2YWx1ZX0gKG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9KSBhcyBhICR7dW5pdH0sIHdoaWNoIGlzIGludmFsaWRgXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkge1xuICBjb25zdCBkID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXkpKTtcblxuICBpZiAoeWVhciA8IDEwMCAmJiB5ZWFyID49IDApIHtcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDApO1xuICB9XG5cbiAgY29uc3QganMgPSBkLmdldFVUQ0RheSgpO1xuXG4gIHJldHVybiBqcyA9PT0gMCA/IDcgOiBqcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSkge1xuICByZXR1cm4gZGF5ICsgKGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcilbbW9udGggLSAxXTtcbn1cblxuZnVuY3Rpb24gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKSB7XG4gIGNvbnN0IHRhYmxlID0gaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyLFxuICAgIG1vbnRoMCA9IHRhYmxlLmZpbmRJbmRleCgoaSkgPT4gaSA8IG9yZGluYWwpLFxuICAgIGRheSA9IG9yZGluYWwgLSB0YWJsZVttb250aDBdO1xuICByZXR1cm4geyBtb250aDogbW9udGgwICsgMSwgZGF5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc29XZWVrZGF5VG9Mb2NhbChpc29XZWVrZGF5LCBzdGFydE9mV2Vlaykge1xuICByZXR1cm4gKChpc29XZWVrZGF5IC0gc3RhcnRPZldlZWsgKyA3KSAlIDcpICsgMTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub1dlZWsoZ3JlZ09iaiwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ09iaixcbiAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSksXG4gICAgd2Vla2RheSA9IGlzb1dlZWtkYXlUb0xvY2FsKGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSwgc3RhcnRPZldlZWspO1xuXG4gIGxldCB3ZWVrTnVtYmVyID0gTWF0aC5mbG9vcigob3JkaW5hbCAtIHdlZWtkYXkgKyAxNCAtIG1pbkRheXNJbkZpcnN0V2VlaykgLyA3KSxcbiAgICB3ZWVrWWVhcjtcblxuICBpZiAod2Vla051bWJlciA8IDEpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgLSAxO1xuICAgIHdlZWtOdW1iZXIgPSB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICB9IGVsc2UgaWYgKHdlZWtOdW1iZXIgPiB3ZWVrc0luV2Vla1llYXIoeWVhciwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaykpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgKyAxO1xuICAgIHdlZWtOdW1iZXIgPSAxO1xuICB9IGVsc2Uge1xuICAgIHdlZWtZZWFyID0geWVhcjtcbiAgfVxuXG4gIHJldHVybiB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5LCAuLi50aW1lT2JqZWN0KGdyZWdPYmopIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrVG9HcmVnb3JpYW4od2Vla0RhdGEsIG1pbkRheXNJbkZpcnN0V2VlayA9IDQsIHN0YXJ0T2ZXZWVrID0gMSkge1xuICBjb25zdCB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5IH0gPSB3ZWVrRGF0YSxcbiAgICB3ZWVrZGF5T2ZKYW40ID0gaXNvV2Vla2RheVRvTG9jYWwoZGF5T2ZXZWVrKHdlZWtZZWFyLCAxLCBtaW5EYXlzSW5GaXJzdFdlZWspLCBzdGFydE9mV2VlayksXG4gICAgeWVhckluRGF5cyA9IGRheXNJblllYXIod2Vla1llYXIpO1xuXG4gIGxldCBvcmRpbmFsID0gd2Vla051bWJlciAqIDcgKyB3ZWVrZGF5IC0gd2Vla2RheU9mSmFuNCAtIDcgKyBtaW5EYXlzSW5GaXJzdFdlZWssXG4gICAgeWVhcjtcblxuICBpZiAob3JkaW5hbCA8IDEpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgLSAxO1xuICAgIG9yZGluYWwgKz0gZGF5c0luWWVhcih5ZWFyKTtcbiAgfSBlbHNlIGlmIChvcmRpbmFsID4geWVhckluRGF5cykge1xuICAgIHllYXIgPSB3ZWVrWWVhciArIDE7XG4gICAgb3JkaW5hbCAtPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIHtcbiAgICB5ZWFyID0gd2Vla1llYXI7XG4gIH1cblxuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qod2Vla0RhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub09yZGluYWwoZ3JlZ0RhdGEpIHtcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBncmVnRGF0YTtcbiAgY29uc3Qgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpO1xuICByZXR1cm4geyB5ZWFyLCBvcmRpbmFsLCAuLi50aW1lT2JqZWN0KGdyZWdEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkaW5hbFRvR3JlZ29yaWFuKG9yZGluYWxEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgb3JkaW5hbCB9ID0gb3JkaW5hbERhdGE7XG4gIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKTtcbiAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgLi4udGltZU9iamVjdChvcmRpbmFsRGF0YSkgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBsb2NhbCB3ZWVrIHVuaXRzIGxpa2UgbG9jYWxXZWVrZGF5IGFyZSB1c2VkIGluIG9iai5cbiAqIElmIHNvLCB2YWxpZGF0ZXMgdGhhdCB0aGV5IGFyZSBub3QgbWl4ZWQgd2l0aCBJU08gd2VlayB1bml0cyBhbmQgdGhlbiBjb3BpZXMgdGhlbSB0byB0aGUgbm9ybWFsIHdlZWsgdW5pdCBwcm9wZXJ0aWVzLlxuICogTW9kaWZpZXMgb2JqIGluLXBsYWNlIVxuICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlc0xvY2FsV2Vla1ZhbHVlcyhvYmosIGxvYykge1xuICBjb25zdCBoYXNMb2NhbGVXZWVrRGF0YSA9XG4gICAgIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtkYXkpIHx8XG4gICAgIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtOdW1iZXIpIHx8XG4gICAgIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtZZWFyKTtcbiAgaWYgKGhhc0xvY2FsZVdlZWtEYXRhKSB7XG4gICAgY29uc3QgaGFzSXNvV2Vla0RhdGEgPVxuICAgICAgIWlzVW5kZWZpbmVkKG9iai53ZWVrZGF5KSB8fCAhaXNVbmRlZmluZWQob2JqLndlZWtOdW1iZXIpIHx8ICFpc1VuZGVmaW5lZChvYmoud2Vla1llYXIpO1xuXG4gICAgaWYgKGhhc0lzb1dlZWtEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IG1peCBsb2NhbGUtYmFzZWQgd2VlayBmaWVsZHMgd2l0aCBJU08tYmFzZWQgd2VlayBmaWVsZHNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChvYmoubG9jYWxXZWVrZGF5KSkgb2JqLndlZWtkYXkgPSBvYmoubG9jYWxXZWVrZGF5O1xuICAgIGlmICghaXNVbmRlZmluZWQob2JqLmxvY2FsV2Vla051bWJlcikpIG9iai53ZWVrTnVtYmVyID0gb2JqLmxvY2FsV2Vla051bWJlcjtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKG9iai5sb2NhbFdlZWtZZWFyKSkgb2JqLndlZWtZZWFyID0gb2JqLmxvY2FsV2Vla1llYXI7XG4gICAgZGVsZXRlIG9iai5sb2NhbFdlZWtkYXk7XG4gICAgZGVsZXRlIG9iai5sb2NhbFdlZWtOdW1iZXI7XG4gICAgZGVsZXRlIG9iai5sb2NhbFdlZWtZZWFyO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5EYXlzSW5GaXJzdFdlZWs6IGxvYy5nZXRNaW5EYXlzSW5GaXJzdFdlZWsoKSxcbiAgICAgIHN0YXJ0T2ZXZWVrOiBsb2MuZ2V0U3RhcnRPZldlZWsoKSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IG1pbkRheXNJbkZpcnN0V2VlazogNCwgc3RhcnRPZldlZWs6IDEgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFdlZWtEYXRhKG9iaiwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoud2Vla1llYXIpLFxuICAgIHZhbGlkV2VlayA9IGludGVnZXJCZXR3ZWVuKFxuICAgICAgb2JqLndlZWtOdW1iZXIsXG4gICAgICAxLFxuICAgICAgd2Vla3NJbldlZWtZZWFyKG9iai53ZWVrWWVhciwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaylcbiAgICApLFxuICAgIHZhbGlkV2Vla2RheSA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrZGF5LCAxLCA3KTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtZZWFyXCIsIG9iai53ZWVrWWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vlaykge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtcIiwgb2JqLndlZWtOdW1iZXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWtkYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrZGF5XCIsIG9iai53ZWVrZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRPcmRpbmFsRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE9yZGluYWwgPSBpbnRlZ2VyQmV0d2VlbihvYmoub3JkaW5hbCwgMSwgZGF5c0luWWVhcihvYmoueWVhcikpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkT3JkaW5hbCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm9yZGluYWxcIiwgb2JqLm9yZGluYWwpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRNb250aCA9IGludGVnZXJCZXR3ZWVuKG9iai5tb250aCwgMSwgMTIpLFxuICAgIHZhbGlkRGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLmRheSwgMSwgZGF5c0luTW9udGgob2JqLnllYXIsIG9iai5tb250aCkpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTW9udGgpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtb250aFwiLCBvYmoubW9udGgpO1xuICB9IGVsc2UgaWYgKCF2YWxpZERheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImRheVwiLCBvYmouZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRUaW1lRGF0YShvYmopIHtcbiAgY29uc3QgeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSA9IG9iajtcbiAgY29uc3QgdmFsaWRIb3VyID1cbiAgICAgIGludGVnZXJCZXR3ZWVuKGhvdXIsIDAsIDIzKSB8fFxuICAgICAgKGhvdXIgPT09IDI0ICYmIG1pbnV0ZSA9PT0gMCAmJiBzZWNvbmQgPT09IDAgJiYgbWlsbGlzZWNvbmQgPT09IDApLFxuICAgIHZhbGlkTWludXRlID0gaW50ZWdlckJldHdlZW4obWludXRlLCAwLCA1OSksXG4gICAgdmFsaWRTZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihzZWNvbmQsIDAsIDU5KSxcbiAgICB2YWxpZE1pbGxpc2Vjb25kID0gaW50ZWdlckJldHdlZW4obWlsbGlzZWNvbmQsIDAsIDk5OSk7XG5cbiAgaWYgKCF2YWxpZEhvdXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJob3VyXCIsIGhvdXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbnV0ZSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbnV0ZVwiLCBtaW51dGUpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInNlY29uZFwiLCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbGxpc2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWlsbGlzZWNvbmRcIiwgbWlsbGlzZWNvbmQpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuIiwgIi8qXG4gIFRoaXMgaXMganVzdCBhIGp1bmsgZHJhd2VyLCBjb250YWluaW5nIGFueXRoaW5nIHVzZWQgYWNyb3NzIG11bHRpcGxlIGNsYXNzZXMuXG4gIEJlY2F1c2UgTHV4b24gaXMgc21hbGwoaXNoKSwgdGhpcyBzaG91bGQgc3RheSBzbWFsbCBhbmQgd2Ugd29uJ3Qgd29ycnkgYWJvdXQgc3BsaXR0aW5nXG4gIGl0IHVwIGludG8sIHNheSwgcGFyc2luZ1V0aWwuanMgYW5kIGJhc2ljVXRpbC5qcyBhbmQgc28gb24uIEJ1dCB0aGV5IGFyZSBkaXZpZGVkIHVwIGJ5IGZlYXR1cmUgYXJlYS5cbiovXG5cbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IHsgZGF5T2ZXZWVrLCBpc29XZWVrZGF5VG9Mb2NhbCB9IGZyb20gXCIuL2NvbnZlcnNpb25zLmpzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG4vLyBUWVBFU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwidW5kZWZpbmVkXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJudW1iZXJcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcihvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJudW1iZXJcIiAmJiBvICUgMSA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInN0cmluZ1wiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG59XG5cbi8vIENBUEFCSUxJVElFU1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzUmVsYXRpdmUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnRsICE9PSBcInVuZGVmaW5lZFwiICYmICEhSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0xvY2FsZVdlZWtJbmZvKCkge1xuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgISFJbnRsLkxvY2FsZSAmJlxuICAgICAgKFwid2Vla0luZm9cIiBpbiBJbnRsLkxvY2FsZS5wcm90b3R5cGUgfHwgXCJnZXRXZWVrSW5mb1wiIGluIEludGwuTG9jYWxlLnByb3RvdHlwZSlcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIE9CSkVDVFMgQU5EIEFSUkFZU1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBcnJheSh0aGluZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZykgPyB0aGluZyA6IFt0aGluZ107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZXN0QnkoYXJyLCBieSwgY29tcGFyZSkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGJlc3QsIG5leHQpID0+IHtcbiAgICBjb25zdCBwYWlyID0gW2J5KG5leHQpLCBuZXh0XTtcbiAgICBpZiAoIWJlc3QpIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyZShiZXN0WzBdLCBwYWlyWzBdKSA9PT0gYmVzdFswXSkge1xuICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH1cbiAgfSwgbnVsbClbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGEsIGspID0+IHtcbiAgICBhW2tdID0gb2JqW2tdO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVXZWVrU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJXZWVrIHNldHRpbmdzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgICFpbnRlZ2VyQmV0d2VlbihzZXR0aW5ncy5maXJzdERheSwgMSwgNykgfHxcbiAgICAgICFpbnRlZ2VyQmV0d2VlbihzZXR0aW5ncy5taW5pbWFsRGF5cywgMSwgNykgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHNldHRpbmdzLndlZWtlbmQpIHx8XG4gICAgICBzZXR0aW5ncy53ZWVrZW5kLnNvbWUoKHYpID0+ICFpbnRlZ2VyQmV0d2Vlbih2LCAxLCA3KSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIkludmFsaWQgd2VlayBzZXR0aW5nc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0RGF5OiBzZXR0aW5ncy5maXJzdERheSxcbiAgICAgIG1pbmltYWxEYXlzOiBzZXR0aW5ncy5taW5pbWFsRGF5cyxcbiAgICAgIHdlZWtlbmQ6IEFycmF5LmZyb20oc2V0dGluZ3Mud2Vla2VuZCksXG4gICAgfTtcbiAgfVxufVxuXG4vLyBOVU1CRVJTIEFORCBTVFJJTkdTXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyQmV0d2Vlbih0aGluZywgYm90dG9tLCB0b3ApIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih0aGluZykgJiYgdGhpbmcgPj0gYm90dG9tICYmIHRoaW5nIDw9IHRvcDtcbn1cblxuLy8geCAlIG4gYnV0IHRha2VzIHRoZSBzaWduIG9mIG4gaW5zdGVhZCBvZiB4XG5leHBvcnQgZnVuY3Rpb24gZmxvb3JNb2QoeCwgbikge1xuICByZXR1cm4geCAtIG4gKiBNYXRoLmZsb29yKHggLyBuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZFN0YXJ0KGlucHV0LCBuID0gMikge1xuICBjb25zdCBpc05lZyA9IGlucHV0IDwgMDtcbiAgbGV0IHBhZGRlZDtcbiAgaWYgKGlzTmVnKSB7XG4gICAgcGFkZGVkID0gXCItXCIgKyAoXCJcIiArIC1pbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhZGRlZCA9IChcIlwiICsgaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfVxuICByZXR1cm4gcGFkZGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXRpbmcoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWlsbGlzKGZyYWN0aW9uKSB7XG4gIC8vIFJldHVybiB1bmRlZmluZWQgKGluc3RlYWQgb2YgMCkgaW4gdGhlc2UgY2FzZXMsIHdoZXJlIGZyYWN0aW9uIGlzIG5vdCBzZXRcbiAgaWYgKGlzVW5kZWZpbmVkKGZyYWN0aW9uKSB8fCBmcmFjdGlvbiA9PT0gbnVsbCB8fCBmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgdG93YXJkWmVybyA9IGZhbHNlKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRpZ2l0cyxcbiAgICByb3VuZGVyID0gdG93YXJkWmVybyA/IE1hdGgudHJ1bmMgOiBNYXRoLnJvdW5kO1xuICByZXR1cm4gcm91bmRlcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuXG4vLyBEQVRFIEJBU0lDU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIGNvbnN0IG1vZE1vbnRoID0gZmxvb3JNb2QobW9udGggLSAxLCAxMikgKyAxLFxuICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBsb2NhbCB0aW1lc3RhbXAgKGVwb2NoLCBidXQgd2l0aCB0aGUgb2Zmc2V0IGJha2VkIGluKVxuZXhwb3J0IGZ1bmN0aW9uIG9ialRvTG9jYWxUUyhvYmopIHtcbiAgbGV0IGQgPSBEYXRlLlVUQyhcbiAgICBvYmoueWVhcixcbiAgICBvYmoubW9udGggLSAxLFxuICAgIG9iai5kYXksXG4gICAgb2JqLmhvdXIsXG4gICAgb2JqLm1pbnV0ZSxcbiAgICBvYmouc2Vjb25kLFxuICAgIG9iai5taWxsaXNlY29uZFxuICApO1xuXG4gIC8vIGZvciBsZWdhY3kgcmVhc29ucywgeWVhcnMgYmV0d2VlbiAwIGFuZCA5OSBhcmUgaW50ZXJwcmV0ZWQgYXMgMTlYWDsgcmV2ZXJ0IHRoYXRcbiAgaWYgKG9iai55ZWFyIDwgMTAwICYmIG9iai55ZWFyID49IDApIHtcbiAgICBkID0gbmV3IERhdGUoZCk7XG4gICAgLy8gc2V0IHRoZSBtb250aCBhbmQgZGF5IGFnYWluLCB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHllYXIgMjAwMCBpcyBhIGxlYXAgeWVhciwgYnV0IHllYXIgMTAwIGlzIG5vdFxuICAgIC8vIHNvIGlmIG9iai55ZWFyIGlzIGluIDk5LCBidXQgb2JqLmRheSBtYWtlcyBpdCByb2xsIG92ZXIgaW50byB5ZWFyIDEwMCxcbiAgICAvLyB0aGUgY2FsY3VsYXRpb25zIGRvbmUgYnkgRGF0ZS5VVEMgYXJlIHVzaW5nIHllYXIgMjAwMCAtIHdoaWNoIGlzIGluY29ycmVjdFxuICAgIGQuc2V0VVRDRnVsbFllYXIob2JqLnllYXIsIG9iai5tb250aCAtIDEsIG9iai5kYXkpO1xuICB9XG4gIHJldHVybiArZDtcbn1cblxuLy8gYWRhcHRlZCBmcm9tIG1vbWVudC5qczogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvYmxvYi8wMDBhYzE4MDBlNjIwZjc3MGY0ZWIzMWI1YWU5MDhmNjE2N2IwYWIyL3NyYy9saWIvdW5pdHMvd2Vlay1jYWxlbmRhci11dGlscy5qc1xuZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspIHtcbiAgY29uc3QgZndkbHcgPSBpc29XZWVrZGF5VG9Mb2NhbChkYXlPZldlZWsoeWVhciwgMSwgbWluRGF5c0luRmlyc3RXZWVrKSwgc3RhcnRPZldlZWspO1xuICByZXR1cm4gLWZ3ZGx3ICsgbWluRGF5c0luRmlyc3RXZWVrIC0gMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhciwgbWluRGF5c0luRmlyc3RXZWVrID0gNCwgc3RhcnRPZldlZWsgPSAxKSB7XG4gIGNvbnN0IHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQod2Vla1llYXIsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICBjb25zdCB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh3ZWVrWWVhciArIDEsIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICByZXR1cm4gKGRheXNJblllYXIod2Vla1llYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyKSB7XG4gIGlmICh5ZWFyID4gOTkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHJldHVybiB5ZWFyID4gU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID8gMTkwMCArIHllYXIgOiAyMDAwICsgeWVhcjtcbn1cblxuLy8gUEFSU0lOR1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Vab25lSW5mbyh0cywgb2Zmc2V0Rm9ybWF0LCBsb2NhbGUsIHRpbWVab25lID0gbnVsbCkge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpLFxuICAgIGludGxPcHRzID0ge1xuICAgICAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIH07XG5cbiAgaWYgKHRpbWVab25lKSB7XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSB0aW1lWm9uZTtcbiAgfVxuXG4gIGNvbnN0IG1vZGlmaWVkID0geyB0aW1lWm9uZU5hbWU6IG9mZnNldEZvcm1hdCwgLi4uaW50bE9wdHMgfTtcblxuICBjb25zdCBwYXJzZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG1vZGlmaWVkKVxuICAgIC5mb3JtYXRUb1BhcnRzKGRhdGUpXG4gICAgLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBcInRpbWV6b25lbmFtZVwiKTtcbiAgcmV0dXJuIHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IG51bGw7XG59XG5cbi8vIHNpZ25lZE9mZnNldCgnLTUnLCAnMzAnKSAtPiAtMzMwXG5leHBvcnQgZnVuY3Rpb24gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cikge1xuICBsZXQgb2ZmSG91ciA9IHBhcnNlSW50KG9mZkhvdXJTdHIsIDEwKTtcblxuICAvLyBkb24ndCB8fCB0aGlzIGJlY2F1c2Ugd2Ugd2FudCB0byBwcmVzZXJ2ZSAtMFxuICBpZiAoTnVtYmVyLmlzTmFOKG9mZkhvdXIpKSB7XG4gICAgb2ZmSG91ciA9IDA7XG4gIH1cblxuICBjb25zdCBvZmZNaW4gPSBwYXJzZUludChvZmZNaW51dGVTdHIsIDEwKSB8fCAwLFxuICAgIG9mZk1pblNpZ25lZCA9IG9mZkhvdXIgPCAwIHx8IE9iamVjdC5pcyhvZmZIb3VyLCAtMCkgPyAtb2ZmTWluIDogb2ZmTWluO1xuICByZXR1cm4gb2ZmSG91ciAqIDYwICsgb2ZmTWluU2lnbmVkO1xufVxuXG4vLyBDT0VSQ0lPTlxuXG5leHBvcnQgZnVuY3Rpb24gYXNOdW1iZXIodmFsdWUpIHtcbiAgY29uc3QgbnVtZXJpY1ZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT09IFwiXCIgfHwgTnVtYmVyLmlzTmFOKG51bWVyaWNWYWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBJbnZhbGlkIHVuaXQgdmFsdWUgJHt2YWx1ZX1gKTtcbiAgcmV0dXJuIG51bWVyaWNWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZXIpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBmb3IgKGNvbnN0IHUgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgdSkpIHtcbiAgICAgIGNvbnN0IHYgPSBvYmpbdV07XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVyKHUpXSA9IGFzTnVtYmVyKHYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE9mZnNldChvZmZzZXQsIGZvcm1hdCkge1xuICBjb25zdCBob3VycyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0IC8gNjApKSxcbiAgICBtaW51dGVzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgJSA2MCkpLFxuICAgIHNpZ24gPSBvZmZzZXQgPj0gMCA/IFwiK1wiIDogXCItXCI7XG5cbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtob3Vyc30ke21pbnV0ZXMgPiAwID8gYDoke21pbnV0ZXN9YCA6IFwiXCJ9YDtcbiAgICBjYXNlIFwidGVjaGllXCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX0ke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBWYWx1ZSBmb3JtYXQgJHtmb3JtYXR9IGlzIG91dCBvZiByYW5nZSBmb3IgcHJvcGVydHkgZm9ybWF0YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVPYmplY3Qob2JqKSB7XG4gIHJldHVybiBwaWNrKG9iaiwgW1wiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7IHBpY2sgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmopIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgT2JqZWN0LmtleXMob2JqKS5zb3J0KCkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGNvbnN0IG1vbnRoc0xvbmcgPSBbXG4gIFwiSmFudWFyeVwiLFxuICBcIkZlYnJ1YXJ5XCIsXG4gIFwiTWFyY2hcIixcbiAgXCJBcHJpbFwiLFxuICBcIk1heVwiLFxuICBcIkp1bmVcIixcbiAgXCJKdWx5XCIsXG4gIFwiQXVndXN0XCIsXG4gIFwiU2VwdGVtYmVyXCIsXG4gIFwiT2N0b2JlclwiLFxuICBcIk5vdmVtYmVyXCIsXG4gIFwiRGVjZW1iZXJcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNTaG9ydCA9IFtcbiAgXCJKYW5cIixcbiAgXCJGZWJcIixcbiAgXCJNYXJcIixcbiAgXCJBcHJcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5cIixcbiAgXCJKdWxcIixcbiAgXCJBdWdcIixcbiAgXCJTZXBcIixcbiAgXCJPY3RcIixcbiAgXCJOb3ZcIixcbiAgXCJEZWNcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNOYXJyb3cgPSBbXCJKXCIsIFwiRlwiLCBcIk1cIiwgXCJBXCIsIFwiTVwiLCBcIkpcIiwgXCJKXCIsIFwiQVwiLCBcIlNcIiwgXCJPXCIsIFwiTlwiLCBcIkRcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aHMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgY2FzZSBcIjItZGlnaXRcIjpcbiAgICAgIHJldHVybiBbXCIwMVwiLCBcIjAyXCIsIFwiMDNcIiwgXCIwNFwiLCBcIjA1XCIsIFwiMDZcIiwgXCIwN1wiLCBcIjA4XCIsIFwiMDlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c0xvbmcgPSBbXG4gIFwiTW9uZGF5XCIsXG4gIFwiVHVlc2RheVwiLFxuICBcIldlZG5lc2RheVwiLFxuICBcIlRodXJzZGF5XCIsXG4gIFwiRnJpZGF5XCIsXG4gIFwiU2F0dXJkYXlcIixcbiAgXCJTdW5kYXlcIixcbl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c1Nob3J0ID0gW1wiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIsIFwiU3VuXCJdO1xuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNOYXJyb3cgPSBbXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIiwgXCJTXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCJdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWVyaWRpZW1zID0gW1wiQU1cIiwgXCJQTVwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNMb25nID0gW1wiQmVmb3JlIENocmlzdFwiLCBcIkFubm8gRG9taW5pXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc1Nob3J0ID0gW1wiQkNcIiwgXCJBRFwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNOYXJyb3cgPSBbXCJCXCIsIFwiQVwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVyYXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTG9uZ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJpZGllbUZvckRhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBtZXJpZGllbXNbZHQuaG91ciA8IDEyID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIHdlZWtkYXlzKGxlbmd0aClbZHQud2Vla2RheSAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBtb250aHMobGVuZ3RoKVtkdC5tb250aCAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gZXJhcyhsZW5ndGgpW2R0LnllYXIgPCAwID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCBudW1lcmljID0gXCJhbHdheXNcIiwgbmFycm93ID0gZmFsc2UpIHtcbiAgY29uc3QgdW5pdHMgPSB7XG4gICAgeWVhcnM6IFtcInllYXJcIiwgXCJ5ci5cIl0sXG4gICAgcXVhcnRlcnM6IFtcInF1YXJ0ZXJcIiwgXCJxdHIuXCJdLFxuICAgIG1vbnRoczogW1wibW9udGhcIiwgXCJtby5cIl0sXG4gICAgd2Vla3M6IFtcIndlZWtcIiwgXCJ3ay5cIl0sXG4gICAgZGF5czogW1wiZGF5XCIsIFwiZGF5XCIsIFwiZGF5c1wiXSxcbiAgICBob3VyczogW1wiaG91clwiLCBcImhyLlwiXSxcbiAgICBtaW51dGVzOiBbXCJtaW51dGVcIiwgXCJtaW4uXCJdLFxuICAgIHNlY29uZHM6IFtcInNlY29uZFwiLCBcInNlYy5cIl0sXG4gIH07XG5cbiAgY29uc3QgbGFzdGFibGUgPSBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdLmluZGV4T2YodW5pdCkgPT09IC0xO1xuXG4gIGlmIChudW1lcmljID09PSBcImF1dG9cIiAmJiBsYXN0YWJsZSkge1xuICAgIGNvbnN0IGlzRGF5ID0gdW5pdCA9PT0gXCJkYXlzXCI7XG4gICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvbW9ycm93XCIgOiBgbmV4dCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInllc3RlcmRheVwiIDogYGxhc3QgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvZGF5XCIgOiBgdGhpcyAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBkZWZhdWx0OiAvLyBmYWxsIHRocm91Z2hcbiAgICB9XG4gIH1cblxuICBjb25zdCBpc0luUGFzdCA9IE9iamVjdC5pcyhjb3VudCwgLTApIHx8IGNvdW50IDwgMCxcbiAgICBmbXRWYWx1ZSA9IE1hdGguYWJzKGNvdW50KSxcbiAgICBzaW5ndWxhciA9IGZtdFZhbHVlID09PSAxLFxuICAgIGxpbFVuaXRzID0gdW5pdHNbdW5pdF0sXG4gICAgZm10VW5pdCA9IG5hcnJvd1xuICAgICAgPyBzaW5ndWxhclxuICAgICAgICA/IGxpbFVuaXRzWzFdXG4gICAgICAgIDogbGlsVW5pdHNbMl0gfHwgbGlsVW5pdHNbMV1cbiAgICAgIDogc2luZ3VsYXJcbiAgICAgID8gdW5pdHNbdW5pdF1bMF1cbiAgICAgIDogdW5pdDtcbiAgcmV0dXJuIGlzSW5QYXN0ID8gYCR7Zm10VmFsdWV9ICR7Zm10VW5pdH0gYWdvYCA6IGBpbiAke2ZtdFZhbHVlfSAke2ZtdFVuaXR9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN0cmluZyhrbm93bkZvcm1hdCkge1xuICAvLyB0aGVzZSBhbGwgaGF2ZSB0aGUgb2Zmc2V0cyByZW1vdmVkIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlbVxuICAvLyB3aXRob3V0IGFsbCB0aGUgaW50bCBzdHVmZiB0aGlzIGlzIGJhY2tmaWxsaW5nXG4gIGNvbnN0IGZpbHRlcmVkID0gcGljayhrbm93bkZvcm1hdCwgW1xuICAgICAgXCJ3ZWVrZGF5XCIsXG4gICAgICBcImVyYVwiLFxuICAgICAgXCJ5ZWFyXCIsXG4gICAgICBcIm1vbnRoXCIsXG4gICAgICBcImRheVwiLFxuICAgICAgXCJob3VyXCIsXG4gICAgICBcIm1pbnV0ZVwiLFxuICAgICAgXCJzZWNvbmRcIixcbiAgICAgIFwidGltZVpvbmVOYW1lXCIsXG4gICAgICBcImhvdXJDeWNsZVwiLFxuICAgIF0pLFxuICAgIGtleSA9IHN0cmluZ2lmeShmaWx0ZXJlZCksXG4gICAgZGF0ZVRpbWVIdWdlID0gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0hVR0UpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcImg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfU0lNUExFKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJISDptbTpzc1wiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRSk6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIGQgTExMIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGFkU3RhcnQgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VucyhzcGxpdHMsIHRva2VuVG9TdHJpbmcpIHtcbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHNwbGl0cykge1xuICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICBzICs9IHRva2VuLnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB0b2tlblRvU3RyaW5nKHRva2VuLnZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5jb25zdCBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzID0ge1xuICBEOiBGb3JtYXRzLkRBVEVfU0hPUlQsXG4gIEREOiBGb3JtYXRzLkRBVEVfTUVELFxuICBEREQ6IEZvcm1hdHMuREFURV9GVUxMLFxuICBEREREOiBGb3JtYXRzLkRBVEVfSFVHRSxcbiAgdDogRm9ybWF0cy5USU1FX1NJTVBMRSxcbiAgdHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMsXG4gIHR0dDogRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VULFxuICB0dHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCxcbiAgVDogRm9ybWF0cy5USU1FXzI0X1NJTVBMRSxcbiAgVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMsXG4gIFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VULFxuICBUVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCxcbiAgZjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVCxcbiAgZmY6IEZvcm1hdHMuREFURVRJTUVfTUVELFxuICBmZmY6IEZvcm1hdHMuREFURVRJTUVfRlVMTCxcbiAgZmZmZjogRm9ybWF0cy5EQVRFVElNRV9IVUdFLFxuICBGOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyxcbiAgRkY6IEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyxcbiAgRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTLFxuICBGRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTLFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcm1hdHRlciB7XG4gIHN0YXRpYyBjcmVhdGUobG9jYWxlLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdHRlcihsb2NhbGUsIG9wdHMpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlRm9ybWF0KGZtdCkge1xuICAgIC8vIHdoaXRlLXNwYWNlIGlzIGFsd2F5cyBjb25zaWRlcmVkIGEgbGl0ZXJhbCBpbiB1c2VyLXByb3ZpZGVkIGZvcm1hdHNcbiAgICAvLyB0aGUgXCIgXCIgdG9rZW4gaGFzIGEgc3BlY2lhbCBtZWFuaW5nIChzZWUgdW5pdEZvclRva2VuKVxuXG4gICAgbGV0IGN1cnJlbnQgPSBudWxsLFxuICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgYnJhY2tldGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBmbXQuY2hhckF0KGkpO1xuICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBicmFja2V0ZWQgfHwgL15cXHMrJC8udGVzdChjdXJyZW50RnVsbCksIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRGdWxsID0gXCJcIjtcbiAgICAgICAgYnJhY2tldGVkID0gIWJyYWNrZXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldGVkKSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RnVsbCA9IGM7XG4gICAgICAgIGN1cnJlbnQgPSBjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCB8fCAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG5cbiAgc3RhdGljIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pIHtcbiAgICByZXR1cm4gbWFjcm9Ub2tlblRvRm9ybWF0T3B0c1t0b2tlbl07XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGZvcm1hdE9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBmb3JtYXRPcHRzO1xuICAgIHRoaXMubG9jID0gbG9jYWxlO1xuICAgIHRoaXMuc3lzdGVtTG9jID0gbnVsbDtcbiAgfVxuXG4gIGZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuc3lzdGVtTG9jID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN5c3RlbUxvYyA9IHRoaXMubG9jLnJlZGVmYXVsdFRvU3lzdGVtKCk7XG4gICAgfVxuICAgIGNvbnN0IGRmID0gdGhpcy5zeXN0ZW1Mb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICAgIHJldHVybiBkZi5mb3JtYXQoKTtcbiAgfVxuXG4gIGR0Rm9ybWF0dGVyKGR0LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5sb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWUoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykuZm9ybWF0KCk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZVBhcnRzKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLmZvcm1hdFRvUGFydHMoKTtcbiAgfVxuXG4gIGZvcm1hdEludGVydmFsKGludGVydmFsLCBvcHRzKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmR0Rm9ybWF0dGVyKGludGVydmFsLnN0YXJ0LCBvcHRzKTtcbiAgICByZXR1cm4gZGYuZHRmLmZvcm1hdFJhbmdlKGludGVydmFsLnN0YXJ0LnRvSlNEYXRlKCksIGludGVydmFsLmVuZC50b0pTRGF0ZSgpKTtcbiAgfVxuXG4gIHJlc29sdmVkT3B0aW9ucyhkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxuXG4gIG51bShuLCBwID0gMCkge1xuICAgIC8vIHdlIGdldCBzb21lIHBlcmYgb3V0IG9mIGRvaW5nIHRoaXMgaGVyZSwgYW5ub3lpbmdseVxuICAgIGlmICh0aGlzLm9wdHMuZm9yY2VTaW1wbGUpIHtcbiAgICAgIHJldHVybiBwYWRTdGFydChuLCBwKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLm9wdHMgfTtcblxuICAgIGlmIChwID4gMCkge1xuICAgICAgb3B0cy5wYWRUbyA9IHA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubG9jLm51bWJlckZvcm1hdHRlcihvcHRzKS5mb3JtYXQobik7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZtdCkge1xuICAgIGNvbnN0IGtub3duRW5nbGlzaCA9IHRoaXMubG9jLmxpc3RpbmdNb2RlKCkgPT09IFwiZW5cIixcbiAgICAgIHVzZURhdGVUaW1lRm9ybWF0dGVyID0gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgJiYgdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgIT09IFwiZ3JlZ29yeVwiLFxuICAgICAgc3RyaW5nID0gKG9wdHMsIGV4dHJhY3QpID0+IHRoaXMubG9jLmV4dHJhY3QoZHQsIG9wdHMsIGV4dHJhY3QpLFxuICAgICAgZm9ybWF0T2Zmc2V0ID0gKG9wdHMpID0+IHtcbiAgICAgICAgaWYgKGR0LmlzT2Zmc2V0Rml4ZWQgJiYgZHQub2Zmc2V0ID09PSAwICYmIG9wdHMuYWxsb3daKSB7XG4gICAgICAgICAgcmV0dXJuIFwiWlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQgPyBkdC56b25lLmZvcm1hdE9mZnNldChkdC50cywgb3B0cy5mb3JtYXQpIDogXCJcIjtcbiAgICAgIH0sXG4gICAgICBtZXJpZGllbSA9ICgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tZXJpZGllbUZvckRhdGVUaW1lKGR0KVxuICAgICAgICAgIDogc3RyaW5nKHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9LCBcImRheXBlcmlvZFwiKSxcbiAgICAgIG1vbnRoID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhzdGFuZGFsb25lID8geyBtb250aDogbGVuZ3RoIH0gOiB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKSxcbiAgICAgIHdlZWtkYXkgPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gud2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoXG4gICAgICAgICAgICAgIHN0YW5kYWxvbmUgPyB7IHdlZWtkYXk6IGxlbmd0aCB9IDogeyB3ZWVrZGF5OiBsZW5ndGgsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9LFxuICAgICAgICAgICAgICBcIndlZWtkYXlcIlxuICAgICAgICAgICAgKSxcbiAgICAgIG1heWJlTWFjcm8gPSAodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuKTtcbiAgICAgICAgaWYgKGZvcm1hdE9wdHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgZm9ybWF0T3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJhID0gKGxlbmd0aCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoID8gRW5nbGlzaC5lcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSA6IHN0cmluZyh7IGVyYTogbGVuZ3RoIH0sIFwiZXJhXCIpLFxuICAgICAgdG9rZW5Ub1N0cmluZyA9ICh0b2tlbikgPT4ge1xuICAgICAgICAvLyBXaGVyZSBwb3NzaWJsZTogaHR0cHM6Ly9jbGRyLnVuaWNvZGUub3JnL3RyYW5zbGF0aW9uL2RhdGUtdGltZS9kYXRlLXRpbWUtc3ltYm9sc1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgLy8gbXNcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQsIDMpO1xuICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kLCAyKTtcbiAgICAgICAgICAvLyBmcmFjdGlvbmFsIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTApLCAyKTtcbiAgICAgICAgICBjYXNlIFwidXV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwMCkpO1xuICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSk7XG4gICAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlLCAyKTtcbiAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIpO1xuICAgICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIpO1xuICAgICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIsIDIpO1xuICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICs2XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcIm5hcnJvd1wiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjowMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJzaG9ydFwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDYwMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJ0ZWNoaWVcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVTVFxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwic2hvcnRcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVhc3Rlcm4gU3RhbmRhcmQgVGltZVxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwibG9uZ1wiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICAvLyB6b25lXG4gICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmVOYW1lO1xuICAgICAgICAgIC8vIG1lcmlkaWVtc1xuICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICByZXR1cm4gbWVyaWRpZW0oKTtcbiAgICAgICAgICAvLyBkYXRlc1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwibnVtZXJpY1wiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5KTtcbiAgICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCIyLWRpZ2l0XCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXksIDIpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxLCBkb2Vzbid0IHNlZW0gdG8gd29ya1xuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8geWVhcnNcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAyMDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIikgOiB0aGlzLm51bShkdC55ZWFyKTtcbiAgICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwiMi1kaWdpdFwiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA2KTtcbiAgICAgICAgICAvLyBlcmFzXG4gICAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQURcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJzaG9ydFwiKTtcbiAgICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW5ubyBEb21pbmlcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJsb25nXCIpO1xuICAgICAgICAgIGNhc2UgXCJHR0dHR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGVyYShcIm5hcnJvd1wiKTtcbiAgICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyKTtcbiAgICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmxvY2FsV2Vla051bWJlcik7XG4gICAgICAgICAgY2FzZSBcIm5uXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubG9jYWxXZWVrTnVtYmVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiaWlcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5sb2NhbFdlZWtZZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwiaWlpaVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmxvY2FsV2Vla1llYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQub3JkaW5hbCk7XG4gICAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwsIDMpO1xuICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyKTtcbiAgICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQudHMgLyAxMDAwKSk7XG4gICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC50cyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBtYXliZU1hY3JvKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIHRva2VuVG9TdHJpbmcpO1xuICB9XG5cbiAgZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKGR1ciwgZm10KSB7XG4gICAgY29uc3QgdG9rZW5Ub0ZpZWxkID0gKHRva2VuKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJob3VyXCI7XG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ3ZWVrXCI7XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblRvU3RyaW5nID0gKGxpbGR1cikgPT4gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHRva2VuVG9GaWVsZCh0b2tlbik7XG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5udW0obGlsZHVyLmdldChtYXBwZWQpLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VucyA9IEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLFxuICAgICAgcmVhbFRva2VucyA9IHRva2Vucy5yZWR1Y2UoXG4gICAgICAgIChmb3VuZCwgeyBsaXRlcmFsLCB2YWwgfSkgPT4gKGxpdGVyYWwgPyBmb3VuZCA6IGZvdW5kLmNvbmNhdCh2YWwpKSxcbiAgICAgICAgW11cbiAgICAgICksXG4gICAgICBjb2xsYXBzZWQgPSBkdXIuc2hpZnRUbyguLi5yZWFsVG9rZW5zLm1hcCh0b2tlblRvRmllbGQpLmZpbHRlcigodCkgPT4gdCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnModG9rZW5zLCB0b2tlblRvU3RyaW5nKGNvbGxhcHNlZCkpO1xuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgdW50cnVuY2F0ZVllYXIsXG4gIHNpZ25lZE9mZnNldCxcbiAgcGFyc2VJbnRlZ2VyLFxuICBwYXJzZU1pbGxpcyxcbiAgaXNVbmRlZmluZWQsXG4gIHBhcnNlRmxvYXRpbmcsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZvciB3ZWxsLXNwZWNpZmllZCBmb3JtYXRzLiBIZXJlJ3MgaG93IGl0IHdvcmtzOlxuICogVHdvIHRoaW5ncyBnbyBpbnRvIHBhcnNpbmc6IGEgcmVnZXggdG8gbWF0Y2ggd2l0aCBhbmQgYW4gZXh0cmFjdG9yIHRvIHRha2UgYXBhcnQgdGhlIGdyb3VwcyBpbiB0aGUgbWF0Y2guXG4gKiBBbiBleHRyYWN0b3IgaXMganVzdCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZWdleCBtYXRjaCBhcnJheSBhbmQgcmV0dXJucyBhIHsgeWVhcjogLi4uLCBtb250aDogLi4uIH0gb2JqZWN0XG4gKiBwYXJzZSgpIGRvZXMgdGhlIHdvcmsgb2YgZXhlY3V0aW5nIHRoZSByZWdleCBhbmQgYXBwbHlpbmcgdGhlIGV4dHJhY3Rvci4gSXQgdGFrZXMgbXVsdGlwbGUgcmVnZXgvZXh0cmFjdG9yIHBhaXJzIHRvIHRyeSBpbiBzZXF1ZW5jZS5cbiAqIEV4dHJhY3RvcnMgY2FuIHRha2UgYSBcImN1cnNvclwiIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IGluIHRoZSBtYXRjaCB0byBsb29rIGF0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gY29tYmluZSBleHRyYWN0b3JzLlxuICogY29tYmluZUV4dHJhY3RvcnMoKSBkb2VzIHRoZSB3b3JrIG9mIGNvbWJpbmluZyB0aGVtLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdXJzb3IgdGhyb3VnaCBtdWx0aXBsZSBleHRyYWN0aW9ucy5cbiAqIFNvbWUgZXh0cmFjdGlvbnMgYXJlIHN1cGVyIGR1bWIgYW5kIHNpbXBsZVBhcnNlIGFuZCBmcm9tU3RyaW5ncyBoZWxwIERSWSB0aGVtLlxuICovXG5cbmNvbnN0IGlhbmFSZWdleCA9IC9bQS1aYS16XystXXsxLDI1Nn0oPzo6P1xcL1tBLVphLXowLTlfKy1dezEsMjU2fSg/OlxcL1tBLVphLXowLTlfKy1dezEsMjU2fSk/KT8vO1xuXG5mdW5jdGlvbiBjb21iaW5lUmVnZXhlcyguLi5yZWdleGVzKSB7XG4gIGNvbnN0IGZ1bGwgPSByZWdleGVzLnJlZHVjZSgoZiwgcikgPT4gZiArIHIuc291cmNlLCBcIlwiKTtcbiAgcmV0dXJuIFJlZ0V4cChgXiR7ZnVsbH0kYCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVFeHRyYWN0b3JzKC4uLmV4dHJhY3RvcnMpIHtcbiAgcmV0dXJuIChtKSA9PlxuICAgIGV4dHJhY3RvcnNcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbbWVyZ2VkVmFscywgbWVyZ2VkWm9uZSwgY3Vyc29yXSwgZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBbdmFsLCB6b25lLCBuZXh0XSA9IGV4KG0sIGN1cnNvcik7XG4gICAgICAgICAgcmV0dXJuIFt7IC4uLm1lcmdlZFZhbHMsIC4uLnZhbCB9LCB6b25lIHx8IG1lcmdlZFpvbmUsIG5leHRdO1xuICAgICAgICB9LFxuICAgICAgICBbe30sIG51bGwsIDFdXG4gICAgICApXG4gICAgICAuc2xpY2UoMCwgMik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHMsIC4uLnBhdHRlcm5zKSB7XG4gIGlmIChzID09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG5cbiAgZm9yIChjb25zdCBbcmVnZXgsIGV4dHJhY3Rvcl0gb2YgcGF0dGVybnMpIHtcbiAgICBjb25zdCBtID0gcmVnZXguZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RvcihtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtudWxsLCBudWxsXTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlUGFyc2UoLi4ua2V5cykge1xuICByZXR1cm4gKG1hdGNoLCBjdXJzb3IpID0+IHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRba2V5c1tpXV0gPSBwYXJzZUludGVnZXIobWF0Y2hbY3Vyc29yICsgaV0pO1xuICAgIH1cbiAgICByZXR1cm4gW3JldCwgbnVsbCwgY3Vyc29yICsgaV07XG4gIH07XG59XG5cbi8vIElTTyBhbmQgU1FMIHBhcnNpbmdcbmNvbnN0IG9mZnNldFJlZ2V4ID0gLyg/OihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pLztcbmNvbnN0IGlzb0V4dGVuZGVkWm9uZSA9IGAoPzoke29mZnNldFJlZ2V4LnNvdXJjZX0/KD86XFxcXFsoJHtpYW5hUmVnZXguc291cmNlfSlcXFxcXSk/KT9gO1xuY29uc3QgaXNvVGltZUJhc2VSZWdleCA9IC8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Wy4sXShcXGR7MSwzMH0pKT8pPyk/LztcbmNvbnN0IGlzb1RpbWVSZWdleCA9IFJlZ0V4cChgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0ke2lzb0V4dGVuZGVkWm9uZX1gKTtcbmNvbnN0IGlzb1RpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86VCR7aXNvVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuY29uc3QgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy87XG5jb25zdCBpc29XZWVrUmVnZXggPSAvKFxcZHs0fSktP1coXFxkXFxkKSg/Oi0/KFxcZCkpPy87XG5jb25zdCBpc29PcmRpbmFsUmVnZXggPSAvKFxcZHs0fSktPyhcXGR7M30pLztcbmNvbnN0IGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0YSA9IHNpbXBsZVBhcnNlKFwieWVhclwiLCBcIm9yZGluYWxcIik7XG5jb25zdCBzcWxZbWRSZWdleCA9IC8oXFxkezR9KS0oXFxkXFxkKS0oXFxkXFxkKS87IC8vIGR1bWJlZC1kb3duIHZlcnNpb24gb2YgdGhlIElTTyBvbmVcbmNvbnN0IHNxbFRpbWVSZWdleCA9IFJlZ0V4cChcbiAgYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9ID8oPzoke29mZnNldFJlZ2V4LnNvdXJjZX18KCR7aWFuYVJlZ2V4LnNvdXJjZX0pKT9gXG4pO1xuY29uc3Qgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzogJHtzcWxUaW1lUmVnZXguc291cmNlfSk/YCk7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICBjb25zdCBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHllYXI6IGludChtYXRjaCwgY3Vyc29yKSxcbiAgICBtb250aDogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAxKSxcbiAgICBkYXk6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1RpbWUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIGhvdXJzOiBpbnQobWF0Y2gsIGN1cnNvciwgMCksXG4gICAgbWludXRlczogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmRzOiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDApLFxuICAgIG1pbGxpc2Vjb25kczogcGFyc2VNaWxsaXMobWF0Y2hbY3Vyc29yICsgM10pLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgNF07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09PZmZzZXQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBsb2NhbCA9ICFtYXRjaFtjdXJzb3JdICYmICFtYXRjaFtjdXJzb3IgKyAxXSxcbiAgICBmdWxsT2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG1hdGNoW2N1cnNvciArIDFdLCBtYXRjaFtjdXJzb3IgKyAyXSksXG4gICAgem9uZSA9IGxvY2FsID8gbnVsbCA6IEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShmdWxsT2Zmc2V0KTtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJQU5BWm9uZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IHpvbmUgPSBtYXRjaFtjdXJzb3JdID8gSUFOQVpvbmUuY3JlYXRlKG1hdGNoW2N1cnNvcl0pIDogbnVsbDtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgMV07XG59XG5cbi8vIElTTyB0aW1lIHBhcnNpbmdcblxuY29uc3QgaXNvVGltZU9ubHkgPSBSZWdFeHAoYF5UPyR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JGApO1xuXG4vLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG5jb25zdCBpc29EdXJhdGlvbiA9XG4gIC9eLT9QKD86KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pWSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pTSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pVyk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pRCk/KD86VCg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUgpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSkoPzpbLixdKC0/XFxkezEsMjB9KSk/Uyk/KT8pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09EdXJhdGlvbihtYXRjaCkge1xuICBjb25zdCBbcywgeWVhclN0ciwgbW9udGhTdHIsIHdlZWtTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIG1pbGxpc2Vjb25kc1N0cl0gPVxuICAgIG1hdGNoO1xuXG4gIGNvbnN0IGhhc05lZ2F0aXZlUHJlZml4ID0gc1swXSA9PT0gXCItXCI7XG4gIGNvbnN0IG5lZ2F0aXZlU2Vjb25kcyA9IHNlY29uZFN0ciAmJiBzZWNvbmRTdHJbMF0gPT09IFwiLVwiO1xuXG4gIGNvbnN0IG1heWJlTmVnYXRlID0gKG51bSwgZm9yY2UgPSBmYWxzZSkgPT5cbiAgICBudW0gIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgKG51bSAmJiBoYXNOZWdhdGl2ZVByZWZpeCkpID8gLW51bSA6IG51bTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHllYXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHllYXJTdHIpKSxcbiAgICAgIG1vbnRoczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtb250aFN0cikpLFxuICAgICAgd2Vla3M6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcod2Vla1N0cikpLFxuICAgICAgZGF5czogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhkYXlTdHIpKSxcbiAgICAgIGhvdXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGhvdXJTdHIpKSxcbiAgICAgIG1pbnV0ZXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobWludXRlU3RyKSksXG4gICAgICBzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHNlY29uZFN0ciksIHNlY29uZFN0ciA9PT0gXCItMFwiKSxcbiAgICAgIG1pbGxpc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VNaWxsaXMobWlsbGlzZWNvbmRzU3RyKSwgbmVnYXRpdmVTZWNvbmRzKSxcbiAgICB9LFxuICBdO1xufVxuXG4vLyBUaGVzZSBhcmUgYSBsaXR0bGUgYnJhaW5kZWFkLiBFRFQgKnNob3VsZCogdGVsbCB1cyB0aGF0IHdlJ3JlIGluLCBzYXksIEFtZXJpY2EvTmV3X1lvcmtcbi8vIGFuZCBub3QganVzdCB0aGF0IHdlJ3JlIGluIC0yNDAgKnJpZ2h0IG5vdyouIEJ1dCBzaW5jZSBJIGRvbid0IHRoaW5rIHRoZXNlIGFyZSB1c2VkIHRoYXQgb2Z0ZW5cbi8vIEknbSBqdXN0IGdvaW5nIHRvIGlnbm9yZSB0aGF0XG5jb25zdCBvYnNPZmZzZXRzID0ge1xuICBHTVQ6IDAsXG4gIEVEVDogLTQgKiA2MCxcbiAgRVNUOiAtNSAqIDYwLFxuICBDRFQ6IC01ICogNjAsXG4gIENTVDogLTYgKiA2MCxcbiAgTURUOiAtNiAqIDYwLFxuICBNU1Q6IC03ICogNjAsXG4gIFBEVDogLTcgKiA2MCxcbiAgUFNUOiAtOCAqIDYwLFxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHllYXI6IHllYXJTdHIubGVuZ3RoID09PSAyID8gdW50cnVuY2F0ZVllYXIocGFyc2VJbnRlZ2VyKHllYXJTdHIpKSA6IHBhcnNlSW50ZWdlcih5ZWFyU3RyKSxcbiAgICBtb250aDogRW5nbGlzaC5tb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSArIDEsXG4gICAgZGF5OiBwYXJzZUludGVnZXIoZGF5U3RyKSxcbiAgICBob3VyOiBwYXJzZUludGVnZXIoaG91clN0ciksXG4gICAgbWludXRlOiBwYXJzZUludGVnZXIobWludXRlU3RyKSxcbiAgfTtcblxuICBpZiAoc2Vjb25kU3RyKSByZXN1bHQuc2Vjb25kID0gcGFyc2VJbnRlZ2VyKHNlY29uZFN0cik7XG4gIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgcmVzdWx0LndlZWtkYXkgPVxuICAgICAgd2Vla2RheVN0ci5sZW5ndGggPiAzXG4gICAgICAgID8gRW5nbGlzaC53ZWVrZGF5c0xvbmcuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDFcbiAgICAgICAgOiBFbmdsaXNoLndlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBSRkMgMjgyMi81MzIyXG5jb25zdCByZmMyODIyID1cbiAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSxcXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KD86KFsrLV1cXGRcXGQpKFxcZFxcZCkpKSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMjgyMihtYXRjaCkge1xuICBjb25zdCBbXG4gICAgICAsXG4gICAgICB3ZWVrZGF5U3RyLFxuICAgICAgZGF5U3RyLFxuICAgICAgbW9udGhTdHIsXG4gICAgICB5ZWFyU3RyLFxuICAgICAgaG91clN0cixcbiAgICAgIG1pbnV0ZVN0cixcbiAgICAgIHNlY29uZFN0cixcbiAgICAgIG9ic09mZnNldCxcbiAgICAgIG1pbE9mZnNldCxcbiAgICAgIG9mZkhvdXJTdHIsXG4gICAgICBvZmZNaW51dGVTdHIsXG4gICAgXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcblxuICBsZXQgb2Zmc2V0O1xuICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICB9IGVsc2UgaWYgKG1pbE9mZnNldCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cik7XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdCwgbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpXTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgXCIgXCIpXG4gICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCBcIiBcIilcbiAgICAudHJpbSgpO1xufVxuXG4vLyBodHRwIGRhdGVcblxuY29uc3QgcmZjMTEyMyA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSwgKFxcZFxcZCkgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoXFxkezR9KSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgcmZjODUwID1cbiAgICAvXihNb25kYXl8VHVlc2RheXxXZWRuZXNkYXl8VGh1cnNkYXl8RnJpZGF5fFNhdHVyZGF5fFN1bmRheSksIChcXGRcXGQpLShKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYyktKFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIGFzY2lpID1cbiAgICAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKCBcXGR8XFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSAoXFxkezR9KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMTEyM09yODUwKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIGRheVN0ciwgbW9udGhTdHIsIHllYXJTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBU0NJSShtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgeWVhclN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5jb25zdCBpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvWW1kUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1dlZWtSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb09yZGluYWxXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvT3JkaW5hbFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29UaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPWW1kLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09XZWVrRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuLypcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW2lzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT09yZGluYWxEYXRlQW5kVGltZV0sXG4gICAgW2lzb1RpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZUFuZE9mZnNldF1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUkZDMjgyMkRhdGUocykge1xuICByZXR1cm4gcGFyc2UocHJlcHJvY2Vzc1JGQzI4MjIocyksIFtyZmMyODIyLCBleHRyYWN0UkZDMjgyMl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIVFRQRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtyZmMxMTIzLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbcmZjODUwLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbYXNjaWksIGV4dHJhY3RBU0NJSV1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRHVyYXRpb24ocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb0R1cmF0aW9uLCBleHRyYWN0SVNPRHVyYXRpb25dKTtcbn1cblxuY29uc3QgZXh0cmFjdElTT1RpbWVPbmx5ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1RpbWUpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09UaW1lT25seShzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvVGltZU9ubHksIGV4dHJhY3RJU09UaW1lT25seV0pO1xufVxuXG5jb25zdCBzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsWW1kUmVnZXgsIHNxbFRpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBzcWxUaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFRpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU1FMKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW3NxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0XSxcbiAgICBbc3FsVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmVdXG4gICk7XG59XG4iLCAiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWREdXJhdGlvbkVycm9yLCBJbnZhbGlkVW5pdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7IHBhcnNlSVNPRHVyYXRpb24sIHBhcnNlSVNPVGltZU9ubHkgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBhc051bWJlcixcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzTnVtYmVyLFxuICBpc1VuZGVmaW5lZCxcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRHVyYXRpb25cIjtcblxuLy8gdW5pdCBjb252ZXJzaW9uIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IGxvd09yZGVyTWF0cml4ID0ge1xuICAgIHdlZWtzOiB7XG4gICAgICBkYXlzOiA3LFxuICAgICAgaG91cnM6IDcgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDcgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBkYXlzOiB7XG4gICAgICBob3VyczogMjQsXG4gICAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgaG91cnM6IHsgbWludXRlczogNjAsIHNlY29uZHM6IDYwICogNjAsIG1pbGxpc2Vjb25kczogNjAgKiA2MCAqIDEwMDAgfSxcbiAgICBtaW51dGVzOiB7IHNlY29uZHM6IDYwLCBtaWxsaXNlY29uZHM6IDYwICogMTAwMCB9LFxuICAgIHNlY29uZHM6IHsgbWlsbGlzZWNvbmRzOiAxMDAwIH0sXG4gIH0sXG4gIGNhc3VhbE1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IDUyLFxuICAgICAgZGF5czogMzY1LFxuICAgICAgaG91cnM6IDM2NSAqIDI0LFxuICAgICAgbWludXRlczogMzY1ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogMTMsXG4gICAgICBkYXlzOiA5MSxcbiAgICAgIGhvdXJzOiA5MSAqIDI0LFxuICAgICAgbWludXRlczogOTEgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IDQsXG4gICAgICBkYXlzOiAzMCxcbiAgICAgIGhvdXJzOiAzMCAqIDI0LFxuICAgICAgbWludXRlczogMzAgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH0sXG4gIGRheXNJblllYXJBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDAwLFxuICBkYXlzSW5Nb250aEFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0ODAwLFxuICBhY2N1cmF0ZU1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyAyOCxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgICBob3VyczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0KSAvIDQsXG4gICAgICBtaW51dGVzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCkgLyA0LFxuICAgICAgc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCkgLyA0LFxuICAgICAgbWlsbGlzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCkgLyA0LFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogZGF5c0luTW9udGhBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5Nb250aEFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfTtcblxuLy8gdW5pdHMgb3JkZXJlZCBieSBzaXplXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXG4gIFwieWVhcnNcIixcbiAgXCJxdWFydGVyc1wiLFxuICBcIm1vbnRoc1wiLFxuICBcIndlZWtzXCIsXG4gIFwiZGF5c1wiLFxuICBcImhvdXJzXCIsXG4gIFwibWludXRlc1wiLFxuICBcInNlY29uZHNcIixcbiAgXCJtaWxsaXNlY29uZHNcIixcbl07XG5cbmNvbnN0IHJldmVyc2VVbml0cyA9IG9yZGVyZWRVbml0cy5zbGljZSgwKS5yZXZlcnNlKCk7XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucyBcImNyZWF0ZSBhbm90aGVyIGluc3RhbmNlIGp1c3QgbGlrZSB0aGlzIG9uZSwgYnV0IHdpdGggdGhlc2UgY2hhbmdlc1wiXG5mdW5jdGlvbiBjbG9uZShkdXIsIGFsdHMsIGNsZWFyID0gZmFsc2UpIHtcbiAgLy8gZGVlcCBtZXJnZSBmb3IgdmFsc1xuICBjb25zdCBjb25mID0ge1xuICAgIHZhbHVlczogY2xlYXIgPyBhbHRzLnZhbHVlcyA6IHsgLi4uZHVyLnZhbHVlcywgLi4uKGFsdHMudmFsdWVzIHx8IHt9KSB9LFxuICAgIGxvYzogZHVyLmxvYy5jbG9uZShhbHRzLmxvYyksXG4gICAgY29udmVyc2lvbkFjY3VyYWN5OiBhbHRzLmNvbnZlcnNpb25BY2N1cmFjeSB8fCBkdXIuY29udmVyc2lvbkFjY3VyYWN5LFxuICAgIG1hdHJpeDogYWx0cy5tYXRyaXggfHwgZHVyLm1hdHJpeCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEdXJhdGlvbihjb25mKTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Ub01pbGxpcyhtYXRyaXgsIHZhbHMpIHtcbiAgbGV0IHN1bSA9IHZhbHMubWlsbGlzZWNvbmRzID8/IDA7XG4gIGZvciAoY29uc3QgdW5pdCBvZiByZXZlcnNlVW5pdHMuc2xpY2UoMSkpIHtcbiAgICBpZiAodmFsc1t1bml0XSkge1xuICAgICAgc3VtICs9IHZhbHNbdW5pdF0gKiBtYXRyaXhbdW5pdF1bXCJtaWxsaXNlY29uZHNcIl07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbi8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlcyhtYXRyaXgsIHZhbHMpIHtcbiAgLy8gdGhlIGxvZ2ljIGJlbG93IGFzc3VtZXMgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIGR1cmF0aW9uIGlzIHBvc2l0aXZlXG4gIC8vIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLCBmYWN0b3IgaXMgdXNlZCB0byBtYWtlIGl0IHNvXG4gIGNvbnN0IGZhY3RvciA9IGR1cmF0aW9uVG9NaWxsaXMobWF0cml4LCB2YWxzKSA8IDAgPyAtMSA6IDE7XG5cbiAgb3JkZXJlZFVuaXRzLnJlZHVjZVJpZ2h0KChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbCA9IHZhbHNbcHJldmlvdXNdICogZmFjdG9yO1xuICAgICAgICBjb25zdCBjb252ID0gbWF0cml4W2N1cnJlbnRdW3ByZXZpb3VzXTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNWYWwgPCAwKTpcbiAgICAgICAgLy8gbG93ZXIgb3JkZXIgdW5pdCBpcyBuZWdhdGl2ZSAoZS5nLiB7IHllYXJzOiAyLCBkYXlzOiAtMiB9KVxuICAgICAgICAvLyBub3JtYWxpemUgdGhpcyBieSByZWR1Y2luZyB0aGUgaGlnaGVyIG9yZGVyIHVuaXQgYnkgdGhlIGFwcHJvcHJpYXRlIGFtb3VudFxuICAgICAgICAvLyBhbmQgaW5jcmVhc2luZyB0aGUgbG93ZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyB0aGlzIGNhbiBuZXZlciBtYWtlIHRoZSBoaWdoZXIgb3JkZXIgdW5pdCBuZWdhdGl2ZSwgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgb3BlcmF0ZXNcbiAgICAgICAgLy8gb24gcG9zaXRpdmUgZHVyYXRpb25zLCBzbyB0aGUgYW1vdW50IG9mIHRpbWUgcmVwcmVzZW50ZWQgYnkgdGhlIGxvd2VyIG9yZGVyIHVuaXQgY2Fubm90XG4gICAgICAgIC8vIGJlIGxhcmdlciB0aGFuIHRoZSBoaWdoZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyBlbHNlOlxuICAgICAgICAvLyBsb3dlciBvcmRlciB1bml0IGlzIHBvc2l0aXZlIChlLmcuIHsgeWVhcnM6IDIsIGRheXM6IDQ1MCB9IG9yIHsgeWVhcnM6IC0yLCBkYXlzOiA0NTAgfSlcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGF0dGVtcHQgdG8gY29udmVydCBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGxvd2VyIG9yZGVyIHVuaXQgaW50b1xuICAgICAgICAvLyB0aGUgaGlnaGVyIG9yZGVyIG9uZVxuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRoLmZsb29yIHRha2VzIGNhcmUgb2YgYm90aCBvZiB0aGVzZSBjYXNlcywgcm91bmRpbmcgYXdheSBmcm9tIDBcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPCAwIGl0IG1ha2VzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBsYXJnZXJcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPj0gaXQgbWFrZXMgdGhlIGFic29sdXRlIHZhbHVlIHNtYWxsZXJcbiAgICAgICAgY29uc3Qgcm9sbFVwID0gTWF0aC5mbG9vcihwcmV2aW91c1ZhbCAvIGNvbnYpO1xuICAgICAgICB2YWxzW2N1cnJlbnRdICs9IHJvbGxVcCAqIGZhY3RvcjtcbiAgICAgICAgdmFsc1twcmV2aW91c10gLT0gcm9sbFVwICogY29udiAqIGZhY3RvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcblxuICAvLyB0cnkgdG8gY29udmVydCBhbnkgZGVjaW1hbHMgaW50byBzbWFsbGVyIHVuaXRzIGlmIHBvc3NpYmxlXG4gIC8vIGZvciBleGFtcGxlIGZvciB7IHllYXJzOiAyLjUsIGRheXM6IDAsIHNlY29uZHM6IDAgfSB3ZSB3YW50IHRvIGdldCB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gIG9yZGVyZWRVbml0cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gdmFsc1twcmV2aW91c10gJSAxO1xuICAgICAgICB2YWxzW3ByZXZpb3VzXSAtPSBmcmFjdGlvbjtcbiAgICAgICAgdmFsc1tjdXJyZW50XSArPSBmcmFjdGlvbiAqIG1hdHJpeFtwcmV2aW91c11bY3VycmVudF07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG59XG5cbi8vIFJlbW92ZSBhbGwgcHJvcGVydGllcyB3aXRoIGEgdmFsdWUgb2YgMCBmcm9tIGFuIG9iamVjdFxuZnVuY3Rpb24gcmVtb3ZlWmVyb2VzKHZhbHMpIHtcbiAgY29uc3QgbmV3VmFscyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWxzKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgbmV3VmFsc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdWYWxzO1xufVxuXG4vKipcbiAqIEEgRHVyYXRpb24gb2JqZWN0IHJlcHJlc2VudHMgYSBwZXJpb2Qgb2YgdGltZSwgbGlrZSBcIjIgbW9udGhzXCIgb3IgXCIxIGRheSwgMSBob3VyXCIuIENvbmNlcHR1YWxseSwgaXQncyBqdXN0IGEgbWFwIG9mIHVuaXRzIHRvIHRoZWlyIHF1YW50aXRpZXMsIGFjY29tcGFuaWVkIGJ5IHNvbWUgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGFuZCBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLiBUaGV5IGNhbiBiZSB1c2VkIG9uIHRoZWlyIG93biBvciBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEx1eG9uIHR5cGVzOyBmb3IgZXhhbXBsZSwgeW91IGNhbiB1c2Uge0BsaW5rIERhdGVUaW1lI3BsdXN9IHRvIGFkZCBhIER1cmF0aW9uIG9iamVjdCB0byBhIERhdGVUaW1lLCBwcm9kdWNpbmcgYW5vdGhlciBEYXRlVGltZS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIER1cmF0aW9uOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhIER1cmF0aW9uLCB1c2Uge0BsaW5rIER1cmF0aW9uLmZyb21NaWxsaXN9LCB7QGxpbmsgRHVyYXRpb24uZnJvbU9iamVjdH0sIG9yIHtAbGluayBEdXJhdGlvbi5mcm9tSVNPfS5cbiAqICogKipVbml0IHZhbHVlcyoqIFNlZSB0aGUge0BsaW5rIER1cmF0aW9uI3llYXJzfSwge0BsaW5rIER1cmF0aW9uI21vbnRoc30sIHtAbGluayBEdXJhdGlvbiN3ZWVrc30sIHtAbGluayBEdXJhdGlvbiNkYXlzfSwge0BsaW5rIER1cmF0aW9uI2hvdXJzfSwge0BsaW5rIER1cmF0aW9uI21pbnV0ZXN9LCB7QGxpbmsgRHVyYXRpb24jc2Vjb25kc30sIHtAbGluayBEdXJhdGlvbiNtaWxsaXNlY29uZHN9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlICB7QGxpbmsgRHVyYXRpb24jbG9jYWxlfSBhbmQge0BsaW5rIER1cmF0aW9uI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG5ldyBEdXJhdGlvbnMgb3V0IG9mIG9sZCBvbmVzIHVzZSB7QGxpbmsgRHVyYXRpb24jcGx1c30sIHtAbGluayBEdXJhdGlvbiNtaW51c30sIHtAbGluayBEdXJhdGlvbiNub3JtYWxpemV9LCB7QGxpbmsgRHVyYXRpb24jc2V0fSwge0BsaW5rIER1cmF0aW9uI3JlY29uZmlndXJlfSwge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99LCBhbmQge0BsaW5rIER1cmF0aW9uI25lZ2F0ZX0uXG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgRHVyYXRpb24gaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgRHVyYXRpb24jYXN9LCB7QGxpbmsgRHVyYXRpb24jdG9JU099LCB7QGxpbmsgRHVyYXRpb24jdG9Gb3JtYXR9LCBhbmQge0BsaW5rIER1cmF0aW9uI3RvSlNPTn1cbiAqXG4gKiBUaGVyZSdzIGFyZSBtb3JlIG1ldGhvZHMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24gYW5kIHZhbGlkaXR5LCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER1cmF0aW9uIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCBhY2N1cmF0ZSA9IGNvbmZpZy5jb252ZXJzaW9uQWNjdXJhY3kgPT09IFwibG9uZ3Rlcm1cIiB8fCBmYWxzZTtcbiAgICBsZXQgbWF0cml4ID0gYWNjdXJhdGUgPyBhY2N1cmF0ZU1hdHJpeCA6IGNhc3VhbE1hdHJpeDtcblxuICAgIGlmIChjb25maWcubWF0cml4KSB7XG4gICAgICBtYXRyaXggPSBjb25maWcubWF0cml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gY29uZmlnLnZhbHVlcztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY29udmVyc2lvbkFjY3VyYWN5ID0gYWNjdXJhdGUgPyBcImxvbmd0ZXJtXCIgOiBcImNhc3VhbFwiO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRHVyYXRpb24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBEdXJhdGlvbiBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IG9mIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhjb3VudCwgb3B0cykge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiBjb3VudCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogSWYgdGhpcyBvYmplY3QgaXMgZW1wdHkgdGhlbiBhIHplcm8gbWlsbGlzZWNvbmRzIGR1cmF0aW9uIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnF1YXJ0ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGhzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91cnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9W11dIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIGN1c3RvbSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBEdXJhdGlvbi5mcm9tT2JqZWN0OiBhcmd1bWVudCBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGdvdCAke1xuICAgICAgICAgIG9iaiA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIG9ialxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKHtcbiAgICAgIHZhbHVlczogbm9ybWFsaXplT2JqZWN0KG9iaiwgRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgICAgY29udmVyc2lvbkFjY3VyYWN5OiBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICAgIG1hdHJpeDogb3B0cy5tYXRyaXgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBEdXJhdGlvbkxpa2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVtYmVyIHwgRHVyYXRpb259IGR1cmF0aW9uTGlrZVxuICAgKiBPbmUgb2Y6XG4gICAqIC0gb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIC0gbnVtYmVyIHJlcHJlc2VudGluZyBtaWxsaXNlY29uZHNcbiAgICogLSBEdXJhdGlvbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uTGlrZSkge1xuICAgIGlmIChpc051bWJlcihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSBpZiAoRHVyYXRpb24uaXNEdXJhdGlvbihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gZHVyYXRpb25MaWtlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uTGlrZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgVW5rbm93biBkdXJhdGlvbiBhcmd1bWVudCAke2R1cmF0aW9uTGlrZX0gb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkxpa2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhbiBJU08gODYwMSBkdXJhdGlvbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1AzWTZNMVc0RFQxMkgzME01UycpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAzLCBtb250aHM6IDYsIHdlZWtzOiAxLCBkYXlzOiA0LCBob3VyczogMTIsIG1pbnV0ZXM6IDMwLCBzZWNvbmRzOiA1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUFQyM0gnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjMgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQNVkzTScpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiA1LCBtb250aHM6IDMgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPRHVyYXRpb24odGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgdGltZSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTE6MjI6MzMuNDQ0JykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAyMiwgc2Vjb25kczogMzMsIG1pbGxpc2Vjb25kczogNDQ0IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTT1RpbWUodGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtwYXJzZWRdID0gcGFyc2VJU09UaW1lT25seSh0ZXh0KTtcbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChwYXJzZWQsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIGRhdGV0aW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRHVyYXRpb24gaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZER1cmF0aW9uRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZVVuaXQodW5pdCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgICB5ZWFyOiBcInllYXJzXCIsXG4gICAgICB5ZWFyczogXCJ5ZWFyc1wiLFxuICAgICAgcXVhcnRlcjogXCJxdWFydGVyc1wiLFxuICAgICAgcXVhcnRlcnM6IFwicXVhcnRlcnNcIixcbiAgICAgIG1vbnRoOiBcIm1vbnRoc1wiLFxuICAgICAgbW9udGhzOiBcIm1vbnRoc1wiLFxuICAgICAgd2VlazogXCJ3ZWVrc1wiLFxuICAgICAgd2Vla3M6IFwid2Vla3NcIixcbiAgICAgIGRheTogXCJkYXlzXCIsXG4gICAgICBkYXlzOiBcImRheXNcIixcbiAgICAgIGhvdXI6IFwiaG91cnNcIixcbiAgICAgIGhvdXJzOiBcImhvdXJzXCIsXG4gICAgICBtaW51dGU6IFwibWludXRlc1wiLFxuICAgICAgbWludXRlczogXCJtaW51dGVzXCIsXG4gICAgICBzZWNvbmQ6IFwic2Vjb25kc1wiLFxuICAgICAgc2Vjb25kczogXCJzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZHNcIixcbiAgICB9W3VuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiB1bml0XTtcblxuICAgIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBEdXJhdGlvbi4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRHVyYXRpb24obykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EdXJhdGlvbikgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0ICB0aGUgbG9jYWxlIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2VuLUdCJ1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEdXJhdGlvbiwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEdXJhdGlvblxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuIFlvdSBtYXkgdXNlIHRoZXNlIHRva2VuczpcbiAgICogKiBgU2AgZm9yIG1pbGxpc2Vjb25kc1xuICAgKiAqIGBzYCBmb3Igc2Vjb25kc1xuICAgKiAqIGBtYCBmb3IgbWludXRlc1xuICAgKiAqIGBoYCBmb3IgaG91cnNcbiAgICogKiBgZGAgZm9yIGRheXNcbiAgICogKiBgd2AgZm9yIHdlZWtzXG4gICAqICogYE1gIGZvciBtb250aHNcbiAgICogKiBgeWAgZm9yIHllYXJzXG4gICAqIE5vdGVzOlxuICAgKiAqIEFkZCBwYWRkaW5nIGJ5IHJlcGVhdGluZyB0aGUgdG9rZW4sIGUuZy4gXCJ5eVwiIHBhZHMgdGhlIHllYXJzIHRvIHR3byBkaWdpdHMsIFwiaGhoaFwiIHBhZHMgdGhlIGhvdXJzIG91dCB0byBmb3VyIGRpZ2l0c1xuICAgKiAqIFRva2VucyBjYW4gYmUgZXNjYXBlZCBieSB3cmFwcGluZyB3aXRoIHNpbmdsZSBxdW90ZXMuXG4gICAqICogVGhlIGR1cmF0aW9uIHdpbGwgYmUgY29udmVydGVkIHRvIHRoZSBzZXQgb2YgdW5pdHMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgdXNpbmcge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99IGFuZCB0aGUgRHVyYXRpb25zJ3MgY29udmVyc2lvbiBhY2N1cmFjeSBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZmxvb3I9dHJ1ZV0gLSBmbG9vciBudW1lcmljYWwgdmFsdWVzXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInkgZCBzXCIpIC8vPT4gXCIxIDYgMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInl5IGRkIHNzc1wiKSAvLz0+IFwiMDEgMDYgMDAyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwiTSBTXCIpIC8vPT4gXCIxMiA1MTg0MDIwMDBcIlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIC8vIHJldmVyc2UtY29tcGF0IHNpbmNlIDEuMjsgd2UgYWx3YXlzIHJvdW5kIGRvd24gbm93LCBuZXZlciB1cCwgYW5kIHdlIGRvIGl0IGJ5IGRlZmF1bHRcbiAgICBjb25zdCBmbXRPcHRzID0ge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGZsb29yOiBvcHRzLnJvdW5kICE9PSBmYWxzZSAmJiBvcHRzLmZsb29yICE9PSBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYywgZm10T3B0cykuZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRHVyYXRpb24gd2l0aCBhbGwgdW5pdHMgaW5jbHVkZWQuXG4gICAqIFRvIG1vZGlmeSBpdHMgYmVoYXZpb3IsIHVzZSBgbGlzdFN0eWxlYCBhbmQgYW55IEludGwuTnVtYmVyRm9ybWF0IG9wdGlvbiwgdGhvdWdoIGB1bml0RGlzcGxheWAgaXMgZXNwZWNpYWxseSByZWxldmFudC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsL051bWJlckZvcm1hdC9OdW1iZXJGb3JtYXQjb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIEZvcm1hdHRpbmcgb3B0aW9ucy4gQWNjZXB0cyB0aGUgc2FtZSBrZXlzIGFzIHRoZSBvcHRpb25zIHBhcmFtZXRlciBvZiB0aGUgbmF0aXZlIGBJbnRsLk51bWJlckZvcm1hdGAgY29uc3RydWN0b3IsIGFzIHdlbGwgYXMgYGxpc3RTdHlsZWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5saXN0U3R5bGU9J25hcnJvdyddIC0gSG93IHRvIGZvcm1hdCB0aGUgbWVyZ2VkIGxpc3QuIENvcnJlc3BvbmRzIHRvIHRoZSBgc3R5bGVgIHByb3BlcnR5IG9mIHRoZSBvcHRpb25zIHBhcmFtZXRlciBvZiB0aGUgbmF0aXZlIGBJbnRsLkxpc3RGb3JtYXRgIGNvbnN0cnVjdG9yLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgZHVyID0gRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEsIGhvdXJzOiA1LCBtaW51dGVzOiA2IH0pXG4gICAqIGR1ci50b0h1bWFuKCkgLy89PiAnMSBkYXksIDUgaG91cnMsIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyBsaXN0U3R5bGU6IFwibG9uZ1wiIH0pIC8vPT4gJzEgZGF5LCA1IGhvdXJzLCBhbmQgNiBtaW51dGVzJ1xuICAgKiBkdXIudG9IdW1hbih7IHVuaXREaXNwbGF5OiBcInNob3J0XCIgfSkgLy89PiAnMSBkYXksIDUgaHIsIDYgbWluJ1xuICAgKiBgYGBcbiAgICovXG4gIHRvSHVtYW4ob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuXG4gICAgY29uc3QgbCA9IG9yZGVyZWRVbml0c1xuICAgICAgLm1hcCgodW5pdCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbHVlc1t1bml0XTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgICAgICAubnVtYmVyRm9ybWF0dGVyKHsgc3R5bGU6IFwidW5pdFwiLCB1bml0RGlzcGxheTogXCJsb25nXCIsIC4uLm9wdHMsIHVuaXQ6IHVuaXQuc2xpY2UoMCwgLTEpIH0pXG4gICAgICAgICAgLmZvcm1hdCh2YWwpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKG4pID0+IG4pO1xuXG4gICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAubGlzdEZvcm1hdHRlcih7IHR5cGU6IFwiY29uanVuY3Rpb25cIiwgc3R5bGU6IG9wdHMubGlzdFN0eWxlIHx8IFwibmFycm93XCIsIC4uLm9wdHMgfSlcbiAgICAgIC5mb3JtYXQobCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEdXJhdGlvbidzIHZhbHVlcy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcbiAgICByZXR1cm4geyAuLi50aGlzLnZhbHVlcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDMsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDNZVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNCwgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQNE1UNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA1IH0pLnRvSVNPKCkgLy89PiAnUDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogNSB9KS50b0lTTygpIC8vPT4gJ1BUNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDYgfSkudG9JU08oKSAvLz0+ICdQVDAuMDA2UydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oKSB7XG4gICAgLy8gd2UgY291bGQgdXNlIHRoZSBmb3JtYXR0ZXIsIGJ1dCB0aGlzIGlzIGFuIGVhc2llciB3YXkgdG8gZ2V0IHRoZSBtaW5pbXVtIHN0cmluZ1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGxldCBzID0gXCJQXCI7XG4gICAgaWYgKHRoaXMueWVhcnMgIT09IDApIHMgKz0gdGhpcy55ZWFycyArIFwiWVwiO1xuICAgIGlmICh0aGlzLm1vbnRocyAhPT0gMCB8fCB0aGlzLnF1YXJ0ZXJzICE9PSAwKSBzICs9IHRoaXMubW9udGhzICsgdGhpcy5xdWFydGVycyAqIDMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy53ZWVrcyAhPT0gMCkgcyArPSB0aGlzLndlZWtzICsgXCJXXCI7XG4gICAgaWYgKHRoaXMuZGF5cyAhPT0gMCkgcyArPSB0aGlzLmRheXMgKyBcIkRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCB8fCB0aGlzLm1pbnV0ZXMgIT09IDAgfHwgdGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgcyArPSBcIlRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCkgcyArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgaWYgKHRoaXMubWludXRlcyAhPT0gMCkgcyArPSB0aGlzLm1pbnV0ZXMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgLy8gdGhpcyB3aWxsIGhhbmRsZSBcImZsb2F0aW5nIHBvaW50IG1hZG5lc3NcIiBieSByZW1vdmluZyBleHRyYSBkZWNpbWFsIHBsYWNlc1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg4MDA0L2lzLWZsb2F0aW5nLXBvaW50LW1hdGgtYnJva2VuXG4gICAgICBzICs9IHJvdW5kVG8odGhpcy5zZWNvbmRzICsgdGhpcy5taWxsaXNlY29uZHMgLyAxMDAwLCAzKSArIFwiU1wiO1xuICAgIGlmIChzID09PSBcIlBcIikgcyArPSBcIlQwU1wiO1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLCBmb3JtYXR0ZWQgYXMgYSB0aW1lIG9mIGRheS5cbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgZHVyYXRpb24gaXMgaW52YWxpZCwgbmVnYXRpdmUsIG9yIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAyNCBob3Vycy5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSgpIC8vPT4gJzExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc01pbGxpc2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMDowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxMTAwMDAuMDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgbWlsbGlzID0gdGhpcy50b01pbGxpcygpO1xuICAgIGlmIChtaWxsaXMgPCAwIHx8IG1pbGxpcyA+PSA4NjQwMDAwMCkgcmV0dXJuIG51bGw7XG5cbiAgICBvcHRzID0ge1xuICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHM6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NTZWNvbmRzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVQcmVmaXg6IGZhbHNlLFxuICAgICAgZm9ybWF0OiBcImV4dGVuZGVkXCIsXG4gICAgICAuLi5vcHRzLFxuICAgICAgaW5jbHVkZU9mZnNldDogZmFsc2UsXG4gICAgfTtcblxuICAgIGNvbnN0IGRhdGVUaW1lID0gRGF0ZVRpbWUuZnJvbU1pbGxpcyhtaWxsaXMsIHsgem9uZTogXCJVVENcIiB9KTtcbiAgICByZXR1cm4gZGF0ZVRpbWUudG9JU09UaW1lKG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHRoZSBSRVBMLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gYER1cmF0aW9uIHsgdmFsdWVzOiAke0pTT04uc3RyaW5naWZ5KHRoaXMudmFsdWVzKX0gfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgRHVyYXRpb24geyBJbnZhbGlkLCByZWFzb246ICR7dGhpcy5pbnZhbGlkUmVhc29ufSB9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBOYU47XG5cbiAgICByZXR1cm4gZHVyYXRpb25Ub01pbGxpcyh0aGlzLm1hdHJpeCwgdGhpcy52YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uIEFsaWFzIG9mIHtAbGluayB0b01pbGxpc31cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b01pbGxpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBsb25nZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBhZGQuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGsgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoZHVyLnZhbHVlcywgaykgfHwgaGFzT3duUHJvcGVydHkodGhpcy52YWx1ZXMsIGspKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IGR1ci5nZXQoaykgKyB0aGlzLmdldChrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHJlc3VsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgRHVyYXRpb24gc2hvcnRlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIHN1YnRyYWN0LiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXMucGx1cyhkdXIubmVnYXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoaXMgRHVyYXRpb24gYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHVuaXQuIEFyaXR5IGlzIDEgb3IgMjogdGhlIHZhbHVlIG9mIHRoZSB1bml0IGFuZCwgb3B0aW9uYWxseSwgdGhlIHVuaXQgbmFtZS4gTXVzdCByZXR1cm4gYSBudW1iZXIuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgbWludXRlczogMzAgfSkubWFwVW5pdHMoeCA9PiB4ICogMikgLy89PiB7IGhvdXJzOiAyLCBtaW51dGVzOiA2MCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgbWludXRlczogMzAgfSkubWFwVW5pdHMoKHgsIHUpID0+IHUgPT09IFwiaG91cnNcIiA/IHggKiAyIDogeCkgLy89PiB7IGhvdXJzOiAyLCBtaW51dGVzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWFwVW5pdHMoZm4pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKSkge1xuICAgICAgcmVzdWx0W2tdID0gYXNOdW1iZXIoZm4odGhpcy52YWx1ZXNba10sIGspKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiByZXN1bHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGUnIG9yICdkYXknXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCd5ZWFycycpIC8vPT4gMlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnbW9udGhzJykgLy89PiAwXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCdkYXlzJykgLy89PiAzXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KV07XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBhIG1hcHBpbmcgb2YgdW5pdHMgdG8gbnVtYmVyc1xuICAgKiBAZXhhbXBsZSBkdXIuc2V0KHsgeWVhcnM6IDIwMTcgfSlcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IGhvdXJzOiA4LCBtaW51dGVzOiAzMCB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBtaXhlZCA9IHsgLi4udGhpcy52YWx1ZXMsIC4uLm5vcm1hbGl6ZU9iamVjdCh2YWx1ZXMsIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpIH07XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBtaXhlZCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUgYW5kL29yIG51bWJlcmluZ1N5c3RlbS4gIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgZHVyLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcmVjb25maWd1cmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgY29udmVyc2lvbkFjY3VyYWN5LCBtYXRyaXggfSA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gdGhpcy5sb2MuY2xvbmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSB9KTtcbiAgICBjb25zdCBvcHRzID0geyBsb2MsIG1hdHJpeCwgY29udmVyc2lvbkFjY3VyYWN5IH07XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBkdXJhdGlvbiBpbiB0aGUgc3BlY2lmaWVkIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZXMnIG9yICdkYXlzJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdkYXlzJykgLy89PiAzNjVcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnbW9udGhzJykgLy89PiAxMlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtob3VyczogNjB9KS5hcygnZGF5cycpIC8vPT4gMi41XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGFzKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5zaGlmdFRvKHVuaXQpLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWR1Y2UgdGhpcyBEdXJhdGlvbiB0byBpdHMgY2Fub25pY2FsIHJlcHJlc2VudGF0aW9uIGluIGl0cyBjdXJyZW50IHVuaXRzLlxuICAgKiBBc3N1bWluZyB0aGUgb3ZlcmFsbCB2YWx1ZSBvZiB0aGUgRHVyYXRpb24gaXMgcG9zaXRpdmUsIHRoaXMgbWVhbnM6XG4gICAqIC0gZXhjZXNzaXZlIHZhbHVlcyBmb3IgbG93ZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBoaWdoZXItb3JkZXIgdW5pdHMgKGlmIHBvc3NpYmxlLCBzZWUgZmlyc3QgYW5kIHNlY29uZCBleGFtcGxlKVxuICAgKiAtIG5lZ2F0aXZlIGxvd2VyLW9yZGVyIHVuaXRzIGFyZSBjb252ZXJ0ZWQgdG8gaGlnaGVyIG9yZGVyIHVuaXRzICh0aGVyZSBtdXN0IGJlIHN1Y2ggYSBoaWdoZXIgb3JkZXIgdW5pdCwgb3RoZXJ3aXNlXG4gICAqICAgdGhlIG92ZXJhbGwgdmFsdWUgd291bGQgYmUgbmVnYXRpdmUsIHNlZSB0aGlyZCBleGFtcGxlKVxuICAgKiAtIGZyYWN0aW9uYWwgdmFsdWVzIGZvciBoaWdoZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBsb3dlci1vcmRlciB1bml0cyAoaWYgcG9zc2libGUsIHNlZSBmb3VydGggZXhhbXBsZSlcbiAgICpcbiAgICogSWYgdGhlIG92ZXJhbGwgdmFsdWUgaXMgbmVnYXRpdmUsIHRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgdGhpcy5uZWdhdGUoKS5ub3JtYWxpemUoKS5uZWdhdGUoKWAuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMTUsIGRheXM6IDI1NSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDUwMDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEyLCBtaW51dGVzOiAtNDUgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAxNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMi41LCBkYXlzOiAwLCBob3VyczogMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMiwgZGF5czogMTgyLCBob3VyczogMTIgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIHZhbHMpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNjYWxlIHVuaXRzIHRvIGl0cyBsYXJnZXN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDkwMDAwIH0pLnJlc2NhbGUoKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiAxLCBzZWNvbmRzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcmVzY2FsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHJlbW92ZVplcm9lcyh0aGlzLm5vcm1hbGl6ZSgpLnNoaWZ0VG9BbGwoKS50b09iamVjdCgpKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIER1cmF0aW9uIGludG8gaXRzIHJlcHJlc2VudGF0aW9uIGluIGEgZGlmZmVyZW50IHNldCBvZiB1bml0cy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5zaGlmdFRvKCdtaW51dGVzJywgJ21pbGxpc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDYwLCBtaWxsaXNlY29uZHM6IDMwMDAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvKC4uLnVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdW5pdHMgPSB1bml0cy5tYXAoKHUpID0+IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSkpO1xuXG4gICAgY29uc3QgYnVpbHQgPSB7fSxcbiAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIGxldCBsYXN0VW5pdDtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICh1bml0cy5pbmRleE9mKGspID49IDApIHtcbiAgICAgICAgbGFzdFVuaXQgPSBrO1xuXG4gICAgICAgIGxldCBvd24gPSAwO1xuXG4gICAgICAgIC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuICAgICAgICBmb3IgKGNvbnN0IGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGx1cyBhbnl0aGluZyB0aGF0J3MgYWxyZWFkeSBpbiB0aGlzIHVuaXRcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgICAgb3duICs9IHZhbHNba107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IGtlZXAgdGhlIGludGVnZXIgcGFydCBmb3Igbm93IGluIHRoZSBob3BlcyBvZiBwdXR0aW5nIGFueSBkZWNpbWFsIHBhcnRcbiAgICAgICAgLy8gaW50byBhIHNtYWxsZXIgdW5pdCBsYXRlclxuICAgICAgICBjb25zdCBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gKG93biAqIDEwMDAgLSBpICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCBpbiB0aGUgd2luZ3MgdG8gYm9pbCBpdCBsYXRlclxuICAgICAgfSBlbHNlIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IHZhbHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgbGVmdG92ZXIgYmVjb21lcyB0aGUgZGVjaW1hbCBmb3IgdGhlIGxhc3QgdW5pdFxuICAgIC8vIGxhc3RVbml0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSB1bml0cyBpcyBub3QgZW1wdHlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgaWYgKGFjY3VtdWxhdGVkW2tleV0gIT09IDApIHtcbiAgICAgICAgYnVpbHRbbGFzdFVuaXRdICs9XG4gICAgICAgICAga2V5ID09PSBsYXN0VW5pdCA/IGFjY3VtdWxhdGVkW2tleV0gOiBhY2N1bXVsYXRlZFtrZXldIC8gdGhpcy5tYXRyaXhbbGFzdFVuaXRdW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCBidWlsdCk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBidWlsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGlmdCB0aGlzIER1cmF0aW9uIHRvIGFsbCBhdmFpbGFibGUgdW5pdHMuXG4gICAqIFNhbWUgYXMgc2hpZnRUbyhcInllYXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG9BbGwoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0VG8oXG4gICAgICBcInllYXJzXCIsXG4gICAgICBcIm1vbnRoc1wiLFxuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgXCJkYXlzXCIsXG4gICAgICBcImhvdXJzXCIsXG4gICAgICBcIm1pbnV0ZXNcIixcbiAgICAgIFwic2Vjb25kc1wiLFxuICAgICAgXCJtaWxsaXNlY29uZHNcIlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZWdhdGl2ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLm5lZ2F0ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAtMSwgc2Vjb25kczogLTMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBuZWdhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG5lZ2F0ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICBuZWdhdGVkW2tdID0gdGhpcy52YWx1ZXNba10gPT09IDAgPyAwIDogLXRoaXMudmFsdWVzW2tdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG5lZ2F0ZWQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMueWVhcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5xdWFydGVycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGhzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRocygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubW9udGhzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy53ZWVrcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5kYXlzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3Vycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuaG91cnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWludXRlcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWlsbGlzZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEdXJhdGlvbiBpcyBpbnZhbGlkLiBJbnZhbGlkIGR1cmF0aW9ucyBhcmUgcmV0dXJuZWQgYnkgZGlmZiBvcGVyYXRpb25zXG4gICAqIG9uIGludmFsaWQgRGF0ZVRpbWVzIG9yIEludGVydmFscy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRHVyYXRpb25zIGFyZSBlcXVhbCBpZmYgdGhleSBoYXZlIHRoZSBzYW1lIHVuaXRzIGFuZCB0aGUgc2FtZSB2YWx1ZXMgZm9yIGVhY2ggdW5pdC5cbiAgICogQHBhcmFtIHtEdXJhdGlvbn0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxKHYxLCB2Mikge1xuICAgICAgLy8gQ29uc2lkZXIgMCBhbmQgdW5kZWZpbmVkIGFzIGVxdWFsXG4gICAgICBpZiAodjEgPT09IHVuZGVmaW5lZCB8fCB2MSA9PT0gMCkgcmV0dXJuIHYyID09PSB1bmRlZmluZWQgfHwgdjIgPT09IDA7XG4gICAgICByZXR1cm4gdjEgPT09IHYyO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICghZXEodGhpcy52YWx1ZXNbdV0sIG90aGVyLnZhbHVlc1t1XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSwgeyBmcmllbmRseURhdGVUaW1lIH0gZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZEludGVydmFsRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBJbnRlcnZhbFwiO1xuXG4vLyBjaGVja3MgaWYgdGhlIHN0YXJ0IGlzIGVxdWFsIHRvIG9yIGJlZm9yZSB0aGUgZW5kXG5mdW5jdGlvbiB2YWxpZGF0ZVN0YXJ0RW5kKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCB8fCAhc3RhcnQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIHN0YXJ0XCIpO1xuICB9IGVsc2UgaWYgKCFlbmQgfHwgIWVuZC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kXCIpO1xuICB9IGVsc2UgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXG4gICAgICBcImVuZCBiZWZvcmUgc3RhcnRcIixcbiAgICAgIGBUaGUgZW5kIG9mIGFuIGludGVydmFsIG11c3QgYmUgYWZ0ZXIgaXRzIHN0YXJ0LCBidXQgeW91IGhhZCBzdGFydD0ke3N0YXJ0LnRvSVNPKCl9IGFuZCBlbmQ9JHtlbmQudG9JU08oKX1gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEFuIEludGVydmFsIG9iamVjdCByZXByZXNlbnRzIGEgaGFsZi1vcGVuIGludGVydmFsIG9mIHRpbWUsIHdoZXJlIGVhY2ggZW5kcG9pbnQgaXMgYSB7QGxpbmsgRGF0ZVRpbWV9LiBDb25jZXB0dWFsbHksIGl0J3MgYSBjb250YWluZXIgZm9yIHRob3NlIHR3byBlbmRwb2ludHMsIGFjY29tcGFuaWVkIGJ5IG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCBjb21wYXJpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIEludGVydmFsOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhbiBJbnRlcnZhbCwgdXNlIHtAbGluayBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzfSwge0BsaW5rIEludGVydmFsLmFmdGVyfSwge0BsaW5rIEludGVydmFsLmJlZm9yZX0sIG9yIHtAbGluayBJbnRlcnZhbC5mcm9tSVNPfS5cbiAqICogKipBY2Nlc3NvcnMqKiBVc2Uge0BsaW5rIEludGVydmFsI3N0YXJ0fSBhbmQge0BsaW5rIEludGVydmFsI2VuZH0gdG8gZ2V0IHRoZSBzdGFydCBhbmQgZW5kLlxuICogKiAqKkludGVycm9nYXRpb24qKiBUbyBhbmFseXplIHRoZSBJbnRlcnZhbCwgdXNlIHtAbGluayBJbnRlcnZhbCNjb3VudH0sIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9LCB7QGxpbmsgSW50ZXJ2YWwjaGFzU2FtZX0sIHtAbGluayBJbnRlcnZhbCNjb250YWluc30sIHtAbGluayBJbnRlcnZhbCNpc0FmdGVyfSwgb3Ige0BsaW5rIEludGVydmFsI2lzQmVmb3JlfS5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBvdGhlciBJbnRlcnZhbHMgb3V0IG9mIHRoaXMgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI3NldH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEF0fSwge0BsaW5rIEludGVydmFsI3NwbGl0Qnl9LCB7QGxpbmsgSW50ZXJ2YWwjZGl2aWRlRXF1YWxseX0sIHtAbGluayBJbnRlcnZhbC5tZXJnZX0sIHtAbGluayBJbnRlcnZhbC54b3J9LCB7QGxpbmsgSW50ZXJ2YWwjdW5pb259LCB7QGxpbmsgSW50ZXJ2YWwjaW50ZXJzZWN0aW9ufSwgb3Ige0BsaW5rIEludGVydmFsI2RpZmZlcmVuY2V9LlxuICogKiAqKkNvbXBhcmlzb24qKiBUbyBjb21wYXJlIHRoaXMgSW50ZXJ2YWwgdG8gYW5vdGhlciBvbmUsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjZXF1YWxzfSwge0BsaW5rIEludGVydmFsI292ZXJsYXBzfSwge0BsaW5rIEludGVydmFsI2FidXRzU3RhcnR9LCB7QGxpbmsgSW50ZXJ2YWwjYWJ1dHNFbmR9LCB7QGxpbmsgSW50ZXJ2YWwjZW5ndWxmc31cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBJbnRlcnZhbCBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBJbnRlcnZhbCN0b1N0cmluZ30sIHtAbGluayBJbnRlcnZhbCN0b0xvY2FsZVN0cmluZ30sIHtAbGluayBJbnRlcnZhbCN0b0lTT30sIHtAbGluayBJbnRlcnZhbCN0b0lTT0RhdGV9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09UaW1lfSwge0BsaW5rIEludGVydmFsI3RvRm9ybWF0fSwgYW5kIHtAbGluayBJbnRlcnZhbCN0b0R1cmF0aW9ufS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJ2YWwge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucyA9IGNvbmZpZy5zdGFydDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmUgPSBjb25maWcuZW5kO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uSW50ZXJ2YWwgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIEludGVydmFsIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRJbnRlcnZhbEVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYW4gZW5kIERhdGVUaW1lLiBJbmNsdXNpdmUgb2YgdGhlIHN0YXJ0IGJ1dCBub3QgdGhlIGVuZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ1aWx0U3RhcnQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KSxcbiAgICAgIGJ1aWx0RW5kID0gZnJpZW5kbHlEYXRlVGltZShlbmQpO1xuXG4gICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IHZhbGlkYXRlU3RhcnRFbmQoYnVpbHRTdGFydCwgYnVpbHRFbmQpO1xuXG4gICAgaWYgKHZhbGlkYXRlRXJyb3IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7XG4gICAgICAgIHN0YXJ0OiBidWlsdFN0YXJ0LFxuICAgICAgICBlbmQ6IGJ1aWx0RW5kLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBhZnRlcihzdGFydCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQsIGR0LnBsdXMoZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gZW5kIERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCBiYWNrd2FyZHMgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGJlZm9yZShlbmQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdC5taW51cyhkdXIpLCBkdCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICAgKiBBY2NlcHRzIGA8c3RhcnQ+LzxlbmQ+YCwgYDxzdGFydD4vPGR1cmF0aW9uPmAsIGFuZCBgPGR1cmF0aW9uPi88ZW5kPmAgZm9ybWF0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9ucyB0byBwYXNzIHtAbGluayBEYXRlVGltZSNmcm9tSVNPfSBhbmQgb3B0aW9uYWxseSB7QGxpbmsgRHVyYXRpb24jZnJvbUlTT31cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcywgZV0gPSAodGV4dCB8fCBcIlwiKS5zcGxpdChcIi9cIiwgMik7XG4gICAgaWYgKHMgJiYgZSkge1xuICAgICAgbGV0IHN0YXJ0LCBzdGFydElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBzdGFydCA9IERhdGVUaW1lLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IHN0YXJ0LmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZXQgZW5kLCBlbmRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGVuZC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlbmRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQgJiYgZW5kSXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYWZ0ZXIoc3RhcnQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kSXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYmVmb3JlKGVuZCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gSW50ZXJ2YWwuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0ludGVydmFsKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uSW50ZXJ2YWwpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMucyA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW5kIG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGF0IGxlYXN0IGl0cyBzdGFydCwgbWVhbmluZyB0aGF0IHRoZSBJbnRlcnZhbCBpc24ndCAnYmFja3dhcmRzJy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkUmVhc29uID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIEludGVydmFsIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBJbnRlcnZhbCBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbCBpbiB0aGUgc3BlY2lmaWVkIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIHJldHVybiB0aGUgbGVuZ3RoIGluLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGgodW5pdCA9IFwibWlsbGlzZWNvbmRzXCIpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0R1cmF0aW9uKC4uLlt1bml0XSkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIG1pbnV0ZXMsIGhvdXJzLCBkYXlzLCBtb250aHMsIG9yIHllYXJzIGluY2x1ZGVkIGluIHRoZSBJbnRlcnZhbCwgZXZlbiBpbiBwYXJ0LlxuICAgKiBVbmxpa2Uge0BsaW5rIEludGVydmFsI2xlbmd0aH0gdGhpcyBjb3VudHMgc2VjdGlvbnMgb2YgdGhlIGNhbGVuZGFyLCBub3QgcGVyaW9kcyBvZiB0aW1lLCBlLmcuIHNwZWNpZnlpbmcgJ2RheSdcbiAgICogYXNrcyAnd2hhdCBkYXRlcyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBpbnRlcnZhbD8nLCBub3QgJ2hvdyBtYW55IGRheXMgbG9uZyBpcyB0aGlzIGludGVydmFsPydcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt1bml0PSdtaWxsaXNlY29uZHMnXSAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnVzZUxvY2FsZVdlZWtzPWZhbHNlXSAtIElmIHRydWUsIHVzZSB3ZWVrcyBiYXNlZCBvbiB0aGUgbG9jYWxlLCBpLmUuIHVzZSB0aGUgbG9jYWxlLWRlcGVuZGVudCBzdGFydCBvZiB0aGUgd2VlazsgdGhpcyBvcGVyYXRpb24gd2lsbCBhbHdheXMgdXNlIHRoZSBsb2NhbGUgb2YgdGhlIHN0YXJ0IERhdGVUaW1lXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvdW50KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBOYU47XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0LnN0YXJ0T2YodW5pdCwgb3B0cyk7XG4gICAgbGV0IGVuZDtcbiAgICBpZiAob3B0cz8udXNlTG9jYWxlV2Vla3MpIHtcbiAgICAgIGVuZCA9IHRoaXMuZW5kLnJlY29uZmlndXJlKHsgbG9jYWxlOiBzdGFydC5sb2NhbGUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IHRoaXMuZW5kO1xuICAgIH1cbiAgICBlbmQgPSBlbmQuc3RhcnRPZih1bml0LCBvcHRzKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpKSArIChlbmQudmFsdWVPZigpICE9PSB0aGlzLmVuZC52YWx1ZU9mKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgYW5kIGVuZCBhcmUgYm90aCBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTYW1lKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5pc0VtcHR5KCkgfHwgdGhpcy5lLm1pbnVzKDEpLmhhc1NhbWUodGhpcy5zLCB1bml0KSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgRGF0ZVRpbWVzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5zLnZhbHVlT2YoKSA9PT0gdGhpcy5lLnZhbHVlT2YoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgaXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQWZ0ZXIoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNCZWZvcmUoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmUgPD0gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBjb250YWlucyB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbnMoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPD0gZGF0ZVRpbWUgJiYgdGhpcy5lID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRzXCIgdGhlIHN0YXJ0IGFuZC9vciBlbmQgZGF0ZXMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIHRoZSB2YWx1ZXMgdG8gc2V0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5zdGFydCAtIHRoZSBzdGFydGluZyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuZW5kIC0gdGhlIGVuZGluZyBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHNldCh7IHN0YXJ0LCBlbmQgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0IHx8IHRoaXMucywgZW5kIHx8IHRoaXMuZSk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBhdCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3BsaXRBdCguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHNvcnRlZCA9IGRhdGVUaW1lc1xuICAgICAgICAubWFwKGZyaWVuZGx5RGF0ZVRpbWUpXG4gICAgICAgIC5maWx0ZXIoKGQpID0+IHRoaXMuY29udGFpbnMoZCkpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnRvTWlsbGlzKCkgLSBiLnRvTWlsbGlzKCkpLFxuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgIGxldCB7IHMgfSA9IHRoaXMsXG4gICAgICBpID0gMDtcblxuICAgIHdoaWxlIChzIDwgdGhpcy5lKSB7XG4gICAgICBjb25zdCBhZGRlZCA9IHNvcnRlZFtpXSB8fCB0aGlzLmUsXG4gICAgICAgIG5leHQgPSArYWRkZWQgPiArdGhpcy5lID8gdGhpcy5lIDogYWRkZWQ7XG4gICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBuZXh0KSk7XG4gICAgICBzID0gbmV4dDtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGludG8gc21hbGxlciBJbnRlcnZhbHMsIGVhY2ggb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gICAqIExlZnQgb3ZlciB0aW1lIGlzIGdyb3VwZWQgaW50byBhIHNtYWxsZXIgaW50ZXJ2YWxcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBsZW5ndGggb2YgZWFjaCByZXN1bHRpbmcgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3BsaXRCeShkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIWR1ci5pc1ZhbGlkIHx8IGR1ci5hcyhcIm1pbGxpc2Vjb25kc1wiKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCB7IHMgfSA9IHRoaXMsXG4gICAgICBpZHggPSAxLFxuICAgICAgbmV4dDtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSB0aGlzLnN0YXJ0LnBsdXMoZHVyLm1hcFVuaXRzKCh4KSA9PiB4ICogaWR4KSk7XG4gICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGludG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc21hbGxlciBpbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZlBhcnRzIC0gVGhlIG51bWJlciBvZiBJbnRlcnZhbHMgdG8gZGl2aWRlIHRoZSBJbnRlcnZhbCBpbnRvLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpdmlkZUVxdWFsbHkobnVtYmVyT2ZQYXJ0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHRoaXMuc3BsaXRCeSh0aGlzLmxlbmd0aCgpIC8gbnVtYmVyT2ZQYXJ0cykuc2xpY2UoMCwgbnVtYmVyT2ZQYXJ0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBvdmVybGFwcyB3aXRoIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxcbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG92ZXJsYXBzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZSA+IG90aGVyLnMgJiYgdGhpcy5zIDwgb3RoZXIuZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBzdGFydC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFidXRzU3RhcnQob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiArdGhpcy5lID09PSArb3RoZXIucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgaXMgYWRqYWNlbnQgdG8gdGhlIHNwZWNpZmllZCBJbnRlcnZhbCdzIGVuZC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFidXRzRW5kKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK290aGVyLmUgPT09ICt0aGlzLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBlbmd1bGZzIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlbmd1bGZzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IG90aGVyLnMgJiYgdGhpcy5lID49IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBhcyB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zLmVxdWFscyhvdGhlci5zKSAmJiB0aGlzLmUuZXF1YWxzKG90aGVyLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIEludGVydmFsIGFuZCB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSByZXN1bHRpbmcgSW50ZXJ2YWwgaGFzIHRoZSBtYXhpbXVtIHN0YXJ0IHRpbWUgYW5kIHRoZSBtaW5pbXVtIGVuZCB0aW1lIG9mIHRoZSB0d28gSW50ZXJ2YWxzLlxuICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGludGVyc2VjdGlvbiBpcyBlbXB0eSwgbWVhbmluZywgdGhlIGludGVydmFscyBkb24ndCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHMgPSB0aGlzLnMgPiBvdGhlci5zID8gdGhpcy5zIDogb3RoZXIucyxcbiAgICAgIGUgPSB0aGlzLmUgPCBvdGhlci5lID8gdGhpcy5lIDogb3RoZXIuZTtcblxuICAgIGlmIChzID49IGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgdW5pb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWluaW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWF4aW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICB1bmlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zIDwgb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lID4gb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIGludG8gYSBlcXVpdmFsZW50IG1pbmltYWwgc2V0IG9mIEludGVydmFscy5cbiAgICogQ29tYmluZXMgb3ZlcmxhcHBpbmcgYW5kIGFkamFjZW50IEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmdlKGludGVydmFscykge1xuICAgIGNvbnN0IFtmb3VuZCwgZmluYWxdID0gaW50ZXJ2YWxzXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5zIC0gYi5zKVxuICAgICAgLnJlZHVjZShcbiAgICAgICAgKFtzb2ZhciwgY3VycmVudF0sIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIsIGl0ZW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5vdmVybGFwcyhpdGVtKSB8fCBjdXJyZW50LmFidXRzU3RhcnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIsIGN1cnJlbnQudW5pb24oaXRlbSldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLmNvbmNhdChbY3VycmVudF0pLCBpdGVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtbXSwgbnVsbF1cbiAgICAgICk7XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmb3VuZC5wdXNoKGZpbmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBJbnRlcnZhbHMgcmVwcmVzZW50aW5nIHRoZSBzcGFucyBvZiB0aW1lIHRoYXQgb25seSBhcHBlYXIgaW4gb25lIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgeG9yKGludGVydmFscykge1xuICAgIGxldCBzdGFydCA9IG51bGwsXG4gICAgICBjdXJyZW50Q291bnQgPSAwO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXSxcbiAgICAgIGVuZHMgPSBpbnRlcnZhbHMubWFwKChpKSA9PiBbXG4gICAgICAgIHsgdGltZTogaS5zLCB0eXBlOiBcInNcIiB9LFxuICAgICAgICB7IHRpbWU6IGkuZSwgdHlwZTogXCJlXCIgfSxcbiAgICAgIF0pLFxuICAgICAgZmxhdHRlbmVkID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi5lbmRzKSxcbiAgICAgIGFyciA9IGZsYXR0ZW5lZC5zb3J0KChhLCBiKSA9PiBhLnRpbWUgLSBiLnRpbWUpO1xuXG4gICAgZm9yIChjb25zdCBpIG9mIGFycikge1xuICAgICAgY3VycmVudENvdW50ICs9IGkudHlwZSA9PT0gXCJzXCIgPyAxIDogLTE7XG5cbiAgICAgIGlmIChjdXJyZW50Q291bnQgPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSBpLnRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnQgJiYgK3N0YXJ0ICE9PSAraS50aW1lKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGkudGltZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJbnRlcnZhbC5tZXJnZShyZXN1bHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBzcGFuIG9mIHRpbWUgaW4gdGhpcyBJbnRlcnZhbCB0aGF0IGRvZXNuJ3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHsuLi5JbnRlcnZhbH0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZGlmZmVyZW5jZSguLi5pbnRlcnZhbHMpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwueG9yKFt0aGlzXS5jb25jYXQoaW50ZXJ2YWxzKSlcbiAgICAgIC5tYXAoKGkpID0+IHRoaXMuaW50ZXJzZWN0aW9uKGkpKVxuICAgICAgLmZpbHRlcigoaSkgPT4gaSAmJiAhaS5pc0VtcHR5KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGBbJHt0aGlzLnMudG9JU08oKX0gXHUyMDEzICR7dGhpcy5lLnRvSVNPKCl9KWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGFwcHJvcHJpYXRlIGZvciB0aGUgUkVQTC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGBJbnRlcnZhbCB7IHN0YXJ0OiAke3RoaXMucy50b0lTTygpfSwgZW5kOiAke3RoaXMuZS50b0lTTygpfSB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBJbnRlcnZhbCB7IEludmFsaWQsIHJlYXNvbjogJHt0aGlzLmludmFsaWRSZWFzb259IH1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBJbnRlcnZhbC4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZVxuICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIGFuZCBhbnkgcHJlc2V0cyBkZWZpbmVkIGJ5IEx1eG9uLCBzdWNoIGFzXG4gICAqIHtAbGluayBEYXRlVGltZS5EQVRFX0ZVTEx9IG9yIHtAbGluayBEYXRlVGltZS5USU1FX1NJTVBMRX0uIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZFxuICAgKiBpcyBicm93c2VyLXNwZWNpZmljLCBidXQgaW4gZ2VuZXJhbCBpdCB3aWxsIHJldHVybiBhbiBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogSW50ZXJ2YWwgaW4gdGhlIGFzc2lnbmVkIGxvY2FsZS4gRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW5cbiAgICogc3BlY2lmaWVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZm9ybWF0T3B0cz1EYXRlVGltZS5EQVRFX1NIT1JUXSAtIEVpdGhlciBhIERhdGVUaW1lIHByZXNldCBvclxuICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgc3RhcnQgRGF0ZVRpbWUuXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAxMS83LzIwMjIgXHUyMDEzIDExLzgvMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gTm92ZW1iZXIgNyBcdTIwMTMgOCwgMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCwgeyBsb2NhbGU6ICdmci1GUicgfSk7IC8vPT4gN1x1MjAxMzggbm92ZW1icmUgMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDE3OjAwWi8yMDIyLTExLTA3VDE5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiA2OjAwIFx1MjAxMyA4OjAwIFBNXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMTc6MDBaLzIwMjItMTEtMDdUMTk6MDBaJykudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnMi1kaWdpdCcsIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7IC8vPT4gTW9uLCBOb3YgMDcsIDY6MDAgXHUyMDEzIDg6MDAgcFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0xvY2FsZVN0cmluZyhmb3JtYXRPcHRzID0gRm9ybWF0cy5EQVRFX1NIT1JULCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5zLmxvYy5jbG9uZShvcHRzKSwgZm9ybWF0T3B0cykuZm9ybWF0SW50ZXJ2YWwodGhpcylcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lI3RvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU08ob3B0cyl9LyR7dGhpcy5lLnRvSVNPKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGRhdGUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIHRpbWUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT0RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09EYXRlKCl9LyR7dGhpcy5lLnRvSVNPRGF0ZSgpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIGRhdGUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lI3RvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPVGltZShvcHRzKX0vJHt0aGlzLmUudG9JU09UaW1lKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXRcbiAgICogc3RyaW5nLiAqKllvdSBtYXkgbm90IHdhbnQgdGhpcy4qKiBTZWUge0BsaW5rIEludGVydmFsI3RvTG9jYWxlU3RyaW5nfSBmb3IgYSBtb3JlIGZsZXhpYmxlXG4gICAqIGZvcm1hdHRpbmcgdG9vbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVGb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZy4gVGhpcyBzdHJpbmcgZm9ybWF0cyB0aGUgc3RhcnQgYW5kIGVuZCB0aW1lLlxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI3RvRm9ybWF0fSBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuc2VwYXJhdG9yID0gICcgXHUyMDEzICddIC0gQSBzZXBhcmF0b3IgdG8gcGxhY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZFxuICAgKiByZXByZXNlbnRhdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGRhdGVGb3JtYXQsIHsgc2VwYXJhdG9yID0gXCIgXHUyMDEzIFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvRm9ybWF0KGRhdGVGb3JtYXQpfSR7c2VwYXJhdG9yfSR7dGhpcy5lLnRvRm9ybWF0KGRhdGVGb3JtYXQpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRHVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSB0aW1lIHNwYW5uZWQgYnkgdGhpcyBpbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbigpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogODg0ODkyNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdkYXlzJykudG9PYmplY3QoKSAvLz0+IHsgZGF5czogMS4wMjQxODEyMTUyNzc3Nzc4IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNC44MjA5NSB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNCwgc2Vjb25kczogNDkuMjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IHNlY29uZHM6IDg4NDg5LjI1NyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgdG9EdXJhdGlvbih1bml0LCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKHRoaXMuaW52YWxpZFJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmUuZGlmZih0aGlzLnMsIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBtYXBGbiBvbiB0aGUgaW50ZXJ2YWwgc3RhcnQgYW5kIGVuZCwgcmV0dXJuaW5nIGEgbmV3IEludGVydmFsIGZyb20gdGhlIHJlc3VsdGluZyBEYXRlVGltZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRm5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC50b1VUQygpKVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQucGx1cyh7IGhvdXJzOiAyIH0pKVxuICAgKi9cbiAgbWFwRW5kcG9pbnRzKG1hcEZuKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMobWFwRm4odGhpcy5zKSwgbWFwRm4odGhpcy5lKSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuXG5pbXBvcnQgeyBoYXNMb2NhbGVXZWVrSW5mbywgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcblxuLyoqXG4gKiBUaGUgSW5mbyBjbGFzcyBjb250YWlucyBzdGF0aWMgbWV0aG9kcyBmb3IgcmV0cmlldmluZyBnZW5lcmFsIHRpbWUgYW5kIGRhdGUgcmVsYXRlZCBkYXRhLiBGb3IgZXhhbXBsZSwgaXQgaGFzIG1ldGhvZHMgZm9yIGZpbmRpbmcgb3V0IGlmIGEgdGltZSB6b25lIGhhcyBhIERTVCwgZm9yIGxpc3RpbmcgdGhlIG1vbnRocyBpbiBhbnkgc3VwcG9ydGVkIGxvY2FsZSwgYW5kIGZvciBkaXNjb3ZlcmluZyB3aGljaCBvZiBMdXhvbiBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmZvIHtcbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBjb250YWlucyBhIERTVC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW3pvbmU9J2xvY2FsJ10gLSBab25lIHRvIGNoZWNrLiBEZWZhdWx0cyB0byB0aGUgZW52aXJvbm1lbnQncyBsb2NhbCB6b25lLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGhhc0RTVCh6b25lID0gU2V0dGluZ3MuZGVmYXVsdFpvbmUpIHtcbiAgICBjb25zdCBwcm90byA9IERhdGVUaW1lLm5vdygpLnNldFpvbmUoem9uZSkuc2V0KHsgbW9udGg6IDEyIH0pO1xuXG4gICAgcmV0dXJuICF6b25lLmlzVW5pdmVyc2FsICYmIHByb3RvLm9mZnNldCAhPT0gcHJvdG8uc2V0KHsgbW9udGg6IDYgfSkub2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBpcyBhIHZhbGlkIElBTkEgc3BlY2lmaWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gem9uZSAtIFpvbmUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkSUFOQVpvbmUoem9uZSkge1xuICAgIHJldHVybiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIHtAbGluayBab25lfSBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBJZiBgaW5wdXRgIGlzIGFscmVhZHkgYSBab25lIGluc3RhbmNlLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBhIHN0cmluZyBjb250YWluaW5nIGEgdmFsaWQgdGltZSB6b25lIG5hbWUsIGEgWm9uZSBpbnN0YW5jZVxuICAgKiAgIHdpdGggdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgdGhhdCBkb2Vzbid0IHJlZmVyIHRvIGEga25vd24gdGltZSB6b25lLCBhIFpvbmVcbiAgICogICBpbnN0YW5jZSB3aXRoIHtAbGluayBab25lI2lzVmFsaWR9ID09IGZhbHNlIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dCBpcyBhIG51bWJlciwgYSBab25lIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBmaXhlZCBvZmZzZXRcbiAgICogICBpbiBtaW51dGVzIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCB6b25lIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfG51bWJlcn0gW2lucHV0XSAtIHRoZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVab25lKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtkYXkgb24gd2hpY2ggdGhlIHdlZWsgc3RhcnRzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gbG9jYWxlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBzdGFydCBvZiB0aGUgd2VlaywgMSBmb3IgTW9uZGF5IHRocm91Z2ggNyBmb3IgU3VuZGF5XG4gICAqL1xuICBzdGF0aWMgZ2V0U3RhcnRPZldlZWsoeyBsb2NhbGUgPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlKSkuZ2V0U3RhcnRPZldlZWsoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGRheXMgbmVjZXNzYXJ5IGluIGEgd2VlayBiZWZvcmUgaXQgaXMgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBuZXh0IHllYXIgYWNjb3JkaW5nXG4gICAqIHRvIHRoZSBnaXZlbiBsb2NhbGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXRNaW5pbXVtRGF5c0luRmlyc3RXZWVrKHsgbG9jYWxlID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSkpLmdldE1pbkRheXNJbkZpcnN0V2VlaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2Vla2RheXMsIHdoaWNoIGFyZSBjb25zaWRlcmVkIHRoZSB3ZWVrZW5kIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gbG9jYWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybnMge251bWJlcltdfSBhbiBhcnJheSBvZiB3ZWVrZGF5cywgMSBmb3IgTW9uZGF5IHRocm91Z2ggNyBmb3IgU3VuZGF5XG4gICAqL1xuICBzdGF0aWMgZ2V0V2Vla2VuZFdlZWtkYXlzKHsgbG9jYWxlID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICAvLyBjb3B5IHRoZSBhcnJheSwgYmVjYXVzZSB3ZSBjYWNoZSBpdCBpbnRlcm5hbGx5XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUpKS5nZXRXZWVrZW5kRGF5cygpLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgbW9udGggbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygpWzBdIC8vPT4gJ0phbnVhcnknXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcpWzBdIC8vPT4gJ0phbidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnKVswXSAvLz0+ICcxJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9IClbMF0gLy89PiAnamFudi4nXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdudW1lcmljJywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAnXHUwNjYxJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbG9uZycsIHsgb3V0cHV0Q2FsZW5kYXI6ICdpc2xhbWljJyB9KVswXSAvLz0+ICdSYWJpXHUwMkJCIEknXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1vbnRocyhcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCBtb250aCBuYW1lcy5cbiAgICogRm9ybWF0IG1vbnRocyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIG1vbnRocyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gdGhlIGRheSBvZiB0aGUgbW9udGguIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI21vbnRoc31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIHdlZWsgbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIHdlZWtkYXkgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygpWzBdIC8vPT4gJ01vbmRheSdcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnKVswXSAvLz0+ICdNb24nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdmci1DQScgfSlbMF0gLy89PiAnbHVuLidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICdcdTA2MjdcdTA2NDRcdTA2MjdcdTA2MkJcdTA2NDZcdTA2NEFcdTA2NDYnXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzKGxlbmd0aCA9IFwibG9uZ1wiLCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCB3ZWVrIG5hbWVzLlxuICAgKiBGb3JtYXQgd2Vla2RheXMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSB3ZWVrZGF5cyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gbW9yZSBkYXRlIGluZm9ybWF0aW9uLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyN3ZWVrZGF5c31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPW51bGxdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgbWVyaWRpZW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoKSAvLz0+IFsgJ0FNJywgJ1BNJyBdXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKHsgbG9jYWxlOiAnbXknIH0pIC8vPT4gWyAnXHUxMDE0XHUxMDM2XHUxMDE0XHUxMDAwXHUxMDNBJywgJ1x1MTAwQVx1MTAxNFx1MTAzMScgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJpZGllbXMoeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSkubWVyaWRpZW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVyYXMsIHN1Y2ggYXMgWydCQycsICdBRCddLiBUaGUgbG9jYWxlIGNhbiBiZSBzcGVjaWZpZWQsIGJ1dCB0aGUgY2FsZW5kYXIgc3lzdGVtIGlzIGFsd2F5cyBHcmVnb3JpYW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdzaG9ydCddIC0gdGhlIGxlbmd0aCBvZiB0aGUgZXJhIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwic2hvcnRcIiBvciBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygpIC8vPT4gWyAnQkMnLCAnQUQnIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJykgLy89PiBbICdCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycsIHsgbG9jYWxlOiAnZnInIH0pIC8vPT4gWyAnYXZhbnQgSlx1MDBFOXN1cy1DaHJpc3QnLCAnYXByXHUwMEU4cyBKXHUwMEU5c3VzLUNocmlzdCcgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBlcmFzKGxlbmd0aCA9IFwic2hvcnRcIiwgeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVsbCwgXCJncmVnb3J5XCIpLmVyYXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNldCBvZiBhdmFpbGFibGUgZmVhdHVyZXMgaW4gdGhpcyBlbnZpcm9ubWVudC5cbiAgICogU29tZSBmZWF0dXJlcyBvZiBMdXhvbiBhcmUgbm90IGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzLiBGb3IgZXhhbXBsZSwgb24gb2xkZXIgYnJvd3NlcnMsIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZyBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUuIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgdGhhdCdzIHRoZSBjYXNlLlxuICAgKiBLZXlzOlxuICAgKiAqIGByZWxhdGl2ZWA6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmdcbiAgICogKiBgbG9jYWxlV2Vla2A6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyBkaWZmZXJlbnQgd2Vla2RheXMgZm9yIHRoZSBzdGFydCBvZiB0aGUgd2VlayBiYXNlZCBvbiB0aGUgbG9jYWxlXG4gICAqIEBleGFtcGxlIEluZm8uZmVhdHVyZXMoKSAvLz0+IHsgcmVsYXRpdmU6IGZhbHNlLCBsb2NhbGVXZWVrOiB0cnVlIH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZlYXR1cmVzKCkge1xuICAgIHJldHVybiB7IHJlbGF0aXZlOiBoYXNSZWxhdGl2ZSgpLCBsb2NhbGVXZWVrOiBoYXNMb2NhbGVXZWVrSW5mbygpIH07XG4gIH1cbn1cbiIsICJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4uL2R1cmF0aW9uLmpzXCI7XG5cbmZ1bmN0aW9uIGRheURpZmYoZWFybGllciwgbGF0ZXIpIHtcbiAgY29uc3QgdXRjRGF5U3RhcnQgPSAoZHQpID0+IGR0LnRvVVRDKDAsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KS5zdGFydE9mKFwiZGF5XCIpLnZhbHVlT2YoKSxcbiAgICBtcyA9IHV0Y0RheVN0YXJ0KGxhdGVyKSAtIHV0Y0RheVN0YXJ0KGVhcmxpZXIpO1xuICByZXR1cm4gTWF0aC5mbG9vcihEdXJhdGlvbi5mcm9tTWlsbGlzKG1zKS5hcyhcImRheXNcIikpO1xufVxuXG5mdW5jdGlvbiBoaWdoT3JkZXJEaWZmcyhjdXJzb3IsIGxhdGVyLCB1bml0cykge1xuICBjb25zdCBkaWZmZXJzID0gW1xuICAgIFtcInllYXJzXCIsIChhLCBiKSA9PiBiLnllYXIgLSBhLnllYXJdLFxuICAgIFtcInF1YXJ0ZXJzXCIsIChhLCBiKSA9PiBiLnF1YXJ0ZXIgLSBhLnF1YXJ0ZXIgKyAoYi55ZWFyIC0gYS55ZWFyKSAqIDRdLFxuICAgIFtcIm1vbnRoc1wiLCAoYSwgYikgPT4gYi5tb250aCAtIGEubW9udGggKyAoYi55ZWFyIC0gYS55ZWFyKSAqIDEyXSxcbiAgICBbXG4gICAgICBcIndlZWtzXCIsXG4gICAgICAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBkYXlzID0gZGF5RGlmZihhLCBiKTtcbiAgICAgICAgcmV0dXJuIChkYXlzIC0gKGRheXMgJSA3KSkgLyA3O1xuICAgICAgfSxcbiAgICBdLFxuICAgIFtcImRheXNcIiwgZGF5RGlmZl0sXG4gIF07XG5cbiAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICBjb25zdCBlYXJsaWVyID0gY3Vyc29yO1xuICBsZXQgbG93ZXN0T3JkZXIsIGhpZ2hXYXRlcjtcblxuICAvKiBUaGlzIGxvb3AgdHJpZXMgdG8gZGlmZiB1c2luZyBsYXJnZXIgdW5pdHMgZmlyc3QuXG4gICAgIElmIHdlIG92ZXJzaG9vdCwgd2UgYmFja3RyYWNrIGFuZCB0cnkgdGhlIG5leHQgc21hbGxlciB1bml0LlxuICAgICBcImN1cnNvclwiIHN0YXJ0cyBvdXQgYXQgdGhlIGVhcmxpZXIgdGltZXN0YW1wIGFuZCBtb3ZlcyBjbG9zZXIgYW5kIGNsb3NlciB0byBcImxhdGVyXCJcbiAgICAgYXMgd2UgdXNlIHNtYWxsZXIgYW5kIHNtYWxsZXIgdW5pdHMuXG4gICAgIGhpZ2hXYXRlciBrZWVwcyB0cmFjayBvZiB3aGVyZSB3ZSB3b3VsZCBiZSBpZiB3ZSBhZGRlZCBvbmUgbW9yZSBvZiB0aGUgc21hbGxlc3QgdW5pdCxcbiAgICAgdGhpcyBpcyB1c2VkIGxhdGVyIHRvIHBvdGVudGlhbGx5IGNvbnZlcnQgYW55IGRpZmZlcmVuY2Ugc21hbGxlciB0aGFuIHRoZSBzbWFsbGVzdCBoaWdoZXIgb3JkZXIgdW5pdFxuICAgICBpbnRvIGEgZnJhY3Rpb24gb2YgdGhhdCBzbWFsbGVzdCBoaWdoZXIgb3JkZXIgdW5pdFxuICAqL1xuICBmb3IgKGNvbnN0IFt1bml0LCBkaWZmZXJdIG9mIGRpZmZlcnMpIHtcbiAgICBpZiAodW5pdHMuaW5kZXhPZih1bml0KSA+PSAwKSB7XG4gICAgICBsb3dlc3RPcmRlciA9IHVuaXQ7XG5cbiAgICAgIHJlc3VsdHNbdW5pdF0gPSBkaWZmZXIoY3Vyc29yLCBsYXRlcik7XG4gICAgICBoaWdoV2F0ZXIgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG5cbiAgICAgIGlmIChoaWdoV2F0ZXIgPiBsYXRlcikge1xuICAgICAgICAvLyB3ZSBvdmVyc2hvdCB0aGUgZW5kIHBvaW50LCBiYWNrdHJhY2sgY3Vyc29yIGJ5IDFcbiAgICAgICAgcmVzdWx0c1t1bml0XS0tO1xuICAgICAgICBjdXJzb3IgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIHN0aWxsIG92ZXJzaG9vdGluZyBub3csIHdlIG5lZWQgdG8gYmFja3RyYWNrIGFnYWluXG4gICAgICAgIC8vIHRoaXMgaGFwcGVucyBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgd2hlbiBkaWZmaW5nIHRpbWVzIGluIGRpZmZlcmVudCB6b25lcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGlzIGNhbGN1bGF0aW9uIGlnbm9yZXMgdGltZSB6b25lc1xuICAgICAgICBpZiAoY3Vyc29yID4gbGF0ZXIpIHtcbiAgICAgICAgICAvLyBrZWVwIHRoZSBcIm92ZXJzaG90IGJ5IDFcIiBhcm91bmQgYXMgaGlnaFdhdGVyXG4gICAgICAgICAgaGlnaFdhdGVyID0gY3Vyc29yO1xuICAgICAgICAgIC8vIGJhY2t0cmFjayBjdXJzb3IgYnkgMVxuICAgICAgICAgIHJlc3VsdHNbdW5pdF0tLTtcbiAgICAgICAgICBjdXJzb3IgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvciA9IGhpZ2hXYXRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChlYXJsaWVyLCBsYXRlciwgdW5pdHMsIG9wdHMpIHtcbiAgbGV0IFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdID0gaGlnaE9yZGVyRGlmZnMoZWFybGllciwgbGF0ZXIsIHVuaXRzKTtcblxuICBjb25zdCByZW1haW5pbmdNaWxsaXMgPSBsYXRlciAtIGN1cnNvcjtcblxuICBjb25zdCBsb3dlck9yZGVyVW5pdHMgPSB1bml0cy5maWx0ZXIoXG4gICAgKHUpID0+IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIl0uaW5kZXhPZih1KSA+PSAwXG4gICk7XG5cbiAgaWYgKGxvd2VyT3JkZXJVbml0cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaGlnaFdhdGVyIDwgbGF0ZXIpIHtcbiAgICAgIGhpZ2hXYXRlciA9IGN1cnNvci5wbHVzKHsgW2xvd2VzdE9yZGVyXTogMSB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGlnaFdhdGVyICE9PSBjdXJzb3IpIHtcbiAgICAgIHJlc3VsdHNbbG93ZXN0T3JkZXJdID0gKHJlc3VsdHNbbG93ZXN0T3JkZXJdIHx8IDApICsgcmVtYWluaW5nTWlsbGlzIC8gKGhpZ2hXYXRlciAtIGN1cnNvcik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZHVyYXRpb24gPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHJlc3VsdHMsIG9wdHMpO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKHJlbWFpbmluZ01pbGxpcywgb3B0cylcbiAgICAgIC5zaGlmdFRvKC4uLmxvd2VyT3JkZXJVbml0cylcbiAgICAgIC5wbHVzKGR1cmF0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cbn1cbiIsICJjb25zdCBudW1iZXJpbmdTeXN0ZW1zID0ge1xuICBhcmFiOiBcIltcXHUwNjYwLVxcdTA2NjldXCIsXG4gIGFyYWJleHQ6IFwiW1xcdTA2RjAtXFx1MDZGOV1cIixcbiAgYmFsaTogXCJbXFx1MUI1MC1cXHUxQjU5XVwiLFxuICBiZW5nOiBcIltcXHUwOUU2LVxcdTA5RUZdXCIsXG4gIGRldmE6IFwiW1xcdTA5NjYtXFx1MDk2Rl1cIixcbiAgZnVsbHdpZGU6IFwiW1xcdUZGMTAtXFx1RkYxOV1cIixcbiAgZ3VqcjogXCJbXFx1MEFFNi1cXHUwQUVGXVwiLFxuICBoYW5pZGVjOiBcIltcdTMwMDd8XHU0RTAwfFx1NEU4Q3xcdTRFMDl8XHU1NkRCfFx1NEU5NHxcdTUxNkR8XHU0RTAzfFx1NTE2QnxcdTRFNURdXCIsXG4gIGtobXI6IFwiW1xcdTE3RTAtXFx1MTdFOV1cIixcbiAga25kYTogXCJbXFx1MENFNi1cXHUwQ0VGXVwiLFxuICBsYW9vOiBcIltcXHUwRUQwLVxcdTBFRDldXCIsXG4gIGxpbWI6IFwiW1xcdTE5NDYtXFx1MTk0Rl1cIixcbiAgbWx5bTogXCJbXFx1MEQ2Ni1cXHUwRDZGXVwiLFxuICBtb25nOiBcIltcXHUxODEwLVxcdTE4MTldXCIsXG4gIG15bXI6IFwiW1xcdTEwNDAtXFx1MTA0OV1cIixcbiAgb3J5YTogXCJbXFx1MEI2Ni1cXHUwQjZGXVwiLFxuICB0YW1sZGVjOiBcIltcXHUwQkU2LVxcdTBCRUZdXCIsXG4gIHRlbHU6IFwiW1xcdTBDNjYtXFx1MEM2Rl1cIixcbiAgdGhhaTogXCJbXFx1MEU1MC1cXHUwRTU5XVwiLFxuICB0aWJ0OiBcIltcXHUwRjIwLVxcdTBGMjldXCIsXG4gIGxhdG46IFwiXFxcXGRcIixcbn07XG5cbmNvbnN0IG51bWJlcmluZ1N5c3RlbXNVVEYxNiA9IHtcbiAgYXJhYjogWzE2MzIsIDE2NDFdLFxuICBhcmFiZXh0OiBbMTc3NiwgMTc4NV0sXG4gIGJhbGk6IFs2OTkyLCA3MDAxXSxcbiAgYmVuZzogWzI1MzQsIDI1NDNdLFxuICBkZXZhOiBbMjQwNiwgMjQxNV0sXG4gIGZ1bGx3aWRlOiBbNjUyOTYsIDY1MzAzXSxcbiAgZ3VqcjogWzI3OTAsIDI3OTldLFxuICBraG1yOiBbNjExMiwgNjEyMV0sXG4gIGtuZGE6IFszMzAyLCAzMzExXSxcbiAgbGFvbzogWzM3OTIsIDM4MDFdLFxuICBsaW1iOiBbNjQ3MCwgNjQ3OV0sXG4gIG1seW06IFszNDMwLCAzNDM5XSxcbiAgbW9uZzogWzYxNjAsIDYxNjldLFxuICBteW1yOiBbNDE2MCwgNDE2OV0sXG4gIG9yeWE6IFsyOTE4LCAyOTI3XSxcbiAgdGFtbGRlYzogWzMwNDYsIDMwNTVdLFxuICB0ZWx1OiBbMzE3NCwgMzE4M10sXG4gIHRoYWk6IFszNjY0LCAzNjczXSxcbiAgdGlidDogWzM4NzIsIDM4ODFdLFxufTtcblxuY29uc3QgaGFuaWRlY0NoYXJzID0gbnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjLnJlcGxhY2UoL1tcXFt8XFxdXS9nLCBcIlwiKS5zcGxpdChcIlwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGlnaXRzKHN0cikge1xuICBsZXQgdmFsdWUgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgIHZhbHVlID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoc3RyW2ldLnNlYXJjaChudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMpICE9PSAtMSkge1xuICAgICAgICB2YWx1ZSArPSBoYW5pZGVjQ2hhcnMuaW5kZXhPZihzdHJbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbnVtYmVyaW5nU3lzdGVtc1VURjE2KSB7XG4gICAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IG51bWJlcmluZ1N5c3RlbXNVVEYxNltrZXldO1xuICAgICAgICAgIGlmIChjb2RlID49IG1pbiAmJiBjb2RlIDw9IG1heCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gY29kZSAtIG1pbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWdpdFJlZ2V4KHsgbnVtYmVyaW5nU3lzdGVtIH0sIGFwcGVuZCA9IFwiXCIpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYCR7bnVtYmVyaW5nU3lzdGVtc1tudW1iZXJpbmdTeXN0ZW0gfHwgXCJsYXRuXCJdfSR7YXBwZW5kfWApO1xufVxuIiwgImltcG9ydCB7IHBhcnNlTWlsbGlzLCBpc1VuZGVmaW5lZCwgdW50cnVuY2F0ZVllYXIsIHNpZ25lZE9mZnNldCwgaGFzT3duUHJvcGVydHkgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4uL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgeyBkaWdpdFJlZ2V4LCBwYXJzZURpZ2l0cyB9IGZyb20gXCIuL2RpZ2l0cy5qc1wiO1xuaW1wb3J0IHsgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5cbmNvbnN0IE1JU1NJTkdfRlRQID0gXCJtaXNzaW5nIEludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBzdXBwb3J0XCI7XG5cbmZ1bmN0aW9uIGludFVuaXQocmVnZXgsIHBvc3QgPSAoaSkgPT4gaSkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHBvc3QocGFyc2VEaWdpdHMocykpIH07XG59XG5cbmNvbnN0IE5CU1AgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCk7XG5jb25zdCBzcGFjZU9yTkJTUCA9IGBbICR7TkJTUH1dYDtcbmNvbnN0IHNwYWNlT3JOQlNQUmVnRXhwID0gbmV3IFJlZ0V4cChzcGFjZU9yTkJTUCwgXCJnXCIpO1xuXG5mdW5jdGlvbiBmaXhMaXN0UmVnZXgocykge1xuICAvLyBtYWtlIGRvdHMgb3B0aW9uYWwgYW5kIGFsc28gbWFrZSB0aGVtIGxpdGVyYWxcbiAgLy8gbWFrZSBzcGFjZSBhbmQgbm9uIGJyZWFrYWJsZSBzcGFjZSBjaGFyYWN0ZXJzIGludGVyY2hhbmdlYWJsZVxuICByZXR1cm4gcy5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLj9cIikucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgc3BhY2VPck5CU1ApO1xufVxuXG5mdW5jdGlvbiBzdHJpcEluc2Vuc2l0aXZpdGllcyhzKSB7XG4gIHJldHVybiBzXG4gICAgLnJlcGxhY2UoL1xcLi9nLCBcIlwiKSAvLyBpZ25vcmUgZG90cyB0aGF0IHdlcmUgbWFkZSBvcHRpb25hbFxuICAgIC5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBcIiBcIikgLy8gaW50ZXJjaGFuZ2Ugc3BhY2UgYW5kIG5ic3BcbiAgICAudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gb25lT2Yoc3RyaW5ncywgc3RhcnRJbmRleCkge1xuICBpZiAoc3RyaW5ncyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZWdleDogUmVnRXhwKHN0cmluZ3MubWFwKGZpeExpc3RSZWdleCkuam9pbihcInxcIikpLFxuICAgICAgZGVzZXI6IChbc10pID0+XG4gICAgICAgIHN0cmluZ3MuZmluZEluZGV4KChpKSA9PiBzdHJpcEluc2Vuc2l0aXZpdGllcyhzKSA9PT0gc3RyaXBJbnNlbnNpdGl2aXRpZXMoaSkpICsgc3RhcnRJbmRleCxcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG9mZnNldChyZWdleCwgZ3JvdXBzKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFssIGgsIG1dKSA9PiBzaWduZWRPZmZzZXQoaCwgbSksIGdyb3VwcyB9O1xufVxuXG5mdW5jdGlvbiBzaW1wbGUocmVnZXgpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBzIH07XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVRva2VuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XG59XG5cbi8qKlxuICogQHBhcmFtIHRva2VuXG4gKiBAcGFyYW0ge0xvY2FsZX0gbG9jXG4gKi9cbmZ1bmN0aW9uIHVuaXRGb3JUb2tlbih0b2tlbiwgbG9jKSB7XG4gIGNvbnN0IG9uZSA9IGRpZ2l0UmVnZXgobG9jKSxcbiAgICB0d28gPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Mn1cIiksXG4gICAgdGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7M31cIiksXG4gICAgZm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcIns0fVwiKSxcbiAgICBzaXggPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Nn1cIiksXG4gICAgb25lT3JUd28gPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwyfVwiKSxcbiAgICBvbmVUb1RocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezEsM31cIiksXG4gICAgb25lVG9TaXggPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSw2fVwiKSxcbiAgICBvbmVUb05pbmUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSw5fVwiKSxcbiAgICB0d29Ub0ZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Miw0fVwiKSxcbiAgICBmb3VyVG9TaXggPSBkaWdpdFJlZ2V4KGxvYywgXCJ7NCw2fVwiKSxcbiAgICBsaXRlcmFsID0gKHQpID0+ICh7IHJlZ2V4OiBSZWdFeHAoZXNjYXBlVG9rZW4odC52YWwpKSwgZGVzZXI6IChbc10pID0+IHMsIGxpdGVyYWw6IHRydWUgfSksXG4gICAgdW5pdGF0ZSA9ICh0KSA9PiB7XG4gICAgICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodC52YWwpIHtcbiAgICAgICAgLy8gZXJhXG4gICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwic2hvcnRcIiksIDApO1xuICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJsb25nXCIpLCAwKTtcbiAgICAgICAgLy8geWVhcnNcbiAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1NpeCk7XG4gICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXIpO1xuICAgICAgICBjYXNlIFwieXl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoc2l4KTtcbiAgICAgICAgLy8gbW9udGhzXG4gICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIHRydWUpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIC8vIGRhdGVzXG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyBvcmRpbmFsc1xuICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwib29vXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICAvLyB0aW1lXG4gICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1RocmVlKTtcbiAgICAgICAgY2FzZSBcIlNTU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKG9uZVRvTmluZSk7XG4gICAgICAgIGNhc2UgXCJ1dVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwidXV1XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lKTtcbiAgICAgICAgLy8gbWVyaWRpZW1cbiAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1lcmlkaWVtcygpLCAwKTtcbiAgICAgICAgLy8gd2Vla1llYXIgKGspXG4gICAgICAgIGNhc2UgXCJra2trXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91cik7XG4gICAgICAgIGNhc2UgXCJra1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuICAgICAgICAvLyB3ZWVrTnVtYmVyIChXKVxuICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIldXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgLy8gd2Vla2RheXNcbiAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcInNob3J0XCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgdHJ1ZSksIDEpO1xuICAgICAgICAvLyBvZmZzZXQvem9uZVxuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSg/OjooJHt0d28uc291cmNlfSkpP2ApLCAyKTtcbiAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKCR7dHdvLnNvdXJjZX0pP2ApLCAyKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBaWlpaIChQU1QpIG9yIFpaWlpaIChQYWNpZmljIFN0YW5kYXJkIFRpbWUpIGluIHBhcnNpbmdcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gZmlndXJlIG91dCB3aGF0IHRoZXkgYXJlXG4gICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW2Etel8rLS9dezEsMjU2fT8vaSk7XG4gICAgICAgIC8vIHRoaXMgc3BlY2lhbC1jYXNlIFwidG9rZW5cIiByZXByZXNlbnRzIGEgcGxhY2Ugd2hlcmUgYSBtYWNyby10b2tlbiBleHBhbmRlZCBpbnRvIGEgd2hpdGUtc3BhY2UgbGl0ZXJhbFxuICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgYWNjZXB0IGFueSBub24tbmV3bGluZSB3aGl0ZS1zcGFjZVxuICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUoL1teXFxTXFxuXFxyXS8pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgY29uc3QgdW5pdCA9IHVuaXRhdGUodG9rZW4pIHx8IHtcbiAgICBpbnZhbGlkUmVhc29uOiBNSVNTSU5HX0ZUUCxcbiAgfTtcblxuICB1bml0LnRva2VuID0gdG9rZW47XG5cbiAgcmV0dXJuIHVuaXQ7XG59XG5cbmNvbnN0IHBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsID0ge1xuICB5ZWFyOiB7XG4gICAgXCIyLWRpZ2l0XCI6IFwieXlcIixcbiAgICBudW1lcmljOiBcInl5eXl5XCIsXG4gIH0sXG4gIG1vbnRoOiB7XG4gICAgbnVtZXJpYzogXCJNXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiTU1cIixcbiAgICBzaG9ydDogXCJNTU1cIixcbiAgICBsb25nOiBcIk1NTU1cIixcbiAgfSxcbiAgZGF5OiB7XG4gICAgbnVtZXJpYzogXCJkXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiZGRcIixcbiAgfSxcbiAgd2Vla2RheToge1xuICAgIHNob3J0OiBcIkVFRVwiLFxuICAgIGxvbmc6IFwiRUVFRVwiLFxuICB9LFxuICBkYXlwZXJpb2Q6IFwiYVwiLFxuICBkYXlQZXJpb2Q6IFwiYVwiLFxuICBob3VyMTI6IHtcbiAgICBudW1lcmljOiBcImhcIixcbiAgICBcIjItZGlnaXRcIjogXCJoaFwiLFxuICB9LFxuICBob3VyMjQ6IHtcbiAgICBudW1lcmljOiBcIkhcIixcbiAgICBcIjItZGlnaXRcIjogXCJISFwiLFxuICB9LFxuICBtaW51dGU6IHtcbiAgICBudW1lcmljOiBcIm1cIixcbiAgICBcIjItZGlnaXRcIjogXCJtbVwiLFxuICB9LFxuICBzZWNvbmQ6IHtcbiAgICBudW1lcmljOiBcInNcIixcbiAgICBcIjItZGlnaXRcIjogXCJzc1wiLFxuICB9LFxuICB0aW1lWm9uZU5hbWU6IHtcbiAgICBsb25nOiBcIlpaWlpaXCIsXG4gICAgc2hvcnQ6IFwiWlpaXCIsXG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0b2tlbkZvclBhcnQocGFydCwgZm9ybWF0T3B0cywgcmVzb2x2ZWRPcHRzKSB7XG4gIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IHBhcnQ7XG5cbiAgaWYgKHR5cGUgPT09IFwibGl0ZXJhbFwiKSB7XG4gICAgY29uc3QgaXNTcGFjZSA9IC9eXFxzKyQvLnRlc3QodmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiAhaXNTcGFjZSxcbiAgICAgIHZhbDogaXNTcGFjZSA/IFwiIFwiIDogdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlID0gZm9ybWF0T3B0c1t0eXBlXTtcblxuICAvLyBUaGUgdXNlciBtaWdodCBoYXZlIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGhvdXIxMiBvciBob3VyQ3ljbGVcbiAgLy8gaWYgc28sIHJlc3BlY3QgdGhlaXIgZGVjaXNpb25cbiAgLy8gaWYgbm90LCByZWZlciBiYWNrIHRvIHRoZSByZXNvbHZlZE9wdHMsIHdoaWNoIGFyZSBiYXNlZCBvbiB0aGUgbG9jYWxlXG4gIGxldCBhY3R1YWxUeXBlID0gdHlwZTtcbiAgaWYgKHR5cGUgPT09IFwiaG91clwiKSB7XG4gICAgaWYgKGZvcm1hdE9wdHMuaG91cjEyICE9IG51bGwpIHtcbiAgICAgIGFjdHVhbFR5cGUgPSBmb3JtYXRPcHRzLmhvdXIxMiA/IFwiaG91cjEyXCIgOiBcImhvdXIyNFwiO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0T3B0cy5ob3VyQ3ljbGUgIT0gbnVsbCkge1xuICAgICAgaWYgKGZvcm1hdE9wdHMuaG91ckN5Y2xlID09PSBcImgxMVwiIHx8IGZvcm1hdE9wdHMuaG91ckN5Y2xlID09PSBcImgxMlwiKSB7XG4gICAgICAgIGFjdHVhbFR5cGUgPSBcImhvdXIxMlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsVHlwZSA9IFwiaG91cjI0XCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRva2VucyBvbmx5IGRpZmZlcmVudGlhdGUgYmV0d2VlbiAyNCBob3VycyBvciBub3QsXG4gICAgICAvLyBzbyB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayBob3VyQ3ljbGUgaGVyZSwgd2hpY2ggaXMgbGVzcyBzdXBwb3J0ZWQgYW55d2F5c1xuICAgICAgYWN0dWFsVHlwZSA9IHJlc29sdmVkT3B0cy5ob3VyMTIgPyBcImhvdXIxMlwiIDogXCJob3VyMjRcIjtcbiAgICB9XG4gIH1cbiAgbGV0IHZhbCA9IHBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsW2FjdHVhbFR5cGVdO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIikge1xuICAgIHZhbCA9IHZhbFtzdHlsZV07XG4gIH1cblxuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdGVyYWw6IGZhbHNlLFxuICAgICAgdmFsLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBidWlsZFJlZ2V4KHVuaXRzKSB7XG4gIGNvbnN0IHJlID0gdW5pdHMubWFwKCh1KSA9PiB1LnJlZ2V4KS5yZWR1Y2UoKGYsIHIpID0+IGAke2Z9KCR7ci5zb3VyY2V9KWAsIFwiXCIpO1xuICByZXR1cm4gW2BeJHtyZX0kYCwgdW5pdHNdO1xufVxuXG5mdW5jdGlvbiBtYXRjaChpbnB1dCwgcmVnZXgsIGhhbmRsZXJzKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBpbnB1dC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBjb25zdCBhbGwgPSB7fTtcbiAgICBsZXQgbWF0Y2hJbmRleCA9IDE7XG4gICAgZm9yIChjb25zdCBpIGluIGhhbmRsZXJzKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoaGFuZGxlcnMsIGkpKSB7XG4gICAgICAgIGNvbnN0IGggPSBoYW5kbGVyc1tpXSxcbiAgICAgICAgICBncm91cHMgPSBoLmdyb3VwcyA/IGguZ3JvdXBzICsgMSA6IDE7XG4gICAgICAgIGlmICghaC5saXRlcmFsICYmIGgudG9rZW4pIHtcbiAgICAgICAgICBhbGxbaC50b2tlbi52YWxbMF1dID0gaC5kZXNlcihtYXRjaGVzLnNsaWNlKG1hdGNoSW5kZXgsIG1hdGNoSW5kZXggKyBncm91cHMpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaEluZGV4ICs9IGdyb3VwcztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFttYXRjaGVzLCBhbGxdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbWF0Y2hlcywge31dO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcykge1xuICBjb25zdCB0b0ZpZWxkID0gKHRva2VuKSA9PiB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgcmV0dXJuIFwibWludXRlXCI7XG4gICAgICBjYXNlIFwiaFwiOlxuICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgcmV0dXJuIFwiZGF5XCI7XG4gICAgICBjYXNlIFwib1wiOlxuICAgICAgICByZXR1cm4gXCJvcmRpbmFsXCI7XG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcbiAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgIGNhc2UgXCJFXCI6XG4gICAgICBjYXNlIFwiY1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrZGF5XCI7XG4gICAgICBjYXNlIFwiV1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrTnVtYmVyXCI7XG4gICAgICBjYXNlIFwia1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrWWVhclwiO1xuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgcmV0dXJuIFwicXVhcnRlclwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGxldCB6b25lID0gbnVsbDtcbiAgbGV0IHNwZWNpZmljT2Zmc2V0O1xuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMueikpIHtcbiAgICB6b25lID0gSUFOQVpvbmUuY3JlYXRlKG1hdGNoZXMueik7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMuWikpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHpvbmUgPSBuZXcgRml4ZWRPZmZzZXRab25lKG1hdGNoZXMuWik7XG4gICAgfVxuICAgIHNwZWNpZmljT2Zmc2V0ID0gbWF0Y2hlcy5aO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnEpKSB7XG4gICAgbWF0Y2hlcy5NID0gKG1hdGNoZXMucSAtIDEpICogMyArIDE7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMuaCkpIHtcbiAgICBpZiAobWF0Y2hlcy5oIDwgMTIgJiYgbWF0Y2hlcy5hID09PSAxKSB7XG4gICAgICBtYXRjaGVzLmggKz0gMTI7XG4gICAgfSBlbHNlIGlmIChtYXRjaGVzLmggPT09IDEyICYmIG1hdGNoZXMuYSA9PT0gMCkge1xuICAgICAgbWF0Y2hlcy5oID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF0Y2hlcy5HID09PSAwICYmIG1hdGNoZXMueSkge1xuICAgIG1hdGNoZXMueSA9IC1tYXRjaGVzLnk7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMudSkpIHtcbiAgICBtYXRjaGVzLlMgPSBwYXJzZU1pbGxpcyhtYXRjaGVzLnUpO1xuICB9XG5cbiAgY29uc3QgdmFscyA9IE9iamVjdC5rZXlzKG1hdGNoZXMpLnJlZHVjZSgociwgaykgPT4ge1xuICAgIGNvbnN0IGYgPSB0b0ZpZWxkKGspO1xuICAgIGlmIChmKSB7XG4gICAgICByW2ZdID0gbWF0Y2hlc1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfSwge30pO1xuXG4gIHJldHVybiBbdmFscywgem9uZSwgc3BlY2lmaWNPZmZzZXRdO1xufVxuXG5sZXQgZHVtbXlEYXRlVGltZUNhY2hlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0RHVtbXlEYXRlVGltZSgpIHtcbiAgaWYgKCFkdW1teURhdGVUaW1lQ2FjaGUpIHtcbiAgICBkdW1teURhdGVUaW1lQ2FjaGUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKDE1NTU1NTU1NTU1NTUpO1xuICB9XG5cbiAgcmV0dXJuIGR1bW15RGF0ZVRpbWVDYWNoZTtcbn1cblxuZnVuY3Rpb24gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHRva2VuLCBsb2NhbGUpIHtcbiAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBjb25zdCBmb3JtYXRPcHRzID0gRm9ybWF0dGVyLm1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4udmFsKTtcbiAgY29uc3QgdG9rZW5zID0gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIGxvY2FsZSk7XG5cbiAgaWYgKHRva2VucyA9PSBudWxsIHx8IHRva2Vucy5pbmNsdWRlcyh1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZE1hY3JvVG9rZW5zKHRva2VucywgbG9jYWxlKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0KC4uLnRva2Vucy5tYXAoKHQpID0+IG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0LCBsb2NhbGUpKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIGNvbnN0IHRva2VucyA9IGV4cGFuZE1hY3JvVG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmb3JtYXQpLCBsb2NhbGUpLFxuICAgIHVuaXRzID0gdG9rZW5zLm1hcCgodCkgPT4gdW5pdEZvclRva2VuKHQsIGxvY2FsZSkpLFxuICAgIGRpc3F1YWxpZnlpbmdVbml0ID0gdW5pdHMuZmluZCgodCkgPT4gdC5pbnZhbGlkUmVhc29uKTtcblxuICBpZiAoZGlzcXVhbGlmeWluZ1VuaXQpIHtcbiAgICByZXR1cm4geyBpbnB1dCwgdG9rZW5zLCBpbnZhbGlkUmVhc29uOiBkaXNxdWFsaWZ5aW5nVW5pdC5pbnZhbGlkUmVhc29uIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW3JlZ2V4U3RyaW5nLCBoYW5kbGVyc10gPSBidWlsZFJlZ2V4KHVuaXRzKSxcbiAgICAgIHJlZ2V4ID0gUmVnRXhwKHJlZ2V4U3RyaW5nLCBcImlcIiksXG4gICAgICBbcmF3TWF0Y2hlcywgbWF0Y2hlc10gPSBtYXRjaChpbnB1dCwgcmVnZXgsIGhhbmRsZXJzKSxcbiAgICAgIFtyZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XSA9IG1hdGNoZXNcbiAgICAgICAgPyBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpXG4gICAgICAgIDogW251bGwsIG51bGwsIHVuZGVmaW5lZF07XG4gICAgaWYgKGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiYVwiKSAmJiBoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcIkhcIikpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBpbmNsdWRlIG1lcmlkaWVtIHdoZW4gc3BlY2lmeWluZyAyNC1ob3VyIGZvcm1hdFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyBpbnB1dCwgdG9rZW5zLCByZWdleCwgcmF3TWF0Y2hlcywgbWF0Y2hlcywgcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIGNvbnN0IHsgcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbiB9ID0gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KTtcbiAgcmV0dXJuIFtyZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpIHtcbiAgaWYgKCFmb3JtYXRPcHRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBmb3JtYXR0ZXIgPSBGb3JtYXR0ZXIuY3JlYXRlKGxvY2FsZSwgZm9ybWF0T3B0cyk7XG4gIGNvbnN0IGRmID0gZm9ybWF0dGVyLmR0Rm9ybWF0dGVyKGdldER1bW15RGF0ZVRpbWUoKSk7XG4gIGNvbnN0IHBhcnRzID0gZGYuZm9ybWF0VG9QYXJ0cygpO1xuICBjb25zdCByZXNvbHZlZE9wdHMgPSBkZi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgcmV0dXJuIHBhcnRzLm1hcCgocCkgPT4gdG9rZW5Gb3JQYXJ0KHAsIGZvcm1hdE9wdHMsIHJlc29sdmVkT3B0cykpO1xufVxuIiwgImltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IEludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQge1xuICBpc1VuZGVmaW5lZCxcbiAgbWF5YmVBcnJheSxcbiAgaXNEYXRlLFxuICBpc051bWJlcixcbiAgYmVzdEJ5LFxuICBkYXlzSW5Nb250aCxcbiAgZGF5c0luWWVhcixcbiAgaXNMZWFwWWVhcixcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG4gIG9ialRvTG9jYWxUUyxcbiAgcGFkU3RhcnQsXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcbmltcG9ydCBkaWZmIGZyb20gXCIuL2ltcGwvZGlmZi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VSRkMyODIyRGF0ZSwgcGFyc2VJU09EYXRlLCBwYXJzZUhUVFBEYXRlLCBwYXJzZVNRTCB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIHBhcnNlRnJvbVRva2VucyxcbiAgZXhwbGFpbkZyb21Ub2tlbnMsXG4gIGZvcm1hdE9wdHNUb1Rva2VucyxcbiAgZXhwYW5kTWFjcm9Ub2tlbnMsXG59IGZyb20gXCIuL2ltcGwvdG9rZW5QYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIGdyZWdvcmlhblRvV2VlayxcbiAgd2Vla1RvR3JlZ29yaWFuLFxuICBncmVnb3JpYW5Ub09yZGluYWwsXG4gIG9yZGluYWxUb0dyZWdvcmlhbixcbiAgaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEsXG4gIGhhc0ludmFsaWRXZWVrRGF0YSxcbiAgaGFzSW52YWxpZE9yZGluYWxEYXRhLFxuICBoYXNJbnZhbGlkVGltZURhdGEsXG4gIHVzZXNMb2NhbFdlZWtWYWx1ZXMsXG4gIGlzb1dlZWtkYXlUb0xvY2FsLFxufSBmcm9tIFwiLi9pbXBsL2NvbnZlcnNpb25zLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2ltcGwvZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yLFxuICBJbnZhbGlkVW5pdEVycm9yLFxuICBJbnZhbGlkRGF0ZVRpbWVFcnJvcixcbn0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBEYXRlVGltZVwiO1xuY29uc3QgTUFYX0RBVEUgPSA4LjY0ZTE1O1xuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZFpvbmUoem9uZSkge1xuICByZXR1cm4gbmV3IEludmFsaWQoXCJ1bnN1cHBvcnRlZCB6b25lXCIsIGB0aGUgem9uZSBcIiR7em9uZS5uYW1lfVwiIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbn1cblxuLy8gd2UgY2FjaGUgd2VlayBkYXRhIG9uIHRoZSBEVCBvYmplY3QgYW5kIHRoaXMgaW50ZXJtZWRpYXRlcyB0aGUgY2FjaGVcbi8qKlxuICogQHBhcmFtIHtEYXRlVGltZX0gZHRcbiAqL1xuZnVuY3Rpb24gcG9zc2libHlDYWNoZWRXZWVrRGF0YShkdCkge1xuICBpZiAoZHQud2Vla0RhdGEgPT09IG51bGwpIHtcbiAgICBkdC53ZWVrRGF0YSA9IGdyZWdvcmlhblRvV2VlayhkdC5jKTtcbiAgfVxuICByZXR1cm4gZHQud2Vla0RhdGE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtEYXRlVGltZX0gZHRcbiAqL1xuZnVuY3Rpb24gcG9zc2libHlDYWNoZWRMb2NhbFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC5sb2NhbFdlZWtEYXRhID09PSBudWxsKSB7XG4gICAgZHQubG9jYWxXZWVrRGF0YSA9IGdyZWdvcmlhblRvV2VlayhcbiAgICAgIGR0LmMsXG4gICAgICBkdC5sb2MuZ2V0TWluRGF5c0luRmlyc3RXZWVrKCksXG4gICAgICBkdC5sb2MuZ2V0U3RhcnRPZldlZWsoKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGR0LmxvY2FsV2Vla0RhdGE7XG59XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucywgXCJtYWtlIGEgbmV3IG9iamVjdCB3aXRoIHRoZXNlIG1vZGlmaWNhdGlvbnNcIi4gYWxsIFwic2V0dGVyc1wiIHJlYWxseSB1c2UgdGhpc1xuLy8gdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB3aGlsZSBvbmx5IGNoYW5naW5nIHNvbWUgb2YgdGhlIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGNsb25lKGluc3QsIGFsdHMpIHtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICB0czogaW5zdC50cyxcbiAgICB6b25lOiBpbnN0LnpvbmUsXG4gICAgYzogaW5zdC5jLFxuICAgIG86IGluc3QubyxcbiAgICBsb2M6IGluc3QubG9jLFxuICAgIGludmFsaWQ6IGluc3QuaW52YWxpZCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IC4uLmN1cnJlbnQsIC4uLmFsdHMsIG9sZDogY3VycmVudCB9KTtcbn1cblxuLy8gZmluZCB0aGUgcmlnaHQgb2Zmc2V0IGEgZ2l2ZW4gbG9jYWwgdGltZS4gVGhlIG8gaW5wdXQgaXMgb3VyIGd1ZXNzLCB3aGljaCBkZXRlcm1pbmVzIHdoaWNoXG4vLyBvZmZzZXQgd2UnbGwgcGljayBpbiBhbWJpZ3VvdXMgY2FzZXMgKGUuZy4gdGhlcmUgYXJlIHR3byAzIEFNcyBiL2MgRmFsbGJhY2sgRFNUKVxuZnVuY3Rpb24gZml4T2Zmc2V0KGxvY2FsVFMsIG8sIHR6KSB7XG4gIC8vIE91ciBVVEMgdGltZSBpcyBqdXN0IGEgZ3Vlc3MgYmVjYXVzZSBvdXIgb2Zmc2V0IGlzIGp1c3QgYSBndWVzc1xuICBsZXQgdXRjR3Vlc3MgPSBsb2NhbFRTIC0gbyAqIDYwICogMTAwMDtcblxuICAvLyBUZXN0IHdoZXRoZXIgdGhlIHpvbmUgbWF0Y2hlcyB0aGUgb2Zmc2V0IGZvciB0aGlzIHRzXG4gIGNvbnN0IG8yID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTtcblxuICAvLyBJZiBzbywgb2Zmc2V0IGRpZG4ndCBjaGFuZ2UgYW5kIHdlJ3JlIGRvbmVcbiAgaWYgKG8gPT09IG8yKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgb107XG4gIH1cblxuICAvLyBJZiBub3QsIGNoYW5nZSB0aGUgdHMgYnkgdGhlIGRpZmZlcmVuY2UgaW4gdGhlIG9mZnNldFxuICB1dGNHdWVzcyAtPSAobzIgLSBvKSAqIDYwICogMTAwMDtcblxuICAvLyBJZiB0aGF0IGdpdmVzIHVzIHRoZSBsb2NhbCB0aW1lIHdlIHdhbnQsIHdlJ3JlIGRvbmVcbiAgY29uc3QgbzMgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuICBpZiAobzIgPT09IG8zKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgbzJdO1xuICB9XG5cbiAgLy8gSWYgaXQncyBkaWZmZXJlbnQsIHdlJ3JlIGluIGEgaG9sZSB0aW1lLiBUaGUgb2Zmc2V0IGhhcyBjaGFuZ2VkLCBidXQgdGhlIHdlIGRvbid0IGFkanVzdCB0aGUgdGltZVxuICByZXR1cm4gW2xvY2FsVFMgLSBNYXRoLm1pbihvMiwgbzMpICogNjAgKiAxMDAwLCBNYXRoLm1heChvMiwgbzMpXTtcbn1cblxuLy8gY29udmVydCBhbiBlcG9jaCB0aW1lc3RhbXAgaW50byBhIGNhbGVuZGFyIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBvZmZzZXRcbmZ1bmN0aW9uIHRzVG9PYmoodHMsIG9mZnNldCkge1xuICB0cyArPSBvZmZzZXQgKiA2MCAqIDEwMDA7XG5cbiAgY29uc3QgZCA9IG5ldyBEYXRlKHRzKTtcblxuICByZXR1cm4ge1xuICAgIHllYXI6IGQuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtb250aDogZC5nZXRVVENNb250aCgpICsgMSxcbiAgICBkYXk6IGQuZ2V0VVRDRGF0ZSgpLFxuICAgIGhvdXI6IGQuZ2V0VVRDSG91cnMoKSxcbiAgICBtaW51dGU6IGQuZ2V0VVRDTWludXRlcygpLFxuICAgIHNlY29uZDogZC5nZXRVVENTZWNvbmRzKCksXG4gICAgbWlsbGlzZWNvbmQ6IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gIH07XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBlcG9jaCB0aW1lc3RhbXBcbmZ1bmN0aW9uIG9ialRvVFMob2JqLCBvZmZzZXQsIHpvbmUpIHtcbiAgcmV0dXJuIGZpeE9mZnNldChvYmpUb0xvY2FsVFMob2JqKSwgb2Zmc2V0LCB6b25lKTtcbn1cblxuLy8gY3JlYXRlIGEgbmV3IERUIGluc3RhbmNlIGJ5IGFkZGluZyBhIGR1cmF0aW9uLCBhZGp1c3RpbmcgZm9yIERTVHNcbmZ1bmN0aW9uIGFkanVzdFRpbWUoaW5zdCwgZHVyKSB7XG4gIGNvbnN0IG9QcmUgPSBpbnN0Lm8sXG4gICAgeWVhciA9IGluc3QuYy55ZWFyICsgTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgIG1vbnRoID0gaW5zdC5jLm1vbnRoICsgTWF0aC50cnVuYyhkdXIubW9udGhzKSArIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSAqIDMsXG4gICAgYyA9IHtcbiAgICAgIC4uLmluc3QuYyxcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheTpcbiAgICAgICAgTWF0aC5taW4oaW5zdC5jLmRheSwgZGF5c0luTW9udGgoeWVhciwgbW9udGgpKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLmRheXMpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIud2Vla3MpICogNyxcbiAgICB9LFxuICAgIG1pbGxpc1RvQWRkID0gRHVyYXRpb24uZnJvbU9iamVjdCh7XG4gICAgICB5ZWFyczogZHVyLnllYXJzIC0gTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgICAgcXVhcnRlcnM6IGR1ci5xdWFydGVycyAtIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSxcbiAgICAgIG1vbnRoczogZHVyLm1vbnRocyAtIE1hdGgudHJ1bmMoZHVyLm1vbnRocyksXG4gICAgICB3ZWVrczogZHVyLndlZWtzIC0gTWF0aC50cnVuYyhkdXIud2Vla3MpLFxuICAgICAgZGF5czogZHVyLmRheXMgLSBNYXRoLnRydW5jKGR1ci5kYXlzKSxcbiAgICAgIGhvdXJzOiBkdXIuaG91cnMsXG4gICAgICBtaW51dGVzOiBkdXIubWludXRlcyxcbiAgICAgIHNlY29uZHM6IGR1ci5zZWNvbmRzLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkdXIubWlsbGlzZWNvbmRzLFxuICAgIH0pLmFzKFwibWlsbGlzZWNvbmRzXCIpLFxuICAgIGxvY2FsVFMgPSBvYmpUb0xvY2FsVFMoYyk7XG5cbiAgbGV0IFt0cywgb10gPSBmaXhPZmZzZXQobG9jYWxUUywgb1ByZSwgaW5zdC56b25lKTtcblxuICBpZiAobWlsbGlzVG9BZGQgIT09IDApIHtcbiAgICB0cyArPSBtaWxsaXNUb0FkZDtcbiAgICAvLyB0aGF0IGNvdWxkIGhhdmUgY2hhbmdlZCB0aGUgb2Zmc2V0IGJ5IGdvaW5nIG92ZXIgYSBEU1QsIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdGhlIHRzIHRoZSBzYW1lXG4gICAgbyA9IGluc3Quem9uZS5vZmZzZXQodHMpO1xuICB9XG5cbiAgcmV0dXJuIHsgdHMsIG8gfTtcbn1cblxuLy8gaGVscGVyIHVzZWZ1bCBpbiB0dXJuaW5nIHRoZSByZXN1bHRzIG9mIHBhcnNpbmcgaW50byByZWFsIGRhdGVzXG4vLyBieSBoYW5kbGluZyB0aGUgem9uZSBvcHRpb25zXG5mdW5jdGlvbiBwYXJzZURhdGFUb0RhdGVUaW1lKHBhcnNlZCwgcGFyc2VkWm9uZSwgb3B0cywgZm9ybWF0LCB0ZXh0LCBzcGVjaWZpY09mZnNldCkge1xuICBjb25zdCB7IHNldFpvbmUsIHpvbmUgfSA9IG9wdHM7XG4gIGlmICgocGFyc2VkICYmIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoICE9PSAwKSB8fCBwYXJzZWRab25lKSB7XG4gICAgY29uc3QgaW50ZXJwcmV0YXRpb25ab25lID0gcGFyc2VkWm9uZSB8fCB6b25lLFxuICAgICAgaW5zdCA9IERhdGVUaW1lLmZyb21PYmplY3QocGFyc2VkLCB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIHpvbmU6IGludGVycHJldGF0aW9uWm9uZSxcbiAgICAgICAgc3BlY2lmaWNPZmZzZXQsXG4gICAgICB9KTtcbiAgICByZXR1cm4gc2V0Wm9uZSA/IGluc3QgOiBpbnN0LnNldFpvbmUoem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICBuZXcgSW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgJHtmb3JtYXR9YClcbiAgICApO1xuICB9XG59XG5cbi8vIGlmIHlvdSB3YW50IHRvIG91dHB1dCBhIHRlY2huaWNhbCBmb3JtYXQgKGUuZy4gUkZDIDI4MjIpLCB0aGlzIGhlbHBlclxuLy8gaGVscHMgaGFuZGxlIHRoZSBkZXRhaWxzXG5mdW5jdGlvbiB0b1RlY2hGb3JtYXQoZHQsIGZvcm1hdCwgYWxsb3daID0gdHJ1ZSkge1xuICByZXR1cm4gZHQuaXNWYWxpZFxuICAgID8gRm9ybWF0dGVyLmNyZWF0ZShMb2NhbGUuY3JlYXRlKFwiZW4tVVNcIiksIHtcbiAgICAgICAgYWxsb3daLFxuICAgICAgICBmb3JjZVNpbXBsZTogdHJ1ZSxcbiAgICAgIH0pLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm9ybWF0KVxuICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9JU09EYXRlKG8sIGV4dGVuZGVkKSB7XG4gIGNvbnN0IGxvbmdGb3JtYXQgPSBvLmMueWVhciA+IDk5OTkgfHwgby5jLnllYXIgPCAwO1xuICBsZXQgYyA9IFwiXCI7XG4gIGlmIChsb25nRm9ybWF0ICYmIG8uYy55ZWFyID49IDApIGMgKz0gXCIrXCI7XG4gIGMgKz0gcGFkU3RhcnQoby5jLnllYXIsIGxvbmdGb3JtYXQgPyA2IDogNCk7XG5cbiAgaWYgKGV4dGVuZGVkKSB7XG4gICAgYyArPSBcIi1cIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgYyArPSBcIi1cIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICB9IGVsc2Uge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1vbnRoKTtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiB0b0lTT1RpbWUoXG4gIG8sXG4gIGV4dGVuZGVkLFxuICBzdXBwcmVzc1NlY29uZHMsXG4gIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICBpbmNsdWRlT2Zmc2V0LFxuICBleHRlbmRlZFpvbmVcbikge1xuICBsZXQgYyA9IHBhZFN0YXJ0KG8uYy5ob3VyKTtcbiAgaWYgKGV4dGVuZGVkKSB7XG4gICAgYyArPSBcIjpcIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5taW51dGUpO1xuICAgIGlmIChvLmMubWlsbGlzZWNvbmQgIT09IDAgfHwgby5jLnNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NTZWNvbmRzKSB7XG4gICAgICBjICs9IFwiOlwiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5taW51dGUpO1xuICB9XG5cbiAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCBvLmMuc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc1NlY29uZHMpIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5zZWNvbmQpO1xuXG4gICAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NNaWxsaXNlY29uZHMpIHtcbiAgICAgIGMgKz0gXCIuXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KG8uYy5taWxsaXNlY29uZCwgMyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBpZiAoby5pc09mZnNldEZpeGVkICYmIG8ub2Zmc2V0ID09PSAwICYmICFleHRlbmRlZFpvbmUpIHtcbiAgICAgIGMgKz0gXCJaXCI7XG4gICAgfSBlbHNlIGlmIChvLm8gPCAwKSB7XG4gICAgICBjICs9IFwiLVwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKC1vLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vICUgNjApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyArPSBcIitcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gJSA2MCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHRlbmRlZFpvbmUpIHtcbiAgICBjICs9IFwiW1wiICsgby56b25lLmlhbmFOYW1lICsgXCJdXCI7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbi8vIGRlZmF1bHRzIGZvciB1bnNwZWNpZmllZCB1bml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFyc1xuY29uc3QgZGVmYXVsdFVuaXRWYWx1ZXMgPSB7XG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdFdlZWtVbml0VmFsdWVzID0ge1xuICAgIHdlZWtOdW1iZXI6IDEsXG4gICAgd2Vla2RheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcyA9IHtcbiAgICBvcmRpbmFsOiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfTtcblxuLy8gVW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnMsIHNvcnRlZCBieSBiaWduZXNzXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gIG9yZGVyZWRXZWVrVW5pdHMgPSBbXG4gICAgXCJ3ZWVrWWVhclwiLFxuICAgIFwid2Vla051bWJlclwiLFxuICAgIFwid2Vla2RheVwiLFxuICAgIFwiaG91clwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcIm1pbGxpc2Vjb25kXCIsXG4gIF0sXG4gIG9yZGVyZWRPcmRpbmFsVW5pdHMgPSBbXCJ5ZWFyXCIsIFwib3JkaW5hbFwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXTtcblxuLy8gc3RhbmRhcmRpemUgY2FzZSBhbmQgcGx1cmFsaXR5IGluIHVuaXRzXG5mdW5jdGlvbiBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICB5ZWFyOiBcInllYXJcIixcbiAgICB5ZWFyczogXCJ5ZWFyXCIsXG4gICAgbW9udGg6IFwibW9udGhcIixcbiAgICBtb250aHM6IFwibW9udGhcIixcbiAgICBkYXk6IFwiZGF5XCIsXG4gICAgZGF5czogXCJkYXlcIixcbiAgICBob3VyOiBcImhvdXJcIixcbiAgICBob3VyczogXCJob3VyXCIsXG4gICAgbWludXRlOiBcIm1pbnV0ZVwiLFxuICAgIG1pbnV0ZXM6IFwibWludXRlXCIsXG4gICAgcXVhcnRlcjogXCJxdWFydGVyXCIsXG4gICAgcXVhcnRlcnM6IFwicXVhcnRlclwiLFxuICAgIHNlY29uZDogXCJzZWNvbmRcIixcbiAgICBzZWNvbmRzOiBcInNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgd2Vla2RheTogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla2RheXM6IFwid2Vla2RheVwiLFxuICAgIHdlZWtudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtzbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrbnVtYmVyczogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3llYXI6IFwid2Vla1llYXJcIixcbiAgICB3ZWVreWVhcnM6IFwid2Vla1llYXJcIixcbiAgICBvcmRpbmFsOiBcIm9yZGluYWxcIixcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRXaXRoTG9jYWxXZWVrcyh1bml0KSB7XG4gIHN3aXRjaCAodW5pdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImxvY2Fsd2Vla2RheVwiOlxuICAgIGNhc2UgXCJsb2NhbHdlZWtkYXlzXCI6XG4gICAgICByZXR1cm4gXCJsb2NhbFdlZWtkYXlcIjtcbiAgICBjYXNlIFwibG9jYWx3ZWVrbnVtYmVyXCI6XG4gICAgY2FzZSBcImxvY2Fsd2Vla251bWJlcnNcIjpcbiAgICAgIHJldHVybiBcImxvY2FsV2Vla051bWJlclwiO1xuICAgIGNhc2UgXCJsb2NhbHdlZWt5ZWFyXCI6XG4gICAgY2FzZSBcImxvY2Fsd2Vla3llYXJzXCI6XG4gICAgICByZXR1cm4gXCJsb2NhbFdlZWtZZWFyXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBub3JtYWxpemVVbml0KHVuaXQpO1xuICB9XG59XG5cbi8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cbmZ1bmN0aW9uIHF1aWNrRFQob2JqLCBvcHRzKSB7XG4gIGNvbnN0IHpvbmUgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgIGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgIHRzTm93ID0gU2V0dGluZ3Mubm93KCk7XG5cbiAgbGV0IHRzLCBvO1xuXG4gIC8vIGFzc3VtZSB3ZSBoYXZlIHRoZSBoaWdoZXItb3JkZXIgdW5pdHNcbiAgaWYgKCFpc1VuZGVmaW5lZChvYmoueWVhcikpIHtcbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoaXNVbmRlZmluZWQob2JqW3VdKSkge1xuICAgICAgICBvYmpbdV0gPSBkZWZhdWx0VW5pdFZhbHVlc1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB8fCBoYXNJbnZhbGlkVGltZURhdGEob2JqKTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0UHJvdmlzID0gem9uZS5vZmZzZXQodHNOb3cpO1xuICAgIFt0cywgb10gPSBvYmpUb1RTKG9iaiwgb2Zmc2V0UHJvdmlzLCB6b25lKTtcbiAgfSBlbHNlIHtcbiAgICB0cyA9IHRzTm93O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IHRzLCB6b25lLCBsb2MsIG8gfSk7XG59XG5cbmZ1bmN0aW9uIGRpZmZSZWxhdGl2ZShzdGFydCwgZW5kLCBvcHRzKSB7XG4gIGNvbnN0IHJvdW5kID0gaXNVbmRlZmluZWQob3B0cy5yb3VuZCkgPyB0cnVlIDogb3B0cy5yb3VuZCxcbiAgICBmb3JtYXQgPSAoYywgdW5pdCkgPT4ge1xuICAgICAgYyA9IHJvdW5kVG8oYywgcm91bmQgfHwgb3B0cy5jYWxlbmRhcnkgPyAwIDogMiwgdHJ1ZSk7XG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBlbmQubG9jLmNsb25lKG9wdHMpLnJlbEZvcm1hdHRlcihvcHRzKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGMsIHVuaXQpO1xuICAgIH0sXG4gICAgZGlmZmVyID0gKHVuaXQpID0+IHtcbiAgICAgIGlmIChvcHRzLmNhbGVuZGFyeSkge1xuICAgICAgICBpZiAoIWVuZC5oYXNTYW1lKHN0YXJ0LCB1bml0KSkge1xuICAgICAgICAgIHJldHVybiBlbmQuc3RhcnRPZih1bml0KS5kaWZmKHN0YXJ0LnN0YXJ0T2YodW5pdCksIHVuaXQpLmdldCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCk7XG4gICAgICB9XG4gICAgfTtcblxuICBpZiAob3B0cy51bml0KSB7XG4gICAgcmV0dXJuIGZvcm1hdChkaWZmZXIob3B0cy51bml0KSwgb3B0cy51bml0KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdW5pdCBvZiBvcHRzLnVuaXRzKSB7XG4gICAgY29uc3QgY291bnQgPSBkaWZmZXIodW5pdCk7XG4gICAgaWYgKE1hdGguYWJzKGNvdW50KSA+PSAxKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChzdGFydCA+IGVuZCA/IC0wIDogMCwgb3B0cy51bml0c1tvcHRzLnVuaXRzLmxlbmd0aCAtIDFdKTtcbn1cblxuZnVuY3Rpb24gbGFzdE9wdHMoYXJnTGlzdCkge1xuICBsZXQgb3B0cyA9IHt9LFxuICAgIGFyZ3M7XG4gIGlmIChhcmdMaXN0Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXSA9PT0gXCJvYmplY3RcIikge1xuICAgIG9wdHMgPSBhcmdMaXN0W2FyZ0xpc3QubGVuZ3RoIC0gMV07XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJnTGlzdCkuc2xpY2UoMCwgYXJnTGlzdC5sZW5ndGggLSAxKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KTtcbiAgfVxuICByZXR1cm4gW29wdHMsIGFyZ3NdO1xufVxuXG4vKipcbiAqIEEgRGF0ZVRpbWUgaXMgYW4gaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIHNwZWNpZmljIGRhdGUgYW5kIHRpbWUgYW5kIGFjY29tcGFueWluZyBtZXRob2RzLiBJdCBjb250YWlucyBjbGFzcyBhbmQgaW5zdGFuY2UgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBBIERhdGVUaW1lIGNvbXByaXNlcyBvZjpcbiAqICogQSB0aW1lc3RhbXAuIEVhY2ggRGF0ZVRpbWUgaW5zdGFuY2UgcmVmZXJzIHRvIGEgc3BlY2lmaWMgbWlsbGlzZWNvbmQgb2YgdGhlIFVuaXggZXBvY2guXG4gKiAqIEEgdGltZSB6b25lLiBFYWNoIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBzcGVjaWZpYyB6b25lIChieSBkZWZhdWx0IHRoZSBsb2NhbCBzeXN0ZW0ncyB6b25lKS5cbiAqICogQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRoYXQgZWZmZWN0IGhvdyBvdXRwdXQgc3RyaW5ncyBhcmUgZm9ybWF0dGVkLCBzdWNoIGFzIGBsb2NhbGVgLCBgbnVtYmVyaW5nU3lzdGVtYCwgYW5kIGBvdXRwdXRDYWxlbmRhcmAuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgZnVuY3Rpb25hbGl0eSBpdCBwcm92aWRlczpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKjogVG8gY3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBpdHMgY29tcG9uZW50cywgdXNlIG9uZSBvZiBpdHMgZmFjdG9yeSBjbGFzcyBtZXRob2RzOiB7QGxpbmsgRGF0ZVRpbWUubG9jYWx9LCB7QGxpbmsgRGF0ZVRpbWUudXRjfSwgYW5kIChtb3N0IGZsZXhpYmx5KSB7QGxpbmsgRGF0ZVRpbWUuZnJvbU9iamVjdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIHN0YW5kYXJkIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUlTT30sIHtAbGluayBEYXRlVGltZS5mcm9tSFRUUH0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUuZnJvbVJGQzI4MjJ9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBjdXN0b20gc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tRm9ybWF0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgbmF0aXZlIEpTIGRhdGUsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUpTRGF0ZX0uXG4gKiAqICoqR3JlZ29yaWFuIGNhbGVuZGFyIGFuZCB0aW1lKio6IFRvIGV4YW1pbmUgdGhlIEdyZWdvcmlhbiBwcm9wZXJ0aWVzIG9mIGEgRGF0ZVRpbWUgaW5kaXZpZHVhbGx5IChpLmUgYXMgb3Bwb3NlZCB0byBjb2xsZWN0aXZlbHkgdGhyb3VnaCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9KSwgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjeWVhcn0sIHtAbGluayBEYXRlVGltZSNtb250aH0sXG4gKiB7QGxpbmsgRGF0ZVRpbWUjZGF5fSwge0BsaW5rIERhdGVUaW1lI2hvdXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXRlfSwge0BsaW5rIERhdGVUaW1lI3NlY29uZH0sIHtAbGluayBEYXRlVGltZSNtaWxsaXNlY29uZH0gYWNjZXNzb3JzLlxuICogKiAqKldlZWsgY2FsZW5kYXIqKjogRm9yIElTTyB3ZWVrIGNhbGVuZGFyIGF0dHJpYnV0ZXMsIHNlZSB0aGUge0BsaW5rIERhdGVUaW1lI3dlZWtZZWFyfSwge0BsaW5rIERhdGVUaW1lI3dlZWtOdW1iZXJ9LCBhbmQge0BsaW5rIERhdGVUaW1lI3dlZWtkYXl9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjbG9jYWxlfSBhbmQge0BsaW5rIERhdGVUaW1lI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKio6IFRvIHRyYW5zZm9ybSB0aGUgRGF0ZVRpbWUgaW50byBvdGhlciBEYXRlVGltZXMsIHVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0fSwge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSwge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0TG9jYWxlfSwge0BsaW5rIERhdGVUaW1lLnBsdXN9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXN9LCB7QGxpbmsgRGF0ZVRpbWUjZW5kT2Z9LCB7QGxpbmsgRGF0ZVRpbWUjc3RhcnRPZn0sIHtAbGluayBEYXRlVGltZSN0b1VUQ30sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0uXG4gKiAqICoqT3V0cHV0Kio6IFRvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZX0sIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlQ2FsZW5kYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9KU09OfSwge0BsaW5rIERhdGVUaW1lI3RvSVNPfSwge0BsaW5rIERhdGVUaW1lI3RvSFRUUH0sIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0sIHtAbGluayBEYXRlVGltZSN0b1JGQzI4MjJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9TdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9LCB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9KU0RhdGV9LlxuICpcbiAqIFRoZXJlJ3MgcGxlbnR5IG90aGVycyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiwgdGltZSB6b25lcywgYWx0ZXJuYXRpdmUgY2FsZW5kYXJzLCB2YWxpZGl0eSwgYW5kIHNvIG9uLCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVUaW1lIHtcbiAgLyoqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3Qgem9uZSA9IGNvbmZpZy56b25lIHx8IFNldHRpbmdzLmRlZmF1bHRab25lO1xuXG4gICAgbGV0IGludmFsaWQgPVxuICAgICAgY29uZmlnLmludmFsaWQgfHxcbiAgICAgIChOdW1iZXIuaXNOYU4oY29uZmlnLnRzKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGwpIHx8XG4gICAgICAoIXpvbmUuaXNWYWxpZCA/IHVuc3VwcG9ydGVkWm9uZSh6b25lKSA6IG51bGwpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHMgPSBpc1VuZGVmaW5lZChjb25maWcudHMpID8gU2V0dGluZ3Mubm93KCkgOiBjb25maWcudHM7XG5cbiAgICBsZXQgYyA9IG51bGwsXG4gICAgICBvID0gbnVsbDtcbiAgICBpZiAoIWludmFsaWQpIHtcbiAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IGNvbmZpZy5vbGQgJiYgY29uZmlnLm9sZC50cyA9PT0gdGhpcy50cyAmJiBjb25maWcub2xkLnpvbmUuZXF1YWxzKHpvbmUpO1xuXG4gICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgIFtjLCBvXSA9IFtjb25maWcub2xkLmMsIGNvbmZpZy5vbGQub107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvdCA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjID0gdHNUb09iaih0aGlzLnRzLCBvdCk7XG4gICAgICAgIGludmFsaWQgPSBOdW1iZXIuaXNOYU4oYy55ZWFyKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGw7XG4gICAgICAgIGMgPSBpbnZhbGlkID8gbnVsbCA6IGM7XG4gICAgICAgIG8gPSBpbnZhbGlkID8gbnVsbCA6IG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3pvbmUgPSB6b25lO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndlZWtEYXRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsV2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYyA9IGM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vID0gbztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EYXRlVGltZSA9IHRydWU7XG4gIH1cblxuICAvLyBDT05TVFJVQ1RcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZm9yIHRoZSBjdXJyZW50IGluc3RhbnQsIGluIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFVzZSBTZXR0aW5ncyB0byBvdmVycmlkZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWVkZWQuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy9+PiBub3cgaW4gdGhlIElTTyBmb3JtYXRcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2FsIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYGxvY2FsKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCh7IHpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiIH0pICAgICAgLy9+PiBub3csIGluIFVTIGVhc3QgY29hc3QgdGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwLCB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgeyB6b25lOiBcInV0Y1wiIH0pICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwLCBpbiBVVENcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGxvY2FsKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgaW4gVVRDXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYHV0YygpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1WiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyB1dGMoKSB7XG4gICAgY29uc3QgW29wdHMsIGFyZ3NdID0gbGFzdE9wdHMoYXJndW1lbnRzKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdID0gYXJncztcblxuICAgIG9wdHMuem9uZSA9IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICByZXR1cm4gcXVpY2tEVCh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdC4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgLSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUpTRGF0ZShkYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0cyA9IGlzRGF0ZShkYXRlKSA/IGRhdGUudmFsdWVPZigpIDogTmFOO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odHMpKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcImludmFsaWQgaW5wdXRcIik7XG4gICAgfVxuXG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoIXpvbmVUb1VzZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZVRvVXNlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICB0czogdHMsXG4gICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXNlY29uZHMgLSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIobWlsbGlzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgZnJvbU1pbGxpcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dCwgYnV0IHJlY2VpdmVkIGEgJHt0eXBlb2YgbWlsbGlzZWNvbmRzfSB3aXRoIHZhbHVlICR7bWlsbGlzZWNvbmRzfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZHMgPCAtTUFYX0RBVEUgfHwgbWlsbGlzZWNvbmRzID4gTUFYX0RBVEUpIHtcbiAgICAgIC8vIHRoaXMgaXNuJ3QgcGVyZmVjdCBiZWNhdXNlIGJlY2F1c2Ugd2UgY2FuIHN0aWxsIGVuZCB1cCBvdXQgb2YgcmFuZ2UgYmVjYXVzZSBvZiBhZGRpdGlvbmFsIHNoaWZ0aW5nLCBidXQgaXQncyBhIHN0YXJ0XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcIlRpbWVzdGFtcCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogbWlsbGlzZWNvbmRzLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kcyAtIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNlY29uZHMoc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbVNlY29uZHMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogc2Vjb25kcyAqIDEwMDAsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFyJyBhbmQgJ2hvdXInIHdpdGggcmVhc29uYWJsZSBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhciAtIGEgeWVhciwgc3VjaCBhcyAxOTg3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGggLSBhIG1vbnRoLCAxLTEyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5IC0gYSBkYXkgb2YgdGhlIG1vbnRoLCAxLTMxLCBkZXBlbmRpbmcgb24gdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoub3JkaW5hbCAtIGRheSBvZiB0aGUgeWVhciwgMS0zNjUgb3IgMzY2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla1llYXIgLSBhbiBJU08gd2VlayB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla051bWJlciAtIGFuIElTTyB3ZWVrIG51bWJlciwgYmV0d2VlbiAxIGFuZCA1MiBvciA1MywgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla2RheSAtIGFuIElTTyB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmxvY2FsV2Vla1llYXIgLSBhIHdlZWsgeWVhciwgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5sb2NhbFdlZWtOdW1iZXIgLSBhIHdlZWsgbnVtYmVyLCBiZXR3ZWVuIDEgYW5kIDUyIG9yIDUzLCBkZXBlbmRpbmcgb24gdGhlIHllYXIsIGFjY29yZGluZyB0byB0aGUgbG9jYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubG9jYWxXZWVrZGF5IC0gYSB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgdGhlIGZpcnN0IGFuZCA3IGlzIHRoZSBsYXN0IGRheSBvZiB0aGUgd2VlaywgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3VyIC0gaG91ciBvZiB0aGUgZGF5LCAwLTIzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlIC0gbWludXRlIG9mIHRoZSBob3VyLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kIC0gc2Vjb25kIG9mIHRoZSBtaW51dGUsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZCAtIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIDAtOTk5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gaW50ZXJwcmV0IHRoZSBudW1iZXJzIGluIHRoZSBjb250ZXh0IG9mIGEgcGFydGljdWxhciB6b25lLiBDYW4gdGFrZSBhbnkgdmFsdWUgdGFrZW4gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHNldFpvbmUoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW1cXCdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyLCBtb250aDogNSwgZGF5OiAyNX0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0pIC8vfj4gdG9kYXkgYXQgMTA6MjY6MDZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAndXRjJyB9KSxcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnbG9jYWwnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB3ZWVrWWVhcjogMjAxNiwgd2Vla051bWJlcjogMiwgd2Vla2RheTogMyB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDE2LTAxLTEzJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgbG9jYWxXZWVrWWVhcjogMjAyMiwgbG9jYWxXZWVrTnVtYmVyOiAxLCBsb2NhbFdlZWtkYXk6IDEgfSwgeyBsb2NhbGU6IFwiZW4tVVNcIiB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDIxLTEyLTI2J1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgb2JqID0gb2JqIHx8IHt9O1xuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVVbml0V2l0aExvY2FsV2Vla3MpO1xuICAgIGNvbnN0IHsgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlayB9ID0gdXNlc0xvY2FsV2Vla1ZhbHVlcyhub3JtYWxpemVkLCBsb2MpO1xuXG4gICAgY29uc3QgdHNOb3cgPSBTZXR0aW5ncy5ub3coKSxcbiAgICAgIG9mZnNldFByb3ZpcyA9ICFpc1VuZGVmaW5lZChvcHRzLnNwZWNpZmljT2Zmc2V0KVxuICAgICAgICA/IG9wdHMuc3BlY2lmaWNPZmZzZXRcbiAgICAgICAgOiB6b25lVG9Vc2Uub2Zmc2V0KHRzTm93KSxcbiAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgY29udGFpbnNHcmVnb3JZZWFyID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQueWVhciksXG4gICAgICBjb250YWluc0dyZWdvck1EID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQubW9udGgpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSksXG4gICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgZGVmaW5pdGVXZWVrRGVmID0gbm9ybWFsaXplZC53ZWVrWWVhciB8fCBub3JtYWxpemVkLndlZWtOdW1iZXI7XG5cbiAgICAvLyBjYXNlczpcbiAgICAvLyBqdXN0IGEgd2Vla2RheSAtPiB0aGlzIHdlZWsncyBpbnN0YW5jZSBvZiB0aGF0IHdlZWtkYXksIG5vIHdvcnJpZXNcbiAgICAvLyAoZ3JlZ29yaWFuIGRhdGEgb3Igb3JkaW5hbCkgKyAod2Vla1llYXIgb3Igd2Vla051bWJlcikgLT4gZXJyb3JcbiAgICAvLyAoZ3JlZ29yaWFuIG1vbnRoIG9yIGRheSkgKyBvcmRpbmFsIC0+IGVycm9yXG4gICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXNlIHdlZWtzIG9yIG9yZGluYWxzIG9yIGdyZWdvcmlhbiwgZGVwZW5kaW5nIG9uIHdoYXQncyBzcGVjaWZpZWRcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VXZWVrRGF0YSA9IGRlZmluaXRlV2Vla0RlZiB8fCAobm9ybWFsaXplZC53ZWVrZGF5ICYmICFjb250YWluc0dyZWdvcik7XG5cbiAgICAvLyBjb25maWd1cmUgb3Vyc2VsdmVzIHRvIGRlYWwgd2l0aCBncmVnb3JpYW4gZGF0ZXMgb3Igd2VlayBzdHVmZlxuICAgIGxldCB1bml0cyxcbiAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICBvYmpOb3cgPSB0c1RvT2JqKHRzTm93LCBvZmZzZXRQcm92aXMpO1xuICAgIGlmICh1c2VXZWVrRGF0YSkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkV2Vla1VuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRXZWVrVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvV2VlayhvYmpOb3csIG1pbkRheXNJbkZpcnN0V2Vlaywgc3RhcnRPZldlZWspO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRPcmRpbmFsVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9PcmRpbmFsKG9iak5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRVbml0VmFsdWVzO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlcyBmb3IgbWlzc2luZyBzdHVmZlxuICAgIGxldCBmb3VuZEZpcnN0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB1IG9mIHVuaXRzKSB7XG4gICAgICBjb25zdCB2ID0gbm9ybWFsaXplZFt1XTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQodikpIHtcbiAgICAgICAgZm91bmRGaXJzdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRmlyc3QpIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IGRlZmF1bHRWYWx1ZXNbdV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gb2JqTm93W3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdmFsdWVzIHdlIGhhdmUgYXJlIGluIHJhbmdlXG4gICAgY29uc3QgaGlnaGVyT3JkZXJJbnZhbGlkID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyBoYXNJbnZhbGlkV2Vla0RhdGEobm9ybWFsaXplZCwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaylcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShub3JtYWxpemVkKSxcbiAgICAgIGludmFsaWQgPSBoaWdoZXJPcmRlckludmFsaWQgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgdGhlIGFjdHVhbCB0aW1lXG4gICAgY29uc3QgZ3JlZ29yaWFuID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyB3ZWVrVG9HcmVnb3JpYW4obm9ybWFsaXplZCwgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlaylcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBvcmRpbmFsVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBub3JtYWxpemVkLFxuICAgICAgW3RzRmluYWwsIG9mZnNldEZpbmFsXSA9IG9ialRvVFMoZ3JlZ29yaWFuLCBvZmZzZXRQcm92aXMsIHpvbmVUb1VzZSksXG4gICAgICBpbnN0ID0gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHRzRmluYWwsXG4gICAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgICAgbzogb2Zmc2V0RmluYWwsXG4gICAgICAgIGxvYyxcbiAgICAgIH0pO1xuXG4gICAgLy8gZ3JlZ29yaWFuIGRhdGEgKyB3ZWVrZGF5IHNlcnZlcyBvbmx5IHRvIHZhbGlkYXRlXG4gICAgaWYgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiBjb250YWluc0dyZWdvciAmJiBvYmoud2Vla2RheSAhPT0gaW5zdC53ZWVrZGF5KSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgICAgXCJtaXNtYXRjaGVkIHdlZWtkYXlcIixcbiAgICAgICAgYHlvdSBjYW4ndCBzcGVjaWZ5IGJvdGggYSB3ZWVrZGF5IG9mICR7bm9ybWFsaXplZC53ZWVrZGF5fSBhbmQgYSBkYXRlIG9mICR7aW5zdC50b0lTTygpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBJU08gODYwMSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcsIHtzZXRab25lOiB0cnVlfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnLCB7em9uZTogJ3V0Yyd9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LVcwNS00JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUlTT0RhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJJU08gODYwMVwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSB0aGUgb2Zmc2V0IGlzIGFsd2F5cyBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMzoxMiBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignRnJpLCAyNSBOb3YgMjAxNiAxMzoyMzoxMiArMDYwMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMyBaJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVJGQzI4MjIodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VSRkMyODIyRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlJGQyAyODIyXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgSFRUUCBkYXRlcyBhcmUgYWx3YXlzIGluIFVUQywgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggdGhlIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nLiBGb3IgSFRUUCBkYXRlcywgdGhpcyBpcyBhbHdheXMgVVRDLCBzbyB0aGlzIG9wdGlvbiBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgdGhlIGB6b25lYCBvcHRpb24gdG8gJ3V0YycsIGJ1dCB0aGlzIG9wdGlvbiBpcyBpbmNsdWRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBzaW1pbGFyIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4sIDA2IE5vdiAxOTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW5kYXksIDA2LU5vdi05NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuIE5vdiAgNiAwODo0OTozNyAxOTk0JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUhUVFAodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VIVFRQRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIkhUVFBcIiwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBpbnB1dCBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmcuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvcGFyc2luZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIHRoZSBsaW5rIGJlbG93IGZvciB0aGUgZm9ybWF0cylcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSB8fCBpc1VuZGVmaW5lZChmbXQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tRm9ybWF0IHJlcXVpcmVzIGFuIGlucHV0IHN0cmluZyBhbmQgYSBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRzLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KSxcbiAgICAgIFt2YWxzLCBwYXJzZWRab25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZF0gPSBwYXJzZUZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBgZm9ybWF0ICR7Zm10fWAsIHRleHQsIHNwZWNpZmljT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXQgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBTUUwgZGF0ZSwgdGltZSwgb3IgZGF0ZXRpbWVcbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycsIHsgc2V0Wm9uZTogdHJ1ZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicsIHsgem9uZTogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzA5OjEyOjM0LjM0MicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TUUwodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VTUUwodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJTUUxcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIERhdGVUaW1lIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRlVGltZUVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIERhdGVUaW1lLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNEYXRlVGltZShvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkRhdGVUaW1lKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSBmb3JtYXQgc3RyaW5nIGZvciBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzXG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VGb3JtYXRGb3JPcHRzKGZvcm1hdE9wdHMsIGxvY2FsZU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRva2VuTGlzdCA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBMb2NhbGUuZnJvbU9iamVjdChsb2NhbGVPcHRzKSk7XG4gICAgcmV0dXJuICF0b2tlbkxpc3QgPyBudWxsIDogdG9rZW5MaXN0Lm1hcCgodCkgPT4gKHQgPyB0LnZhbCA6IG51bGwpKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIHRoZSBmdWxseSBleHBhbmRlZCBmb3JtYXQgdG9rZW4gZm9yIHRoZSBsb2NhbGVcbiAgICogRG9lcyBOT1QgcXVvdGUgY2hhcmFjdGVycywgc28gcXVvdGVkIHRva2VucyB3aWxsIG5vdCByb3VuZCB0cmlwIGNvcnJlY3RseVxuICAgKiBAcGFyYW0gZm10XG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZXhwYW5kRm9ybWF0KGZtdCwgbG9jYWxlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSwgTG9jYWxlLmZyb21PYmplY3QobG9jYWxlT3B0cykpO1xuICAgIHJldHVybiBleHBhbmRlZC5tYXAoKHQpID0+IHQudmFsKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgLy8gSU5GT1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdtb250aCcpOyAvLz0+IDdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdkYXknKTsgLy89PiA0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbdW5pdF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyB2YWxpZC4gSW52YWxpZCBEYXRlVGltZXMgb2NjdXIgd2hlbjpcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgZnJvbSBpbnZhbGlkIGNhbGVuZGFyIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSAxM3RoIG1vbnRoIG9yIEZlYnJ1YXJ5IDMwXG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGJ5IGFuIG9wZXJhdGlvbiBvbiBhbm90aGVyIGludmFsaWQgZGF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIERhdGVUaW1lIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvY2FsZSBvZiBhIERhdGVUaW1lLCBzdWNoICdlbi1HQicuIFRoZSBsb2NhbGUgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5sb2NhbGUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIERhdGVUaW1lLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3V0cHV0IGNhbGVuZGFyIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2lzbGFtaWMnLiBUaGUgb3V0cHV0IGNhbGVuZGFyIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aW1lIHpvbmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgZ2V0IHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgem9uZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5uYW1lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnllYXIgLy89PiAyMDE3XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnllYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5xdWFydGVyIC8vPT4gMlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IE1hdGguY2VpbCh0aGlzLmMubW9udGggLyAzKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoICgxLTEyKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm1vbnRoIC8vPT4gNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubW9udGggOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIG1vbnRoICgxLTMwaXNoKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLmRheSAvLz0+IDI1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91ciBvZiB0aGUgZGF5ICgwLTIzKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDkpLmhvdXIgLy89PiA5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmhvdXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGUgb2YgdGhlIGhvdXIgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzApLm1pbnV0ZSAvLz0+IDMwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWludXRlIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kIG9mIHRoZSBtaW51dGUgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyKS5zZWNvbmQgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQgKDAtOTk5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1MiwgNjU0KS5taWxsaXNlY29uZCAvLz0+IDY1NFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWlsbGlzZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDEyLCAzMSkud2Vla1llYXIgLy89PiAyMDE1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla1llYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyICgxLTUyaXNoKS5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS53ZWVrTnVtYmVyIC8vPT4gMjFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTEsIDMxKS53ZWVrZGF5IC8vPT4gNFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla2RheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkYXRlIGlzIG9uIGEgd2Vla2VuZCBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzV2Vla2VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkICYmIHRoaXMubG9jLmdldFdlZWtlbmREYXlzKCkuaW5jbHVkZXModGhpcy53ZWVrZGF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2VlayBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZS5cbiAgICogMSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGFuZCA3IGlzIHRoZSBsYXN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICogSWYgdGhlIGxvY2FsZSBhc3NpZ25zIFN1bmRheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCB0aGVuIGEgZGF0ZSB3aGljaCBpcyBhIFN1bmRheSB3aWxsIHJldHVybiAxLFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxvY2FsV2Vla2RheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRMb2NhbFdlZWtEYXRhKHRoaXMpLndlZWtkYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyIGFjY29yZGluZyB0byB0aGUgbG9jYWxlLiBEaWZmZXJlbnQgbG9jYWxlcyBhc3NpZ24gd2VlayBudW1iZXJzIGRpZmZlcmVudGx5LFxuICAgKiBiZWNhdXNlIHRoZSB3ZWVrIGNhbiBzdGFydCBvbiBkaWZmZXJlbnQgZGF5cyBvZiB0aGUgd2VlayAoc2VlIGxvY2FsV2Vla2RheSkgYW5kIGJlY2F1c2UgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGRheXNcbiAgICogaXMgcmVxdWlyZWQgZm9yIGEgd2VlayB0byBjb3VudCBhcyB0aGUgZmlyc3Qgd2VlayBvZiBhIHllYXIuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbG9jYWxXZWVrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZExvY2FsV2Vla0RhdGEodGhpcykud2Vla051bWJlciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgeWVhciBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZS4gRGlmZmVyZW50IGxvY2FsZXMgYXNzaWduIHdlZWsgbnVtYmVycyAoYW5kIHRoZXJlZm9yIHdlZWsgeWVhcnMpXG4gICAqIGRpZmZlcmVudGx5LCBzZWUgbG9jYWxXZWVrTnVtYmVyLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxvY2FsV2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkTG9jYWxXZWVrRGF0YSh0aGlzKS53ZWVrWWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yZGluYWwgKG1lYW5pbmcgdGhlIGRheSBvZiB0aGUgeWVhcilcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm9yZGluYWwgLy89PiAxNDVcbiAgICogQHR5cGUge251bWJlcnxEYXRlVGltZX1cbiAgICovXG4gIGdldCBvcmRpbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKS5vcmRpbmFsIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhTaG9ydCAvLz0+IE9jdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdG9iZXInLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aExvbmcgLy89PiBPY3RvYmVyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCB3ZWVrZGF5LCBzdWNoIGFzICdNb24nLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5U2hvcnQgLy89PiBNb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5U2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyB3ZWVrZGF5LCBzdWNoIGFzICdNb25kYXknLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5TG9uZyAvLz0+IE1vbmRheVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVRDIG9mZnNldCBvZiB0aGlzIERhdGVUaW1lIGluIG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkub2Zmc2V0IC8vPT4gLTI0MFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5vZmZzZXQgLy89PiAwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyArdGhpcy5vIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2hvcnQgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFU1RcIiBvciBcIkVEVFwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lU2hvcnQoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcInNob3J0XCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9uZyBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVhc3Rlcm4gU3RhbmRhcmQgVGltZVwiIG9yIFwiRWFzdGVybiBEYXlsaWdodCBUaW1lXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVMb25nKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJsb25nXCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoaXMgem9uZSdzIG9mZnNldCBldmVyIGNoYW5nZXMsIGFzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc09mZnNldEZpeGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUuaXNVbml2ZXJzYWwgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkRTVCgpIHtcbiAgICBpZiAodGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoeyBtb250aDogMSwgZGF5OiAxIH0pLm9mZnNldCB8fFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDUgfSkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhvc2UgRGF0ZVRpbWVzIHdoaWNoIGhhdmUgdGhlIHNhbWUgbG9jYWwgdGltZSBhcyB0aGlzIERhdGVUaW1lLCBidXQgYSBkaWZmZXJlbnQgb2Zmc2V0IGZyb20gVVRDXG4gICAqIGluIHRoaXMgRGF0ZVRpbWUncyB6b25lLiBEdXJpbmcgRFNUIGNoYW5nZXMgbG9jYWwgdGltZSBjYW4gYmUgYW1iaWd1b3VzLCBmb3IgZXhhbXBsZVxuICAgKiBgMjAyMy0xMC0yOVQwMjozMDowMGAgaW4gYEV1cm9wZS9CZXJsaW5gIGNhbiBoYXZlIG9mZnNldCBgKzAxOjAwYCBvciBgKzAyOjAwYC5cbiAgICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYm90aCBwb3NzaWJsZSBEYXRlVGltZXMgaWYgdGhpcyBEYXRlVGltZSdzIGxvY2FsIHRpbWUgaXMgYW1iaWd1b3VzLlxuICAgKiBAcmV0dXJucyB7RGF0ZVRpbWVbXX1cbiAgICovXG4gIGdldFBvc3NpYmxlT2Zmc2V0cygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCB0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIGNvbnN0IGRheU1zID0gODY0MDAwMDA7XG4gICAgY29uc3QgbWludXRlTXMgPSA2MDAwMDtcbiAgICBjb25zdCBsb2NhbFRTID0gb2JqVG9Mb2NhbFRTKHRoaXMuYyk7XG4gICAgY29uc3Qgb0VhcmxpZXIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBkYXlNcyk7XG4gICAgY29uc3Qgb0xhdGVyID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTICsgZGF5TXMpO1xuXG4gICAgY29uc3QgbzEgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBvRWFybGllciAqIG1pbnV0ZU1zKTtcbiAgICBjb25zdCBvMiA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyAtIG9MYXRlciAqIG1pbnV0ZU1zKTtcbiAgICBpZiAobzEgPT09IG8yKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBjb25zdCB0czEgPSBsb2NhbFRTIC0gbzEgKiBtaW51dGVNcztcbiAgICBjb25zdCB0czIgPSBsb2NhbFRTIC0gbzIgKiBtaW51dGVNcztcbiAgICBjb25zdCBjMSA9IHRzVG9PYmoodHMxLCBvMSk7XG4gICAgY29uc3QgYzIgPSB0c1RvT2JqKHRzMiwgbzIpO1xuICAgIGlmIChcbiAgICAgIGMxLmhvdXIgPT09IGMyLmhvdXIgJiZcbiAgICAgIGMxLm1pbnV0ZSA9PT0gYzIubWludXRlICYmXG4gICAgICBjMS5zZWNvbmQgPT09IGMyLnNlY29uZCAmJlxuICAgICAgYzEubWlsbGlzZWNvbmQgPT09IGMyLm1pbGxpc2Vjb25kXG4gICAgKSB7XG4gICAgICByZXR1cm4gW2Nsb25lKHRoaXMsIHsgdHM6IHRzMSB9KSwgY2xvbmUodGhpcywgeyB0czogdHMyIH0pXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0aGlzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbiBhIGxlYXAgeWVhciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmlzSW5MZWFwWWVhciAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuaXNJbkxlYXBZZWFyIC8vPT4gZmFsc2VcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkxlYXBZZWFyKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIG1vbnRoXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDIpLmRheXNJbk1vbnRoIC8vPT4gMjlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMykuZGF5c0luTW9udGggLy89PiAzMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmRheXNJblllYXIgLy89PiAzNjZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuZGF5c0luWWVhciAvLz0+IDM2NVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGRheXNJblllYXIodGhpcy55ZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMDQpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbldlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB3ZWVrc0luV2Vla1llYXIodGhpcy53ZWVrWWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoaXMgRGF0ZVRpbWUncyBsb2NhbCB3ZWVrIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAyMCwgNiwge2xvY2FsZTogJ2VuLVVTJ30pLndlZWtzSW5Mb2NhbFdlZWtZZWFyIC8vPT4gNTJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAyMCwgNiwge2xvY2FsZTogJ2RlLURFJ30pLndlZWtzSW5Mb2NhbFdlZWtZZWFyIC8vPT4gNTNcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrc0luTG9jYWxXZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IHdlZWtzSW5XZWVrWWVhcihcbiAgICAgICAgICB0aGlzLmxvY2FsV2Vla1llYXIsXG4gICAgICAgICAgdGhpcy5sb2MuZ2V0TWluRGF5c0luRmlyc3RXZWVrKCksXG4gICAgICAgICAgdGhpcy5sb2MuZ2V0U3RhcnRPZldlZWsoKVxuICAgICAgICApXG4gICAgICA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHZlZCBJbnRsIG9wdGlvbnMgZm9yIHRoaXMgRGF0ZVRpbWUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGluIHVuZGVyc3RhbmRpbmcgdGhlIGJlaGF2aW9yIG9mIGZvcm1hdHRpbmcgbWV0aG9kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHRoZSBzYW1lIG9wdGlvbnMgYXMgdG9Mb2NhbGVTdHJpbmdcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgcmVzb2x2ZWRMb2NhbGVPcHRpb25zKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyIH0gPSBGb3JtYXR0ZXIuY3JlYXRlKFxuICAgICAgdGhpcy5sb2MuY2xvbmUob3B0cyksXG4gICAgICBvcHRzXG4gICAgKS5yZXNvbHZlZE9wdGlvbnModGhpcyk7XG4gICAgcmV0dXJuIHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyOiBjYWxlbmRhciB9O1xuICB9XG5cbiAgLy8gVFJBTlNGT1JNXG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBVVEMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0oJ3V0YycpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gb3B0aW9uYWxseSwgYW4gb2Zmc2V0IGZyb20gVVRDIGluIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIG9wdGlvbnMgdG8gcGFzcyB0byBgc2V0Wm9uZSgpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHRvVVRDKG9mZnNldCA9IDAsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnNldFpvbmUoRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKG9mZnNldCksIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byB0aGUgaG9zdCdzIGxvY2FsIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogRXF1aXZhbGVudCB0byBgc2V0Wm9uZSgnbG9jYWwnKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b0xvY2FsKCkge1xuICAgIHJldHVybiB0aGlzLnNldFpvbmUoU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBzcGVjaWZpZWQgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgc2V0dGVyIGtlZXBzIHRoZSB1bmRlcmx5aW5nIHRpbWUgdGhlIHNhbWUgKGFzIGluLCB0aGUgc2FtZSB0aW1lc3RhbXApLCBidXQgdGhlIG5ldyBpbnN0YW5jZSB3aWxsIHJlcG9ydCBkaWZmZXJlbnQgbG9jYWwgdGltZXMgYW5kIGNvbnNpZGVyIERTVHMgd2hlbiBtYWtpbmcgY29tcHV0YXRpb25zLCBhcyB3aXRoIHtAbGluayBEYXRlVGltZSNwbHVzfS4gWW91IG1heSB3aXNoIHRvIHVzZSB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0gYW5kIHtAbGluayBEYXRlVGltZSN0b1VUQ30gd2hpY2ggcHJvdmlkZSBzaW1wbGUgY29udmVuaWVuY2Ugd3JhcHBlcnMgZm9yIGNvbW1vbmx5IHVzZWQgem9uZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gYSB6b25lIGlkZW50aWZpZXIuIEFzIGEgc3RyaW5nLCB0aGF0IGNhbiBiZSBhbnkgSUFOQSB6b25lIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBlbnZpcm9ubWVudCwgb3IgYSBmaXhlZC1vZmZzZXQgbmFtZSBvZiB0aGUgZm9ybSAnVVRDKzMnLCBvciB0aGUgc3RyaW5ncyAnbG9jYWwnIG9yICd1dGMnLiBZb3UgbWF5IGFsc28gc3VwcGx5IGFuIGluc3RhbmNlIG9mIGEge0BsaW5rIERhdGVUaW1lI1pvbmV9IGNsYXNzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5rZWVwTG9jYWxUaW1lPWZhbHNlXSAtIElmIHRydWUsIGFkanVzdCB0aGUgdW5kZXJseWluZyB0aW1lIHNvIHRoYXQgdGhlIGxvY2FsIHRpbWUgc3RheXMgdGhlIHNhbWUsIGJ1dCBpbiB0aGUgdGFyZ2V0IHpvbmUuIFlvdSBzaG91bGQgcmFyZWx5IG5lZWQgdGhpcy5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRab25lKHpvbmUsIHsga2VlcExvY2FsVGltZSA9IGZhbHNlLCBrZWVwQ2FsZW5kYXJUaW1lID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgem9uZSA9IG5vcm1hbGl6ZVpvbmUoem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLnpvbmUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKCF6b25lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdUUyA9IHRoaXMudHM7XG4gICAgICBpZiAoa2VlcExvY2FsVGltZSB8fCBrZWVwQ2FsZW5kYXJUaW1lKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldEd1ZXNzID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGNvbnN0IGFzT2JqID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgICBbbmV3VFNdID0gb2JqVG9UUyhhc09iaiwgb2Zmc2V0R3Vlc3MsIHpvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdHM6IG5ld1RTLCB6b25lIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3Igb3V0cHV0Q2FsZW5kYXIuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSB0aGUgcHJvcGVydGllcyB0byBzZXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcmVjb25maWd1cmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIgfSA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gdGhpcy5sb2MuY2xvbmUoeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIgfSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgbG9jIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBKdXN0IGEgY29udmVuaWVudCBhbGlhcyBmb3IgcmVjb25maWd1cmUoeyBsb2NhbGUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnNldExvY2FsZSgnZW4tR0InKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbmZpZ3VyZSh7IGxvY2FsZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIFlvdSBjYW4gb25seSBzZXQgdW5pdHMgd2l0aCB0aGlzIG1ldGhvZDsgZm9yIFwic2V0dGluZ1wiIG1ldGFkYXRhLCBzZWUge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSBhbmQge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhbHNvIHN1cHBvcnRzIHNldHRpbmcgbG9jYWxlLWJhc2VkIHdlZWsgdW5pdHMsIGkuZS4gYGxvY2FsV2Vla2RheWAsIGBsb2NhbFdlZWtOdW1iZXJgIGFuZCBgbG9jYWxXZWVrWWVhcmAuXG4gICAqIFRoZXkgY2Fubm90IGJlIG1peGVkIHdpdGggSVNPLXdlZWsgdW5pdHMgbGlrZSBgd2Vla2RheWAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBhIG1hcHBpbmcgb2YgdW5pdHMgdG8gbnVtYmVyc1xuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IGhvdXI6IDgsIG1pbnV0ZTogMzAgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgd2Vla2RheTogNSB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDA1LCBvcmRpbmFsOiAyMzQgfSlcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdCh2YWx1ZXMsIG5vcm1hbGl6ZVVuaXRXaXRoTG9jYWxXZWVrcyk7XG4gICAgY29uc3QgeyBtaW5EYXlzSW5GaXJzdFdlZWssIHN0YXJ0T2ZXZWVrIH0gPSB1c2VzTG9jYWxXZWVrVmFsdWVzKG5vcm1hbGl6ZWQsIHRoaXMubG9jKTtcblxuICAgIGNvbnN0IHNldHRpbmdXZWVrU3R1ZmYgPVxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrWWVhcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla051bWJlcikgfHxcbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla2RheSksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyO1xuXG4gICAgaWYgKChjb250YWluc0dyZWdvciB8fCBjb250YWluc09yZGluYWwpICYmIGRlZmluaXRlV2Vla0RlZikge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IG1peCB3ZWVrWWVhci93ZWVrTnVtYmVyIHVuaXRzIHdpdGggeWVhci9tb250aC9kYXkgb3Igb3JkaW5hbHNcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnNHcmVnb3JNRCAmJiBjb250YWluc09yZGluYWwpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcIkNhbid0IG1peCBvcmRpbmFsIGRhdGVzIHdpdGggbW9udGgvZGF5XCIpO1xuICAgIH1cblxuICAgIGxldCBtaXhlZDtcbiAgICBpZiAoc2V0dGluZ1dlZWtTdHVmZikge1xuICAgICAgbWl4ZWQgPSB3ZWVrVG9HcmVnb3JpYW4oXG4gICAgICAgIHsgLi4uZ3JlZ29yaWFuVG9XZWVrKHRoaXMuYywgbWluRGF5c0luRmlyc3RXZWVrLCBzdGFydE9mV2VlayksIC4uLm5vcm1hbGl6ZWQgfSxcbiAgICAgICAgbWluRGF5c0luRmlyc3RXZWVrLFxuICAgICAgICBzdGFydE9mV2Vla1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpKSB7XG4gICAgICBtaXhlZCA9IG9yZGluYWxUb0dyZWdvcmlhbih7IC4uLmdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLCAuLi5ub3JtYWxpemVkIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaXhlZCA9IHsgLi4udGhpcy50b09iamVjdCgpLCAuLi5ub3JtYWxpemVkIH07XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBzZXQgdGhlIGRheSBidXQgd2UgZW5kZWQgdXAgb24gYW4gb3ZlcmZsb3cgZGF0ZSxcbiAgICAgIC8vIHVzZSB0aGUgbGFzdCBkYXkgb2YgdGhlIHJpZ2h0IG1vbnRoXG4gICAgICBpZiAoaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpKSB7XG4gICAgICAgIG1peGVkLmRheSA9IE1hdGgubWluKGRheXNJbk1vbnRoKG1peGVkLnllYXIsIG1peGVkLm1vbnRoKSwgbWl4ZWQuZGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBbdHMsIG9dID0gb2JqVG9UUyhtaXhlZCwgdGhpcy5vLCB0aGlzLnpvbmUpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzLCBvIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqXG4gICAqIEFkZGluZyBob3VycywgbWludXRlcywgc2Vjb25kcywgb3IgbWlsbGlzZWNvbmRzIGluY3JlYXNlcyB0aGUgdGltZXN0YW1wIGJ5IHRoZSByaWdodCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLiBBZGRpbmcgZGF5cywgbW9udGhzLCBvciB5ZWFycyBzaGlmdHMgdGhlIGNhbGVuZGFyLCBhY2NvdW50aW5nIGZvciBEU1RzIGFuZCBsZWFwIHllYXJzIGFsb25nIHRoZSB3YXkuIFRodXMsIGBkdC5wbHVzKHsgaG91cnM6IDI0IH0pYCBtYXkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHRpbWUgdGhhbiBgZHQucGx1cyh7IGRheXM6IDEgfSlgIGlmIHRoZXJlJ3MgYSBEU1Qgc2hpZnQgaW4gYmV0d2Vlbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKDEyMykgLy9+PiBpbiAxMjMgbWlsbGlzZWNvbmRzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBtaW51dGVzOiAxNSB9KSAvL34+IGluIDE1IG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkgLy9+PiB0aGlzIHRpbWUgdG9tb3Jyb3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IC0xIH0pIC8vfj4gdGhpcyB0aW1lIHllc3RlcmRheVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgaG91cnM6IDMsIG1pbnV0ZXM6IDEzIH0pIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0IGEgcGVyaW9kIG9mIHRpbWUgdG8gdGhpcyBEYXRlVGltZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVcbiAgICogU2VlIHtAbGluayBEYXRlVGltZSNwbHVzfVxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbikubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIGFkanVzdFRpbWUodGhpcywgZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSB1bml0IG9mIHRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGJlZ2lubmluZyBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudXNlTG9jYWxlV2Vla3M9ZmFsc2VdIC0gSWYgdHJ1ZSwgdXNlIHdlZWtzIGJhc2VkIG9uIHRoZSBsb2NhbGUsIGkuZS4gdXNlIHRoZSBsb2NhbGUtZGVwZW5kZW50IHN0YXJ0IG9mIHRoZSB3ZWVrXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ21vbnRoJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3llYXInKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignd2VlaycpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAzJywgd2Vla3MgYWx3YXlzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2RheScpLnRvSVNPVGltZSgpOyAvLz0+ICcwMDowMC4wMDAtMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdob3VyJykudG9JU09UaW1lKCk7IC8vPT4gJzA1OjAwOjAwLjAwMC0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGFydE9mKHVuaXQsIHsgdXNlTG9jYWxlV2Vla3MgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBvID0ge30sXG4gICAgICBub3JtYWxpemVkVW5pdCA9IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCk7XG4gICAgc3dpdGNoIChub3JtYWxpemVkVW5pdCkge1xuICAgICAgY2FzZSBcInllYXJzXCI6XG4gICAgICAgIG8ubW9udGggPSAxO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInF1YXJ0ZXJzXCI6XG4gICAgICBjYXNlIFwibW9udGhzXCI6XG4gICAgICAgIG8uZGF5ID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJ3ZWVrc1wiOlxuICAgICAgY2FzZSBcImRheXNcIjpcbiAgICAgICAgby5ob3VyID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJob3Vyc1wiOlxuICAgICAgICBvLm1pbnV0ZSA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwibWludXRlc1wiOlxuICAgICAgICBvLnNlY29uZCA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwic2Vjb25kc1wiOlxuICAgICAgICBvLm1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlsbGlzZWNvbmRzXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gbm8gZGVmYXVsdCwgaW52YWxpZCB1bml0cyB0aHJvdyBpbiBub3JtYWxpemVVbml0KClcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsaXplZFVuaXQgPT09IFwid2Vla3NcIikge1xuICAgICAgaWYgKHVzZUxvY2FsZVdlZWtzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZXZWVrID0gdGhpcy5sb2MuZ2V0U3RhcnRPZldlZWsoKTtcbiAgICAgICAgY29uc3QgeyB3ZWVrZGF5IH0gPSB0aGlzO1xuICAgICAgICBpZiAod2Vla2RheSA8IHN0YXJ0T2ZXZWVrKSB7XG4gICAgICAgICAgby53ZWVrTnVtYmVyID0gdGhpcy53ZWVrTnVtYmVyIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBvLndlZWtkYXkgPSBzdGFydE9mV2VlaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8ud2Vla2RheSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcInF1YXJ0ZXJzXCIpIHtcbiAgICAgIGNvbnN0IHEgPSBNYXRoLmNlaWwodGhpcy5tb250aCAvIDMpO1xuICAgICAgby5tb250aCA9IChxIC0gMSkgKiAzICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQobyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBlbmQgKG1lYW5pbmcgdGhlIGxhc3QgbWlsbGlzZWNvbmQpIG9mIGEgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGVuZCBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudXNlTG9jYWxlV2Vla3M9ZmFsc2VdIC0gSWYgdHJ1ZSwgdXNlIHdlZWtzIGJhc2VkIG9uIHRoZSBsb2NhbGUsIGkuZS4gdXNlIHRoZSBsb2NhbGUtZGVwZW5kZW50IHN0YXJ0IG9mIHRoZSB3ZWVrXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCdtb250aCcpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZigneWVhcicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMTItMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignd2VlaycpLnRvSVNPKCk7IC8vID0+ICcyMDE0LTAzLTA5VDIzOjU5OjU5Ljk5OS0wNTowMCcsIHdlZWtzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdkYXknKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdob3VyJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QwNTo1OTo1OS45OTktMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgZW5kT2YodW5pdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gdGhpcy5wbHVzKHsgW3VuaXRdOiAxIH0pXG4gICAgICAgICAgLnN0YXJ0T2YodW5pdCwgb3B0cylcbiAgICAgICAgICAubWludXMoMSlcbiAgICAgIDogdGhpcztcbiAgfVxuXG4gIC8vIE9VVFBVVFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuXG4gICAqICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGUgZm9ybWF0dGluZyB0b29sLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vIy9mb3JtYXR0aW5nP2lkPXRhYmxlLW9mLXRva2VucykuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0cyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9uIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBBcHIgMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZnInKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdChcIkhIICdob3VycyBhbmQnIG1tICdtaW51dGVzJ1wiKSAvLz0+ICcyMCBob3VycyBhbmQgNTUgbWludXRlcydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MucmVkZWZhdWx0VG9FTihvcHRzKSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBkYXRlLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXMgYERhdGVUaW1lLkRBVEVfRlVMTGAgb3IgYERhdGVUaW1lLlRJTUVfU0lNUExFYC5cbiAgICogVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIG9mIHRoZSBEYXRlVGltZSBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0T3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucyBhbmQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0cyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9uIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiA0LzIwLzIwMTdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdlbi1nYicpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gJzIwLzA0LzIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gJ0FwcmlsIDIwLCAyMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwsIHsgbG9jYWxlOiAnZnInIH0pOyAvLz0+ICcyOCBhb1x1MDBGQnQgMjAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpOyAvLz0+ICcxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURVRJTUVfU0hPUlQpOyAvLz0+ICc0LzIwLzIwMTcsIDExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdsb25nJywgbW9udGg6ICdsb25nJywgZGF5OiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodXJzZGF5LCBBcHJpbCAyMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnMi1kaWdpdCcsIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7IC8vPT4gJ1RodSwgQXByIDIwLCAxMToyNyBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnLCBob3VyQ3ljbGU6ICdoMjMnIH0pOyAvLz0+ICcxMTozMidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBmb3JtYXRPcHRzKS5mb3JtYXREYXRlVGltZSh0aGlzKVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgZm9ybWF0IFwicGFydHNcIiwgbWVhbmluZyBpbmRpdmlkdWFsIHRva2VucyBhbG9uZyB3aXRoIG1ldGFkYXRhLiBUaGlzIGlzIGFsbG93cyBjYWxsZXJzIHRvIHBvc3QtcHJvY2VzcyBpbmRpdmlkdWFsIHNlY3Rpb25zIG9mIHRoZSBmb3JtYXR0ZWQgb3V0cHV0LlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdC9mb3JtYXRUb1BhcnRzXG4gICAqIEBwYXJhbSBvcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLCBzYW1lIGFzIGB0b0xvY2FsZVN0cmluZ2AuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlUGFydHMoKTsgLy89PiBbXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnZGF5JywgdmFsdWU6ICcyNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ21vbnRoJywgdmFsdWU6ICcwNScgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcvJyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ3llYXInLCB2YWx1ZTogJzE5ODInIH1cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gXVxuICAgKi9cbiAgdG9Mb2NhbGVQYXJ0cyhvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIG9wdHMpLmZvcm1hdERhdGVUaW1lUGFydHModGhpcylcbiAgICAgIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZXh0ZW5kZWRab25lPWZhbHNlXSAtIGFkZCB0aGUgdGltZSB6b25lIGZvcm1hdCBleHRlbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgzLCA1LCAyNSkudG9JU08oKSAvLz0+ICcxOTgyLTA1LTI1VDAwOjAwOjAwLjAwMFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzIwMTcwNDIyVDIwNDcwNS4zMzUtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oe1xuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICAgIGV4dGVuZGVkWm9uZSA9IGZhbHNlLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ID0gZm9ybWF0ID09PSBcImV4dGVuZGVkXCI7XG5cbiAgICBsZXQgYyA9IHRvSVNPRGF0ZSh0aGlzLCBleHQpO1xuICAgIGMgKz0gXCJUXCI7XG4gICAgYyArPSB0b0lTT1RpbWUodGhpcywgZXh0LCBzdXBwcmVzc1NlY29uZHMsIHN1cHByZXNzTWlsbGlzZWNvbmRzLCBpbmNsdWRlT2Zmc2V0LCBleHRlbmRlZFpvbmUpO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgZGF0ZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzE5ODIwNTI1J1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT0RhdGUoeyBmb3JtYXQgPSBcImV4dGVuZGVkXCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0b0lTT0RhdGUodGhpcywgZm9ybWF0ID09PSBcImV4dGVuZGVkXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3Mgd2VlayBkYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09XZWVrRGF0ZSgpIC8vPT4gJzE5ODItVzIxLTInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPV2Vla0RhdGUoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcImtra2stJ1cnV1ctY1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHRpbWUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmV4dGVuZGVkWm9uZT10cnVlXSAtIGFkZCB0aGUgdGltZSB6b25lIGZvcm1hdCBleHRlbnNpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKCkgLy89PiAnMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcwNzozNFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzA3MzQxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDA3OjM0OjE5LjM2MVonXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZSh7XG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBpbmNsdWRlUHJlZml4ID0gZmFsc2UsXG4gICAgZXh0ZW5kZWRab25lID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGMgPSBpbmNsdWRlUHJlZml4ID8gXCJUXCIgOiBcIlwiO1xuICAgIHJldHVybiAoXG4gICAgICBjICtcbiAgICAgIHRvSVNPVGltZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZm9ybWF0ID09PSBcImV4dGVuZGVkXCIsXG4gICAgICAgIHN1cHByZXNzU2Vjb25kcyxcbiAgICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gICAgICAgIGluY2x1ZGVPZmZzZXQsXG4gICAgICAgIGV4dGVuZGVkWm9uZVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBSRkMgMjgyMi1jb21wYXRpYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCArMDAwMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgLTA0MDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvUkZDMjgyMigpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyBaWlpcIiwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEhUVFAgaGVhZGVycy4gVGhlIG91dHB1dCBpcyBhbHdheXMgZXhwcmVzc2VkIGluIEdNVC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgc3RyaW5nIGNvbmZvcm1zIHRvIFJGQyAxMTIzLlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgR01UJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMsIDE5KS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDE5OjAwOjAwIEdNVCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9IVFRQKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcy50b1VUQygpLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgJ0dNVCdcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIERhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTERhdGUoKSAvLz0+ICcyMDE0LTA3LTEzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTERhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVab25lPWZhbHNlXSAtIGluY2x1ZGUgdGhlIHpvbmUsIHN1Y2ggYXMgJ0FtZXJpY2EvTmV3X1lvcmsnLiBPdmVycmlkZXMgaW5jbHVkZU9mZnNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXRTcGFjZT10cnVlXSAtIGluY2x1ZGUgdGhlIHNwYWNlIGJldHdlZW4gdGhlIHRpbWUgYW5kIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVab25lOiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUgQW1lcmljYS9OZXdfWW9yaydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxUaW1lKHsgaW5jbHVkZU9mZnNldCA9IHRydWUsIGluY2x1ZGVab25lID0gZmFsc2UsIGluY2x1ZGVPZmZzZXRTcGFjZSA9IHRydWUgfSA9IHt9KSB7XG4gICAgbGV0IGZtdCA9IFwiSEg6bW06c3MuU1NTXCI7XG5cbiAgICBpZiAoaW5jbHVkZVpvbmUgfHwgaW5jbHVkZU9mZnNldCkge1xuICAgICAgaWYgKGluY2x1ZGVPZmZzZXRTcGFjZSkge1xuICAgICAgICBmbXQgKz0gXCIgXCI7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZVpvbmUpIHtcbiAgICAgICAgZm10ICs9IFwielwiO1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICAgIGZtdCArPSBcIlpaXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBmbXQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMKCkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKCkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IHRydWUgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAgQW1lcmljYS9OZXdfWW9yaydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUwob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnRvU1FMRGF0ZSgpfSAke3RoaXMudG9TUUxUaW1lKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciBkZWJ1Z2dpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9JU08oKSA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB0aGUgUkVQTC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGBEYXRlVGltZSB7IHRzOiAke3RoaXMudG9JU08oKX0sIHpvbmU6ICR7dGhpcy56b25lLm5hbWV9LCBsb2NhbGU6ICR7dGhpcy5sb2NhbGV9IH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYERhdGVUaW1lIHsgSW52YWxpZCwgcmVhc29uOiAke3RoaXMuaW52YWxpZFJlYXNvbn0gfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLiBBbGlhcyBvZiB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1NlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgLyAxMDAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgKGFzIGEgd2hvbGUgbnVtYmVyKSBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1VuaXhJbnRlZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmZsb29yKHRoaXMudHMgLyAxMDAwKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQlNPTiBzZXJpYWxpemFibGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNEYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEYXRlVGltZSdzIHllYXIsIG1vbnRoLCBkYXksIGFuZCBzbyBvbi5cbiAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlQ29uZmlnPWZhbHNlXSAtIGluY2x1ZGUgY29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzIGluIHRoZSBvdXRwdXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcjogMjAxNywgbW9udGg6IDQsIGRheTogMjIsIGhvdXI6IDIwLCBtaW51dGU6IDQ5LCBzZWNvbmQ6IDQyLCBtaWxsaXNlY29uZDogMjY4IH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3Qob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcblxuICAgIGNvbnN0IGJhc2UgPSB7IC4uLnRoaXMuYyB9O1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUNvbmZpZykge1xuICAgICAgYmFzZS5vdXRwdXRDYWxlbmRhciA9IHRoaXMub3V0cHV0Q2FsZW5kYXI7XG4gICAgICBiYXNlLm51bWJlcmluZ1N5c3RlbSA9IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbTtcbiAgICAgIGJhc2UubG9jYWxlID0gdGhpcy5sb2MubG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBEYXRlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvSlNEYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOKTtcbiAgfVxuXG4gIC8vIENPTVBBUkVcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIERhdGVUaW1lcyBhcyBhIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIERhdGVUaW1lIHRvIGNvbXBhcmUgdGhpcyBvbmUgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGkxID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4Mi0wNS0yNVQwOTo0NScpLFxuICAgKiAgICAgaTIgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgzLTEwLTE0VDEwOjMwJyk7XG4gICAqIGkyLmRpZmYoaTEpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogNDM4MDc1MDAwMDAgfVxuICAgKiBpMi5kaWZmKGkxLCAnaG91cnMnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTIxNjguNzUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LjAzMTI1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cycsICdob3VycyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOSwgaG91cnM6IDAuNzUgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmYob3RoZXJEYXRlVGltZSwgdW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlckRhdGVUaW1lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwiY3JlYXRlZCBieSBkaWZmaW5nIGFuIGludmFsaWQgRGF0ZVRpbWVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZHVyT3B0cyA9IHsgbG9jYWxlOiB0aGlzLmxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSwgLi4ub3B0cyB9O1xuXG4gICAgY29uc3QgdW5pdHMgPSBtYXliZUFycmF5KHVuaXQpLm1hcChEdXJhdGlvbi5ub3JtYWxpemVVbml0KSxcbiAgICAgIG90aGVySXNMYXRlciA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpID4gdGhpcy52YWx1ZU9mKCksXG4gICAgICBlYXJsaWVyID0gb3RoZXJJc0xhdGVyID8gdGhpcyA6IG90aGVyRGF0ZVRpbWUsXG4gICAgICBsYXRlciA9IG90aGVySXNMYXRlciA/IG90aGVyRGF0ZVRpbWUgOiB0aGlzLFxuICAgICAgZGlmZmVkID0gZGlmZihlYXJsaWVyLCBsYXRlciwgdW5pdHMsIGR1ck9wdHMpO1xuXG4gICAgcmV0dXJuIG90aGVySXNMYXRlciA/IGRpZmZlZC5uZWdhdGUoKSA6IGRpZmZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCByaWdodCBub3cuXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjZGlmZn1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmZOb3codW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmRpZmYoRGF0ZVRpbWUubm93KCksIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCBzcGFubmluZyBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIGFub3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBlbmQgcG9pbnQgb2YgdGhlIEludGVydmFsXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW50aWwob3RoZXJEYXRlVGltZSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHRoaXMsIG90aGVyRGF0ZVRpbWUpIDogdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIERhdGVUaW1lIGlzIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZSBhcyBhbm90aGVyIERhdGVUaW1lLlxuICAgKiBIaWdoZXItb3JkZXIgdW5pdHMgbXVzdCBhbHNvIGJlIGlkZW50aWNhbCBmb3IgdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gYHRydWVgLlxuICAgKiBOb3RlIHRoYXQgdGltZSB6b25lcyBhcmUgKippZ25vcmVkKiogaW4gdGhpcyBjb21wYXJpc29uLCB3aGljaCBjb21wYXJlcyB0aGUgKipsb2NhbCoqIGNhbGVuZGFyIHRpbWUuIFVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0gdG8gY29udmVydCBvbmUgb2YgdGhlIGRhdGVzIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudXNlTG9jYWxlV2Vla3M9ZmFsc2VdIC0gSWYgdHJ1ZSwgdXNlIHdlZWtzIGJhc2VkIG9uIHRoZSBsb2NhbGUsIGkuZS4gdXNlIHRoZSBsb2NhbGUtZGVwZW5kZW50IHN0YXJ0IG9mIHRoZSB3ZWVrOyBvbmx5IHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZSBpcyB1c2VkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLmhhc1NhbWUob3RoZXJEVCwgJ2RheScpOyAvL34+IHRydWUgaWYgb3RoZXJEVCBpcyBpbiB0aGUgc2FtZSBjdXJyZW50IGNhbGVuZGFyIGRheVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZShvdGhlckRhdGVUaW1lLCB1bml0LCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGlucHV0TXMgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKTtcbiAgICBjb25zdCBhZGp1c3RlZFRvWm9uZSA9IHRoaXMuc2V0Wm9uZShvdGhlckRhdGVUaW1lLnpvbmUsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKFxuICAgICAgYWRqdXN0ZWRUb1pvbmUuc3RhcnRPZih1bml0LCBvcHRzKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gYWRqdXN0ZWRUb1pvbmUuZW5kT2YodW5pdCwgb3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEYXRlVGltZXMgYXJlIGVxdWFsIGlmIGFuZCBvbmx5IGlmIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIG1pbGxpc2Vjb25kLCBoYXZlIHRoZSBzYW1lIHpvbmUgYW5kIGxvY2F0aW9uLCBhbmQgYXJlIGJvdGggdmFsaWQuXG4gICAqIFRvIGNvbXBhcmUganVzdCB0aGUgbWlsbGlzZWNvbmQgdmFsdWVzLCB1c2UgYCtkdDEgPT09ICtkdDJgLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlciAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaXNWYWxpZCAmJlxuICAgICAgb3RoZXIuaXNWYWxpZCAmJlxuICAgICAgdGhpcy52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKSAmJlxuICAgICAgdGhpcy56b25lLmVxdWFscyhvdGhlci56b25lKSAmJlxuICAgICAgdGhpcy5sb2MuZXF1YWxzKG90aGVyLmxvYylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB0aGlzIHRpbWUgcmVsYXRpdmUgdG8gbm93LCBzdWNoIGFzIFwiaW4gdHdvIGRheXNcIi4gQ2FuIG9ubHkgaW50ZXJuYXRpb25hbGl6ZSBpZiB5b3VyXG4gICAqIHBsYXRmb3JtIHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LiBSb3VuZHMgZG93biBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3R5bGU9XCJsb25nXCJdIC0gdGhlIHN0eWxlIG9mIHVuaXRzLCBtdXN0IGJlIFwibG9uZ1wiLCBcInNob3J0XCIsIG9yIFwibmFycm93XCJcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHM7IGlmIG9taXR0ZWQsIG9yIGFuIGFycmF5LCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgYmVzdCB1bml0LiBVc2UgYW4gYXJyYXkgb3Igb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBvciBcInNlY29uZHNcIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJvdW5kPXRydWVdIC0gd2hldGhlciB0byByb3VuZCB0aGUgbnVtYmVycyBpbiB0aGUgb3V0cHV0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGFkZGluZz0wXSAtIHBhZGRpbmcgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIGFsbG93cyB5b3UgdG8gcm91bmQgdXAgdGhlIHJlc3VsdCBpZiBpdCBmaXRzIGluc2lkZSB0aGUgdGhyZXNob2xkLiBEb24ndCB1c2UgaW4gY29tYmluYXRpb24gd2l0aCB7cm91bmQ6IGZhbHNlfSBiZWNhdXNlIHRoZSBkZWNpbWFsIG91dHB1dCB3aWxsIGluY2x1ZGUgdGhlIHBhZGRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsZSAtIG92ZXJyaWRlIHRoZSBsb2NhbGUgb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiaW4gMSBkYXlcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoXCJlc1wiKS50b1JlbGF0aXZlKHsgZGF5czogMSB9KSAvLz0+IFwiZGVudHJvIGRlIDEgZFx1MDBFRGFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRhbnMgMjMgaGV1cmVzXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKHsgdW5pdDogXCJob3Vyc1wiIH0pIC8vPT4gXCI0OCBob3VycyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGhvdXJzOiAzNiB9KS50b1JlbGF0aXZlKHsgcm91bmQ6IGZhbHNlIH0pIC8vPT4gXCIxLjUgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZShvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYmFzZSA9IG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHt9LCB7IHpvbmU6IHRoaXMuem9uZSB9KSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcgPyAodGhpcyA8IGJhc2UgPyAtb3B0aW9ucy5wYWRkaW5nIDogb3B0aW9ucy5wYWRkaW5nKSA6IDA7XG4gICAgbGV0IHVuaXRzID0gW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXTtcbiAgICBsZXQgdW5pdCA9IG9wdGlvbnMudW5pdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnVuaXQpKSB7XG4gICAgICB1bml0cyA9IG9wdGlvbnMudW5pdDtcbiAgICAgIHVuaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUoYmFzZSwgdGhpcy5wbHVzKHBhZGRpbmcpLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhbHdheXNcIixcbiAgICAgIHVuaXRzLFxuICAgICAgdW5pdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZSByZWxhdGl2ZSB0byB0b2RheSwgc3VjaCBhcyBcInllc3RlcmRheVwiIG9yIFwibmV4dCBtb250aFwiLlxuICAgKiBPbmx5IGludGVybmF0aW9uYWxpemVzIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQ7IGlmIG9taXR0ZWQsIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSB1bml0LiBVc2Ugb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIG9yIFwiZGF5c1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcInRvbW9ycm93XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJcIm1hXHUwMEYxYW5hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRlbWFpblwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqL1xuICB0b1JlbGF0aXZlQ2FsZW5kYXIob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksIHRoaXMsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBudW1lcmljOiBcImF1dG9cIixcbiAgICAgIHVuaXRzOiBbXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcImRheXNcIl0sXG4gICAgICBjYWxlbmRhcnk6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtaW4gb2Ygc2V2ZXJhbCBkYXRlIHRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSBEYXRlVGltZXMgZnJvbSB3aGljaCB0byBjaG9vc2UgdGhlIG1pbmltdW1cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSBtaW4gRGF0ZVRpbWUsIG9yIHVuZGVmaW5lZCBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudFxuICAgKi9cbiAgc3RhdGljIG1pbiguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIWRhdGVUaW1lcy5ldmVyeShEYXRlVGltZS5pc0RhdGVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWluIHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgYmUgRGF0ZVRpbWVzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgKGkpID0+IGkudmFsdWVPZigpLCBNYXRoLm1pbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtYXggb2Ygc2V2ZXJhbCBkYXRlIHRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSBEYXRlVGltZXMgZnJvbSB3aGljaCB0byBjaG9vc2UgdGhlIG1heGltdW1cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSBtYXggRGF0ZVRpbWUsIG9yIHVuZGVmaW5lZCBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudFxuICAgKi9cbiAgc3RhdGljIG1heCguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIWRhdGVUaW1lcy5ldmVyeShEYXRlVGltZS5pc0RhdGVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWF4IHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgYmUgRGF0ZVRpbWVzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgKGkpID0+IGkudmFsdWVPZigpLCBNYXRoLm1heCk7XG4gIH1cblxuICAvLyBNSVNDXG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gaG93IGEgc3RyaW5nIHdvdWxkIGJlIHBhcnNlZCBieSBmcm9tRm9ybWF0KClcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZSBkZXNjcmlwdGlvbilcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRha2VuIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdGlvbnMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIHJldHVybiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZnJvbUZvcm1hdEV4cGxhaW4gaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmdFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBGT1JNQVQgUFJFU0VUU1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlIDEwLzE0LzE5ODNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX1NIT1JUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9NRUQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpLCBPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEX1dJVEhfV0VFS0RBWSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVk7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfRlVMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdUdWVzZGF5LCBPY3RvYmVyIDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX0hVR0UoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9IVUdFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzAnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9TSU1QTEUoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9TSU1QTEU7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRURUJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgMTQgT2N0IDE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMsIDk6MzAgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0ZVTEwoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmlkYXksIE9jdG9iZXIgMTQsIDE5ODMsIDk6MzAgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0hVR0UoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmlkYXksIE9jdG9iZXIgMTQsIDE5ODMsIDk6MzA6MzMgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyaWVuZGx5RGF0ZVRpbWUoZGF0ZVRpbWVpc2gpIHtcbiAgaWYgKERhdGVUaW1lLmlzRGF0ZVRpbWUoZGF0ZVRpbWVpc2gpKSB7XG4gICAgcmV0dXJuIGRhdGVUaW1laXNoO1xuICB9IGVsc2UgaWYgKGRhdGVUaW1laXNoICYmIGRhdGVUaW1laXNoLnZhbHVlT2YgJiYgaXNOdW1iZXIoZGF0ZVRpbWVpc2gudmFsdWVPZigpKSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tSlNEYXRlKGRhdGVUaW1laXNoKTtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiB0eXBlb2YgZGF0ZVRpbWVpc2ggPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdChkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgYFVua25vd24gZGF0ZXRpbWUgYXJndW1lbnQ6ICR7ZGF0ZVRpbWVpc2h9LCBvZiB0eXBlICR7dHlwZW9mIGRhdGVUaW1laXNofWBcbiAgICApO1xuICB9XG59XG4iLCAiaW1wb3J0IHt1dGlsc0FQSX0gZnJvbSAnLi91dGlsc0FQSSdcbmltcG9ydCB7IFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgY2xhc3MgcmVnaXN0cm9UaWVtcG9BUEkge1xuICAgIHByaXZhdGUgdXRpbHNBcGk6IHV0aWxzQVBJO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBwbHVnaW46IFBsdWdpbikge1xuICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICB0aGlzLnV0aWxzQXBpID0gbmV3IHV0aWxzQVBJKHBsdWdpbik7XG4gICAgICBcbiAgICB9XG4gICAgXG5cbiAgICBhc3luYyBpbmljaWFyUmVnaXN0cm8oKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgcmVnaXN0cm8gPSBhd2FpdCB0aGlzLnV0aWxzQXBpLmNyZWFyT2JqZXRvUmVnaXN0cm8odGhpcy5wbHVnaW4pO1xuICAgICAgICBhd2FpdCB0aGlzLnV0aWxzQXBpLnZlcmlmaWNhclRhcmVhc0FjdGl2YXMocmVnaXN0cm8sIHRoaXMucGx1Z2luLmFwcCk7XG4gICAgICAgIGlmIChyZWdpc3Ryby5kZXRlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0cm87IC8vIERldnVlbHZlIGVsIHJlZ2lzdHJvIGFjdHVhbCB5IGRldGllbmUgbGEgZWplY3VjaVx1MDBGM24gYXF1XHUwMEVEXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy51dGlsc0FwaS5kZWZpbmlyVGlwb1JlZ2lzdHJvKHJlZ2lzdHJvLHRoaXMucGx1Z2luLmFwcClcbiAgICAgICAgaWYgKHJlZ2lzdHJvLmRldGVuZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RybzsgLy8gRGV2dWVsdmUgZWwgcmVnaXN0cm8gYWN0dWFsIHkgZGV0aWVuZSBsYSBlamVjdWNpXHUwMEYzbiBhcXVcdTAwRURcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnV0aWxzQXBpLmNvbnN0cnVpck5vbWJyZXlBbGlhcyhyZWdpc3RybywgdGhpcy5wbHVnaW4uYXBwKVxuICAgICAgICByZXR1cm4gcmVnaXN0cm87XG4gICAgICAgIH1jYXRjaCAoZXJyb3Ipe1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBzZSBwdWRvIGNyZWFyIGVsIG9iamV0byBkZSByZWdpc3Ryby5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSW52b2NhZG8gZGVzZGUgZWwgdGVtcGxhdGUgZGUgdGVtcGxhdGVyIFBhc28gMyBkZSAzXG4gICAgYXN5bmMgcmV0b21hclJlZ2lzdHJvKGlkKXtcbiAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9SZWdpc3Ryb1RpZW1wb1xuICAgICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlZ2lzdHJvID0gYXdhaXQgdGhpcy51dGlsc0FwaS5jcmVhck9iamV0b1JlZ2lzdHJvKHRoaXMucGx1Z2luKTtcbiAgICAgIGF3YWl0IHRoaXMudXRpbHNBcGkudmVyaWZpY2FyVGFyZWFzQWN0aXZhcyhyZWdpc3RybywgdGhpcy5wbHVnaW4uYXBwKTtcbiAgICAgIGlmIChyZWdpc3Ryby5kZXRlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZ2lzdHJvOyAvLyBEZXZ1ZWx2ZSBlbCByZWdpc3RybyBhY3R1YWwgeSBkZXRpZW5lIGxhIGVqZWN1Y2lcdTAwRjNuIGFxdVx1MDBFRFxuICAgICAgfVxuICAgICAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgICAgbGV0IHJlZ2lzdHJvQW50aWd1bztcbiAgICAgIFxuICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgIGlmIChmaWxlLnBhdGguc3RhcnRzV2l0aChmb2xkZXIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhPy5pZCA9PT0gcGFyc2VJbnQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICByZWdpc3Ryb0FudGlndW8gPSB7IGZpbGUsIGZyb250bWF0dGVyOiBtZXRhZGF0YSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVidWdnZXJcbiAgICAgIHJlZ2lzdHJvLnRpdHVsbyA9IHJlZ2lzdHJvQW50aWd1bz8uZnJvbnRtYXR0ZXIudGl0dWxvID8gcmVnaXN0cm9BbnRpZ3VvLmZyb250bWF0dGVyLnRpdHVsbyA6IFwiU2luIFRpdHVsb1wiO1xuICAgICAgcmVnaXN0cm8uYXN1bnRvUmV0b21hZG8gPSByZWdpc3Ryb0FudGlndW8/LmZyb250bWF0dGVyLmFzdW50byA/IHJlZ2lzdHJvQW50aWd1by5mcm9udG1hdHRlci5hc3VudG8gOiBudWxsO1xuICAgICAgYXdhaXQgdGhpcy51dGlsc0FwaS5jb25zdHJ1aXJOb21icmV5QWxpYXMocmVnaXN0cm8sIHRoaXMucGx1Z2luLmFwcClcbiAgICAgIHJldHVybiByZWdpc3RybztcbiAgICAgIH1jYXRjaCAoZXJyb3Ipe1xuICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gc2UgcHVkbyBjcmVhciBlbCBvYmpldG8gZGUgcmVnaXN0cm8uXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIEludm9jYWRvIHBhcmEgY3JlYXIgZWwgdGVtcGxhdGUgZGUgUmV0b21hciBQYXNvIDEgZGUgM1xuICBhc3luYyByZXRvbWFyVGFyZWEoaWQpIHsgXG4gICAgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgcmVlbXBsYXphciAncnV0YS9hbC9hcmNoaXZvLm1kJyBjb24gbGEgcnV0YSBleGFjdGEgZGVsIGFyY2hpdm8gcXVlIGRlc2VhcyBvYnRlbmVyXG4gICAgZGVidWdnZXI7XG4gICAgY29uc3QgZmlsZVBhdGggPSBgUGxhbnRpbGxhcy8ke3RoaXMucGx1Z2luLnNldHRpbmdzW2Bmb2xkZXJfUmVnaXN0cm9UaWVtcG9gXX0vUGx0IC0gUmVnaXN0cm9UaWVtcG8ubWRgO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCk7XG5cbiAgICBpZiAodGVtcGxhdGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAvLyBBaG9yYSAnZmlsZScgZXMgdHUgYXJjaGl2byBkZXNlYWRvLCB5IHB1ZWRlcyB0cmFiYWphciBjb24gXHUwMEU5bCBjb21vIG5lY2VzaXRlc1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFyY2hpdm8gZW5jb250cmFkbzpcIiwgdGVtcGxhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpIGVsIGFyY2hpdm8gbm8gc2UgZW5jb250clx1MDBGMywgJ2ZpbGUnIHNlclx1MDBFMSBudWxsXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXJjaGl2byBubyBlbmNvbnRyYWRvLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZW5hbWUgPSBcIlJldG9tYXIgXCIgKyBpZDtcbiAgICBjb25zdCBmb2xkZXIgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKFwiSW5ib3hcIik7XG4gICAgY29uc3QgdHAgPSB0aGlzLmdldFRwKCk7XG4gICAgbGV0IGNyZWFyTm90YSA9IHRwLmZpbGUuc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJjcmVhdGVfbmV3XCIpXG4gICAgYXdhaXQgY3JlYXJOb3RhICh0ZW1wbGF0ZSwgZmlsZW5hbWUsIGZhbHNlLCBmb2xkZXIpLmJhc2VuYW1lO1xuICB9XG5cblxuXG4gIC8vIFNvYnJlY2FyZ2EgZGUgbVx1MDBFOXRvZG8gcGFyYSBsb3MgZGlmZXJlbnRlcyB0aXBvcyBkZSBlbnRyYWRhXG4gIGFzeW5jIGNlcnJhclJlZ2lzdHJvKGlkOiBudW1iZXIgfCBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuICBhc3luYyBjZXJyYXJSZWdpc3RybyhmaWxlOiBURmlsZSk6IFByb21pc2U8dm9pZD47XG4gIGFzeW5jIGNlcnJhclJlZ2lzdHJvKCk6IFByb21pc2U8dm9pZD47XG4gIC8vIEltcGxlbWVudGFjaVx1MDBGM24gZGVsIG1cdTAwRTl0b2RvIGNvbiB1bmlcdTAwRjNuIGRlIHRpcG9zIHBhcmEgZWwgcGFyXHUwMEUxbWV0cm8gaWRcbiAgYXN5bmMgY2VycmFyUmVnaXN0cm8ocmVnaXN0cm8/OiBudW1iZXIgfCBzdHJpbmcgfCBURmlsZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGZvbGRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9SZWdpc3Ryb1RpZW1wbztcbiAgICBpZiAodHlwZW9mIHJlZ2lzdHJvID09PSAnc3RyaW5nJykge1xuICAgIHJlZ2lzdHJvID0gcGFyc2VJbnQocmVnaXN0cm8pO1xuICAgIH1cbiAgICAvLyBMXHUwMEYzZ2ljYSBzaSAnaWQnIGVzIHVuIG5cdTAwRkFtZXJvIC0+IEN1YW5kbyBsbGVnYSBkZWwgYm90b24gZGUgbGEgdGFibGEgZGUgcmVnaXN0cm9zIGRlbCBkXHUwMEVEYS5cbiAgICBpZiAodHlwZW9mIHJlZ2lzdHJvID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgICAgIGxldCBpbmZvTm90YTtcbiAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgaWYgKGZpbGUucGF0aC5zdGFydHNXaXRoKGZvbGRlcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhPy5pZCA9PT0gcmVnaXN0cm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mb05vdGEgPSB7IGZpbGUgfTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbmZvTm90YSwgbWV0YWRhdGEpOyBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhbXBvcyA9IFtcImZlY2hhXCIsXCJob3JhRmluYWxcIixcInRpZW1wb1RyYWJhamFkb1wiXTtcbiAgICAgICAgbGV0IHJlc3VsdGFkbyA9IGF3YWl0IHRoaXMucGx1Z2luLllBTUxVcGRhdGVyQVBJLmFyY2hpdmFyTm90YShpbmZvTm90YSwgY2FtcG9zKTtcbiAgICAgICAgbGV0IHRleHRvUmVzdWx0YWRvID0gT2JqZWN0LmVudHJpZXMocmVzdWx0YWRvKS5tYXAoKFtwcm9waWVkYWQsIHZhbG9yXSkgPT4gYCR7cHJvcGllZGFkfTogJHt2YWxvcn1gKS5qb2luKCcsICcpO1xuICAgICAgICBuZXcgTm90aWNlKGBUYXJlYSBjZXJyYWRhLiBDYW1wb3MgYWN0dWFsaXphZG9zOiAke3RleHRvUmVzdWx0YWRvfWApO1xuICAgIH1cbiAgICAvLyBMXHUwMEYzZ2ljYSBzaSAnaWQnIGVzIHVuIFRGaWxlXG4gICAgZWxzZSBpZiAocmVnaXN0cm8gaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUocmVnaXN0cm8pPy5mcm9udG1hdHRlcjtcbiAgICAgIGxldCBpbmZvTm90YSA9IHtmaWxlOiByZWdpc3Ryb307XG4gICAgICBPYmplY3QuYXNzaWduKGluZm9Ob3RhLCBtZXRhZGF0YSk7IFxuICAgICAgbGV0IGNhbXBvcyA9IFtcImZlY2hhXCIsXCJob3JhRmluYWxcIixcInRpZW1wb1RyYWJhamFkb1wiXTtcbiAgICAgIGxldCByZXN1bHRhZG8gPSBhd2FpdCB0aGlzLnBsdWdpbi5ZQU1MVXBkYXRlckFQSS5hcmNoaXZhck5vdGEoaW5mb05vdGEsIGNhbXBvcyk7XG4gICAgICBsZXQgdGV4dG9SZXN1bHRhZG8gPSBPYmplY3QuZW50cmllcyhyZXN1bHRhZG8pLm1hcCgoW3Byb3BpZWRhZCwgdmFsb3JdKSA9PiBgJHtwcm9waWVkYWR9OiAke3ZhbG9yfWApLmpvaW4oJywgJyk7XG4gICAgICBuZXcgTm90aWNlKGBUYXJlYSBjZXJyYWRhLiBDYW1wb3MgYWN0dWFsaXphZG9zOiAke3RleHRvUmVzdWx0YWRvfWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTFx1MDBGM2dpY2EgcGFyYSBjdWFuZG8gbm8gc2UgcHJvcG9yY2lvbmEgYXJndW1lbnRvcywgc2UgYnVzY2EgbGEgdGFyZWEgYWN0aXZhIHkgc2UgY2llcnJhLlxuICAgICAgICBjb25zdCByZWdpc3RybyA9IGF3YWl0IHRoaXMudXRpbHNBcGkuYnVzY2FyUmVnaXN0cm9zQWN0aXZvcyhhcHApO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShyZWdpc3Rybyk/LmZyb250bWF0dGVyO1xuICAgICAgICBsZXQgaW5mb05vdGEgPSB7ZmlsZTogcmVnaXN0cm99O1xuICAgICAgICBPYmplY3QuYXNzaWduKGluZm9Ob3RhLCBtZXRhZGF0YSk7IFxuICAgICAgICBsZXQgY2FtcG9zID0gW1wiZmVjaGFcIixcImhvcmFGaW5hbFwiLFwidGllbXBvVHJhYmFqYWRvXCJdO1xuICAgICAgICBsZXQgcmVzdWx0YWRvID0gYXdhaXQgdGhpcy5wbHVnaW4uWUFNTFVwZGF0ZXJBUEkuYXJjaGl2YXJOb3RhKGluZm9Ob3RhLCBjYW1wb3MpO1xuICAgICAgICBsZXQgdGV4dG9SZXN1bHRhZG8gPSBPYmplY3QuZW50cmllcyhyZXN1bHRhZG8pLm1hcCgoW3Byb3BpZWRhZCwgdmFsb3JdKSA9PiBgJHtwcm9waWVkYWR9OiAke3ZhbG9yfWApLmpvaW4oJywgJyk7XG4gICAgICAgIG5ldyBOb3RpY2UoYFRhcmVhIGNlcnJhZGEuIENhbXBvcyBhY3R1YWxpemFkb3M6ICR7dGV4dG9SZXN1bHRhZG99YCk7XG4gICAgfVxuICB9XG5cblxuICAvLyBTb2JyZWNhcmdhIGRlIG1cdTAwRTl0b2RvIHBhcmEgbG9zIGRpZmVyZW50ZXMgdGlwb3MgZGUgZW50cmFkYVxuICBhc3luYyBkZXRhbGxlUmVnaXN0cm8oaWQ6IG51bWJlciB8IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG4gIGFzeW5jIGRldGFsbGVSZWdpc3RybyhmaWxlOiBURmlsZSk6IFByb21pc2U8dm9pZD47XG4gIGFzeW5jIGRldGFsbGVSZWdpc3RybygpOiBQcm9taXNlPHZvaWQ+O1xuICAvLyBJbXBsZW1lbnRhY2lcdTAwRjNuIGRlbCBtXHUwMEU5dG9kbyBjb24gdW5pXHUwMEYzbiBkZSB0aXBvcyBwYXJhIGVsIHBhclx1MDBFMW1ldHJvIGlkXG4gIGFzeW5jIGRldGFsbGVSZWdpc3RybyhyZWdpc3Rybz86IG51bWJlciB8IHN0cmluZyB8IFRGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZm9sZGVyID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1JlZ2lzdHJvVGllbXBvO1xuICAgIGxldCBpbmZvTm90YTtcbiAgICBkZWJ1Z2dlcjtcbiAgICBpZiAodHlwZW9mIHJlZ2lzdHJvID09PSAnc3RyaW5nJykge1xuICAgIHJlZ2lzdHJvID0gcGFyc2VJbnQocmVnaXN0cm8pO1xuICAgIH1cbiAgICAvLyBMXHUwMEYzZ2ljYSBzaSAnaWQnIGVzIHVuIG5cdTAwRkFtZXJvIC0+IEN1YW5kbyBsbGVnYSBkZWwgYm90b24gZGUgbGEgdGFibGEgZGUgcmVnaXN0cm9zIGRlbCBkXHUwMEVEYS5cbiAgICBpZiAodHlwZW9mIHJlZ2lzdHJvID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgIGlmIChmaWxlLnBhdGguc3RhcnRzV2l0aChmb2xkZXIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YT8uaWQgPT09IHJlZ2lzdHJvKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm9Ob3RhID0geyBmaWxlIH07XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5mb05vdGEsIG1ldGFkYXRhKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIExcdTAwRjNnaWNhIHNpICdpZCcgZXMgdW4gVEZpbGVcbiAgICBlbHNlIGlmIChyZWdpc3RybyBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShyZWdpc3Rybyk/LmZyb250bWF0dGVyO1xuICAgICAgaW5mb05vdGEgPSB7ZmlsZTogcmVnaXN0cm99O1xuICAgICAgT2JqZWN0LmFzc2lnbihpbmZvTm90YSwgbWV0YWRhdGEpOyBcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIExcdTAwRjNnaWNhIHBhcmEgY3VhbmRvIG5vIHNlIHByb3BvcmNpb25hIGFyZ3VtZW50b3MsIHNlIGJ1c2NhIGxhIHRhcmVhIGFjdGl2YSB5IHNlIGNpZXJyYS5cbiAgICAgICAgY29uc3QgcmVnaXN0cm8gPSBhd2FpdCB0aGlzLnV0aWxzQXBpLmJ1c2NhclJlZ2lzdHJvc0FjdGl2b3MoYXBwKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUocmVnaXN0cm8pPy5mcm9udG1hdHRlcjtcbiAgICAgICAgaW5mb05vdGEgPSB7ZmlsZTogcmVnaXN0cm99O1xuICAgICAgICBPYmplY3QuYXNzaWduKGluZm9Ob3RhLCBtZXRhZGF0YSk7IFxuICAgIH1cbiAgICBsZXQgY2FtcG9zID0gW1wiZGVzY3JpcGNpb25fUmVnaXN0cm9UaWVtcG9cIl07XG4gICAgZGVidWdnZXI7XG4gICAgbGV0IHJlc3VsdGFkbyA9IGF3YWl0IHRoaXMucGx1Z2luLllBTUxVcGRhdGVyQVBJLmFjdHVhbGl6YXJOb3RhKGluZm9Ob3RhLCBjYW1wb3MpO1xuICAgIGxldCB0ZXh0b1Jlc3VsdGFkbyA9IE9iamVjdC5lbnRyaWVzKHJlc3VsdGFkbykubWFwKChbcHJvcGllZGFkLCB2YWxvcl0pID0+IGAke3Byb3BpZWRhZH06ICR7dmFsb3J9YCkuam9pbignLCAnKTtcbiAgICBuZXcgTm90aWNlKGBEZXNjcmlwY2lcdTAwRjNuIGFjdHVhbGl6YWRhOiAke3RleHRvUmVzdWx0YWRvfWApO1xuICB9XG5cbiAgZ2V0VHAoKXtcbiAgICBpZiAoIXRoaXMucGx1Z2luIHx8ICF0aGlzLnBsdWdpbi5hcHAucGx1Z2lucy5lbmFibGVkUGx1Z2lucy5oYXMoJ3RlbXBsYXRlci1vYnNpZGlhbicpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VsIHBsdWdpbiBUZW1wbGF0ZXIgbm8gZXN0XHUwMEUxIGhhYmlsaXRhZG8uJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9ICAgXG4gICAgbGV0IHRwR2VuID0gdGhpcy5wbHVnaW4uYXBwLnBsdWdpbnMucGx1Z2luc1tcInRlbXBsYXRlci1vYnNpZGlhblwiXS50ZW1wbGF0ZXI7XG4gICAgdHBHZW4gPSB0cEdlbi5mdW5jdGlvbnNfZ2VuZXJhdG9yLmludGVybmFsX2Z1bmN0aW9ucy5tb2R1bGVzX2FycmF5O1xuICAgIGxldCB0cCA9IHt9XG4gICAgLy8gZ2V0IGFuIGluc3RhbmNlIG9mIG1vZHVsZXNcbiAgICB0cC5maWxlID0gdHBHZW4uZmluZChtID0+IG0ubmFtZSA9PSBcImZpbGVcIik7XG4gICAgdHAuc3lzdGVtID0gdHBHZW4uZmluZChtID0+IG0ubmFtZSA9PSBcInN5c3RlbVwiKTtcblxuICAgIGlmICghdHAuZmlsZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJObyBzZSBwdWRvIGFjY2VkZXIgYWwgb2JqZXRvIGRlIGZ1bmNpb25lcyBhY3R1YWxlcyBkZSBUZW1wbGF0ZXIuXCIpO1xuICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ3RwIGNvbiBwcm9waWVkYWRlcyBcImZpbGVcIiBzZSBoYSBjYXJnYWRvIHNhdGlzZmFjdG9yaWFtZW50ZScpO1xuICAgIHJldHVybiB0cDtcbn1cblxuXG4gIH1cbiAgIiwgIi8vaW1wb3J0IHt1dGlsc0FQSX0gZnJvbSAnLi91dGlsc0FQSSdcbmltcG9ydCB7VEZpbGUsIFRGb2xkZXIsIFBsdWdpbiwgTm90aWNlfSBmcm9tICdvYnNpZGlhbidcbmltcG9ydCB7IERhdGVUaW1lIH0gZnJvbSAnbHV4b24nO1xuXG5cbmV4cG9ydCBjbGFzcyBzdGFydGVyQVBJIHtcbiAgICAvL3ByaXZhdGUgdXRpbHNBcGk6IHV0aWxzQVBJO1xuICAgIHByaXZhdGUgcGx1Z2luOiBQbHVnaW47XG4gICAgcHJpdmF0ZSBpbmZvU3Vic2lzdGVtYTogb2JqZWN0OyAvLyBBc3VtaWVuZG8gcXVlIGVzIHVuIHN0cmluZ1xuICAgIHByaXZhdGUgdHA6IG9iamVjdDtcbiAgICBwcml2YXRlIG5vdGE6IG9iamVjdDtcbiAgICBwcml2YXRlIHBhdGhDYW1wb3M6IHN0cmluZzsgXG5cbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFBsdWdpbikge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgLy8gSW5pY2lhbGl6YSBmb2xkZXIgZSBpbmRpY2UgY29uIHZhbG9yZXMgcHJlZGV0ZXJtaW5hZG9zIG8gbFx1MDBGM2dpY2EgZXNwZWNcdTAwRURmaWNhLlxuICAgICAgICB0aGlzLmluZm9TdWJzaXN0ZW1hID0ge307XG4gICAgICAgIHRoaXMubm90YSA9IHt9O1xuICAgICAgICB0aGlzLnRwID0gdGhpcy5nZXRUcCgpO1xuICAgICAgICB0aGlzLnBhdGhDYW1wb3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5maWxlX2NhbXBvc0NlbnRyYWwgKyBcIi5tZFwiO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhciBOb3RhIGRlc2RlIHRlbXBsYXRlXG4gICAgYXN5bmMgY3JlYXRlTm90ZShzdWJzaXN0ZW1hOiBzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlYnVnZ2VyXG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZVBhdGggPSBgUGxhbnRpbGxhcy8ke3RoaXMucGx1Z2luLnNldHRpbmdzW2Bmb2xkZXJfJHtzdWJzaXN0ZW1hfWBdfS9QbHQgLSAke3N1YnNpc3RlbWF9Lm1kYDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBJbnRlbnRhciBvYnRlbmVyIGVsIGFyY2hpdm8gcG9yIHBhdGhcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlRmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGVtcGxhdGVQYXRoKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGVsIGFyY2hpdm8gZXMgdW4gVEZpbGVcbiAgICAgICAgICAgIGlmICghKHRlbXBsYXRlRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpIG5vIGVzIHVuIFRGaWxlLCBtYW5lamFyIGVsIGVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbCB0ZW1wbGF0ZSBwYXJhIFwiJHtzdWJzaXN0ZW1hfVwiIG5vIHNlIGVuY29udHJcdTAwRjMgbyBubyBlcyB1biBhcmNoaXZvIHZcdTAwRTFsaWRvLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZHRDb25zZXEgPSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eS1NTS1kZCBISG1tc3MnKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYCR7c3Vic2lzdGVtYX0gJHtkdENvbnNlcX1gO1xuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChcIkluYm94XCIpO1xuICAgICAgICAgICAgaWYgKCFmb2xkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExhIGNhcnBldGEgXCJJbmJveFwiIG5vIHNlIGVuY29udHJcdTAwRjMuYCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBjb25zdCB0cCA9IHRoaXMuZ2V0VHAoKTtcbiAgICAgICAgICAgIGxldCBjcmVhck5vdGEgPSB0cC5maWxlLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwiY3JlYXRlX25ld1wiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3JlYXJOb3RhICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYSBmdW5jaVx1MDBGM24gcGFyYSBjcmVhciBub3RhcyBubyBlc3RcdTAwRTEgZGlzcG9uaWJsZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBjcmVhck5vdGEodGVtcGxhdGVGaWxlLCBmaWxlbmFtZSwgdHJ1ZSwgZm9sZGVyKS5iYXNlbmFtZTtcbiAgICAgICAgICAgIFxuICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAvLyBBcXVcdTAwRUQgcHVlZGVzIG1hbmVqYXIgZWwgZXJyb3IsIHBvciBlamVtcGxvLCBtb3N0cmFuZG8gdW4gbWVuc2FqZSBhbCB1c3VhcmlvXG4gICAgICAgICAgICAvLyBQdWVkZXMgcmVlbXBsYXphciBlc3RlIG1lbnNhamUgZGUgZXJyb3IgcG9yIGN1YWxxdWllciBhY2NpXHUwMEYzbiBxdWUgY29uc2lkZXJlcyBhZGVjdWFkYVxuICAgICAgICAgICAgYWxlcnQoYEVycm9yIGFsIGNyZWFyIGxhIG5vdGE6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcblxuXG4gICAgLy8gY3JlYXJOb3RhIC0+IExsZW5hciBsb3MgY2FtcG9zIFlBTUwgZGVsIHRlbXBsYXRlLlxuICAgIGFzeW5jIGZpbGxOb3RlKGluZm9TdWJzaXN0ZW1hOiB7IGZvbGRlcjogc3RyaW5nIHwgbnVtYmVyOyBpbmRpY2U6IHN0cmluZyB8IG51bWJlcjsgfSwgY2FtcG9zOiBhbnkpIHtcbiAgICAgICAgdGhpcy5ub3RhID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5pbmZvU3Vic2lzdGVtYSwgaW5mb1N1YnNpc3RlbWEpOyBcbiAgICAgICAgaWYgKHRoaXMuaW5mb1N1YnNpc3RlbWEuZGVmaW5lZCl7XG4gICAgICAgIC8vIGluZm9TdWJzaXN0ZW1hLmZvbGRlciBlIGluZGljZSBjb250aWVuZW4gbGEgaW5mb3JtYWNpXHUwMEYzbiBkZSBsYXMgY2FycGV0YXNcblx0ICAgICAgICB0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzW2luZm9TdWJzaXN0ZW1hLmZvbGRlcl1cblx0ICAgICAgICB0aGlzLmluZm9TdWJzaXN0ZW1hLmluZGljZSA9IHRoaXMucGx1Z2luLnNldHRpbmdzW2luZm9TdWJzaXN0ZW1hLmluZGljZV1cblx0ICAgICAgICAvLyBub3RhIGFob3JhIHRpZW5lIHRvZGEgbGEgaW5mb3JtYWNpXHUwMEYzbiBkZSBsYSBwbGFudGlsbGFcblx0ICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMubm90YSwgaW5mb1N1YnNpc3RlbWEpOyAvLyBOb3RhIGVzIGVsIG9iamV0byBxdWUgc2UgZGV2b2x2ZXJcdTAwRTEuXG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKGxldCBjYW1wbyBvZiBjYW1wb3MpIHsgICAgICAgXG5cdFx0XHQvLyBVc2EgZWwgbm9tYnJlIGRlbCBjYW1wbyBwYXJhIGNvbnN0cnVpciBlbCBub21icmUgZGUgbGEgZnVuY2lcdTAwRjNuIChwLiBlai4sIFwiZ2V0SWRcIilcblx0XHRcdFx0ZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYGdldCR7Y2FtcG8uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1wby5zbGljZSgxKX1gO1xuXHRcdFx0XHQvLyBWZXJpZmljYSBzaSBleGlzdGUgdW5hIGZ1bmNpXHUwMEYzbiBjb24gZXNlIG5vbWJyZS5cblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzW2Z1bmN0aW9uTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gTGxhbWEgYSBsYSBmdW5jaVx1MDBGM24gZGUgbWFuZXJhIGRpblx1MDBFMW1pY2EgeSBhc2lnbmEgZWwgcmVzdWx0YWRvIGFsIGNhbXBvIGNvcnJlc3BvbmRpZW50ZSBkZSBsYSBub3RhLlxuXHRcdFx0XHRcdHRoaXMubm90YVtjYW1wb10gPSBhd2FpdCB0aGlzW2Z1bmN0aW9uTmFtZV0oKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGBMYSBmdW5jaVx1MDBGM24gJHtmdW5jdGlvbk5hbWV9IG5vIGVzdFx1MDBFMSBkZWZpbmlkYS5gKTtcblx0XHRcdFx0fVxuICAgICAgICAgICAgICAgIH0gLy8gRmluIEZvciBcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIHNlIHB1ZG8gY3JlYXIgZWwgb2JqZXRvIGRlIHJlZ2lzdHJvLlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIk5vIHNlIHB1ZG8gY3JlYXIgZWwgb2JqZXRvIGRlIHJlZ2lzdHJvLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm90YTsgLy8gUmV0b3JuYSBlbCBvYmpldG8gbm90YSBjb24gdG9kYXMgbGFzIHByb3BpZWRhZGVzIGFncmVnYWRhcy5cbiAgICB9XG4gICAgXG5cbiAgICBnZXRUcCgpe1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0aGlzLnBsdWdpbiB8fCAhdGhpcy5wbHVnaW4uYXBwLnBsdWdpbnMuZW5hYmxlZFBsdWdpbnMuaGFzKCd0ZW1wbGF0ZXItb2JzaWRpYW4nKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRWwgcGx1Z2luIFRlbXBsYXRlciBubyBlc3RcdTAwRTEgaGFiaWxpdGFkby4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyAgRm9ybWEgZGUgYWNjZWRlciBhbCBvYmpldG8gdHAgbm9ybWFsIHF1ZSBoZSB1c2FkbyBkZXNkZSBEVkpTIGN1YW5kbyBjdXJyZW50IEZ1bmN0aW9ucyBlc3RhIGNhcmdhZG8uXG4gICAgICAgIC8vY29uc3QgdGVtcGxhdGVyUGx1Z2luID0gdGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zWyd0ZW1wbGF0ZXItb2JzaWRpYW4nXTtcbiAgICAgICAgLy9jb25zdCB0cCA9IHRlbXBsYXRlclBsdWdpbi50ZW1wbGF0ZXIuY3VycmVudF9mdW5jdGlvbnNfb2JqZWN0O1xuICAgICAgICAvLyAtPiB2ZXJzaW9uIHF1ZSBmYWxsYSBzaSBubyBlc3RhIGFycmliYSBlbCBwbHVnaW4gcG9ycXVlIGhhY2UgZ2V0IGRlbCBwbHVnaW4gZGlyZWN0by4gY29uc3QgdGVtcGxhdGVyUGx1Z2luID0gdGhpcy5hcHAucGx1Z2lucy5nZXRQbHVnaW4oJ3RlbXBsYXRlci1vYnNpZGlhbicpO1xuICAgICAgICBcbiAgICAgICAgbGV0IHRwR2VuID0gdGhpcy5wbHVnaW4uYXBwLnBsdWdpbnMucGx1Z2luc1tcInRlbXBsYXRlci1vYnNpZGlhblwiXS50ZW1wbGF0ZXI7XG4gICAgICAgIHRwR2VuID0gdHBHZW4uZnVuY3Rpb25zX2dlbmVyYXRvci5pbnRlcm5hbF9mdW5jdGlvbnMubW9kdWxlc19hcnJheTtcbiAgICAgICAgbGV0IHRwID0ge31cbiAgICAgICAgLy8gZ2V0IGFuIGluc3RhbmNlIG9mIG1vZHVsZXNcbiAgICAgICAgdHAuZmlsZSA9IHRwR2VuLmZpbmQobSA9PiBtLm5hbWUgPT0gXCJmaWxlXCIpO1xuICAgICAgICB0cC5zeXN0ZW0gPSB0cEdlbi5maW5kKG0gPT4gbS5uYW1lID09IFwic3lzdGVtXCIpO1xuXG4gICAgICAgIGlmICghdHAuc3lzdGVtKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBzZSBwdWRvIGFjY2VkZXIgYWwgb2JqZXRvIGRlIGZ1bmNpb25lcyBhY3R1YWxlcyBkZSBUZW1wbGF0ZXIuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCd0cCBlbiBZQU1MVXBkYXRlckFQSSBzZSBoYSBjYXJnYWRvIHNhdGlzZmFjdG9yaWFtZW50ZScpO1xuICAgIHJldHVybiB0cDtcbiAgICB9XG5cbiAgICAvLyBFamVtcGxvIGRlIGZ1bmNpXHUwMEYzbiBnZXRDYW1wbyBzaW11bGFkYS4gRGViZXMgZGVmaW5pciBmdW5jaW9uZXMgc2ltaWxhcmVzIHBhcmEgJ2lkJywgJ2ZlY2hhJywgZXRjLlxuICAgIGFzeW5jIGdldElkKCkge1xuICAgICAgICBcbiAgICAgICAgbGV0IG1heElkID0gMDtcbiAgICAgICAgLy8gT2J0XHUwMEU5biB0b2RvcyBsb3MgYXJjaGl2b3MgTWFya2Rvd25cbiAgICAgICAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgICAgICBsZXQgcmVnaXN0cm9zRXhpc3RlbnRlcyA9IGZpbGVzLmZpbHRlcigoZmlsZTogeyBwYXRoOiBzdHJpbmc7IH0pID0+IGZpbGUucGF0aC5zdGFydHNXaXRoKHRoaXMuaW5mb1N1YnNpc3RlbWEuZm9sZGVyKSk7XG4gICAgICAgIC8vIEZpbHRyYSBwb3IgbG9zIGFyY2hpdm9zIGVuIGxhIGNhcnBldGEgZGVzZWFkYVxuICAgICAgICBzd2l0Y2godGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibkFWXCI6XG4gICAgICAgICAgICBjYXNlIFwiQVZcIjogICAgXG4gICAgICAgICAgICAgICAgcmVnaXN0cm9zRXhpc3RlbnRlcy5mb3JFYWNoKChmaWxlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuaWQgJiYgIWlzTmFOKG1ldGFkYXRhLmlkKSAmJiBtZXRhZGF0YS50eXBlICYmIG1ldGFkYXRhLnR5cGUgPT09IHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBwYXJzZUludChtZXRhZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPiBtYXhJZCkgbWF4SWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlZ2lzdHJvc0V4aXN0ZW50ZXMuZm9yRWFjaCgoZmlsZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmlkICYmICFpc05hTihtZXRhZGF0YS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gcGFyc2VJbnQobWV0YWRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkID4gbWF4SWQpIG1heElkID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgXG5cbiAgICAgICAgLy8gRWwgcHJcdTAwRjN4aW1vIElEIGRpc3BvbmlibGVcbiAgICAgICAgY29uc3QgbmV4dElkID0gbWF4SWQgKyAxO1xuICAgICAgICAvL3RoaXMubm90YS5pZCA9IG5leHRJZDtcbiAgICAgICAgcmV0dXJuIG5leHRJZDtcbiAgICB9XG4gICAgXG4gICAgYXN5bmMgZ2V0RmVjaGEoKSB7XG4gICAgICAgIGxldCBmZWNoYTtcbiAgICAgICAgbGV0IHByb21wdCA9IHRoaXMudHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwicHJvbXB0XCIpO1xuICAgICAgICBzd2l0Y2godGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgICAgICBsZXQgZmVjaGFPcmlnaW5hbCA9IGF3YWl0IHByb21wdChgQ29uZmlybWEgbGEgZmVjaGEgZGUgbGEgdHJhbnNhY2NpXHUwMEYzbjogYCwgYCR7RGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXktTU0tZGQgSEg6bW0nKX1gLCB0cnVlKVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlYW5kbyBsYSBmZWNoYSBvcmlnaW5hbCB1dGlsaXphbmRvIG1vbWVudFxuICAgICAgICAgICAgICAgIGxldCBmZWNoYU1vbWVudCA9IHdpbmRvdy5tb21lbnQoZmVjaGFPcmlnaW5hbCwgXCJZWVlZLU1NLUREIEhIOm1tXCIpO1xuICAgICAgICAgICAgICAgIC8vIEZvcm1hdGVhbmRvIGxhIG51ZXZhIGZlY2hhIGFsIGZvcm1hdG8gZGVzZWFkb1xuICAgICAgICAgICAgICAgIGZlY2hhID0gZmVjaGFNb21lbnQuZm9ybWF0KFwiWVlZWS1NTS1ERCBkZGRkIEhIbW1zc1wiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICBmZWNoYSA9ICB0aGlzLmZvcm1hdGVhckZlY2hhKG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmVjaGE7XG4gICAgICAgXG5cbiAgICAgICAgXG4gICAgfVxuXG4gICAgZm9ybWF0ZWFyRmVjaGEoZmVjaGE6IERhdGUpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBmZWNoYS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgIGNvbnN0IGZlY2hhTG9jYWwgPSBuZXcgRGF0ZShmZWNoYS5nZXRUaW1lKCkgLSBvZmZzZXQpO1xuICAgICAgICBjb25zdCBmZWNoYUZvcm1hdG8gPSBmZWNoYUxvY2FsLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICAgICAgY29uc3QgZGlhcyA9IFsnRG9taW5nbycsICdMdW5lcycsICdNYXJ0ZXMnLCAnTWlcdTAwRTlyY29sZXMnLCAnSnVldmVzJywgJ1ZpZXJuZXMnLCAnU1x1MDBFMWJhZG8nXTtcbiAgICAgICAgY29uc3QgZGlhU2VtYW5hID0gZGlhc1tmZWNoYS5nZXREYXkoKV07XG4gICAgICAgIGNvbnN0IGhvcmFGb3JtYXRvID0gZmVjaGEudG9UaW1lU3RyaW5nKCkuc3BsaXQoJyAnKVswXS5zdWJzdHJpbmcoMCwgNSk7XG4gICAgICAgIHJldHVybiBgJHtmZWNoYUZvcm1hdG99ICR7ZGlhU2VtYW5hfSAke2hvcmFGb3JtYXRvfWA7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0U2VjSWQoKXtcblxuICAgIH1cbiAgICBcbiAgICBhc3luYyBnZXRUaXR1bG8oKXtcbiAgICAgICAgbGV0IHByb21wdCA9IHRoaXMudHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwicHJvbXB0XCIpO1xuICAgICAgICBsZXQgdGl0dWxvO1xuICAgICAgICBzd2l0Y2godGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiVHhcIjogLy9UcmFuc2FjY2lcdTAwRjNuXG4gICAgICAgICAgICAgICAgdGl0dWxvID0gYXdhaXQgcHJvbXB0KGBOb21icmUgZGUgZXN0ZShhKSAke3RoaXMuaW5mb1N1YnNpc3RlbWEudHlwZU5hbWV9YCwgYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlTmFtZX0gLSAke3RoaXMubm90YS5pZH1gLCB0cnVlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk9DQVwiOiAvL09iamV0aXZvQ29tcGFzc0FudWFsXG4gICAgICAgICAgICAgICAgdGl0dWxvID0gYXdhaXQgcHJvbXB0KGBDdWFsIGVzIHR1IG9iamV0aXZvIGVuICR7dGhpcy5ub3RhLmFcdTAwRjFvfSBwYXJhICR7dGhpcy5ub3RhLmFyZWFWaWRhfT9gLCBgVm95IGEgYCwgdHJ1ZSwgdHJ1ZSkgLy8gNCBwYXJhbWV0cm8gdHJ1ZTogTXVsdGlsaW5lYS5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGl0dWxvID0gYXdhaXQgcHJvbXB0KGBUaXR1bG8gZGUgZXN0ZShhKSAke3RoaXMuaW5mb1N1YnNpc3RlbWEudHlwZU5hbWV9YCwgYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlTmFtZX0gLSAke3RoaXMubm90YS5pZH1gLCB0cnVlKVxuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblx0ICAgIC8vIFZlcmlmaWNhciBzaSBlbCB1c3VhcmlvIHByZXNpb25cdTAwRjMgRXNjLlxuICAgICAgICBpZiAodGl0dWxvID09PSBudWxsKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJDcmVhY2lcdTAwRjNuIGRlIG5vdGEgY2FuY2VsYWRhIHBvciBlbCB1c3VhcmlvLlwiKTtcbiAgICAgICAgcmV0dXJuOyAvLyBUZXJtaW5hIGxhIGVqZWN1Y2lcdTAwRjNuIGRlIGxhIGZ1bmNpXHUwMEYzbiBhcXVcdTAwRUQuXG5cdCAgICB9XG4gICAgICAgIC8vdGhpcy5ub3RhLnRpdHVsbyA9IHRpdHVsbztcbiAgICAgICAgcmV0dXJuIHRpdHVsbztcbiAgICB9XG5cbiAgICBhc3luYyBnZXREZXNjcmlwY2lvbigpe1xuICAgICAgICBsZXQgcHJvbXB0ID0gdGhpcy50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJwcm9tcHRcIik7XG4gICAgICAgIGxldCBkZXNjcmlwY2lvbjtcbiAgICAgICAgc3dpdGNoKHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkF4XCI6XG4gICAgICAgICAgICAgICAgIGRlc2NyaXBjaW9uID0gYXdhaXQgcHJvbXB0KFwiXHUwMEJGUXVpZXJlcyBhZ3JlZ2FyIHVuYSBkZXNjcmlwY2lcdTAwRjNuP1wiLCBcIiBcIiArIGBFc3RhIGFub3RhY2lcdTAwRjNuIGVzIHNvYnJlICR7dGhpcy5ub3RhLnRpdHVsb31gLCBmYWxzZSwgdHJ1ZSApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeFwiOlxuICAgICAgICAgICAgICAgICBkZXNjcmlwY2lvbiA9IGF3YWl0IHByb21wdChgXHUwMEJGUXVpZXJlcyBhZ3JlZ2FyIHVuYSBkZXNjcmlwY2lcdTAwRjNuIGRlICR7dGhpcy5ub3RhLnRpdHVsb30/YCwgXCIgXCIgKyBgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGVOYW1lfSBkZSAke3RoaXMubm90YS50aXR1bG99YCwgZmFsc2UsIHRydWUgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQVZcIjpcbiAgICAgICAgICAgICAgICAgZGVzY3JpcGNpb24gPSBhd2FpdCBwcm9tcHQoYFx1MDBCRlF1aWVyZXMgYWdyZWdhciB1bmEgZGVzY3JpcGNpXHUwMEYzbiBzb2JyZSAke3RoaXMubm90YS50aXR1bG99P2AsIFwiIFwiLCBmYWxzZSwgdHJ1ZSApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBSVwiOlxuICAgICAgICAgICAgICAgICBkZXNjcmlwY2lvbiA9IGF3YWl0IHByb21wdChgXHUwMEJGUXVpZXJlcyBhZ3JlZ2FyIHVuYSBkZXNjcmlwY2lcdTAwRjNuIHNvYnJlICR7dGhpcy5ub3RhLnRpdHVsb30/YCwgXCIgXCIsIGZhbHNlLCB0cnVlIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBHVERcIjpcbiAgICAgICAgICAgICAgICAgZGVzY3JpcGNpb24gPSBhd2FpdCBwcm9tcHQoXCJcdTAwQkZTb2JyZSBxdWUgZXMgZXN0ZSBwcm95ZWN0byBHVEQ/XCIsIFwiIFwiICsgYFByb3llY3RvIHNvYnJlIGAsIGZhbHNlLCB0cnVlIClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk9DQVwiOlxuICAgICAgICAgICAgICAgICBkZXNjcmlwY2lvbiA9IGF3YWl0IHByb21wdChcIlx1MDBCRlF1aWVyZXMgYWdyZWdhciBkZXRhbGxlcyBkZSB0dSBvYmpldGl2bz9cIiwgYCR7dGhpcy5ub3RhLnRpdHVsb31gLCBmYWxzZSwgdHJ1ZSApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGVzY3JpcGNpb24gPSBhd2FpdCBwcm9tcHQoXCJcdTAwQkZRdWllcmVzIGFncmVnYXIgdW5hIGRlc2NyaXBjaVx1MDBGM24/XCIsIFwiIFwiICsgYEVzdGEgbm90YSBlcyBzb2JyZSAke3RoaXMubm90YS50aXR1bG99YCwgZmFsc2UsIHRydWUgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBcblx0ICAgIC8vIFZlcmlmaWNhciBzaSBlbCB1c3VhcmlvIHByZXNpb25cdTAwRjMgRXNjLlxuICAgICAgICBpZiAoZGVzY3JpcGNpb24gPT09IG51bGwpIHtcbiAgICAgICAgbmV3IE5vdGljZShcIkNyZWFjaVx1MDBGM24gZGUgbm90YSBjYW5jZWxhZGEgcG9yIGVsIHVzdWFyaW8uXCIpO1xuICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cblx0ICAgIH1cbiAgICAgICAgLy90aGlzLm5vdGEuZGVzY3JpcGNpb24gPSBkZXNjcmlwY2lvbjtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXBjaW9uO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEFsaWFzZXMoKXtcbiAgICAgICAgbGV0IG5vdGEgPSB7YWxpYXNlczogW119ICAgICAgIFxuICAgICAgICBzd2l0Y2godGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiQXhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJQR1REXCI6XG4gICAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJDUEVcIjogIC8vIENvbnRlbmlkbyBwYXJhIEVzdHVkaW9cbiAgICAgICAgICAgICAgICBub3RhLmFsaWFzZXMucHVzaChgJHt0aGlzLm5vdGEudGl0dWxvfWApXG4gICAgICAgICAgICAgICAgbm90YS5hbGlhc2VzLnB1c2goYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlfS8ke3RoaXMubm90YS50aXR1bG99YClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBSVwiOlxuICAgICAgICAgICAgICAgIG5vdGEuYWxpYXNlcy5wdXNoKGAke3RoaXMuaW5mb1N1YnNpc3RlbWEudHlwZX0vJHt0aGlzLm5vdGEudGl0dWxvfWApXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm90YS5hcmVhVmlkYSAhPSBcIk5vIGVzIGRlIG5pbmdcdTAwRkFuIEFyZWEgZGUgVmlkYVwiKXtcbiAgICAgICAgICAgICAgICBub3RhLmFsaWFzZXMucHVzaChgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGV9LyR7dGhpcy5ub3RhLmFyZWFWaWRhfS8ke3RoaXMubm90YS50aXR1bG99YClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMCAtPiBOb21icmUsIDEgLT4gdHlwZSArIE5vbWJyZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5BVlwiOlxuICAgICAgICAgICAgICAgIG5vdGEuYWxpYXNlcy5wdXNoKGBBVi8ke3RoaXMubm90YS5hcmVhVmlkYX1gKVxuICAgICAgICAgICAgICAgIG5vdGEuYWxpYXNlcy5wdXNoKGBBVi8ke3RoaXMubm90YS5ncnVwb30vJHt0aGlzLm5vdGEuYXJlYVZpZGF9YClcbiAgICAgICAgICAgICAgICBicmVhazsgICBcbiAgICAgICAgICAgIGNhc2UgXCJBVlwiOlxuICAgICAgICAgICAgICAgIG5vdGEuYWxpYXNlcy5wdXNoKGAke3RoaXMuaW5mb1N1YnNpc3RlbWEudHlwZX0vJHt0aGlzLm5vdGEudHJpbWVzdHJlfS8ke3RoaXMubm90YS50aXR1bG99YClcbiAgICAgICAgICAgICAgICBub3RhLmFsaWFzZXMucHVzaChgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGV9LyR7dGhpcy5ub3RhLmdydXBvfS8ke3RoaXMubm90YS50cmltZXN0cmV9LyR7dGhpcy5ub3RhLnRpdHVsb31gKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJSXCI6XG4gICAgICAgICAgICAgICAgbm90YS5hbGlhc2VzLnB1c2goYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlfS8ke3RoaXMubm90YS50aXR1bG99YClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJQUVwiOlxuICAgICAgICAgICAgICAgIG5vdGEuYWxpYXNlcy5wdXNoKGAke3RoaXMuaW5mb1N1YnNpc3RlbWEudHlwZX0vJHt0aGlzLm5vdGEudHJpbWVzdHJlfS8ke3RoaXMubm90YS50aXR1bG99YClcbiAgICAgICAgICAgICAgICBub3RhLmFsaWFzZXMucHVzaChgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGV9LyR7QXJyYXkuaXNBcnJheSh0aGlzLm5vdGEuYXJlYVZpZGEpID8gdGhpcy5ub3RhLmFyZWFWaWRhWzBdIDogdGhpcy5ub3RhLmFyZWFWaWRhfS8ke3RoaXMubm90YS50cmltZXN0cmV9LyR7dGhpcy5ub3RhLnRpdHVsb31gKTtcbiAgICAgICAgICAgICAgICBub3RhLmFsaWFzZXMucHVzaChgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGV9LyR7dGhpcy5ub3RhLnRyaW1lc3RyZX0vJHtBcnJheS5pc0FycmF5KHRoaXMubm90YS5hcmVhVmlkYSkgPyB0aGlzLm5vdGEuYXJlYVZpZGFbMF0gOiB0aGlzLm5vdGEuYXJlYVZpZGF9LyR7dGhpcy5ub3RhLnRpdHVsb31gKVxuICAgICAgICAgICAgYnJlYWs7ICAgIFxuICAgICAgICAgICAgY2FzZSBcIk9DQVwiOlxuICAgICAgICAgICAgICAgIG5vdGEuYWxpYXNlcy5wdXNoKGAke3RoaXMuaW5mb1N1YnNpc3RlbWEudHlwZX0vJHt0aGlzLm5vdGEuYVx1MDBGMW99LyR7dGhpcy5ub3RhLmlkfWApXG4gICAgICAgICAgICAgICAgbm90YS5hbGlhc2VzLnB1c2goYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlfS8ke3RoaXMubm90YS5hXHUwMEYxb30vJHt0aGlzLm5vdGEuYXJlYVZpZGF9LyR7dGhpcy5ub3RhLmlkfWApXG4gICAgICAgICAgICAgICAgbm90YS5hbGlhc2VzLnB1c2goYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlfS8ke3RoaXMubm90YS50aXR1bG99YClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJDQUlcIjogLy8gQ29tcGFzc0FudWFsSW5pY2lvXG4gICAgICAgICAgICAgICAgbm90YS5hbGlhc2VzLnB1c2goYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlTmFtZX0vJHt0aGlzLm5vdGEuYVx1MDBGMW99YCkgICBcbiAgICAgICAgICAgICAgICBub3RhLmFsaWFzZXMucHVzaChgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGVOYW1lfS8ke3RoaXMubm90YS5pZH1gKSAgIFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkNUSVwiOiAvLyBDb21wYXNzVHJpbWVzdHJhbEluaWNpb1xuICAgICAgICAgICAgICAgIG5vdGEuYWxpYXNlcy5wdXNoKGAke3RoaXMuaW5mb1N1YnNpc3RlbWEudHlwZU5hbWV9LyR7dGhpcy5ub3RhLnRyaW1lc3RyZX1gKSAgIFxuICAgICAgICAgICAgICAgIG5vdGEuYWxpYXNlcy5wdXNoKGAke3RoaXMuaW5mb1N1YnNpc3RlbWEudHlwZU5hbWV9LyR7dGhpcy5ub3RhLmlkfWApICAgXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9ICAgICAgIFxuXG4gICAgICAgICAgICByZXR1cm4gbm90YS5hbGlhc2VzO1xuICAgICAgIFxuICAgIH1cblxuICAgIGFzeW5jIGdldEFzdW50bygpeyAvLyBGdW5jaW9uYSBjb24gZnJvbnRtYXR0ZXJcblxuICAgICAgICBsZXQgc3VnZ2VzdGVyID0gdGhpcy50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG4gICAgICAgIGxldCB0aXBvU2lzdGVtYSA9IHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZTtcbiAgICAgICAgbGV0IG5vbWJyZVNpc3RlbWEgPSB0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGVOYW1lO1xuICAgICAgICBsZXQgc3Vic2lzdGVtYXMsIHBhZHJlcyA9IFtdO1xuICAgICAgICBsZXQgYWN0aXZvID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIGxldCBzaUFzdW50byA9IGZhbHNlO1xuICAgICAgICBsZXQgbm9tYnJlID0gXCJcIjtcbiAgICAgICAgbGV0IG5vdGE7XG4gICAgICAgIGlmIChhY3Rpdm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgbm9tYnJlID0gYWN0aXZvLmJhc2VuYW1lO1xuICAgICAgICAgICAgbm90YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShhY3Rpdm8pO1xuICAgICAgICAgICAgLy8gQXNlZ3VyYXIgcXVlIG5vdGEuZnJvbnRtYXR0ZXIgZXhpc3RlIHkgYXNpZ25hciB1biBvYmpldG8gdmFjXHUwMEVEbyBhIGZpbGVcbiAgICAgICAgICAgIG5vdGEuZnJvbnRtYXR0ZXIgPSBub3RhLmZyb250bWF0dGVyIHx8IHt9O1xuICAgICAgICAgICAgbm90YS5mcm9udG1hdHRlci5maWxlID0ge307XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5vdGEuZnJvbnRtYXR0ZXIuZmlsZSwgYWN0aXZvKTtcbiAgICAgICAgICAgIC8vMS4gc2lBc3VudG8gPSBhd2FpdCBzdWdnZXN0ZXIoW1wiU2lcIiwgXCJOb1wiXSwgW3RydWUsIGZhbHNlXSwgdHJ1ZSwgbm9tYnJlICsgXCIgZXMgb3JpZ2VuIGRlIFwiICsgdGhpcy5ub3RhLnRpdHVsbyArIFwiP1wiKTtcbiAgICAgICAgICAgIHBhZHJlcy51bnNoaWZ0KG5vbWJyZSk7IC8vIEFcdTAwRjFhZGUgZWwgbm9tYnJlIGFsIGluaWNpbyBkZWwgYXJyZWdsbywgZGVzcGxhemFuZG8gbG9zIGRlbVx1MDBFMXMgZWxlbWVudG9zXG4gICAgICAgICAgICBzd2l0Y2godGlwb1Npc3RlbWEpIHsgLy8gRXN0b3kgY3JlYW5kbyB1bjogXG4gICAgICAgICAgICAgICAgY2FzZSBcIlJSXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBHVERcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXhcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQ1BFXCI6ICAvLyBDb250ZW5pZG8gcGFyYSBFc3R1ZGlvXG4gICAgICAgICAgICAgICAgICAgIHNpQXN1bnRvID0gYXdhaXQgc3VnZ2VzdGVyKFtcIlNpXCIsIFwiTm9cIl0sIFt0cnVlLCBmYWxzZV0sIHRydWUsIG5vbWJyZSArIFwiIGVzIG9yaWdlbiBkZSBcIiArIHRoaXMubm90YS50aXR1bG8gKyBcIj9cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaUFzdW50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXN1bnRvRGVmaW5pZG8gPSB0cnVlOyAvLyBQYXJhIHF1ZSBubyBlamVjdXRlIGxhIGJ1c3F1ZWRhIGRlIEFyZWEgVmlkYSwgQXJlYSBkZSBJbnRlclx1MDBFOXMsIHByb3llY3RvIFEgbyBHVERcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuaXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobm90YT8uZnJvbnRtYXR0ZXI/LnR5cGUpeyAvLyBMYSBub3RhIGFjdGl2cyBlcyB1bmE6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlBHVERcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUFFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZFUklGSUNBQ0lPTiBERSBQUk9ZRUNUT1MgREUgUSBZIFBST1lFQ1RPIEdURFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90YS5mcm9udG1hdHRlcj8udHlwZSA9PT0gXCJQUVwiKXsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENVQU5ETyBMQSBOT1RBIEFDVElWQSBFUyBVTiBQUS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLnByb3llY3RvUSA9IG5vbWJyZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWRVJJRklDQUNJT04gREUgUFJPWUVDVE9TR1REXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluaWNpYWxpemFtb3MgdGhpcy5ub3RhLnByb3llY3RvR1REIGNvbiB1biB2YWxvciBwcmVkZXRlcm1pbmFkbyBkZSBjYWRlbmEgdmFjXHUwMEVEYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEucHJveWVjdG9HVEQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZmljYW1vcyBzaSBub3RhLnByb3llY3RvR1REIGV4aXN0ZSB5IGVzIHVuIGFycmVnbG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGVzIHVuIGFycmVnbG8sIGl0ZXJhbW9zIHNvYnJlIGNhZGEgZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b0dURCA9IG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQubWFwKGVsZW1lbnRvID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRvLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGV4aXN0ZSBwZXJvIG5vIGVzIHVuIGFycmVnbG8sIGFwbGljYW1vcyBlbCByZWdleCBkaXJlY3RhbWVudGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b0dURCA9IG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBub3RhLnByb3llY3RvR1REIG5vIGV4aXN0ZSwgdGhpcy5ub3RhLnByb3llY3RvR1REIHlhIGVzdFx1MDBFMSBlc3RhYmxlY2lkbyBlbiBcIlwiIHBvciBkZWZlY3RvXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9idGVuZXIgUHJveWVjdG9RIHkgUHJveWVjdG8gR1REIGN1YW5kbyBsYSBub3RhIGVzIFByb3llY3RvR1RELlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub3RhLmZyb250bWF0dGVyPy50eXBlID09PSBcIlBHVERcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENVQU5ETyBMQSBOT1RBIEFDVElWQSBFUyBVTiBHVEQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWRVJJRklDQUNJT04gREUgUFJPWUVDVE9TR1REXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEucHJveWVjdG9HVEQgPSBbbm9tYnJlXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBlcyB1biBhcnJlZ2xvLCB1dGlsaXphbW9zIGNvbmNhdCBwYXJhIGFcdTAwRjFhZGlyIGxvcyBlbGVtZW50b3MgeWEgcHJvY2VzYWRvcyBjb24gZWwgcmVnZXggYWwgYXJyZWdsbyB0aGlzLm5vdGEucHJveWVjdG9HVERcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEucHJveWVjdG9HVEQgPSB0aGlzLm5vdGEucHJveWVjdG9HVEQuY29uY2F0KG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQubWFwKGVsZW1lbnRvID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50by5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBleGlzdGUgcGVybyBubyBlcyB1biBhcnJlZ2xvLCBhcGxpY2Ftb3MgZWwgcmVnZXggZGlyZWN0YW1lbnRlIHkgdXNhbW9zIHB1c2ggcGFyYSBhZ3JlZ2FybG8gYSB0aGlzLm5vdGEucHJveWVjdG9HVERcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEucHJveWVjdG9HVEQucHVzaChub3RhLmZyb250bWF0dGVyLnByb3llY3RvR1RELnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBub3RhLnByb3llY3RvR1REIG5vIGV4aXN0ZSwgdGhpcy5ub3RhLnByb3llY3RvR1REIHlhIGVzdFx1MDBFMSBlc3RhYmxlY2lkbyBlbiBcIlwiIHBvciBkZWZlY3RvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEucHJveWVjdG9RID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9RKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXMgdW4gYXJyZWdsbywgaXRlcmFtb3Mgc29icmUgY2FkYSBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLnByb3llY3RvUSA9IG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9RLm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50by5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub3RhLmZyb250bWF0dGVyLnByb3llY3RvUSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlIHBlcm8gbm8gZXMgdW4gYXJyZWdsbywgYXBsaWNhbW9zIGVsIHJlZ2V4IGRpcmVjdGFtZW50ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLnByb3llY3RvUSA9IG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9RLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPYnRlbmVyIFByb3llY3RvUSB5IFByb3llY3RvIEdURCBjdWFuZG8gbGEgbm90YSBlcyBvdHJhIGNvc2EgcXVlIG5vIGVzIHByb3llY3RvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEucHJveWVjdG9RID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGE/LmZyb250bWF0dGVyPy5wcm95ZWN0b1EpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXMgdW4gYXJyZWdsbywgaXRlcmFtb3Mgc29icmUgY2FkYSBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b1EgPSBub3RhLmZyb250bWF0dGVyLnByb3llY3RvUS5tYXAoZWxlbWVudG8gPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRvLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub3RhPy5mcm9udG1hdHRlcj8ucHJveWVjdG9RKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlIHBlcm8gbm8gZXMgdW4gYXJyZWdsbywgYXBsaWNhbW9zIGVsIHJlZ2V4IGRpcmVjdGFtZW50ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b1EgPSBub3RhLmZyb250bWF0dGVyLnByb3llY3RvUS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEucHJveWVjdG9HVEQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Ftb3Mgc2kgbm90YS5wcm95ZWN0b0dURCBleGlzdGUgeSBlcyB1biBhcnJlZ2xvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub3RhPy5mcm9udG1hdHRlcj8ucHJveWVjdG9HVEQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXMgdW4gYXJyZWdsbywgaXRlcmFtb3Mgc29icmUgY2FkYSBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b0dURCA9IG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQubWFwKGVsZW1lbnRvID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50by5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm90YT8uZnJvbnRtYXR0ZXI/LnByb3llY3RvR1REKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlIHBlcm8gbm8gZXMgdW4gYXJyZWdsbywgYXBsaWNhbW9zIGVsIHJlZ2V4IGRpcmVjdGFtZW50ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b0dURCA9IG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmaWNhbW9zIGFyZWFJbnRlcmVzIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYUludGVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm90YT8uZnJvbnRtYXR0ZXI/LmFyZWFJbnRlcmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXMgdW4gYXJyZWdsbywgaXRlcmFtb3Mgc29icmUgY2FkYSBlbGVtZW50byAoZXhjbHV5ZW5kbyBlbCBwcmltZXIgZWxlbWVudG8geWEgYWdyZWdhZG8gcXVlIGVzIG5vdGEudGl0dWxvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geSBhcGxpY2Ftb3MgZWwgcmVnZXggYSBjYWRhIGVsZW1lbnRvLiBMdWVnbyBjb25jYXRlbmFtb3MgY29uIGVsIGFycmF5IGV4aXN0ZW50ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhSW50ZXJlcyA9IHRoaXMubm90YS5hcmVhSW50ZXJlcy5jb25jYXQobm90YS5mcm9udG1hdHRlci5hcmVhSW50ZXJlcy5tYXAoZWxlbWVudG8gPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgbm8gZXMgdW4gYXJyZWdsbywgcmV2aXNhbW9zIHNpIG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMgZXhpc3RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90YT8uZnJvbnRtYXR0ZXI/LmFyZWFJbnRlcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlLCBhcGxpY2Ftb3MgZWwgcmVnZXggeSBsbyBhXHUwMEYxYWRpbW9zIGNvbW8gc2VndW5kbyBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhSW50ZXJlcy5wdXNoKG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Ftb3MgQXJlYVZpZGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGE/LmZyb250bWF0dGVyPy5hcmVhVmlkYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm90YS5mcm9udG1hdHRlci5hcmVhVmlkYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcyB1biBhcnJlZ2xvLCB1c2EgZWwgcHJpbWVyIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gbm90YS5mcm9udG1hdHRlci5hcmVhVmlkYVswXS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm90YS5mcm9udG1hdHRlci5hcmVhVmlkYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcyB1biBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBub3RhLmZyb250bWF0dGVyLmFyZWFWaWRhLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBlc3RcdTAwRTEgZGVmaW5pZG8gbyBlc3RcdTAwRTEgdmFjXHUwMEVEb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gXCJObyBlcyBkZSBuaW5nXHUwMEZBbiBBcmVhIGRlIFZpZGFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gREVGSU5JUiBOSVZFTFBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHJ1ZWJhIHNpIG5pdmVsQUkgZXhpc3RlIHkgbm8gZXMgTmFOIGRlc3B1XHUwMEU5cyBkZSBpbnRlbnRhciBjb252ZXJ0aXJsbyBhIGVudGVyb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZUludChub3RhPy5mcm9udG1hdHRlcj8ubml2ZWxQKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pdmVsID0gcGFyc2VJbnQobm90YS5mcm9udG1hdHRlci5uaXZlbFApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIG5pdmVsQUkgbm8gZXhpc3RlIG8gc3UgY29udmVyc2lcdTAwRjNuIGEgZW50ZXJvIHJlc3VsdGEgZW4gTmFOLCBlc3RhYmxlY2Ugbml2ZWwgYSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLm5pdmVsUCA9IG5pdmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gUEdURCB5IFBRXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFJXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWRVJJRklDQUNJT04gREUgQVJFQSBERSBJTlRFUkVTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RhPy5mcm9udG1hdHRlcj8udHlwZSA9PT0gXCJBSVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhSW50ZXJlcyA9IFtub3RhLmZyb250bWF0dGVyLmZpbGUuYmFzZW5hbWVdOyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluaWNpYWxpemFtb3MgdGhpcy5ub3RhLmFyZWFJbnRlcmVzIGNvbiBub3RhLnRpdHVsbyBjb21vIGVsIHByaW1lciBlbGVtZW50by5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzdGUgc29sbyBhcGxpY2EgcGFyYSBjdWFuZG8gZXN0b3kgY29uc3RydXllbmRvIGRlc2RlIEFyZWEgZGUgSW50ZXJlcyBvdHJhIEFyZWEgZGUgSW50ZXJlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Ftb3Mgc2kgbm90YS5hcmVhSW50ZXJlcyBlcyB1biBhcnJlZ2xvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub3RhLmZyb250bWF0dGVyPy5hcmVhSW50ZXJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGVzIHVuIGFycmVnbG8sIGl0ZXJhbW9zIHNvYnJlIGNhZGEgZWxlbWVudG8gKGV4Y2x1eWVuZG8gZWwgcHJpbWVyIGVsZW1lbnRvIHlhIGFncmVnYWRvIHF1ZSBlcyBub3RhLnRpdHVsbylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHkgYXBsaWNhbW9zIGVsIHJlZ2V4IGEgY2FkYSBlbGVtZW50by4gTHVlZ28gY29uY2F0ZW5hbW9zIGNvbiBlbCBhcnJheSBleGlzdGVudGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYUludGVyZXMgPSB0aGlzLm5vdGEuYXJlYUludGVyZXMuY29uY2F0KG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMubWFwKGVsZW1lbnRvID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRvLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIG5vIGVzIHVuIGFycmVnbG8sIHJldmlzYW1vcyBzaSBub3RhLmZyb250bWF0dGVyLmFyZWFJbnRlcmVzIGV4aXN0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGE/LmZyb250bWF0dGVyLmFyZWFJbnRlcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlLCBhcGxpY2Ftb3MgZWwgcmVnZXggeSBsbyBhXHUwMEYxYWRpbW9zIGNvbW8gc2VndW5kbyBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhSW50ZXJlcy5wdXNoKG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgbm8gZXMgYXJyZWdsbyBuaSBzdHJpbmcsIGFyZWFJbnRlcmVzIGVzIGVsIGFyZWEgaW50ZXJlcyBxdWUgZXN0XHUwMEUxIGVuIHRpdHVsby4gICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgbm90YS5mcm9udG1hdHRlci5hcmVhSW50ZXJlcyBubyBleGlzdGUsIHRoaXMubm90YS5hcmVhSW50ZXJlcyB5YSB0ZW5kclx1MDBFMSBub3RhLnRpdHVsbyBjb21vIHN1IFx1MDBGQW5pY28gZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZFUklGSUNBQ0lPTiBERSBBUkVBIERFIFZJREFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGE/LmZyb250bWF0dGVyPy5hcmVhVmlkYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm90YS5mcm9udG1hdHRlci5hcmVhVmlkYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcyB1biBhcnJlZ2xvLCB1c2EgZWwgcHJpbWVyIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gbm90YS5mcm9udG1hdHRlci5hcmVhVmlkYVswXS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm90YS5mcm9udG1hdHRlci5hcmVhVmlkYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcyB1biBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBub3RhLmZyb250bWF0dGVyLmFyZWFWaWRhLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBlc3RcdTAwRTEgZGVmaW5pZG8gbyBlc3RcdTAwRTEgdmFjXHUwMEVEb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gXCJObyBlcyBkZSBuaW5nXHUwMEZBbiBcdTAwQzFyZWEgZGUgVmlkYVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvbmllbmRvIHNpIEFzdW50byBlbiBmYWxzZSBwYXJhIGxhcyBub3RhcyBlc3RydWN0dXJhIEFJIHkgQVYuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90YT8uZnJvbnRtYXR0ZXI/LnR5cGUgPT09IFwiQUlcInx8bm90YT8uZnJvbnRtYXR0ZXI/LnR5cGUgPT09IFwiQVZcIil7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lBc3VudG8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERFRklOSVIgTklWRUxQXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBydWViYSBzaSBuaXZlbEFJIGV4aXN0ZSB5IG5vIGVzIE5hTiBkZXNwdVx1MDBFOXMgZGUgaW50ZW50YXIgY29udmVydGlybG8gYSBlbnRlcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQobm90YS5mcm9udG1hdHRlcj8ubml2ZWxQKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pdmVsID0gcGFyc2VJbnQobm90YS5mcm9udG1hdHRlci5uaXZlbFApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIG5pdmVsQUkgbm8gZXhpc3RlIG8gc3UgY29udmVyc2lcdTAwRjNuIGEgZW50ZXJvIHJlc3VsdGEgZW4gTmFOLCBlc3RhYmxlY2Ugbml2ZWwgYSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLm5pdmVsUCA9IG5pdmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7IC8vIGFjdGl2YSBubyBlcyBvcmlnZW4gZGUgQ3JlYW5kbyBSUiAtIFBHVEQgLSBQUSAgaWYoc2lBc3VudG8pXG5cbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIENyZWFuZG8gUlJcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhc2UgXCJQUVwiOiAgLy8gRXN0b3kgQ3JlYW5kbyB1biBQUSBcbiAgICAgICAgICAgICAgICAgICAgc2lBc3VudG8gPSBhd2FpdCBzdWdnZXN0ZXIoW1wiU2lcIiwgXCJOb1wiXSwgW3RydWUsIGZhbHNlXSwgdHJ1ZSwgbm9tYnJlICsgXCIgZXMgb3JpZ2VuIGRlIFwiICsgdGhpcy5ub3RhLnRpdHVsbyArIFwiP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpQXN1bnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBRIHJlcXVpZXJlIG9ibGlnYXRvcmlhbWVudGUgdGVuZXIgQXJlYSBkZSBWaWRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGE/LmZyb250bWF0dGVyPy5hcmVhVmlkYSAhPT0gdW5kZWZpbmVkICYmIG5vdGEuZnJvbnRtYXR0ZXIuYXJlYVZpZGEgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDXHUwMEYzZGlnbyBhIGVqZWN1dGFyIHNpIGFyZWFWaWRhIGV4aXN0ZSB5IG5vIGVzIHVuYSBjYWRlbmEgdmFjXHUwMEVEYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGEuZnJvbnRtYXR0ZXIuYXJlYVZpZGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzIHVuIGFycmVnbG8sIHVzYSBlbCBwcmltZXIgZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gbm90YS5mcm9udG1hdHRlci5hcmVhVmlkYVswXS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vdGEuZnJvbnRtYXR0ZXIuYXJlYVZpZGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzIHVuIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBub3RhLmZyb250bWF0dGVyLmFyZWFWaWRhLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb25pZW5kbyBzaSBBc3VudG8gZW4gZmFsc2UgcGFyYSBsYXMgbm90YXMgZXN0cnVjdHVyYSBBSSB5IEFWLiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90YT8uZnJvbnRtYXR0ZXI/LnR5cGUgPT09IFwiQUlcInx8bm90YT8uZnJvbnRtYXR0ZXI/LnR5cGUgPT09IFwiQVZcIil7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaUFzdW50byA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuaXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobm90YT8uZnJvbnRtYXR0ZXI/LnR5cGUpeyAvLyB0aXBvIGRlIG5vdGEgYWN0aXZhIGNyZWFuZG8gdW4gUFEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlBHVERcIjpcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWRVJJRklDQUNJT04gREUgUFJPWUVDVE9TR1REXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b0dURCA9IFtub21icmVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBlcyB1biBhcnJlZ2xvLCB1dGlsaXphbW9zIGNvbmNhdCBwYXJhIGFcdTAwRjFhZGlyIGxvcyBlbGVtZW50b3MgeWEgcHJvY2VzYWRvcyBjb24gZWwgcmVnZXggYWwgYXJyZWdsbyB0aGlzLm5vdGEucHJveWVjdG9HVERcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b0dURCA9IHRoaXMubm90YS5wcm95ZWN0b0dURC5jb25jYXQobm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURC5tYXAoZWxlbWVudG8gPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vdGEuZnJvbnRtYXR0ZXIucHJveWVjdG9HVEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGV4aXN0ZSBwZXJvIG5vIGVzIHVuIGFycmVnbG8sIGFwbGljYW1vcyBlbCByZWdleCBkaXJlY3RhbWVudGUgeSB1c2Ftb3MgcHVzaCBwYXJhIGFncmVnYXJsbyBhIHRoaXMubm90YS5wcm95ZWN0b0dURFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLnByb3llY3RvR1RELnB1c2gobm90YS5mcm9udG1hdHRlci5wcm95ZWN0b0dURC5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBSVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWRVJJRklDQUNJT04gREUgQVJFQSBERSBJTlRFUkVTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RhPy5mcm9udG1hdHRlcj8udHlwZSA9PT0gXCJBSVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhSW50ZXJlcyA9IFtub3RhLmZyb250bWF0dGVyLmZpbGUuYmFzZW5hbWVdOyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluaWNpYWxpemFtb3MgdGhpcy5ub3RhLmFyZWFJbnRlcmVzIGNvbiBub3RhLnRpdHVsbyBjb21vIGVsIHByaW1lciBlbGVtZW50by5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzdGUgc29sbyBhcGxpY2EgcGFyYSBjdWFuZG8gZXN0b3kgY29uc3RydXllbmRvIGRlc2RlIEFyZWEgZGUgSW50ZXJlcyBvdHJhIEFyZWEgZGUgSW50ZXJlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYUludGVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Ftb3Mgc2kgbm90YS5hcmVhSW50ZXJlcyBlcyB1biBhcnJlZ2xvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub3RhLmZyb250bWF0dGVyPy5hcmVhSW50ZXJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGVzIHVuIGFycmVnbG8sIGl0ZXJhbW9zIHNvYnJlIGNhZGEgZWxlbWVudG8gKGV4Y2x1eWVuZG8gZWwgcHJpbWVyIGVsZW1lbnRvIHlhIGFncmVnYWRvIHF1ZSBlcyBub3RhLnRpdHVsbylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHkgYXBsaWNhbW9zIGVsIHJlZ2V4IGEgY2FkYSBlbGVtZW50by4gTHVlZ28gY29uY2F0ZW5hbW9zIGNvbiBlbCBhcnJheSBleGlzdGVudGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYUludGVyZXMgPSB0aGlzLm5vdGEuYXJlYUludGVyZXMuY29uY2F0KG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMubWFwKGVsZW1lbnRvID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRvLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIG5vIGVzIHVuIGFycmVnbG8sIHJldmlzYW1vcyBzaSBub3RhLmZyb250bWF0dGVyLmFyZWFJbnRlcmVzIGV4aXN0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGE/LmZyb250bWF0dGVyLmFyZWFJbnRlcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlLCBhcGxpY2Ftb3MgZWwgcmVnZXggeSBsbyBhXHUwMEYxYWRpbW9zIGNvbW8gc2VndW5kbyBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhSW50ZXJlcy5wdXNoKG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFJbnRlcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgbm90YS5mcm9udG1hdHRlci5hcmVhSW50ZXJlcyBubyBleGlzdGUsIHRoaXMubm90YS5hcmVhSW50ZXJlcyB5YSB0ZW5kclx1MDBFMSBub3RhLnRpdHVsbyBjb21vIHN1IFx1MDBGQW5pY28gZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQVZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibkFWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBERUZJTklSIE5JVkVMUFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wcnVlYmEgc2kgbml2ZWxBSSBleGlzdGUgeSBubyBlcyBOYU4gZGVzcHVcdTAwRTlzIGRlIGludGVudGFyIGNvbnZlcnRpcmxvIGEgZW50ZXJvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQobm90YS5mcm9udG1hdHRlcj8ubml2ZWxQKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pdmVsID0gcGFyc2VJbnQobm90YS5mcm9udG1hdHRlci5uaXZlbFApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIG5pdmVsQUkgbm8gZXhpc3RlIG8gc3UgY29udmVyc2lcdTAwRjNuIGEgZW50ZXJvIHJlc3VsdGEgZW4gTmFOLCBlc3RhYmxlY2Ugbml2ZWwgYSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLm5pdmVsUCA9IG5pdmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXN1bnRvRGVmaW5pZG8gPSB0cnVlOyAvLyBQYXJhIHF1ZSBubyBlamVjdXRlIGxhIGJ1c3F1ZWRhIGRlIEFyZWEgVmlkYSwgQXJlYSBkZSBJbnRlclx1MDBFOXMsIHByb3llY3RvIFEgbyBHVERcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlVuIFByb3llY3RvIGRlIFEgc29sbyBwdWVkZSBpbmljaWFyIGRlIHVuIEFWLCBBSSBvIFBHVEQuIEFzdW50byBubyBkZWZpbmlkby5cIik7ICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIC8vIEFyZWEgZGUgdmlkYSBkZSBhY3RpdmEsIGNyZWFuZG8gUFEgTm8gZXN0XHUwMEUxIGRlZmluaWRvIG8gZXN0XHUwMEUxIHZhY1x1MDBFRG9cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJUb2RvcyBsb3MgcHJveWVjdG9zIGRlIFEgcmVxdWllcmVuIEFyZWEgZGUgVmlkYS4gQXN1bnRvIG5vIGRlZmluaWRvLlwiKTsgXG4gICAgICAgICAgICAgICAgICAgICAgIHNpQXN1bnRvID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ZWxzZXsgLy8gYWN0aXZhIG5vIGVzIG9yaWdlbiBkZSBDcmVhbmRvIFBRICBpZihzaUFzdW50bylcblxuICAgICAgICAgICAgICAgIH0gICAgIFxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBDcmVhbmRvIFBRXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFJXCI6IC8vIENyZWFuZG8gdW4gQUlcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5pdmVsO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vdGE/LmZyb250bWF0dGVyPy50eXBlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBSVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibkFWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lBc3VudG8gPSBhd2FpdCBzdWdnZXN0ZXIoW1wiU2lcIiwgXCJOb1wiXSwgW3RydWUsIGZhbHNlXSwgdHJ1ZSwgbm9tYnJlICsgXCIgZXMgb3JpZ2VuIGRlIFwiICsgdGhpcy5ub3RhLnRpdHVsbyArIFwiP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lBc3VudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFzdW50b0RlZmluaWRvID0gdHJ1ZTsgLy8gUGFyYSBxdWUgbm8gZWplY3V0ZSBsYSBidXNxdWVkYSBkZSBBcmVhIFZpZGEsIEFyZWEgZGUgSW50ZXJcdTAwRTlzLCBwcm95ZWN0byBRIG8gR1REXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZFUklGSUNBQ0lPTiBERSBBUkVBIERFIElOVEVSRVNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5pY2lhbGl6YW1vcyB0aGlzLm5vdGEuYXJlYUludGVyZXMgY29uIG5vdGEudGl0dWxvIGNvbW8gZWwgcHJpbWVyIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90YT8uZnJvbnRtYXR0ZXI/LnR5cGUgPT09IFwiQUlcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYUludGVyZXMgPSBbbm90YS5mcm9udG1hdHRlci5maWxlLmJhc2VuYW1lXTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZmljYW1vcyBzaSBub3RhLmFyZWFJbnRlcmVzIGVzIHVuIGFycmVnbG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXMgdW4gYXJyZWdsbywgaXRlcmFtb3Mgc29icmUgY2FkYSBlbGVtZW50byAoZXhjbHV5ZW5kbyBlbCBwcmltZXIgZWxlbWVudG8geWEgYWdyZWdhZG8gcXVlIGVzIG5vdGEudGl0dWxvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHkgYXBsaWNhbW9zIGVsIHJlZ2V4IGEgY2FkYSBlbGVtZW50by4gTHVlZ28gY29uY2F0ZW5hbW9zIGNvbiBlbCBhcnJheSBleGlzdGVudGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFJbnRlcmVzID0gdGhpcy5ub3RhLmFyZWFJbnRlcmVzLmNvbmNhdChub3RhLmZyb250bWF0dGVyLmFyZWFJbnRlcmVzLm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBubyBlcyB1biBhcnJlZ2xvLCByZXZpc2Ftb3Mgc2kgbm90YS5mcm9udG1hdHRlci5hcmVhSW50ZXJlcyBleGlzdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90YT8uZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXhpc3RlLCBhcGxpY2Ftb3MgZWwgcmVnZXggeSBsbyBhXHUwMEYxYWRpbW9zIGNvbW8gc2VndW5kbyBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYUludGVyZXMucHVzaChub3RhLmZyb250bWF0dGVyLmFyZWFJbnRlcmVzLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMgbm8gZXhpc3RlLCB0aGlzLm5vdGEuYXJlYUludGVyZXMgeWEgdGVuZHJcdTAwRTEgbm90YS50aXR1bG8gY29tbyBzdSBcdTAwRkFuaWNvIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVkVSSUZJQ0FDSU9OIERFIEFSRUEgREUgVklEQVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90YT8uZnJvbnRtYXR0ZXI/LmFyZWFWaWRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub3RhLmZyb250bWF0dGVyLmFyZWFWaWRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzIHVuIGFycmVnbG8sIHVzYSBlbCBwcmltZXIgZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBub3RhLmZyb250bWF0dGVyLmFyZWFWaWRhWzBdLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub3RhLmZyb250bWF0dGVyLmFyZWFWaWRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzIHVuIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhVmlkYSA9IG5vdGEuZnJvbnRtYXR0ZXIuYXJlYVZpZGEucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGVzdFx1MDBFMSBkZWZpbmlkbyBvIGVzdFx1MDBFMSB2YWNcdTAwRURvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBcIk5vIGVzIGRlIG5pbmdcdTAwRkFuIFx1MDBDMXJlYSBkZSBWaWRhXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9uaWVuZG8gc2kgQXN1bnRvIGVuIGZhbHNlIHBhcmEgbGFzIG5vdGFzIGVzdHJ1Y3R1cmEgQUkgeSBBVi4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RhPy5mcm9udG1hdHRlcj8udHlwZSA9PT0gXCJBSVwifHxub3RhPy5mcm9udG1hdHRlcj8udHlwZSA9PT0gXCJBVlwiKXsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaUFzdW50byA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gREVGSU5JUiBOSVZFTEFJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBydWViYSBzaSBuaXZlbEFJIGV4aXN0ZSB5IG5vIGVzIE5hTiBkZXNwdVx1MDBFOXMgZGUgaW50ZW50YXIgY29udmVydGlybG8gYSBlbnRlcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZUludChub3RhLmZyb250bWF0dGVyPy5uaXZlbEFJKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pdmVsID0gcGFyc2VJbnQobm90YS5mcm9udG1hdHRlci5uaXZlbEFJKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBuaXZlbEFJIG5vIGV4aXN0ZSBvIHN1IGNvbnZlcnNpXHUwMEYzbiBhIGVudGVybyByZXN1bHRhIGVuIE5hTiwgZXN0YWJsZWNlIG5pdmVsIGEgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbml2ZWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5uaXZlbEFJID0gbml2ZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgLy8gQ2FzZSBBSSAtIEFWXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gc3dpdGNoIGNhc2Ugc29icmUgZWwgdGlwbyBkZSBub3RhIGFjdGl2YS5cbiAgICAgICAgICAgICAgICBicmVhazsgLy8gQ3JlYW5kbyB1biBBSVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAvLyBBc3VudG8gRGUgbGEgbm90YSBxdWUgZXN0XHUwMEU5IGNyZWFuZG8gY3VhbmRvIGVzIGN1YWxxdWVpciBjb3NhXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRGVwZW5kaWVuZG8gZGUgbGEgZXN0cnVjdHVyYSwgZ2V0QXN1bnRvIGRlYmVyaWEgdGVuZXIgc3UgY2xhc2lmaWNhY2lcdTAwRjNuLiBBcXVpIHZhcyBhIHRlbmVyIHVuIGVycm9yLlwiKSBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSAvLyBzd2l0Y2ggdGlwbyhzaXN0ZW1hKSAtPiBTb2JyZSBsYSBub3RhIHF1ZSBlc3RcdTAwRTkgY3JlYW5kby5cblxuICAgICAgICB9IGVsc2UgeyAvLyBhY3Rpdm8gPT0gbnVsbFxuICAgICAgICAgICAgc2lBc3VudG8gPSBmYWxzZTtcbiAgICAgICAgfSBcbiAgICAgICAgcmV0dXJuIHtzaUFzdW50bywgbm9tYnJlOiBwYWRyZXN9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0T3Ryb3NBc3VudG9zKHN1YnNpc3RlbWFzKSB7XG4gICAgICAgIGxldCBzdWdnZXN0ZXIgPSB0aGlzLnRwLnN5c3RlbS5zdGF0aWNfZnVuY3Rpb25zLmdldChcInN1Z2dlc3RlclwiKTtcbiAgICAgICAgbGV0IGNhbXBvID0gW107XG4gICAgXG4gICAgICAgIGZvciAobGV0IHN1YnNpc3RlbWEgb2Ygc3Vic2lzdGVtYXMpIHtcbiAgICAgICAgICAgIC8vIFByZWd1bnRhIGluaWNpYWwgcGFyYSBpbmNsdWlyIGFsZ1x1MDBGQW4gc3Vic2lzdGVtYSBjb21vIG9yaWdlblxuICAgICAgICAgICAgbGV0IGluY2x1eWUgPSBhd2FpdCBzdWdnZXN0ZXIoW1wiU2lcIiwgXCJOb1wiXSwgW3RydWUsIGZhbHNlXSwgdHJ1ZSwgYERlc2VhIGFncmVnYXIgYWxndW4gJHtzdWJzaXN0ZW1hfSBhY3Rpdm8gY29tbyBvcmlnZW4/YCk7XG4gICAgICAgICAgICBpZiAoIWluY2x1eWUpIGNvbnRpbnVlOyAvLyBTaSBsYSByZXNwdWVzdGEgZXMgJ05vJywgY29udGluXHUwMEZBYSBjb24gZWwgc2lndWllbnRlIHN1YnNpc3RlbWFcbiAgICAgICAgICAgIGRlYnVnZ2VyXG4gICAgICAgICAgICBsZXQgcmVjdXJzb3NBY3Rpdm9zID0gYXdhaXQgdGhpcy5hY3RpdmVTdHJ1Y3R1cmVSZXNvdXJjZXMoc3Vic2lzdGVtYSk7XG4gICAgICAgICAgICBsZXQgcHJpbWVyQWxpYXMgPSByZWN1cnNvc0FjdGl2b3MubWFwKGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEgJiYgbWV0YWRhdGEuYWxpYXNlcyAmJiBtZXRhZGF0YS5hbGlhc2VzLmxlbmd0aCA+IDAgPyBtZXRhZGF0YS5hbGlhc2VzWzBdIDogbnVsbDtcbiAgICAgICAgICAgIH0pLmZpbHRlcihhbGlhcyA9PiBhbGlhcyAhPT0gbnVsbCk7XG4gICAgXG4gICAgICAgICAgICB3aGlsZSAocmVjdXJzb3NBY3Rpdm9zLmxlbmd0aCA+IDApIHsgLy8gQ29udGluXHUwMEZBYSBtaWVudHJhcyBoYXlhIHJlY3Vyc29zIGFjdGl2b3MgcGFyYSBlbGVnaXJcbiAgICAgICAgICAgICAgICBsZXQgaW5kaWNlU2VsZWNjaW9uYWRvXG4gICAgICAgICAgICAgICAgaWYgKHN1YnNpc3RlbWEgPT09IFwiQXJlYXNWaWRhXCIgfHwgc3Vic2lzdGVtYSA9PT0gXCJBcmVhc0ludGVyZXNcIil7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY2Npb24gPSBhd2FpdCBzdWdnZXN0ZXIocHJpbWVyQWxpYXMsIHJlY3Vyc29zQWN0aXZvcy5tYXAoYiA9PiBiLnBhdGgpLCBmYWxzZSwgYCR7c3Vic2lzdGVtYX0gYWN0aXZvczpgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY2Npb24pIGJyZWFrOyAvLyBTaSBubyBoYXkgc2VsZWNjaVx1MDBGM24sIHNhbGUgZGVsIGNpY2xvXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY3VlbnRyYSB5IGVsaW1pbmEgbGEgc2VsZWNjaVx1MDBGM24gZGUgbG9zIGFycmVnbG9zIHBhcmEgbm8gdm9sdmVyIGEgbW9zdHJhcmxhXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY3VlbnRyYSBlbCBcdTAwRURuZGljZSBkZWwgYXJjaGl2byBzZWxlY2Npb25hZG8gZW4gcmVjdXJzb3NBY3Rpdm9zIGJhc1x1MDBFMW5kb25vcyBlbiBlbCBiYXNlbmFtZVxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VTZWxlY2Npb25hZG8gPSByZWN1cnNvc0FjdGl2b3MuZmluZEluZGV4KGIgPT4gYi5wYXRoID09PSBzZWxlY2Npb24pO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGxldCBzZWxlY2Npb24gPSBhd2FpdCBzdWdnZXN0ZXIocHJpbWVyQWxpYXMsIHJlY3Vyc29zQWN0aXZvcy5tYXAoYiA9PiBiLmJhc2VuYW1lKSwgZmFsc2UsIGAke3N1YnNpc3RlbWF9IGFjdGl2b3M6YCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY2Npb24pIGJyZWFrOyAvLyBTaSBubyBoYXkgc2VsZWNjaVx1MDBGM24sIHNhbGUgZGVsIGNpY2xvXG4gICAgICAgICAgICAgICAgLy8gRW5jdWVudHJhIHkgZWxpbWluYSBsYSBzZWxlY2NpXHUwMEYzbiBkZSBsb3MgYXJyZWdsb3MgcGFyYSBubyB2b2x2ZXIgYSBtb3N0cmFybGFcbiAgICAgICAgICAgICAgICAvLyBFbmN1ZW50cmEgZWwgXHUwMEVEbmRpY2UgZGVsIGFyY2hpdm8gc2VsZWNjaW9uYWRvIGVuIHJlY3Vyc29zQWN0aXZvcyBiYXNcdTAwRTFuZG9ub3MgZW4gZWwgYmFzZW5hbWVcbiAgICAgICAgICAgICAgICBpbmRpY2VTZWxlY2Npb25hZG8gPSByZWN1cnNvc0FjdGl2b3MuZmluZEluZGV4KGIgPT4gYi5iYXNlbmFtZSA9PT0gc2VsZWNjaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGljZVNlbGVjY2lvbmFkbyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNpc3RlbWEgPT09IFwiQXJlYXNWaWRhXCIgfHwgc3Vic2lzdGVtYSA9PT0gXCJBcmVhc0ludGVyZXNcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY2FtcG8ucHVzaChyZWN1cnNvc0FjdGl2b3NbaW5kaWNlU2VsZWNjaW9uYWRvXS5wYXRoKTsgLy8gQWdyZWdhIGVsIGJhc2VuYW1lIGRlbCBhcmNoaXZvIHNlbGVjY2lvbmFkbyBhbCBjYW1wbyAgICBcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNhbXBvLnB1c2gocmVjdXJzb3NBY3Rpdm9zW2luZGljZVNlbGVjY2lvbmFkb10uYmFzZW5hbWUpOyAvLyBBZ3JlZ2EgZWwgYmFzZW5hbWUgZGVsIGFyY2hpdm8gc2VsZWNjaW9uYWRvIGFsIGNhbXBvXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRWxpbWluYSBlbCBlbGVtZW50byBzZWxlY2Npb25hZG8gZGUgYW1ib3MgYXJyZWdsb3MgcGFyYSBubyB2b2x2ZXIgYSBtb3N0cmFybG9cbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzb3NBY3Rpdm9zLnNwbGljZShpbmRpY2VTZWxlY2Npb25hZG8sIDEpO1xuICAgICAgICAgICAgICAgICAgICBwcmltZXJBbGlhcy5zcGxpY2UoaW5kaWNlU2VsZWNjaW9uYWRvLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gU2kgbm8gcXVlZGFuIG1cdTAwRTFzIHJlY3Vyc29zIGFjdGl2b3MsIG5vIHByZWd1bnRhIHNpIGRlc2VhIGFncmVnYXIgb3Ryb1xuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNvc0FjdGl2b3MubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBQcmVndW50YSBzaSBkZXNlYSBhZ3JlZ2FyIG90cm8gcmVnaXN0cm8gZGVsIG1pc21vIHN1YnNpc3RlbWFcbiAgICAgICAgICAgICAgICBsZXQgZGVzZWFBZ3JlZ2FyT3RybyA9IGF3YWl0IHN1Z2dlc3RlcihbXCJTaVwiLCBcIk5vXCJdLCBbdHJ1ZSwgZmFsc2VdLCB0cnVlLCBgRGVzZWEgYWdyZWdhciBvdHJvICR7c3Vic2lzdGVtYX0gY29tbyBvcmlnZW4/YCk7XG4gICAgICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIWRlc2VhQWdyZWdhck90cm8pIGJyZWFrOyAvLyBTaSBsYSByZXNwdWVzdGEgZXMgJ05vJywgc2FsZSBkZWwgY2ljbG9cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gY2FtcG87IC8vIFJldG9ybmEgZWwgYXJyZWdsbyBjYW1wbyBjb24gdG9kYXMgbGFzIHNlbGVjY2lvbmVzIHJlYWxpemFkYXNcbiAgICB9XG4gICAgXG4gICAgXG4gICAgLy8gRlVOQ0lPTiBRVUUgVFJBRSBUT0RBUyBMQVMgTk9UQVMgQUNUSVZBUyBERSBMT1MgU0lTVEVNQVMuIC0gUmV2aXNhciBlbiBxdWUgbGEgdXNvLi4uXG4gICAgYXN5bmMgYWN0aXZlU3RydWN0dXJlUmVzb3VyY2VzKHR5cGVOYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBPYnRcdTAwRTluIHRvZG9zIGxvcyBhcmNoaXZvcyBNYXJrZG93blxuICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpe1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFyZWFzSW50ZXJlc1wiOlxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFxuICAgICAgICAgICAgICAgIC8vIERldGVybWluYSBlbCBub21icmUgZGUgbGEgY2FycGV0YSBkZSByZWN1cnNvcyBiYXNhZG8gZW4gZWwgdGlwb1xuICAgICAgICAgICAgICAgIGxldCByZXNvdXJjZUZvbGRlck5hbWUgPSBcImZvbGRlcl9cIiArIHR5cGVOYW1lO1xuICAgICAgICAgICAgICAgIGxldCByZXNvdXJjZUZvbGRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzW3Jlc291cmNlRm9sZGVyTmFtZV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Egc2kgbGEgY2FycGV0YSBkZSByZWN1cnNvcyBleGlzdGUgcGFyYSBldml0YXIgZXJyb3Jlc1xuICAgICAgICAgICAgICAgIGlmICghcmVzb3VyY2VGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTGEgY2FycGV0YSBcIiR7cmVzb3VyY2VGb2xkZXJOYW1lfVwiIG5vIGV4aXN0ZSBlbiBsYSBjb25maWd1cmFjaVx1MDBGM24gZGVsIHBsdWdpbi5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBSZXRvcm5hIHVuIGFycmVnbG8gdmFjXHUwMEVEbyBzaSBsYSBjYXJwZXRhIG5vIGV4aXN0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlUmVzb3VyY2VzID0gW107XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gRmlsdHJhIGxvcyBhcmNoaXZvcyBxdWUgZXN0XHUwMEUxbiBkZW50cm8gZGVsIGRpcmVjdG9yaW8gZGVzZWFkbyB5IHRpZW5lbiBlc3RhZG8gXHVEODNEXHVERkUyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnaXN0cm9zRXhpc3RlbnRlcyA9IGZpbGVzLmZpbHRlcihmaWxlID0+IGZpbGUucGF0aC5zdGFydHNXaXRoKHJlc291cmNlRm9sZGVyKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVXNhIG1ldGFkYXRhQ2FjaGUgcGFyYSBidXNjYXIgbG9zIGVzdGFkb3MgZW4gZWwgZnJvbnRtYXR0ZXJcbiAgICAgICAgICAgICAgICByZWdpc3Ryb3NFeGlzdGVudGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmVzdGFkbyA9PT0gXCJcdUQ4M0RcdURGRTJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUmVzb3VyY2VzLnB1c2goZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAvLyBGaW4gU3dpdGNoXG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlUmVzb3VyY2VzO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGJ1c2NhciByZWN1cnNvcyBhY3Rpdm9zOlwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gW107IC8vIFJldG9ybmEgdW4gYXJyZWdsbyB2YWNcdTAwRURvIGVuIGNhc28gZGUgZXJyb3JcbiAgICAgICAgfVxuICAgIH1cbiAgICBcblxuXG4gICAgYXN5bmMgZ2V0Q2xhc2lmaWNhY2lvbigpe1xuICAgICAgICBsZXQgY2xhc2lmaWNhY2lvbjogc3RyaW5nIHwgbnVsbCwgdGFnQ2xhc2lmaWNhY2lvbjogc3RyaW5nIHwgbnVsbCwgY2xhc2lmaWNhY2lvbkFYOiB7IFt4OiBzdHJpbmddOiBhbnk7IH0sIHRhZ3NDbGFzaWZpY2FjaW9uQVg6IHN0cmluZyB8IGFueVtdO1xuICAgICAgICBsZXQgbnVldmFDbGFzaWZpY2FjaW9uID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMucGF0aENhbXBvcyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBmcm9udG1hdHRlciA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgIGlmIChmcm9udG1hdHRlcikge1xuICAgICAgICAgICAgY2xhc2lmaWNhY2lvbkFYID0gZnJvbnRtYXR0ZXIudGl0dWxvQ2xhc2lmaWNhY2lvbkFYIHx8IFtdO1xuICAgICAgICAgICAgdGFnc0NsYXNpZmljYWNpb25BWCA9IGZyb250bWF0dGVyLnRhZ3NDbGFzaWZpY2FjaW9uQVggfHwgW107XG4gICAgICAgICAgICBsZXQgc3VnZ2VzdGVyID0gdGhpcy50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG4gICAgICAgICAgICB0YWdDbGFzaWZpY2FjaW9uID0gYXdhaXQgc3VnZ2VzdGVyKGNsYXNpZmljYWNpb25BWCwgdGFnc0NsYXNpZmljYWNpb25BWCwgZmFsc2UsIFwiXHUwMEJGQ2xhc2lmaWNhclx1MDBFRGFzIGVzdGEgbm90YSBiYWpvIGFsZ3VuYSBkZSBsYXMgc2lndWllbnRlcyBjYXRlZ29yXHUwMEVEYXM/XCIpXG4gICAgICAgICAgICAvLyBWZXJpZmljYXIgc2kgZWwgdXN1YXJpbyBwcmVzaW9uXHUwMEYzIEVzYy4gXG4gICAgICAgICAgICBpZiAodGFnQ2xhc2lmaWNhY2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJDcmVhY2lcdTAwRjNuIGRlIG5vdGEgY2FuY2VsYWRhIHBvciBlbCB1c3VhcmlvLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnQ2xhc2lmaWNhY2lvbj09XCJOdWV2b1wiKXtcbiAgICAgICAgICAgICAgICBsZXQgcHJvbXB0ID0gdGhpcy50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJwcm9tcHRcIik7XG4gICAgICAgICAgICAgICAgY2xhc2lmaWNhY2lvbiA9IGF3YWl0IHByb21wdChcIlx1MDBCRkN1YWwgZXMgZWwgbm9tYnJlIGRlIGxhIG51ZXZhIGNsYXNpZmljYWNpXHUwMEYzbiBxdWUgdmFzIGEgaW5ncmVzYXI/XCIsIFwiTWlDbGFzaWZpY2FjaVx1MDBGM25cIiwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAvLyBWZXJpZmljYXIgc2kgZWwgdXN1YXJpbyBwcmVzaW9uXHUwMEYzIEVzYy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNpZmljYWNpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJDcmVhY2lcdTAwRjNuIGRlIG5vdGEgY2FuY2VsYWRhIHBvciBlbCB1c3VhcmlvLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVGVybWluYSBsYSBlamVjdWNpXHUwMEYzbiBkZSBsYSBmdW5jaVx1MDBGM24gYXF1XHUwMEVELlxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YWdDbGFzaWZpY2FjaW9uID0gYXdhaXQgcHJvbXB0KFwiXHUwMEJGQ3VhbCBlcyBlbCB0YWcgcXVlIHV0aWxpemFyYXMgcGFyYSBcIiArIGNsYXNpZmljYWNpb24gKyBcIj8uIE5vIHV0aWxpY2VzIGVzcGFjaW9zIGVuIGxhIGRlZmluaWNpXHUwMEYzbiBkZWwgdGFnLlwiLCBcIm51ZXZvVGFnXCIsIHRydWUpXG4gICAgICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgICAgICAgICAgICAgaWYgKHRhZ0NsYXNpZmljYWNpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkNyZWFjaVx1MDBGM24gZGUgbm90YSBjYW5jZWxhZGEgcG9yIGVsIHVzdWFyaW8uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnVldmFDbGFzaWZpY2FjaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1lbHNlIGlmKHRhZ0NsYXNpZmljYWNpb249PVwiTmluZ3VuYVwiKXtcbiAgICAgICAgICAgICAgICB0YWdDbGFzaWZpY2FjaW9uID0gXCJcIlxuICAgICAgICAgICAgICAgIGNsYXNpZmljYWNpb24gPSBcIlwiXHRcbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kaWNlID0gdGFnc0NsYXNpZmljYWNpb25BWC5pbmRleE9mKHRhZ0NsYXNpZmljYWNpb24pXG4gICAgICAgICAgICAgICAgY2xhc2lmaWNhY2lvbiA9IGNsYXNpZmljYWNpb25BWFtpbmRpY2VdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVldmFDbGFzaWZpY2FjaW9uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIoZmlsZSwgKGZyb250bWF0dGVyOiB7IHRpdHVsb0NsYXNpZmljYWNpb25BWDogYW55W107IHRhZ3NDbGFzaWZpY2FjaW9uQVg6IGFueVtdOyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzdW1pZW5kbyBxdWUgJ2FjdHNUZW1hcycgZXMgZWwgY2FtcG8gYSBtb2RpZmljYXJcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q2xhc2lmaWNhY2lvbiA9IFsuLi5jbGFzaWZpY2FjaW9uQVgsIGNsYXNpZmljYWNpb25dXG4gICAgICAgICAgICAgICAgbGV0IG5ld1RhZ0NsYXNpZmljYWNpb24gPSBbLi4udGFnc0NsYXNpZmljYWNpb25BWCwgdGFnQ2xhc2lmaWNhY2lvbl1cbiAgICAgICAgICAgICAgICBmcm9udG1hdHRlci50aXR1bG9DbGFzaWZpY2FjaW9uQVggPSBuZXdDbGFzaWZpY2FjaW9uO1xuICAgICAgICAgICAgICAgIGZyb250bWF0dGVyLnRhZ3NDbGFzaWZpY2FjaW9uQVggPSBuZXdUYWdDbGFzaWZpY2FjaW9uO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRnJvbnRtYXR0ZXIgYWN0dWFsaXphZG8gY29uIFx1MDBFOXhpdG9cIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgYWN0dWFsaXphciBlbCBmcm9udG1hdHRlclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICBpZiAodGFnQ2xhc2lmaWNhY2lvbiAhPSBcIlwiKXtcbiAgICAgICAgICAgIHRhZ0NsYXNpZmljYWNpb24gPSBcImNsL1wiICsgdGFnQ2xhc2lmaWNhY2lvbiBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubm90YS5jbGFzaWZpY2FjaW9uQVggPSBjbGFzaWZpY2FjaW9uO1xuICAgICAgICAgICAgdGhpcy5ub3RhLnRhZ0NsYXNpZmljYWNpb25BWCA9IHRhZ0NsYXNpZmljYWNpb247XG4gICAgICAgICAgICByZXR1cm4ge2NsYXNlOiBjbGFzaWZpY2FjaW9uLCB0YWc6IHRhZ0NsYXNpZmljYWNpb259O1xuICAgIH1cbiAgICAvLyAtPlxuXG4gICAgZ2V0RHVwbGFzRmlqYXMoYXBwOiBBcHAsIGFyZWE6IHN0cmluZyk6IFByb21pc2U8R3J1cG9BY3RpdmlkYWRbXT4ge1xuICAgICAgICAvLyBFbmN1ZW50cmEgZWwgYXJjaGl2byBwb3Igc3UgcnV0YVxuICAgICAgICBjb25zdCBmaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnBhdGhDYW1wb3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgIC8vIFVzYSBtZXRhZGF0YUNhY2hlIHBhcmEgb2J0ZW5lciBsb3MgbWV0YWRhdG9zIGRlbCBhcmNoaXZvXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgLy8gQWNjZWRlIGFsIGZyb250IG1hdHRlciAoWUFNTCkgZGVsIGFyY2hpdm8geSBvYnRpZW5lIGVsIGFycmVnbG8gYmFzYWRvIGVuIGVsIHRlbWFcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJlZ2xvUmVzdWx0ID0gbWV0YWRhdGE/LmZyb250bWF0dGVyPy5bYXJlYV0gfHwgW107XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydXllIGVsIGFycmVnbG8gZGUgb2JqZXRvcyByZXN1bHRhZG8gYmFzYWRvIGVuIGxhIGVzdHJ1Y3R1cmEgZGUgR3J1cG9BY3RpdmlkYWRcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRhZG8gPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbGxlbmEgZWwgYXJyZWdsbyBjb24gbG9zIGRhdG9zIGRlbCBhcnJlZ2xvUmVzdWx0XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyZWdsb1Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyZWdsb1Jlc3VsdC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgJiYgaXRlbS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGFkby5wdXNoKHsgZ3J1cG86IGl0ZW1bMF0sIGFyZWE6IGl0ZW1bMV0sIHRleHRvOiBpdGVtWzBdK1wiL1wiK2l0ZW1bMV19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRhZG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igb2J0ZW5pZW5kbyBlbCBhcmNoaXZvIGRlIGNhbXBvczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gQXF1XHUwMEVEIG1hbmVqYXJcdTAwRURhcyBlbCBlcnJvciBjb21vIHNlYSBhcHJvcGlhZG8gcGFyYSB0dSBhcGxpY2FjaVx1MDBGM25cbiAgICAgICAgICAgIHRocm93IGVycm9yOyAvLyBPIGRldm9sdmVyIHVuIGFycmVnbG8gdmFjXHUwMEVEbyBjb21vIHJlc3VsdGFkbyBkZSBlcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV2dWVsdmUgdW4gYXJyZWdsbyB2YWNcdTAwRURvIHNpIG5vIHNlIGVuY3VlbnRyYSBlbCBhcmNoaXZvIG8gc2kgb2N1cnJlIGN1YWxxdWllciBvdHJvIHByb2JsZW1hXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBGdW5jaVx1MDBGM24gY3JlZGEgcGFyYSBsYXMgQXJlYXMgZGUgVmlkYSB5IHBhcmEgbGFzIEFub3RhY2lvbmVzLCBwYXJhIHRyYWVyIGxhcyBxdWUgZXN0YW4gZW4gcGx0IENhbXBvc1xuICAgIGFzeW5jIGdldEFyZWEoKXtcbiAgICAgICAgbGV0IGFyZWE6IHN0cmluZyB8IG51bGwsIGdydXBvOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBcbiAgICAgICAgbGV0IHRpcG9BcmVhID0gdGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlTmFtZTtcbiAgICAgICAgbGV0IG51ZXZhQXJlYSA9IGZhbHNlO1xuICAgICAgICBsZXQgYXJlYXNHcnVwb3MgPSAgdGhpcy5nZXREdXBsYXNGaWphcyhhcHAsIHRpcG9BcmVhKVxuICAgICAgICBsZXQgc3VnZ2VzdGVyID0gdGhpcy50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG4gICAgICAgIGxldCBhcmVhR3J1cG8gPSBhd2FpdCBzdWdnZXN0ZXIoYXJlYXNHcnVwb3MubWFwKGI9PiBiLnRleHRvKSwgYXJlYXNHcnVwb3MubWFwKGI9PiBiLnRleHRvKSwgZmFsc2UsIGBcdTAwQkZDdVx1MDBFMWwgJHt0aXBvQXJlYX0gZGVzZWFzIGNyZWFyP2ApXG4gICAgICAgICAgICAvLyBWZXJpZmljYXIgc2kgZWwgdXN1YXJpbyBwcmVzaW9uXHUwMEYzIEVzYy4gXG4gICAgICAgICAgICBpZiAoYXJlYUdydXBvID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkNyZWFjaVx1MDBGM24gZGUgbm90YSBjYW5jZWxhZGEgcG9yIGVsIHVzdWFyaW8uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVGVybWluYSBsYSBlamVjdWNpXHUwMEYzbiBkZSBsYSBmdW5jaVx1MDBGM24gYXF1XHUwMEVELlxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmVhR3J1cG89PVwiTnVldm9cIil7XG4gICAgICAgICAgICAgICAgbGV0IHByb21wdCA9IHRoaXMudHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwicHJvbXB0XCIpO1xuICAgICAgICAgICAgICAgIGNsYXNpZmljYWNpb24gPSBhd2FpdCBwcm9tcHQoXCJcdTAwQkZDdWFsIGVzIGVsIG5vbWJyZSBkZSBsYSBudWV2YSBjbGFzaWZpY2FjaVx1MDBGM24gcXVlIHZhcyBhIGluZ3Jlc2FyP1wiLCBcIk1pQ2xhc2lmaWNhY2lcdTAwRjNuXCIsIHRydWUpXG4gICAgICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzaWZpY2FjaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiQ3JlYWNpXHUwMEYzbiBkZSBub3RhIGNhbmNlbGFkYSBwb3IgZWwgdXN1YXJpby5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFnQ2xhc2lmaWNhY2lvbiA9IGF3YWl0IHByb21wdChcIlx1MDBCRkN1YWwgZXMgZWwgdGFnIHF1ZSB1dGlsaXphcmFzIHBhcmEgXCIgKyBjbGFzaWZpY2FjaW9uICsgXCI/LiBObyB1dGlsaWNlcyBlc3BhY2lvcyBlbiBsYSBkZWZpbmljaVx1MDBGM24gZGVsIHRhZy5cIiwgXCJudWV2b1RhZ1wiLCB0cnVlKVxuICAgICAgICAgICAgICAgIC8vIFZlcmlmaWNhciBzaSBlbCB1c3VhcmlvIHByZXNpb25cdTAwRjMgRXNjLlxuICAgICAgICAgICAgICAgIGlmICh0YWdDbGFzaWZpY2FjaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJDcmVhY2lcdTAwRjNuIGRlIG5vdGEgY2FuY2VsYWRhIHBvciBlbCB1c3VhcmlvLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUZXJtaW5hIGxhIGVqZWN1Y2lcdTAwRjNuIGRlIGxhIGZ1bmNpXHUwMEYzbiBhcXVcdTAwRUQuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51ZXZhQ2xhc2lmaWNhY2lvbiA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgaW5kaWNlID0gYXJlYXNHcnVwb3MuZmluZEluZGV4KG9iamV0byA9PiBvYmpldG8udGV4dG8gPT09IGFyZWFHcnVwbyk7XG4gICAgICAgICAgICAgICAgZ3J1cG8gPSBhcmVhc0dydXBvc1tpbmRpY2VdLmdydXBvO1xuICAgICAgICAgICAgICAgIGFyZWEgPSBhcmVhc0dydXBvc1tpbmRpY2VdLmFyZWE7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RhLmdydXBvID0gZ3J1cG87XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RhLnRpdHVsbyA9IGFyZWE7XG4gICAgICAgICAgICByZXR1cm4ge2dydXBvOiBncnVwbywgdGl0dWxvOiBhcmVhfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgYXN5bmMgZ2V0RXN0YWRvKCl7XG4gICAgICAgIGxldCBzdWdnZXN0ZXIgPSB0aGlzLnRwLnN5c3RlbS5zdGF0aWNfZnVuY3Rpb25zLmdldChcInN1Z2dlc3RlclwiKTtcbiAgICAgICAgbGV0IHRpcG9TaXN0ZW1hID0gdGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlO1xuICAgICAgICBsZXQgbm9tYnJlU2lzdGVtYSA9IHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZU5hbWU7XG4gICAgICAgIGxldCBjYW1wbztcbiAgICAgICAgc3dpdGNoKHRpcG9TaXN0ZW1hKSB7XG4gICAgICAgICAgICBjYXNlIFwiQXhcIjpcbiAgICAgICAgICAgICAgICBjYW1wbyA9IGF3YWl0IHN1Z2dlc3RlcihbXCJcdUQ4M0RcdUREMzUgLT4gUGFyYSBBcmNoaXZvIC0gSW5mb3JtYWNpXHUwMEYzblwiLCBcIlx1RDgzRFx1REZFMiAtPiBGaW5hbGl6YWRvXCIsXCJcdUQ4M0RcdURGRTEgLT4gRW4gZGVzYXJyb2xsb1wiLCBcIlx1RDgzRFx1REQzNCAtPiBObyByZWFsaXphZG9cIl0sW1wiXHVEODNEXHVERDM1XCIsIFwiXHVEODNEXHVERkUyXCIsXCJcdUQ4M0RcdURGRTFcIiwgXCJcdUQ4M0RcdUREMzRcIl0sIGZhbHNlLCBgRXN0YWRvIGFjdHVhbCAke25vbWJyZVNpc3RlbWF9OmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBHVERcIjpcbiAgICAgICAgICAgICAgICBjYW1wbyA9IGF3YWl0IHN1Z2dlc3RlcihbXCJcdUQ4M0RcdUREMzUgLT4gQ29tcGxldGFkbyAtIEFyY2hpdm9cIiwgXCJcdUQ4M0RcdURGRTIgLT4gQWN0aXZvXCIsXCJcdUQ4M0RcdURGRTEgLT4gRW4gUGF1c2FcIiwgXCJcdUQ4M0RcdUREMzQgLT4gRGV0ZW5pZG9cIl0sW1wiXHVEODNEXHVERDM1XCIsIFwiXHVEODNEXHVERkUyXCIsXCJcdUQ4M0RcdURGRTFcIiwgXCJcdUQ4M0RcdUREMzRcIl0sIGZhbHNlLCBgRXN0YWRvIGFjdHVhbCAke25vbWJyZVNpc3RlbWF9OmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBRXCI6XG4gICAgICAgICAgICAgICAgY2FtcG8gPSBhd2FpdCBzdWdnZXN0ZXIoW1wiXHVEODNEXHVERDM1IC0+IENvbXBsZXRhZG8gLSBBcmNoaXZvXCIsIFwiXHVEODNEXHVERkUyIC0+IEFjdGl2b1wiLFwiXHVEODNEXHVERkUxIC0+IFBvciBJbmljaWFyLCBFbiBQYXVzYVwiLCBcIlx1RDgzRFx1REQzNCAtPiBDYW5jZWxhZG9cIl0sW1wiXHVEODNEXHVERDM1XCIsIFwiXHVEODNEXHVERkUyXCIsXCJcdUQ4M0RcdURGRTFcIiwgXCJcdUQ4M0RcdUREMzRcIl0sIGZhbHNlLCBgRXN0YWRvIGFjdHVhbCAke3RoaXMubm90YS50aXR1bG99OmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR4XCI6XG4gICAgICAgICAgICAgICAgY2FtcG8gPSBhd2FpdCBzdWdnZXN0ZXIoW1wiXHVEODNEXHVERDM1IC0+IEFyY2hpdm9cIiwgXCJcdUQ4M0RcdURGRTIgLT4gRW4gUHJvY2Vzb1wiLFwiXHVEODNEXHVERkUxIC0+IEVuIFBhdXNhXCIsIFwiXHVEODNEXHVERDM0IC0+IENhbmNlbGFkb1wiXSxbXCJcdUQ4M0RcdUREMzVcIiwgXCJcdUQ4M0RcdURGRTJcIixcIlx1RDgzRFx1REZFMVwiLCBcIlx1RDgzRFx1REQzNFwiXSwgZmFsc2UsIGBFc3RhZG8gZGUgJHt0aGlzLm5vdGEudGl0dWxvfTpgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBSVwiOlxuICAgICAgICAgICAgY2FzZSBcIkFWXCI6XG4gICAgICAgICAgICBjYXNlIFwiUlJcIjpcbiAgICAgICAgICAgICAgICAvLyBMXHUwMEYzZ2ljYSBwYXJhIHBlcm1pdGlyIGFsIHVzdWFyaW8gZWxlZ2lyIHVuYSB0YXJlYSBlc3BlY1x1MDBFRGZpY2EuXG4gICAgICAgICAgICAgICAgY2FtcG8gPSBhd2FpdCBzdWdnZXN0ZXIoW1wiXHVEODNEXHVERDM1IC0+IEFyY2hpdmFkb1wiLCBcIlx1RDgzRFx1REZFMiAtPiBBY3Rpdm9cIixcIlx1RDgzRFx1REZFMSAtPiBFbiBQYXVzYVwiLCBcIlx1RDgzRFx1REQzNCAtPiBEZXRlbmlkb1wiXSxbXCJcdUQ4M0RcdUREMzVcIiwgXCJcdUQ4M0RcdURGRTJcIixcIlx1RDgzRFx1REZFMVwiLCBcIlx1RDgzRFx1REQzNFwiXSwgZmFsc2UsIGBFc3RhZG8gYWN0dWFsICR7dGhpcy5ub3RhLnRpdHVsb306YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQVlcIjpcbiAgICAgICAgICAgICAgICBjYW1wbyA9IGF3YWl0IHN1Z2dlc3RlcihbXCJcdUQ4M0RcdUREMzUgLT4gQVx1MDBGMW8gQXJjaGl2YWRvXCIsIFwiXHVEODNEXHVERkUyIC0+IEFcdTAwRjFvIGFjdGl2b1wiLFwiXHVEODNEXHVERkUxIC0+IEFcdTAwRjFvIGVuIHBsYW5lYWNpXHUwMEYzblwiLCBcIlx1RDgzRFx1REQzNCAtPiBOb3RhIHBvciBhcnJlZ2xhclwiXSxbXCJcdUQ4M0RcdUREMzVcIiwgXCJcdUQ4M0RcdURGRTJcIixcIlx1RDgzRFx1REZFMVwiLCBcIlx1RDgzRFx1REQzNFwiXSwgZmFsc2UsIGBFc3RhZG8gZGVsIGFcdTAwRjFvIGVsZWdpZG86YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiT0NBXCI6IC8vIEVuIGxhIGNyZWFjaVx1MDBGM24gZGVsIG9iamV0aXZvIGZpam8gdmEgZW4gYW1hcmlsbG8uXG4gICAgICAgICAgICBjYXNlIFwiQ1RJXCI6IC8vIENvbXBhc3NUcmltZXN0cmFsSW5pY2lvXG4gICAgICAgICAgICAgICAgY2FtcG8gPSBcIlx1RDgzRFx1REZFMVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBTaSBlbCB1c3VhcmlvIGVsaWdlIFwiT3Ryb1wiIG8gY3VhbHF1aWVyIG90cmEgb3BjaVx1MDBGM24uXG4gICAgICAgICAgICAgICAgY2FtcG8gPSBhd2FpdCBzdWdnZXN0ZXIoW1wiXHVEODNEXHVERDM1IC0+IENvbXBsZXRhZG8gLSBJbmZvcm1hY2lcdTAwRjNuXCIsIFwiXHVEODNEXHVERkUyIC0+IEZpbmFsaXphZG9cIixcIlx1RDgzRFx1REZFMSAtPiBFbiBkZXNhcnJvbGxvXCIsIFwiXHVEODNEXHVERDM0IC0+IERldGVuaWRvXCJdLFtcIlx1RDgzRFx1REQzNVwiLCBcIlx1RDgzRFx1REZFMlwiLFwiXHVEODNEXHVERkUxXCIsIFwiXHVEODNEXHVERDM0XCJdLCBmYWxzZSwgXCJTZWxlY2Npb25lIGVsIGVzdGFkbyBkZSBsYSBub3RhOlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuXHQgICAgLy8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgICAgIGlmIChjYW1wbyA9PT0gbnVsbCkge1xuICAgICAgICBuZXcgTm90aWNlKFwiTW9kaWZpY2FjaVx1MDBGM24gZGUgbm90YSBjYW5jZWxhZGEgcG9yIGVsIHVzdWFyaW8uXCIpO1xuICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cblx0ICAgIH1cbiAgICAgICAgLy90aGlzLm5vdGEuZXN0YWRvID0gY2FtcG87XG4gICAgICAgIHJldHVybiBjYW1wbztcbiAgICB9XG5cbiAgICAvKiBcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgTWV0b2RvIHF1ZSB0aWVuZSBkb3MgcHJvcG9zaXRvcywgaW5pY2lhbG1lbnRlIHNlIGNyZVx1MDBGMyBwYXJhICBkZXZvbHZlclxuICAgIGVsIGZpbGVuYW1lIGRlIGxhcyBBSSwgQVYsIG5BViwgQXggeSBQR1REIHkgZGVzZGUgbGEgcGxhbnRpbGxhIFxuICAgIGNhbWJpYXJsZSBlbCBub21icmUgYWwgYXJjaGl2by4gU2luIGVtYmFyZ28sIHNlIG1vZGlmaWNcdTAwRjMgeSBhaG9yYSBzaXJ2ZVxuICAgIHBhcmEgY3VhbmRvIHVuYSBwbGFudGlsbGEgdGllbmUgdW4gbm9tYnJlIGVzcGVjaWFsLCBwb3JxdWUgZXMgcmVzdWx0YWRvXG4gICAgZGUgdW4gcHJvY2VzbyBwcmV2aW8geSBzZSBkZWJlIHRyYWVyIGluZm9ybWFjaVx1MDBGM24gcGFyYSBxdWUgc2UgZ2VuZXJlIGxhXG4gICAgbm90YSBkZSBsYSBwbGFudGlsbGEgYWRlY3VhZGFtZW50ZS4gIFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAqLyBcbiAgICBhc3luYyBnZXRGaWxlbmFtZSgpe1xuICAgICAgICBsZXQgZmlsZU5hbWU7XG4gICAgICAgIHN3aXRjaCh0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGUpIHsgIFxuICAgICAgICAgICAgY2FzZSBcIkFJXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm90YS5hcmVhVmlkYT09PVwiTm8gZXMgZGUgbmluZ1x1MDBGQW4gQXJlYSBkZSBWaWRhXCIpe1xuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IChgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlcn0vT3RyYXMvJHt0aGlzLm5vdGEudGl0dWxvfWApXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gKGAke3RoaXMuaW5mb1N1YnNpc3RlbWEuZm9sZGVyfS8ke3RoaXMubm90YS5hcmVhVmlkYX0vJHt0aGlzLm5vdGEudGl0dWxvfWApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFWXCI6XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mb1N1YnNpc3RlbWEuaGFzT3duUHJvcGVydHkoXCJmaWxlTmFtZVwiKSl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRlcyA9IHRoaXMuaW5mb1N1YnNpc3RlbWEuZmlsZU5hbWUuc3BsaXQoJyAtLSAnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLnRyaW1lc3RyZSA9IHBhcnRlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLnRpdHVsbyA9IHBhcnRlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gcGFydGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuZ3J1cG8gPSBwYXJ0ZXNbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gYCR7dGhpcy5ub3RhLnRyaW1lc3RyZX0gLSAke3RoaXMubm90YS50aXR1bG99YCAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJuQVZcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ZXMgPSB0aGlzLm5vdGEuZmlsZU5hbWUuc3BsaXQoJyAtICcpO1xuICAgICAgICAgICAgICAgIHRoaXMubm90YS5ncnVwbyA9IHBhcnRlc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBwYXJ0ZXNbMV07XG4gICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBgJHtwYXJ0ZXNbMV19YDsgICAgXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUEdURFwiOiBcbiAgICAgICAgICAgIGNhc2UgXCJQUVwiOiAgIFxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmZvU3Vic2lzdGVtYS5oYXNPd25Qcm9wZXJ0eShcImZpbGVOYW1lXCIpKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlZ2V4RmlsZU5hbWUgPSAvKFteL10rKVxccy1cXHMoXFxkKylcXC5tZCQvO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydGVzID0gdGhpcy5pbmZvU3Vic2lzdGVtYS5maWxlTmFtZS5tYXRjaChyZWdleEZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uIGVzdGUgcmVnZXhGaWxlTmFtZSwgcGFydGVzWzBdIGVzIGVsIG5vbWJyZSBkZWwgYXJjaGl2byBjb24gbGEgZXh0ZW5zaVx1MDBGM24gbWQuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gcGFydGVzWzFdOyBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gcGFydGVzWzJdO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUHJveWVjdG8gcGFyYSBPYmpldGl2byBDb21wYXNzIEFudWFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vdGEgPSBhd2FpdCB0aGlzLmdldE9yaWdlbihcIk9iakNvbXBhc3NBbnVhbFwiLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvXFxbXFxbXFxzKiguKj8pXFxzKlxcXVxcXS87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gbm90YT8uYXJlYVZpZGEubWF0Y2gocmVnZXgpWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhSW50ZXJcdTAwRTlzID0gbm90YS5hcmVhSW50ZXJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXN1bnRvID0ge3NpQXN1bnRvOiB0cnVlLCBub21icmU6IG5vdGEuZmlsZS5iYXNlbmFtZX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLnRyaW1lc3RyZSA9IG5vdGE/LnRyaW1lc3RyZS5tYXRjaChyZWdleClbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLm5pdmVsUCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSB0aGlzLmluZm9TdWJzaXN0ZW1hLmZpbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhazsgLy8gR1REIHkgUFEgVmluaWVuZG8gZGUgY29tcGFzcyBBbnVhbC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlTmFtZTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRUcmltZXN0cmUoKXtcbiAgICAgICAgXG4gICAgICAgIGxldCBzdWdnZXN0ZXIgPSB0aGlzLnRwLnN5c3RlbS5zdGF0aWNfZnVuY3Rpb25zLmdldChcInN1Z2dlc3RlclwiKTtcbiAgICAgICAgbGV0IHRpcG9TaXN0ZW1hID0gdGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlO1xuICAgICAgICBsZXQgbm9tYnJlU2lzdGVtYSA9IHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZU5hbWU7XG4gICAgICAgIGxldCB0cmltZXN0cmU7XG4gICAgICAgIC8vbGV0IHRyaW1lc3RyZXMgPSBhd2FpdCB0aGlzLmFjdGl2ZVN0cnVjdHVyZVJlc291cmNlcyhcIlRyaW1lc3RyYWxcIik7IC8vIEZ1bmNpb25hIGVuIGxhIHZlcnNpXHUwMEYzbiAxLjAgZGUgQXJlYXMgZGUgVmlkYS5cbiAgICAgICAgbGV0IHRyaW1lc3RyZXMgPSBhd2FpdCB0aGlzLmZpbmRNYWluRmlsZXNXaXRoU3RhdGUoXCJUUVwiKTtcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCh0aXBvU2lzdGVtYSkge1xuICAgICAgICAgICAgY2FzZSBcIkFWXCI6XG4gICAgICAgICAgICBjYXNlIFwiUFFcIjpcbiAgICAgICAgICAgICAgICAvLyBMXHUwMEYzZ2ljYSBwYXJhIHBlcm1pdGlyIGFsIHVzdWFyaW8gZWxlZ2lyIHVuYSB0YXJlYSBlc3BlY1x1MDBFRGZpY2EuXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdHJpbWVzdHJlID0gYXdhaXQgc3VnZ2VzdGVyKHRyaW1lc3RyZXMubWFwKGIgPT4gYi5maWxlLmJhc2VuYW1lKSx0cmltZXN0cmVzLm1hcChiID0+IGIuZmlsZS5iYXNlbmFtZSksIGZhbHNlLCBgVHJpbWVzdHJlIGRlbCAke25vbWJyZVNpc3RlbWF9OmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk9DQVwiOiAvLyBPYmpldGl2b0NvbXBhc3NBbnVhbCBcbiAgICAgICAgICAgICAgICAgICAgdHJpbWVzdHJlID0gYXdhaXQgc3VnZ2VzdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgW1wiUTFcIiwgXCJRMlwiLCBcIlEzXCIsIFwiUTRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMubm90YS5hXHUwMEYxb30tUTFgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLm5vdGEuYVx1MDBGMW99LVEyYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5ub3RhLmFcdTAwRjFvfS1RM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMubm90YS5hXHUwMEYxb30tUTRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBgXHUwMEJGRW4gcXVcdTAwRTkgdHJpbWVzdHJlIGRlbCAke3RoaXMubm90YS5hXHUwMEYxb30gY29uc2lkZXJhcyBxdWUgc2UgcHVlZGUgcmVhbGl6YXIgZXNlIG9iamV0aXZvP2BcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkNUSVwiOiAvLyBDb21wYXNzVHJpbWVzdHJhbEluaWNpb1xuICAgICAgICAgICAgICAgICAgICB0cmltZXN0cmUgPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJRMVwiLCBcIlEyXCIsIFwiUTNcIiwgXCJRNFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5ub3RhLmFcdTAwRjFvfS1RMWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMubm90YS5hXHUwMEYxb30tUTJgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLm5vdGEuYVx1MDBGMW99LVEzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5ub3RhLmFcdTAwRjFvfS1RNGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcdTAwQkZEZSBxdVx1MDBFOSB0cmltZXN0cmUgZGVsICR7dGhpcy5ub3RhLmFcdTAwRjFvfSBlcyBlc3RhIHBsYW5lYWNpXHUwMEYzbj9gXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFNpIGVsIHVzdWFyaW8gZWxpZ2UgXCJPdHJvXCIgbyBjdWFscXVpZXIgb3RyYSBvcGNpXHUwMEYzbi5cbiAgICAgICAgICAgICAgICB0cmltZXN0cmUgPSBhd2FpdCBzdWdnZXN0ZXIodHJpbWVzdHJlcy5tYXAoYiA9PiBiLmZpbGUuYmFzZW5hbWUpLHRyaW1lc3RyZXMubWFwKGIgPT4gYi5maWxlLnBhdGgpLCBmYWxzZSwgYFRyaW1lc3RyZSBkZWwgJHtub21icmVTaXN0ZW1hfTpgKTtcbiAgICAgICAgICAgICAgICB9XG5cdCAgICAvLyBWZXJpZmljYXIgc2kgZWwgdXN1YXJpbyBwcmVzaW9uXHUwMEYzIEVzYy5cbiAgICAgICAgaWYgKHRyaW1lc3RyZSA9PT0gbnVsbCkge1xuICAgICAgICBuZXcgTm90aWNlKFwiTW9kaWZpY2FjaVx1MDBGM24gZGUgbm90YSBjYW5jZWxhZGEgcG9yIGVsIHVzdWFyaW8uXCIpO1xuICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cblx0ICAgIH1cbiAgICAgICAgdGhpcy5ub3RhLnRyaW1lc3RyZSA9IHRyaW1lc3RyZTtcbiAgICAgICAgcmV0dXJuIHRyaW1lc3RyZTtcbiAgICB9XG5cblxuICAgIGFzeW5jIGdldEFcdTAwRjFvKCl7XG4gICAgICAgIFxuICAgICAgICBsZXQgc3VnZ2VzdGVyID0gdGhpcy50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG4gICAgICAgIGxldCB0aXBvU2lzdGVtYSA9IHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZTtcbiAgICAgICAgbGV0IG5vbWJyZVNpc3RlbWEgPSB0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGVOYW1lO1xuICAgICAgICBsZXQgYVx1MDBGMW87XG4gICAgICAgIC8vbGV0IHRyaW1lc3RyZXMgPSBhd2FpdCB0aGlzLmFjdGl2ZVN0cnVjdHVyZVJlc291cmNlcyhcIlRyaW1lc3RyYWxcIik7IC8vIEZ1bmNpb25hIGVuIGxhIHZlcnNpXHUwMEYzbiAxLjAgZGUgQXJlYXMgZGUgVmlkYS5cbiAgICAgICAgbGV0IGFcdTAwRjFvcyA9IGF3YWl0IHRoaXMuZmluZE1haW5GaWxlc1dpdGhTdGF0ZShcIkFZXCIpO1xuICAgICAgICBcbiAgICAgICAgc3dpdGNoKHRpcG9TaXN0ZW1hKSB7XG4gICAgICAgICAgICBjYXNlIFwiQ0FDXCI6XG4gICAgICAgICAgICBjYXNlIFwiQ0FJXCI6XG4gICAgICAgICAgICBjYXNlIFwiQ1RJXCI6IC8vIENvbXBhc3NUcmltZXN0cmFsSW5pY2lvXG4gICAgICAgICAgICAgICAgYVx1MDBGMW8gPSBhd2FpdCBzdWdnZXN0ZXIoYVx1MDBGMW9zLm1hcChiID0+IGIuZmlsZS5iYXNlbmFtZSksYVx1MDBGMW9zLm1hcChiID0+IGIuZmlsZS5iYXNlbmFtZSksIGZhbHNlLCBgU2VsZWNjaW9uYSBlbCBhXHUwMEYxbyBxdWUgZGVzZWFzIHBhcmEgZWwgJHtub21icmVTaXN0ZW1hfTpgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBWVwiOlxuICAgICAgICAgICAgICAgIC8vIE9idGVuZXIgZWwgYVx1MDBGMW8gYWN0dWFsXG4gICAgICAgICAgICAgICAgY29uc3QgYVx1MDBGMW9BY3R1YWwgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXIgZWwgYXJyZWdsbyBjb24gbG9zIGFcdTAwRjFvcyBzb2xpY2l0YWRvc1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmVnbG9BXHUwMEYxb3MgPSBbYVx1MDBGMW9BY3R1YWwgLSAyLCBhXHUwMEYxb0FjdHVhbCAtIDEsIGFcdTAwRjFvQWN0dWFsLCBhXHUwMEYxb0FjdHVhbCArIDEsIGFcdTAwRjFvQWN0dWFsICsgMiBdO1xuICAgICAgICAgICAgICAgIC8vIEFxdWkgbGUgcXVpdG8gbG9zIGFcdTAwRjFvcyBxdWUgeWEgZXN0YW4gY3JlYWRvcyB5IGFjdGl2b3MuXG4gICAgICAgICAgICAgICAgYVx1MDBGMW8gPSBhd2FpdCBzdWdnZXN0ZXIoYXJyZWdsb0FcdTAwRjFvcyxhcnJlZ2xvQVx1MDBGMW9zLCBmYWxzZSwgYFNlbGVjY2lvbmEgZWwgYVx1MDBGMW8gcXVlIHZhbW9zIGEgY3JlYXIuYClcbiAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiT0NBXCI6IC8vIE9iamV0aXZvQ29tcGFzc0FudWFsXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgbGV0IG5vbWJyZUFyY2hpdm8gPSB0aGlzLmluZm9TdWJzaXN0ZW1hLmZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gL1xcLyhcXGR7NH0pLztcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRhZG8gPSBub21icmVBcmNoaXZvLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0YWRvICYmIHJlc3VsdGFkb1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXRvcm5hbW9zIGVsIGdydXBvIGNhcHR1cmFkbywgcXVlIGVzIGVsIHZhbG9yIGRlc2VhZG8gZGUgc3Vic3RyXG4gICAgICAgICAgICAgICAgICAgIGFcdTAwRjFvID0gcmVzdWx0YWRvWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpIG5vIHNlIGVuY3VlbnRyYSB1bmEgY29pbmNpZGVuY2lhLCBwb2RyXHUwMEVEYW1vcyByZXRvcm5hciBudWxsIG8gYWxndW5hIG90cmEgc2VcdTAwRjFhbCBkZSBubyBlbmNvbnRyYWRvXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBTaSBlbCB1c3VhcmlvIGVsaWdlIFwiT3Ryb1wiIG8gY3VhbHF1aWVyIG90cmEgb3BjaVx1MDBGM24uXG4gICAgICAgICAgICAgICAgLy8gdHJpbWVzdHJlID0gYXdhaXQgc3VnZ2VzdGVyKHRyaW1lc3RyZXMubWFwKGIgPT4gYi5maWxlLmJhc2VuYW1lKSx0cmltZXN0cmVzLm1hcChiID0+IGIuZmlsZS5wYXRoKSwgZmFsc2UsIGBUcmltZXN0cmUgZGVsICR7bm9tYnJlU2lzdGVtYX06YCk7XG4gICAgICAgICAgICAgICAgfVxuXHQgICAgLy8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgICAgIGlmIChhXHUwMEYxbyA9PT0gbnVsbCkge1xuICAgICAgICBuZXcgTm90aWNlKFwiQ3JlYWNpXHUwMEYzbiBjYW5jZWxhZGEgcG9yIGVsIHVzdWFyaW8uXCIpO1xuICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cblx0ICAgIH1cbiAgICAgICAgdGhpcy5ub3RhLmFcdTAwRjFvID0gYVx1MDBGMW87XG4gICAgICAgIHJldHVybiBhXHUwMEYxbztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRSZW5hbWUoKXtcbiAgICAgICAgbGV0IHN1Z2dlc3RlciA9IHRoaXMudHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwic3VnZ2VzdGVyXCIpO1xuICAgICAgICBsZXQgbmV3TmFtZSwgbmFtZSwgZm9sZGVyO1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgc3dpdGNoKHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZSkgeyBcbiAgICAgICAgY2FzZSBcIkF4XCI6XG4gICAgICAgICAgICBuZXdOYW1lID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlfSAtICR7dGhpcy5ub3RhLmlkfS5tZGBcbiAgICAgICAgICAgIG5hbWUgPSBgJHt0aGlzLm5vdGEuZmlsZU5hbWV9YFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBSVwiOlxuICAgICAgICBjYXNlIFwiUEdURFwiOlxuICAgICAgICAgICAgaWYgKHRoaXMubm90YS5hcmVhVmlkYT09PVwiTm8gZXMgZGUgbmluZ1x1MDBGQW4gQXJlYSBkZSBWaWRhXCIpe1xuICAgICAgICAgICAgICAgIG5ld05hbWUgPSBgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlcn0vT3RyYXMvJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGV9IC0gJHt0aGlzLm5vdGEuaWR9Lm1kYFxuICAgICAgICAgICAgICAgIGZvbGRlciA9IGAke3RoaXMuaW5mb1N1YnNpc3RlbWEuZm9sZGVyfS9PdHJhc2BcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIG5ld05hbWUgPSBgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlcn0vJHt0aGlzLm5vdGEuYXJlYVZpZGF9LyR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlfSAtICR7dGhpcy5ub3RhLmlkfS5tZGBcbiAgICAgICAgICAgICAgICBmb2xkZXIgPSBgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlcn0vJHt0aGlzLm5vdGEuYXJlYVZpZGF9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhckNhcnBldGEoZm9sZGVyKTtcbiAgICAgICAgICAgIG5hbWUgPSBgJHt0aGlzLm5vdGEuZmlsZU5hbWV9YFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBVlwiOiAgICAgICAgXG4gICAgICAgICAgICBuZXdOYW1lID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5ub3RhLmFyZWFWaWRhfS8ke3RoaXMubm90YS5maWxlbmFtZX0ubWRgXG4gICAgICAgICAgICBuYW1lID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5ub3RhLmFyZWFWaWRhfS8ke3RoaXMubm90YS5maWxlTmFtZX0ubWRgXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJSXCI6ICAgICAgICBcbiAgICAgICAgICAgIG5ld05hbWUgPSBgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlcn0vJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGV9IC0gJHt0aGlzLm5vdGEuaWR9Lm1kYFxuICAgICAgICAgICAgZm9sZGVyID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9YFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhckNhcnBldGEoZm9sZGVyKTtcbiAgICAgICAgICAgIG5hbWUgPSBgJHt0aGlzLm5vdGEuZmlsZU5hbWV9YFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQUVwiOiBcbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICBsZXQgZm9sZGVyQVYgPSBBcnJheS5pc0FycmF5KHRoaXMubm90YS5hcmVhVmlkYSk/IHRoaXMubm90YS5hcmVhVmlkYVswXSA6IHRoaXMubm90YS5hcmVhVmlkYTsgXG4gICAgICAgICAgICBuZXdOYW1lID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5ub3RhLnRyaW1lc3RyZX0vJHtmb2xkZXJBVn0vJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGV9IC0gJHt0aGlzLm5vdGEuaWR9Lm1kYFxuICAgICAgICAgICAgZm9sZGVyID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5ub3RhLnRyaW1lc3RyZX0vJHtmb2xkZXJBVn1gXG4gICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXJDYXJwZXRhKGZvbGRlcik7XG4gICAgICAgICAgICBuYW1lID0gYCR7dGhpcy5ub3RhLmZpbGVOYW1lfWBcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJUeFwiOlxuICAgICAgICAgICAgbGV0IGZlY2hhID0gd2luZG93Lm1vbWVudCh0aGlzLm5vdGEuZmVjaGEsIFwiWVlZWS1NTS1ERCBkZGRkIEhIOm1tXCIpO1xuICAgICAgICAgICAgbGV0IGZlY2hhWSA9IGZlY2hhLmZvcm1hdChcIllZWVlcIik7XG4gICAgICAgICAgICBsZXQgZmVjaGFNZXMgPSBmZWNoYS5mb3JtYXQoXCJNTSAtIE1NTU1cIik7XG4gICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIG5ld05hbWUgPSBgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlcn0vJHtmZWNoYVl9LyR7ZmVjaGFNZXN9LyR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlfSAtICR7dGhpcy5ub3RhLmlkfS5tZGBcbiAgICAgICAgICAgIGZvbGRlciA9IGAke3RoaXMuaW5mb1N1YnNpc3RlbWEuZm9sZGVyfS8ke2ZlY2hhWX0vJHtmZWNoYU1lc31gXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWFyQ2FycGV0YShmb2xkZXIpO1xuICAgICAgICAgICAgbmFtZSA9IGAke3RoaXMubm90YS5maWxlTmFtZX1gXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNBQ1wiOiAgICAgLy8gQ29tcGFzc0FudWFsX0NpZXJyZSAgIFxuICAgICAgICAgICAgbmV3TmFtZSA9IGAke3RoaXMuaW5mb1N1YnNpc3RlbWEuZm9sZGVyfS8ke3RoaXMubm90YS5hXHUwMEYxb30vRGVzZW1wZVx1MDBGMW8gJHt0aGlzLm5vdGEuYVx1MDBGMW99Lm1kYFxuICAgICAgICAgICAgZm9sZGVyID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5ub3RhLmFcdTAwRjFvfWBcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXJDYXJwZXRhKGZvbGRlcik7XG4gICAgICAgICAgICBuYW1lID0gYCR7dGhpcy5ub3RhLmZpbGVOYW1lfWBcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDQUlcIjogICAgIC8vIENvbXBhc3NBbnVhbF9JbmljaW8gICBcbiAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgbmV3TmFtZSA9IGAke3RoaXMuaW5mb1N1YnNpc3RlbWEuZm9sZGVyfS8ke3RoaXMubm90YS5hXHUwMEYxb30vUGxhbmVhY2lcdTAwRjNuICR7dGhpcy5ub3RhLmFcdTAwRjFvfS5tZGBcbiAgICAgICAgICAgIGZvbGRlciA9IGAke3RoaXMuaW5mb1N1YnNpc3RlbWEuZm9sZGVyfS8ke3RoaXMubm90YS5hXHUwMEYxb31gXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWFyQ2FycGV0YShmb2xkZXIpO1xuICAgICAgICAgICAgbmFtZSA9IGAke3RoaXMubm90YS5maWxlTmFtZX1gXG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ1RJXCI6ICAgICAvLyBDb21wYXNzVHJpbWVzdHJhbF9JbmljaW8gICBcbiAgICAgICAgICAgIG5ld05hbWUgPSBgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlcn0vJHt0aGlzLm5vdGEuYVx1MDBGMW99L1BsYW5lYWNpXHUwMEYzbiAke3RoaXMubm90YS50cmltZXN0cmV9Lm1kYFxuICAgICAgICAgICAgZm9sZGVyID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5ub3RhLmFcdTAwRjFvfWBcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXJDYXJwZXRhKGZvbGRlcik7XG4gICAgICAgICAgICBuYW1lID0gYCR7dGhpcy5ub3RhLmZpbGVOYW1lfWBcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBWVwiOiAgICAgLy8gQW51YWwgXG4gICAgICAgICAgICBuZXdOYW1lID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5ub3RhLmFcdTAwRjFvfS5tZGBcbiAgICAgICAgICAgIGZvbGRlciA9IGAke3RoaXMuaW5mb1N1YnNpc3RlbWEuZm9sZGVyfWBcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXJDYXJwZXRhKGZvbGRlcik7XG4gICAgICAgICAgICBuYW1lID0gYCR7dGhpcy5ub3RhLmZpbGVOYW1lfWBcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPQ0FcIjogIC8vIE9iamV0aXZvQ29tcGFzc0FudWFsXG4gICAgICAgICAgICBuZXdOYW1lID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5ub3RhLmFcdTAwRjFvfS8ke3RoaXMuaW5mb1N1YnNpc3RlbWEudHlwZX0gLSAke3RoaXMubm90YS5pZH0ubWRgXG4gICAgICAgICAgICBmb2xkZXIgPSBgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlcn0vJHt0aGlzLm5vdGEuYVx1MDBGMW99YFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhckNhcnBldGEoZm9sZGVyKTtcbiAgICAgICAgICAgIG5hbWUgPSBgJHt0aGlzLm5vdGEuZmlsZU5hbWV9YFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDUEVcIjogICAgIC8vIENvbnRlbmlkbyBQYXJhIEVzdHVkaW8gXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgbmV3TmFtZSA9IGAke3RoaXMuaW5mb1N1YnNpc3RlbWEuZm9sZGVyfS8ke3RoaXMubm90YS5mZWNoYS5zbGljZSgwLCA0KX0vJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGV9IC0gJHt0aGlzLm5vdGEuaWR9Lm1kYFxuICAgICAgICAgICAgZm9sZGVyID0gYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5ub3RhLmZlY2hhLnNsaWNlKDAsIDQpfWBcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXJDYXJwZXRhKGZvbGRlcik7XG4gICAgICAgICAgICBuYW1lID0gYCR7dGhpcy5ub3RhLmZpbGVOYW1lfWBcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChuYW1lKTtcbiAgICAgICAgY29uc3QgZXhpc3RlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChuZXdOYW1lKTtcbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGlmIChleGlzdGUgaW5zdGFuY2VvZiBURmlsZSl7XG4gICAgICAgICAgICAgICAgbGV0IG5vbWJyZUZpbGUgPSBuZXdOYW1lPy5zcGxpdChcIi9cIik7XG5cbiAgICAgICAgICAgICAgICBsZXQgYm9ycmFyID0gYXdhaXQgc3VnZ2VzdGVyKFxuICAgICAgICAgICAgICAgICAgICBbXCJTb2JyZWVzY3JpYmlyIEFyY2hpdm8gQWN0dWFsXCIsIFwiRGV0ZW5lciBjcmVhY2lcdTAwRjNuIGRlbCBhcmNoaXZvLlwiXSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2VdLFxuICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBgXHUwMEJGJHtub21icmVGaWxlLnBvcCgpfSB5YSBleGlzdGUuIFF1ZSBkZXNlYXMgaGFjZXI/YFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoYm9ycmFyKXtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXBwLnZhdWx0LmRlbGV0ZShleGlzdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGFwcC52YXVsdC5yZW5hbWUoZmlsZSwgbmV3TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFyY2hpdm8gcmVub21icmFkbyBjb24gXHUwMEU5eGl0by5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbmNlbGFuZG8gbGEgY3JlYWNpXHUwMEYzbiBkZWwgYXJjaGl2by5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5ib3JyYXJOb3RhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKXtcbiAgICAgICAgICAgICAgICBhd2FpdCBhcHAudmF1bHQucmVuYW1lKGZpbGUsIG5ld05hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXJjaGl2byByZW5vbWJyYWRvIGNvbiBcdTAwRTl4aXRvLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1jYXRjaCAoZXJyb3Ipe1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGNhbWJpYXIgZWwgbm9tYnJlXCIsIGVycm9yKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QXJlYVZpZGEoKXtcbiAgICAgICAgbGV0IHN1Z2dlc3RlciA9IHRoaXMudHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwic3VnZ2VzdGVyXCIpO1xuICAgICAgICBsZXQgdGlwbyA9IHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZTtcbiAgICAgICAgbGV0IG5vbWJyZVRpcG8gPSB0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGVOYW1lO1xuICAgICAgICBsZXQgYXJlYXNWaWRhID0ge307XG4gICAgICAgIGxldCBhcmVhVmlkYTtcbiAgICAgICAgbGV0IG5vQVYgPSB7fSA7XG4gICAgICAgIG5vQVYuZmlsZSA9IHt9IDtcbiAgICAgICAgbm9BVi5hcmVhVmlkYSA9IFwiTm8gZXMgZGUgbmluZ1x1MDBGQW4gQXJlYSBkZSBWaWRhXCI7XG4gICAgICAgIG5vQVYuZmlsZS5iYXNlbmFtZSA9IFwiTm8gZXMgZGUgbmluZ1x1MDBGQW4gQXJlYSBkZSBWaWRhXCI7XG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBcblxuICAgICAgICBpZiAoIXRoaXMubm90YS5hc3VudG9EZWZpbmlkbykge1xuICAgICAgICBzd2l0Y2godGlwbykge1xuICAgICAgICAgICAgY2FzZSBcIkFJXCI6XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm90YS5hcmVhSW50ZXJlcyA9PSBcIlwiKXtcbiAgICAgICAgICAgICAgICAvLyBMXHUwMEYzZ2ljYSBwYXJhIHBlcm1pdGlyIGFsIHVzdWFyaW8gZWxlZ2lyIHVuYSB0YXJlYSBlc3BlY1x1MDBFRGZpY2EuXG4gICAgICAgICAgICAgICAgYXJlYXNWaWRhID0gYXdhaXQgdGhpcy5maW5kTWFpbkZpbGVzV2l0aFN0YXRlKFwiQVZcIilcbiAgICAgICAgICAgICAgICBhcmVhc1ZpZGEucHVzaChub0FWKTtcbiAgICAgICAgICAgICAgICBhcmVhVmlkYSA9IGF3YWl0IHN1Z2dlc3RlcihhcmVhc1ZpZGEubWFwKGIgPT4gYi5hcmVhVmlkYSksYXJlYXNWaWRhLm1hcChiID0+IGIuYXJlYVZpZGEpLCBmYWxzZSwgYEEgcXVlIEFyZWEgZGUgVmlkYSBwZXJ0ZW5lY2UgZXN0YSAke25vbWJyZVRpcG99OmApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBhcmVhVmlkYSA9IHRoaXMubm90YS5hcmVhVmlkYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgXG5cbiAgICAgICAgICAgIGNhc2UgXCJQUVwiOlxuICAgICAgICAgICAgICAgIGFyZWFzVmlkYSA9IGF3YWl0IHRoaXMuZmluZE1haW5GaWxlc1dpdGhTdGF0ZShcIkFWXCIsIHRoaXMubm90YS50cmltZXN0cmUpXG4gICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBhcmVhVmlkYSA9IGF3YWl0IHN1Z2dlc3RlcihhcmVhc1ZpZGEubWFwKGIgPT4gYi5maWxlLmJhc2VuYW1lKSxhcmVhc1ZpZGEubWFwKGIgPT4gW2IuYXJlYVZpZGEsIGIuZmlsZS5iYXNlbmFtZV0pLCBmYWxzZSwgYEEgcXVlIEFyZWEgZGUgVmlkYSBwZXJ0ZW5lY2UgZXN0YShlKSAke25vbWJyZVRpcG99OmApO1xuICAgICAgICAgICAgICAgIHRoaXMubm90YS5uaXZlbFAgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJPQ0FcIjogLy8gT2JqZXRpdm9Db21wYXNzQW51YWxcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBsZXQgbm9tYnJlQXJjaGl2byA9IHRoaXMuaW5mb1N1YnNpc3RlbWEuZmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvT2JqZXRpdm8gcGFyYSAoLispXFwubWQkLztcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRhZG8gPSBub21icmVBcmNoaXZvLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0YWRvICYmIHJlc3VsdGFkb1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXRvcm5hbW9zIGVsIGdydXBvIGNhcHR1cmFkbywgcXVlIGVzIGVsIHZhbG9yIGRlc2VhZG8gZGUgc3Vic3RyXG4gICAgICAgICAgICAgICAgICAgIGFyZWFWaWRhID0gcmVzdWx0YWRvWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpIG5vIHNlIGVuY3VlbnRyYSB1bmEgY29pbmNpZGVuY2lhLCBwb2RyXHUwMEVEYW1vcyByZXRvcm5hciBudWxsIG8gYWxndW5hIG90cmEgc2VcdTAwRjFhbCBkZSBubyBlbmNvbnRyYWRvXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhcmVhc1ZpZGEgPSBhd2FpdCB0aGlzLmZpbmRNYWluRmlsZXNXaXRoU3RhdGUoXCJBVlwiKVxuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIGFyZWFzVmlkYS5wdXNoKG5vQVYpO1xuICAgICAgICAgICAgICAgIGFyZWFWaWRhID0gYXdhaXQgc3VnZ2VzdGVyKGFyZWFzVmlkYS5tYXAoYiA9PiBiLmZpbGUuYmFzZW5hbWUpLGFyZWFzVmlkYS5tYXAoYiA9PiBiLmZpbGUuYmFzZW5hbWUpLCBmYWxzZSwgYEEgcXVlIEFyZWEgZGUgVmlkYSBwZXJ0ZW5lY2UgZXN0YShlKSAke25vbWJyZVRpcG99OmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblx0ICAgIC8vIFZlcmlmaWNhciBzaSBlbCB1c3VhcmlvIHByZXNpb25cdTAwRjMgRXNjLlxuICAgICAgICByZXR1cm4gYXJlYVZpZGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RhLmFyZWFWaWRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QXJlYUludGVyZXMoKXtcbiAgICAgICAgbGV0IHN1Z2dlc3RlciA9IHRoaXMudHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwic3VnZ2VzdGVyXCIpO1xuICAgICAgICBsZXQgdGlwbyA9IHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZTtcbiAgICAgICAgbGV0IG5vbWJyZVRpcG8gPSB0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGVOYW1lO1xuICAgICAgICBsZXQgYXJlYXNJbnRlcmVzID0gYXdhaXQgdGhpcy5maW5kTWFpbkZpbGVzV2l0aFN0YXRlKFwiQUlcIilcbiAgICAgICAgbGV0IGFyZWFJbnRlcmVzLCBuaXZlbCwgdGl0dWxvLCBwYWRyZUFJLCBhcnJheUFJO1xuICAgICAgICBpZiAoIXRoaXMubm90YS5hc3VudG9EZWZpbmlkbykge1xuICAgICAgICBzd2l0Y2godGlwbykge1xuICAgICAgICAgICAgY2FzZSBcIkFJXCI6XG4gICAgICAgICAgICAgICAgcGFkcmVBSSA9IGF3YWl0IHN1Z2dlc3RlcihbXCJTaVwiLCBcIk5vXCJdLCBbdHJ1ZSxmYWxzZV0sIGZhbHNlLCBgICR7dGhpcy5ub3RhLnRpdHVsb30gZXMgaGlqbyBkZSBvdHJhICR7bm9tYnJlVGlwb306YCk7XG4gICAgICAgICAgICAgICAgLy8gTFx1MDBGM2dpY2EgcGFyYSBwZXJtaXRpciBhbCB1c3VhcmlvIGVsZWdpciB1bmEgdGFyZWEgZXNwZWNcdTAwRURmaWNhLlxuICAgICAgICAgICAgICAgIGlmIChwYWRyZUFJKXtcbiAgICAgICAgICAgICAgICAgICAgYXJlYUludGVyZXMgPSBhd2FpdCBzdWdnZXN0ZXIoYXJlYXNJbnRlcmVzLm1hcChiID0+IGIudGl0dWxvKSAsYXJlYXNJbnRlcmVzLm1hcChiID0+IGIpLCBmYWxzZSwgYFF1ZSBBcmVhIGRlIEludGVyXHUwMEU5cyBlcyBwYWRyZSBkZSAke3RoaXMubm90YS50aXR1bG99PzpgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWFJbnRlcmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiU2luIEFyZWEgZGUgSW50ZXJlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdHVsbyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBuaXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNleyAvLyBRVUUgSEFDRSBFU1RFIEVMU0U/P1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYUludGVyZXMuYXJlYVZpZGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBcIk5vIGVzIGRlIG5pbmdcdTAwRkFuIEFyZWEgZGUgVmlkYVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBhcmVhSW50ZXJlcy5hcmVhVmlkYS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0dWxvID0gYXJlYUludGVyZXMudGl0dWxvO1xuICAgICAgICAgICAgICAgICAgICAgICAgbml2ZWwgPSBwYXJzZUludChhcmVhSW50ZXJlcy5uaXZlbEFJKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgdGl0dWxvID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgbml2ZWwgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJSXCI6XG4gICAgICAgICAgICBjYXNlIFwiQXhcIjpcbiAgICAgICAgICAgIHBhZHJlQUkgPSBhd2FpdCBzdWdnZXN0ZXIoW1wiU2lcIiwgXCJOb1wiXSwgW3RydWUsZmFsc2VdLCBmYWxzZSwgYCAke3RoaXMubm90YS50aXR1bG99IGVzIGhpam8gZGUgdW4gQXJlYSBkZSBJbnRlclx1MDBFOXM6YCk7XG4gICAgICAgICAgICAvLyBMXHUwMEYzZ2ljYSBwYXJhIHBlcm1pdGlyIGFsIHVzdWFyaW8gZWxlZ2lyIHVuYSB0YXJlYSBlc3BlY1x1MDBFRGZpY2EuXG4gICAgICAgICAgICBpZiAocGFkcmVBSSl7XG4gICAgICAgICAgICAgICAgYXJlYUludGVyZXMgPSBhd2FpdCBzdWdnZXN0ZXIoYXJlYXNJbnRlcmVzLm1hcChiID0+IGIudGl0dWxvKSAsYXJlYXNJbnRlcmVzLm1hcChiID0+IGIpLCBmYWxzZSwgYFF1ZSBBcmVhIGRlIEludGVyXHUwMEU5cyBlcyBwYWRyZSBkZSAke3RoaXMubm90YS50aXR1bG99PzpgKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJlYUludGVyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlNpbiBBcmVhIGRlIEludGVyZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHRpdHVsbyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIG5pdmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUZXJtaW5hIGxhIGVqZWN1Y2lcdTAwRjNuIGRlIGxhIGZ1bmNpXHUwMEYzbiBhcXVcdTAwRUQuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgICAgICB0aXR1bG8gPSBbYXJlYUludGVyZXMudGl0dWxvXTsgXG4gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Ftb3Mgc2kgbm90YS5hcmVhSW50ZXJlcyBlcyB1biBhcnJlZ2xvXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZWFJbnRlcmVzPy5hcmVhSW50ZXJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdHVsbyA9IHRpdHVsby5jb25jYXQoYXJlYUludGVyZXMuYXJlYUludGVyZXMubWFwKGVsZW1lbnRvID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRvLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2kgbm8gZXMgdW4gYXJyZWdsbywgcmV2aXNhbW9zIHNpIG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMgZXhpc3RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhSW50ZXJlcz8uYXJlYUludGVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGV4aXN0ZSwgYXBsaWNhbW9zIGVsIHJlZ2V4IHkgbG8gYVx1MDBGMWFkaW1vcyBjb21vIHNlZ3VuZG8gZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdHVsby5wdXNoKGFyZWFJbnRlcmVzLmFyZWFJbnRlcmVzLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBWRVJJRklDQUNJT04gREUgQVJFQSBERSBWSURBXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhSW50ZXJlcz8uYXJlYVZpZGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZWFJbnRlcmVzLmFyZWFWaWRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzIHVuIGFycmVnbG8sIHVzYSBlbCBwcmltZXIgZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBhcmVhSW50ZXJlcy5hcmVhVmlkYVswXS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJlYUludGVyZXMuYXJlYVZpZGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXMgdW4gc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gYXJlYUludGVyZXMuYXJlYVZpZGEucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGVzdFx1MDBFMSBkZWZpbmlkbyBvIGVzdFx1MDBFMSB2YWNcdTAwRURvXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBcIk5vIGVzIGRlIG5pbmdcdTAwRkFuIFx1MDBDMXJlYSBkZSBWaWRhXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFzdW50b0RlZmluaWRvID0gdHJ1ZTsgLy8gUGFyYSBxdWUgbm8gZWplY3V0ZSBsYSBidXNxdWVkYSBkZSBwcm95ZWN0byBRIG8gR1RELi4uXG4gICAgICAgICAgICAgICAgICAgIG5pdmVsID0gcGFyc2VJbnQoYXJlYUludGVyZXMubml2ZWxBSSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aXR1bG8gPSBcIlwiO1xuICAgICAgICAgICAgICAgIG5pdmVsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBRXCI6XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgcGFkcmVBSSA9IGF3YWl0IHN1Z2dlc3RlcihbXCJTaVwiLCBcIk5vXCJdLCBbdHJ1ZSxmYWxzZV0sIGZhbHNlLCBgICR7dGhpcy5ub3RhLnRpdHVsb30gZXMgaGlqbyBkZSB1biBBcmVhIGRlIEludGVyXHUwMEU5czpgKTtcbiAgICAgICAgICAgIC8vIExcdTAwRjNnaWNhIHBhcmEgcGVybWl0aXIgYWwgdXN1YXJpbyBlbGVnaXIgdW5hIHRhcmVhIGVzcGVjXHUwMEVEZmljYS5cbiAgICAgICAgICAgIGlmIChwYWRyZUFJKXtcbiAgICAgICAgICAgICAgICBhcmVhSW50ZXJlcyA9IGF3YWl0IHN1Z2dlc3RlcihhcmVhc0ludGVyZXMubWFwKGIgPT4gYi50aXR1bG8pICxhcmVhc0ludGVyZXMubWFwKGIgPT4gYiksIGZhbHNlLCBgUXVlIEFyZWEgZGUgSW50ZXJcdTAwRTlzIGVzIHBhZHJlIGRlICR7dGhpcy5ub3RhLnRpdHVsb30/OmApO1xuICAgICAgICAgICAgICAgIGlmIChhcmVhSW50ZXJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiU2luIEFyZWEgZGUgSW50ZXJlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGl0dWxvID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgbml2ZWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhSW50ZXJlcy5hcmVhVmlkYSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gXCJObyBlcyBkZSBuaW5nXHUwMEZBbiBBcmVhIGRlIFZpZGFcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWRVJJRklDQUNJT04gREUgQVJFQSBERSBWSURBXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBbXTsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhVmlkYVswXSA9IGFyZWFJbnRlcmVzPy5hcmVhVmlkYVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhcmVhSW50ZXJlcy5hcmVhVmlkYS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiTm8gZXMgZGUgbmluZ1x1MDBGQW4gQXJlYSBkZSBWaWRhXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGFbMV0gPSBgJHt0aGlzLm5vdGEudHJpbWVzdHJlfSAtICR7dGhpcy5ub3RhLmFyZWFWaWRhWzBdfWBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEubml2ZWxQID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFzdW50b0RlZmluaWRvID0gdHJ1ZTsgLy8gUGFyYSBxdWUgbm8gZWplY3V0ZSBsYSBidXNxdWVkYSBkZSBwcm95ZWN0byBRIG8gR1RELi4uXG4gICAgICAgICAgICAgICAgICAgIGFycmF5QUkgPSBbYXJlYUludGVyZXMudGl0dWxvXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Ftb3Mgc2kgbm90YS5hcmVhSW50ZXJlcyBlcyB1biBhcnJlZ2xvXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZWFJbnRlcmVzLmFyZWFJbnRlcmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXMgdW4gYXJyZWdsbywgaXRlcmFtb3Mgc29icmUgY2FkYSBlbGVtZW50byAoZXhjbHV5ZW5kbyBlbCBwcmltZXIgZWxlbWVudG8geWEgYWdyZWdhZG8gcXVlIGVzIG5vdGEudGl0dWxvKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geSBhcGxpY2Ftb3MgZWwgcmVnZXggYSBjYWRhIGVsZW1lbnRvLiBMdWVnbyBjb25jYXRlbmFtb3MgY29uIGVsIGFycmF5IGV4aXN0ZW50ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhSW50ZXJlcyA9IGFycmF5QUkuY29uY2F0KGFyZWFJbnRlcmVzLmFyZWFJbnRlcmVzLm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50by5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBubyBlcyB1biBhcnJlZ2xvLCByZXZpc2Ftb3Mgc2kgbm90YS5mcm9udG1hdHRlci5hcmVhSW50ZXJlcyBleGlzdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmVhSW50ZXJlcz8uYXJlYUludGVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBleGlzdGUsIGFwbGljYW1vcyBlbCByZWdleCB5IGxvIGFcdTAwRjFhZGltb3MgY29tbyBzZWd1bmRvIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlBSS5wdXNoKGFyZWFJbnRlcmVzLmFyZWFJbnRlcmVzLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgYXJlYUludGVyZXMuYXJlYUludGVyZXMgbm8gZXhpc3RlLCB0aGlzLm5vdGEuYXJlYUludGVyZXMgeWEgdGVuZHJcdTAwRTEgbm90YS50aXR1bG8gY29tbyBzdSBcdTAwRkFuaWNvIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBhcnJheUFJID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheUFJO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIExhIHNhbGlkYSBwYXJhIGRlZmF1bHQgbm8gcHVlZGUgc2VyIHNvbG8gYXJlYUludGVyZXMuLiBWYWxpZGFyIGN1YW5kbyBjb3JyZXNwb25kYS5cbiAgICAgICAgICAgICAgICBhcmVhSW50ZXJlcyA9IGF3YWl0IHN1Z2dlc3RlcihhcmVhc0ludGVyZXMubWFwKGIgPT4gYi5maWxlLmJhc2VuYW1lKSxhcmVhc1ZpZGEubWFwKGIgPT4gYi5maWxlLmJhc2VuYW1lKSwgZmFsc2UsIGBBIHF1ZSBBcmVhIGRlIFZpZGEgcGVydGVuZWNlIGVzdGEgJHtub21icmVUaXBvfTpgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgZGVidWdnZXI7XG5cdCAgICB0aGlzLm5vdGEubml2ZWxBSSA9IG5pdmVsO1xuICAgICAgICByZXR1cm4gdGl0dWxvO1xuICAgICB9ZWxzZXtcbiAgICAgICByZXR1cm4gdGhpcy5ub3RhLmFyZWFJbnRlcmVzOyBcbiAgICAgICB9XG4gICAgfVxuXG5cbiAgICBhc3luYyBnZXRQcm95ZWN0b0dURCgpe1xuICAgICAgICBsZXQgc3VnZ2VzdGVyID0gdGhpcy50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG4gICAgICAgIGxldCB0aXBvID0gdGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlO1xuICAgICAgICBsZXQgbm9tYnJlVGlwbyA9IHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZU5hbWU7XG4gICAgICAgIGxldCBub3Rhc0YgPSBhd2FpdCB0aGlzLmZpbmRNYWluRmlsZXNXaXRoU3RhdGUoXCJQR1REXCIpXG4gICAgICAgIGxldCBub3RhRiwgbml2ZWwsIHRpdHVsbztcbiAgICAgICAgaWYgKCF0aGlzLm5vdGEuYXN1bnRvRGVmaW5pZG8pIHtcbiAgICAgICAgICAgIC8vIEVqZWN1dGFyIGNcdTAwRjNkaWdvIGFxdVx1MDBFRCBzaSBhc3VudG9EZWZpbmlkbyBlcyBmYWxzeSAoaW5jbHV5ZSBmYWxzZSwgbnVsbCwgdW5kZWZpbmVkLCAwLCBcIlwiLCBOYU4pXG4gICAgICAgIHN3aXRjaCh0aXBvKSB7XG4gICAgICAgICAgICBjYXNlIFwiUlJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBeFwiOlxuICAgICAgICAgICAgICAgIGxldCBwYWRyZVBHVEQgPSBhd2FpdCBzdWdnZXN0ZXIoW1wiU2lcIiwgXCJOb1wiXSwgW3RydWUsZmFsc2VdLCBmYWxzZSwgYCAke3RoaXMubm90YS50aXR1bG99IGVzIGhpam8gZGUgdW4gUHJveWVjdG8gR1REP2ApO1xuICAgICAgICAgICAgICAgIC8vIExcdTAwRjNnaWNhIHBhcmEgcGVybWl0aXIgYWwgdXN1YXJpbyBlbGVnaXIgdW5hIHRhcmVhIGVzcGVjXHUwMEVEZmljYS5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocGFkcmVQR1REKXtcbiAgICAgICAgICAgICAgICAgICAgbm90YUYgPSBhd2FpdCBzdWdnZXN0ZXIobm90YXNGLm1hcChiID0+IGIudGl0dWxvKSAsbm90YXNGLm1hcChiID0+IGIpLCBmYWxzZSwgYFF1ZSBQcm95ZWN0byBHVEQgZXMgcGFkcmUgZGUgJHt0aGlzLm5vdGEudGl0dWxvfT86YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3RhRiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlNpbiBwcm95ZWN0byBHVEQgZGVmaW5pZG8uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0dWxvID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVGVybWluYSBsYSBlamVjdWNpXHUwMEYzbiBkZSBsYSBmdW5jaVx1MDBGM24gYXF1XHUwMEVELlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmaWNhbW9zIGFyZWFJbnRlcmVzIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFJbnRlcmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub3RhRj8uYXJlYUludGVyZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXMgdW4gYXJyZWdsbywgaXRlcmFtb3Mgc29icmUgY2FkYSBlbGVtZW50byAoZXhjbHV5ZW5kbyBlbCBwcmltZXIgZWxlbWVudG8geWEgYWdyZWdhZG8gcXVlIGVzIG5vdGEudGl0dWxvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHkgYXBsaWNhbW9zIGVsIHJlZ2V4IGEgY2FkYSBlbGVtZW50by4gTHVlZ28gY29uY2F0ZW5hbW9zIGNvbiBlbCBhcnJheSBleGlzdGVudGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFJbnRlcmVzID0gdGhpcy5ub3RhLmFyZWFJbnRlcmVzLmNvbmNhdChub3RhRi5hcmVhSW50ZXJlcy5tYXAoZWxlbWVudG8gPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRvLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgbm8gZXMgdW4gYXJyZWdsbywgcmV2aXNhbW9zIHNpIG5vdGEuZnJvbnRtYXR0ZXIuYXJlYUludGVyZXMgZXhpc3RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGFGPy5hcmVhSW50ZXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBleGlzdGUsIGFwbGljYW1vcyBlbCByZWdleCB5IGxvIGFcdTAwRjFhZGltb3MgY29tbyBzZWd1bmRvIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhSW50ZXJlcy5wdXNoKG5vdGFGLmFyZWFJbnRlcmVzLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmaWNhbW9zIEFyZWFWaWRhXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RhRj8uYXJlYVZpZGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub3RhRi5hcmVhVmlkYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXMgdW4gYXJyZWdsbywgdXNhIGVsIHByaW1lciBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBub3RhRi5hcmVhVmlkYVswXS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vdGFGLmFyZWFWaWRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcyB1biBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gbm90YUYuYXJlYVZpZGEucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGVzdFx1MDBFMSBkZWZpbmlkbyBvIGVzdFx1MDBFMSB2YWNcdTAwRURvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFWaWRhID0gXCJObyBlcyBkZSBuaW5nXHUwMEZBbiBBcmVhIGRlIFZpZGFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLnByb3llY3RvUSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub3RhRj8ucHJveWVjdG9RKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGVzIHVuIGFycmVnbG8sIGl0ZXJhbW9zIHNvYnJlIGNhZGEgZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEucHJveWVjdG9RID0gbm90YUYucHJveWVjdG9RLm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vdGFGPy5wcm95ZWN0b1EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBleGlzdGUgcGVybyBubyBlcyB1biBhcnJlZ2xvLCBhcGxpY2Ftb3MgZWwgcmVnZXggZGlyZWN0YW1lbnRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLnByb3llY3RvUSA9IG5vdGFGLnByb3llY3RvUS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXR1bG8gPSBbbm90YUYudGl0dWxvXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmaWNhbW9zIHNpIG5vdGEucHJveWVjdG9HVEQgZXhpc3RlIHkgZXMgdW4gYXJyZWdsb1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm90YUY/LnByb3llY3RvR1REKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGVzIHVuIGFycmVnbG8sIGl0ZXJhbW9zIHNvYnJlIGNhZGEgZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXR1bG8gPSB0aXR1bG8uY29uY2F0KG5vdGFGLnByb3llY3RvR1RELm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub3RhRj8ucHJveWVjdG9HVEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBleGlzdGUgcGVybyBubyBlcyB1biBhcnJlZ2xvLCBhcGxpY2Ftb3MgZWwgcmVnZXggZGlyZWN0YW1lbnRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0dWxvLnB1c2gobm90YUYucHJveWVjdG9HVEQucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXN1bnRvRGVmaW5pZG8gPSB0cnVlOyAvLyBQYXJhIHF1ZSBubyBlamVjdXRlIGxhIGJ1c3F1ZWRhIGRlIHByb3llY3RvIFFcbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgdGl0dWxvID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgbml2ZWwgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gTGEgc2FsaWRhIHBhcmEgZGVmYXVsdCBubyBwdWVkZSBzZXIgc29sbyBhcmVhSW50ZXJlcy4uIFZhbGlkYXIgY3VhbmRvIGNvcnJlc3BvbmRhLlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblx0ICAgIFxuICAgICAgICByZXR1cm4gdGl0dWxvO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdGEucHJveWVjdG9HVEQvLz8gdGhpcy5ub3RhLlByb3llY3RvR1REO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBhc3luYyBnZXRQcm95ZWN0b1EoKXtcbiAgICAgICAgbGV0IHN1Z2dlc3RlciA9IHRoaXMudHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwic3VnZ2VzdGVyXCIpO1xuICAgICAgICBsZXQgdGlwbyA9IHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZTtcbiAgICAgICAgbGV0IG5vbWJyZVRpcG8gPSB0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGVOYW1lO1xuICAgICAgICBsZXQgbm90YXNGID0gYXdhaXQgdGhpcy5maW5kTWFpbkZpbGVzV2l0aFN0YXRlKFwiUFFcIilcbiAgICAgICAgbGV0IG5vdGFGLCBuaXZlbCwgdGl0dWxvO1xuICAgICAgICBpZiAoIXRoaXMubm90YS5hc3VudG9EZWZpbmlkbykge1xuICAgICAgICAgICAgLy8gRWplY3V0YXIgY1x1MDBGM2RpZ28gYXF1XHUwMEVEIHNpIGFzdW50b0RlZmluaWRvIGVzIGZhbHN5IChpbmNsdXllIGZhbHNlLCBudWxsLCB1bmRlZmluZWQsIDAsIFwiXCIsIE5hTilcbiAgICAgICAgc3dpdGNoKHRpcG8pIHtcbiAgICAgICAgICAgIGNhc2UgXCJSUlwiOlxuICAgICAgICAgICAgY2FzZSBcIkF4XCI6XG4gICAgICAgICAgICAgICAgbGV0IHBhZHJlUSA9IGF3YWl0IHN1Z2dlc3RlcihbXCJTaVwiLCBcIk5vXCJdLCBbdHJ1ZSxmYWxzZV0sIGZhbHNlLCBgICR7dGhpcy5ub3RhLnRpdHVsb30gZXMgaGlqbyBkZSB1biBQcm95ZWN0byBRP2ApO1xuICAgICAgICAgICAgICAgIC8vIExcdTAwRjNnaWNhIHBhcmEgcGVybWl0aXIgYWwgdXN1YXJpbyBlbGVnaXIgdW5hIHRhcmVhIGVzcGVjXHUwMEVEZmljYS5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocGFkcmVRKXtcbiAgICAgICAgICAgICAgICAgICAgbm90YUYgPSBhd2FpdCBzdWdnZXN0ZXIobm90YXNGLm1hcChiID0+IGIudGl0dWxvKSAsbm90YXNGLm1hcChiID0+IGIpLCBmYWxzZSwgYFF1ZSBQcm95ZWN0byBRIGVzIHBhZHJlIGRlICR7dGhpcy5ub3RhLnRpdHVsb30/OmApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm90YUYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJTaW4gcHJveWVjdG8gUSBkZWZpbmlkby5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXR1bG8gPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUZXJtaW5hIGxhIGVqZWN1Y2lcdTAwRjNuIGRlIGxhIGZ1bmNpXHUwMEYzbiBhcXVcdTAwRUQuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Ftb3MgYXJlYUludGVyZXMgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYUludGVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGFGPy5hcmVhSW50ZXJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBlcyB1biBhcnJlZ2xvLCBpdGVyYW1vcyBzb2JyZSBjYWRhIGVsZW1lbnRvIChleGNsdXllbmRvIGVsIHByaW1lciBlbGVtZW50byB5YSBhZ3JlZ2FkbyBxdWUgZXMgbm90YS50aXR1bG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geSBhcGxpY2Ftb3MgZWwgcmVnZXggYSBjYWRhIGVsZW1lbnRvLiBMdWVnbyBjb25jYXRlbmFtb3MgY29uIGVsIGFycmF5IGV4aXN0ZW50ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYUludGVyZXMgPSB0aGlzLm5vdGEuYXJlYUludGVyZXMuY29uY2F0KG5vdGFGLmFyZWFJbnRlcmVzLm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBubyBlcyB1biBhcnJlZ2xvLCByZXZpc2Ftb3Mgc2kgbm90YS5mcm9udG1hdHRlci5hcmVhSW50ZXJlcyBleGlzdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90YUY/LmFyZWFJbnRlcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGV4aXN0ZSwgYXBsaWNhbW9zIGVsIHJlZ2V4IHkgbG8gYVx1MDBGMWFkaW1vcyBjb21vIHNlZ3VuZG8gZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFyZWFJbnRlcmVzLnB1c2gobm90YUYuYXJlYUludGVyZXMucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Ftb3MgQXJlYVZpZGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhVmlkYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGFGPy5hcmVhVmlkYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vdGFGLmFyZWFWaWRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcyB1biBhcnJlZ2xvLCB1c2EgZWwgcHJpbWVyIGVsZW1lbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5hcmVhVmlkYSA9IG5vdGFGLmFyZWFWaWRhWzBdLnJlcGxhY2UoL1xcW1xcW1xccyp8XFxzKlxcXVxcXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm90YUYuYXJlYVZpZGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzIHVuIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBub3RhRi5hcmVhVmlkYS5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gZXN0XHUwMEUxIGRlZmluaWRvIG8gZXN0XHUwMEUxIHZhY1x1MDBFRG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEuYXJlYVZpZGEgPSBcIk5vIGVzIGRlIG5pbmdcdTAwRkFuIEFyZWEgZGUgVmlkYVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXR1bG8gPSBbbm90YUY/LnRpdHVsb107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b0dURCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub3RhRj8ucHJveWVjdG9HVEQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZXMgdW4gYXJyZWdsbywgaXRlcmFtb3Mgc29icmUgY2FkYSBlbGVtZW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90YS5wcm95ZWN0b0dURCA9IG5vdGFGLnByb3llY3RvR1RELm1hcChlbGVtZW50byA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudG8ucmVwbGFjZSgvXFxbXFxbXFxzKnxcXHMqXFxdXFxdL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vdGFGPy5wcm95ZWN0b0dURCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpIGV4aXN0ZSBwZXJvIG5vIGVzIHVuIGFycmVnbG8sIGFwbGljYW1vcyBlbCByZWdleCBkaXJlY3RhbWVudGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGEucHJveWVjdG9HVEQgPSBub3RhRi5wcm95ZWN0b0dURC5yZXBsYWNlKC9cXFtcXFtcXHMqfFxccypcXF1cXF0vZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFzdW50b0RlZmluaWRvID0gdHJ1ZTsgLy8gUGFyYSBxdWUgbm8gZWplY3V0ZSBsYSBidXNxdWVkYSBkZSBwcm95ZWN0byBRXG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRpdHVsbyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIG5pdmVsID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIExhIHNhbGlkYSBwYXJhIGRlZmF1bHQgbm8gcHVlZGUgc2VyIHNvbG8gYXJlYUludGVyZXMuLiBWYWxpZGFyIGN1YW5kbyBjb3JyZXNwb25kYS5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cdCAgICBcbiAgICAgICAgcmV0dXJuIHRpdHVsbztcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RhLnByb3llY3RvUS8vPyB0aGlzLm5vdGEuUHJveWVjdG9HVEQ7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgLy8gRXN0YSBmdW5jaVx1MDBGM24gZW5jdWVudHJhIGxvcyBhcmNoaXZvcyBkZSBzdWJzaXN0ZW1hcyB5IGN1eW8gZXN0YWRvIGVzIFx1RDgzRFx1REZFMlxuICAgIC8vIEVzdGEgZnVuY2lcdTAwRjNuIHNhbGUgZGUgbWVudU90cm8sIGRlIHJlZ2lzdHJvIFRpZW1wby4gUmV2aXNhciBzaSBkZWJvIHNpbmNyb25pemFybGFzLlxuICAgIGFzeW5jIGZpbmRNYWluRmlsZXNXaXRoU3RhdGUodGlwbywgcGFyYW1ldHJvKSB7XG4gICAgXG4gICAgY29uc3QgcHJvcGVydGllc1RpcG8gPSB7XG4gICAgICAgIEFWOiB7XG4gICAgICAgICAgICBmb2xkZXI6IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9BcmVhc1ZpZGEsXG4gICAgICAgIH0sXG4gICAgICAgIEFJOiB7XG4gICAgICAgICAgICBmb2xkZXI6IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9BcmVhc0ludGVyZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBQUToge1xuICAgICAgICAgICAgZm9sZGVyOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfUHJveWVjdG9zUSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIFBHVEQ6IHtcbiAgICAgICAgICAgIGZvbGRlcjogdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1Byb3llY3Rvc0dURCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIFRJOiB7XG4gICAgICAgICAgICAgICAgZm9sZGVyOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfVGVtYXNJbnRlcmVzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgUlI6IHtcbiAgICAgICAgICAgIGZvbGRlcjogdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX1JlY3Vyc29zUmVjdXJyZW50ZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBUUToge1xuICAgICAgICAgICAgZm9sZGVyOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfVHJpbWVzdHJhbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIEFZOiB7XG4gICAgICAgICAgICBmb2xkZXI6IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9BbnVhbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIC8vIFB1ZWRlcyBjb250aW51YXIgYVx1MDBGMWFkaWVuZG8gbVx1MDBFMXMgY2Fzb3MgYXF1XHUwMEVEXG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8vIEFzZWdcdTAwRkFyYXRlIGRlIHF1ZSB0aXBvIGVzIHVuYSBwcm9waWVkYWQgdlx1MDBFMWxpZGEgYW50ZXMgZGUgZGVzZXN0cnVjdHVyYXJcblxuICAgICAgICBjb25zdCBhY3RpdmVGaWxlc1dpdGhGcm9udG1hdHRlciA9IFtdO1xuICAgICAgICBsZXQgZmlsZXMsIHRyaW1lc3RyZSA6ICBzdHJpbmc7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHByb3BlcnRpZXNUaXBvW3RpcG9dLmZvbGRlcjtcbiAgICAgICAgc3dpdGNoICh0aXBvKXtcbiAgICAgICAgY2FzZSBcIkFWXCI6XG4gICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIGlmICghcGFyYW1ldHJvKXsgLy8gcGFyYW1ldHJvIGVuIGVzdGUgY2FzbyBlcyBlbCB0cmltZXN0cmUuIFNpbiBwYXJhbWV0cm8gc2UgYnVzY2EgZWwgbm9kb0FyZWFWaWRhXG4gICAgICAgICAgICAgICAgdHJpbWVzdHJlID0gRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoXCJ5eXl5LVFxXCIpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEN1YW5kbyBlbCB0cmltZXN0cmUgc2kgc2UgaW5ncmVzYSBlbiBsYSBmdW5jaVx1MDBGM24sIGVudG9uY2VzIGJ1c2NhIGxhcyBBcmVhc1ZpZGEgZGVsIHRyaW1lc3RyZS5cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgdHJpbWVzdHJlID0gcGFyYW1ldHJvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkuZmlsdGVyKGZpbGUgPT4gXG4gICAgICAgICAgICAgICAgZmlsZS5wYXRoLmluY2x1ZGVzKGZvbGRlcikgJiYgIWZpbGUucGF0aC5pbmNsdWRlcyhcIlBsYW50aWxsYXNcIikgJiYgIWZpbGUucGF0aC5pbmNsdWRlcyhcIkFyY2hpdm9cIikgJiYgZmlsZS5uYW1lLnN0YXJ0c1dpdGgodHJpbWVzdHJlKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpIHtcblxuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGE/LmVzdGFkbyA9PT0gXCJcdUQ4M0RcdURGRTJcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWN0aXZlRmlsZSA9IE9iamVjdC5hc3NpZ24oe30sIG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRmlsZS5maWxlID0gZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRmlsZXNXaXRoRnJvbnRtYXR0ZXIucHVzaChhY3RpdmVGaWxlKTsgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFJXCI6XG4gICAgICAgIGNhc2UgXCJUUVwiOlxuICAgICAgICBjYXNlIFwiQVlcIjpcbiAgICAgICAgICAgIGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5maWx0ZXIoZmlsZSA9PiBcbiAgICAgICAgICAgICAgICBmaWxlLnBhdGguaW5jbHVkZXMoZm9sZGVyKSAmJiAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiUGxhbnRpbGxhc1wiKSAmJiAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiQXJjaGl2b1wiKSk7ICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhPy5lc3RhZG8gPT09IFwiXHVEODNEXHVERkUyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZUZpbGUgPSBPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUZpbGUuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUZpbGVzV2l0aEZyb250bWF0dGVyLnB1c2goYWN0aXZlRmlsZSk7ICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiBcbiAgICAgICAgICAgIGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5maWx0ZXIoZmlsZSA9PiBcbiAgICAgICAgICAgICAgICBmaWxlLnBhdGguaW5jbHVkZXMoZm9sZGVyKSAmJiAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiUGxhbnRpbGxhc1wiKSAmJiAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiQXJjaGl2b1wiKSk7ICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhPy5lc3RhZG8gPT09IFwiXHVEODNEXHVERkUyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZUZpbGUgPSBPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUZpbGUuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUZpbGVzV2l0aEZyb250bWF0dGVyLnB1c2goYWN0aXZlRmlsZSk7ICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlRmlsZXNXaXRoRnJvbnRtYXR0ZXI7XG4gICAgfVxuXG5cbiAgICBhc3luYyBjcmVhckNhcnBldGEoZm9sZGVyUGF0aDogc3RyaW5nKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFZlcmlmaWNhIHNpIGxhIGNhcnBldGEgeWEgZXhpc3RlXG4gICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgY29uc3QgY2FycGV0YUV4aXN0ZW50ZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyUGF0aCk7XG4gICAgICAgICAgICBpZiAoY2FycGV0YUV4aXN0ZW50ZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTGEgY2FycGV0YSAnJHtmb2xkZXJQYXRofScgeWEgZXhpc3RlLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWEgbGEgY2FycGV0YVxuICAgICAgICAgICAgYXdhaXQgYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihmb2xkZXJQYXRoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYXJwZXRhICcke2ZvbGRlclBhdGh9JyBjcmVhZGEgZXhpdG9zYW1lbnRlLmApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFsIGNyZWFyIGxhIGNhcnBldGEgJyR7Zm9sZGVyUGF0aH0nOmAsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gIFxuICAgIC8qIFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBNZXRvZG8gY29uIGVsIGN1YWwgcHVlZG8gZGVzZGUgZWwgbVx1MDBFOXRvZG8gZmlsZU5hbWUgb2J0ZW5lciBsYSBub3RhIFxuICAgIGRlIG9yaWdlbiBkZSBsYSBwbGFudGlsbGEgcXVlIGVzdG95IGNyZWFuZG8sIHBhcmEgY29udGFyIGNvbiB0b2RhIFxuICAgIGxhIGluZm9ybWFjaVx1MDBGM24gcXVlIHJlcXVpZXJvIGVuIGxhIGNyZWFjaVx1MDBGM24uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICovIFxuICAgIGFzeW5jIGdldE9yaWdlbih0eXBlTmFtZSwgaWQpe1xuICAgIGRlYnVnZ2VyO1xuICAgIGxldCBmb2xkZXIgPSB0aGlzLnBsdWdpbi5zZXR0aW5nc1tgZm9sZGVyXyR7dHlwZU5hbWV9YF07XG4gICAgbGV0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5maWx0ZXIoZmlsZSA9PiBcbiAgICAgICAgZmlsZS5wYXRoLmluY2x1ZGVzKGZvbGRlcikgJiYgIWZpbGUucGF0aC5pbmNsdWRlcyhcIlBsYW50aWxsYXNcIikgJiYgIWZpbGUucGF0aC5pbmNsdWRlcyhcIkFyY2hpdm9cIikpO1xuICAgIFxuICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpIHtcblxuICAgICAgICBsZXQgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuXG4gICAgICAgIGlmIChtZXRhZGF0YT8uaWQgPT09ICtpZCkgeyAvLyAraWQgc2UgaGFjZSBwYXJhIGNvbnZlcnRpcmxvIGVuIG5cdTAwRkFtZXJvLlxuICAgICAgICAgICAgbGV0IGFjdGl2ZUZpbGUgPSBPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSk7XG4gICAgICAgICAgICBhY3RpdmVGaWxlLmZpbGUgPSBmaWxlO1xuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZUZpbGU7ICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuICAiLCAiZXhwb3J0IGNsYXNzIGFkZE9uc0FQSSB7XG4gICAgY29uc3RydWN0b3IocGx1Z2luKSB7XG4gICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG4gIFxuICAgIGNyZWFyUHJldk5leHQocGFnaW5hcywgcGFnSW5kaWNlLCBkdikge1xuICAgICAgICBsZXQgcGFnaW5hID0gZHYuY3VycmVudCgpO1xuICAgICAgICBsZXQgaW5kaWNlO1xuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IHBhZ2luYXMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIGlmIChwYWdpbmFzW2FdLmZpbGUubmFtZSA9PSBwYWdpbmEuZmlsZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBsZXQgbGlua3MgPSBbXTtcbiAgICAgICAgaWYgKGluZGljZSA9PSAwICYmIHBhZ2luYXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxpbmtzWzBdID0gXCJcIjtcbiAgICAgICAgICAgIGxpbmtzWzFdID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRpY2UgPT0gMCkge1xuICAgICAgICAgICAgbGlua3NbMF0gPSBcIlwiO1xuICAgICAgICAgICAgbGlua3NbMV0gPSBcIlx1MjdBMVx1RkUwRiBcIiArIGR2LmZ1bmMubGluayhwYWdpbmFzW2luZGljZSArIDFdLmZpbGUucGF0aCwgdGhpcy5kZXRlcm1pbmFyVGV4dG9FbmxhY2UocGFnaW5hc1tpbmRpY2UgKyAxXSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGljZSA9PSAocGFnaW5hcy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgbGlua3NbMF0gPSBkdi5mdW5jLmxpbmsocGFnaW5hc1tpbmRpY2UgLSAxXS5maWxlLnBhdGgsIHRoaXMuZGV0ZXJtaW5hclRleHRvRW5sYWNlKHBhZ2luYXNbaW5kaWNlIC0gMV0pKSArIFwiIFx1MkIwNVx1RkUwRlwiO1xuICAgICAgICAgICAgbGlua3NbMV0gPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlua3NbMF0gPSBkdi5mdW5jLmxpbmsocGFnaW5hc1tpbmRpY2UgLSAxXS5maWxlLnBhdGgsIHRoaXMuZGV0ZXJtaW5hclRleHRvRW5sYWNlKHBhZ2luYXNbaW5kaWNlIC0gMV0pKSArIFwiIFx1MkIwNVx1RkUwRlwiO1xuICAgICAgICAgICAgbGlua3NbMV0gPSBcIlx1MjdBMVx1RkUwRiBcIiArIGR2LmZ1bmMubGluayhwYWdpbmFzW2luZGljZSArIDFdLmZpbGUucGF0aCwgdGhpcy5kZXRlcm1pbmFyVGV4dG9FbmxhY2UocGFnaW5hc1tpbmRpY2UgKyAxXSkpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGR2LnBhcmFncmFwaChsaW5rc1swXSArIFwiID09XCIgKyBkdi5mdW5jLmxpbmsocGFnSW5kaWNlLmZpbGUucGF0aCwgcGFnSW5kaWNlLnRpdHVsbyB8fCBwYWdJbmRpY2UuZmlsZS5uYW1lKSArIFwiPT0gXCIgKyBsaW5rc1sxXSk7XG4gICAgfVxuXG4gICAgZGV0ZXJtaW5hclRleHRvRW5sYWNlKHBhZ2luYSkge1xuICAgICAgICBpZiAocGFnaW5hLnRpdHVsbykge1xuICAgICAgICAgICAgcmV0dXJuIHBhZ2luYS50aXR1bG87XG4gICAgICAgIH0gZWxzZSBpZiAocGFnaW5hLmFsaWFzZXMgJiYgcGFnaW5hLmFsaWFzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhZ2luYS5hbGlhc2VzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhZ2luYS5maWxlLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gIFxuXG5cbiAgfSIsICIvL2ltcG9ydCB7dXRpbHNBUEl9IGZyb20gJy4vdXRpbHNBUEknXG5cbmltcG9ydCB7IE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgbW9kYWxfY2FtYmlvSEYgfSBmcm9tIFwiLi4vLi4vbW9kdWxvUmVnaXN0cm9UaWVtcG8vbW9kYWxzL2NhbWJpb0hGXCI7XG5cbmV4cG9ydCBjbGFzcyBZQU1MVXBkYXRlckFQSSB7XG4gICAgLy9wcml2YXRlIHV0aWxzQXBpOiB1dGlsc0FQSTtcbiAgICBwcml2YXRlIHBsdWdpbjogUGx1Z2luO1xuICAgIHByaXZhdGUgaW5mb1N1YnNpc3RlbWE6IG9iamVjdDsgLy8gQXN1bWllbmRvIHF1ZSBlcyB1biBzdHJpbmdcbiAgICBwcml2YXRlIHRwOiBvYmplY3Q7XG4gICAgcHJpdmF0ZSBub3RhOiBvYmplY3Q7XG4gICAgcHJpdmF0ZSBwYXRoQ2FtcG9zOiBzdHJpbmc7IFxuICAgIGluZm9Ob3RhOiB7fTtcblxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogUGx1Z2luKSB7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgICAgICAvLyBJbmljaWFsaXphIGZvbGRlciBlIGluZGljZSBjb24gdmFsb3JlcyBwcmVkZXRlcm1pbmFkb3MgbyBsXHUwMEYzZ2ljYSBlc3BlY1x1MDBFRGZpY2EuXG4gICAgICAgIHRoaXMuaW5mb05vdGEgPSB7fTtcbiAgICAgICAgdGhpcy5ub3RhID0ge307XG4gICAgICAgIHRoaXMudHAgPSB0aGlzLmdldFRwKCk7XG4gICAgICAgIHRoaXMucGF0aENhbXBvcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZpbGVfY2FtcG9zQ2VudHJhbCArIFwiLm1kXCI7XG4gICAgfVxuICAgIFxuXG4gICAgYXN5bmMgYWN0dWFsaXphck5vdGEoaW5mb05vdGE6IGFueSwgY2FtcG9zOiBhbnkpIHtcbiAgICAgICAgXG4gICAgICAgIGxldCBub3RhID0ge307IC8vIEluaWNpYWxpemEgZWwgb2JqZXRvIG5vdGEuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5pbmZvTm90YSwgaW5mb05vdGEpOyBcbiAgICAgICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNhbXBvIG9mIGNhbXBvcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBEaXZpZGUgZWwgY2FtcG8gZW4gZnVuY2lcdTAwRjNuIGRlbCBzXHUwMEVEbWJvbG8gXCJfXCJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGVzID0gY2FtcG8uc3BsaXQoJ18nKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbXBvTmFtZSwgZnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldHJvID0gbnVsbDsgXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpIGhheSB1biBzXHUwMEVEbWJvbG8gXCJfXCIsIHVzYSBsYSBwYXJ0ZSBhbnRlcyBkZSBcIl9cIiBwYXJhIGVsIG5vbWJyZSBkZSBsYSBmdW5jaVx1MDBGM24sXG4gICAgICAgICAgICAgICAgICAgIC8vIHkgbGEgcGFydGUgZGVzcHVcdTAwRTlzIGRlIFwiX1wiIGNvbW8gcGFyXHUwMEUxbWV0cm8uXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lID0gYGdldCR7cGFydGVzWzBdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcGFydGVzWzBdLnNsaWNlKDEpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW1wb05hbWUgPSBwYXJ0ZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0cm8gPSBwYXJ0ZXNbMV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW1wb05hbWUgPSBwYXJ0ZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBgZ2V0JHtjYW1wby5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbXBvLnNsaWNlKDEpfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSAgYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHRoaXMuaW5mb05vdGEuZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbG9yQWN0dWFsQ2FtcG8gPSBtZXRhZGF0YVtjYW1wb05hbWVdIHx8IFwiU2luIGRlZmluaXJcIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZpY2Egc2kgZXhpc3RlIHVuYSBmdW5jaVx1MDBGM24gY29uIGVzZSBub21icmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tmdW5jdGlvbk5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMbGFtYSBhIGxhIGZ1bmNpXHUwMEYzbiBkZSBtYW5lcmEgZGluXHUwMEUxbWljYS4gU2kgZXhpc3RlIHVuIHBhclx1MDBFMW1ldHJvLCBwXHUwMEUxc2FsbyBhIGxhIGZ1bmNpXHUwMEYzbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0cm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RhW2NhbXBvTmFtZV0gPSBhd2FpdCB0aGlzW2Z1bmN0aW9uTmFtZV0ocGFyYW1ldHJvLHZhbG9yQWN0dWFsQ2FtcG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RhW2NhbXBvTmFtZV0gPSBhd2FpdCB0aGlzW2Z1bmN0aW9uTmFtZV0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYExhIGZ1bmNpXHUwMEYzbiAke2Z1bmN0aW9uTmFtZX0gbm8gZXN0XHUwMEUxIGRlZmluaWRhLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFuZWphIGVsIGNhc28gZW4gcXVlIGxhIGZ1bmNpXHUwMEYzbiBubyBlc3RcdTAwRTkgZGVmaW5pZGEuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsaXphciBsYSBub3RhXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5vdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWplY3V0YSB0dSBjXHUwMEYzZGlnbyBhcXVcdTAwRUQgc2kgZWwgb2JqZXRvIGBub3RhYCB0aWVuZSBtXHUwMEUxcyBkZSB1bmEgcHJvcGllZGFkXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlWUFNTEZpZWxkcyhub3RhLCBpbmZvTm90YS5maWxlLnBhdGgpXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIC8vTm8gc2UgZW5jb250cmFyb24gY2FtcG9zIHBhcmEgbW9kaWZpY2FyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFxdVx1MDBFRCBpclx1MDBFRGEgZWwgY1x1MDBGM2RpZ28gcGFyYSBwcm9jZXNhciBlbCBvYmpldG8gbm90YSwgY29tbyBndWFyZGFyIGVuIHVuIGFyY2hpdm8gZGVudHJvIGRlICdmb2xkZXInLlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gc2UgcHVkbyBjcmVhciBlbCBvYmpldG8gZGUgcmVnaXN0cm8uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gc2UgcHVkbyBjcmVhciBlbCBvYmpldG8gZGUgcmVnaXN0cm8uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm90YTsgLy8gUmV0b3JuYSBlbCBvYmpldG8gbm90YSBjb24gdG9kYXMgbGFzIHByb3BpZWRhZGVzIGFncmVnYWRhcy5cbiAgICB9XG4gICAgXG4gICAgYXN5bmMgYXJjaGl2YXJOb3RhKGluZm9Ob3RhOiBhbnksIGNhbXBvczogYW55KSB7XG4gICAgICAgIFxuICAgICAgICBsZXQgbm90YSA9IHt9OyAvLyBJbmljaWFsaXphIGVsIG9iamV0byBub3RhLlxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuaW5mb05vdGEsIGluZm9Ob3RhKTsgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNhbXBvIG9mIGNhbXBvcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2EgZWwgbm9tYnJlIGRlbCBjYW1wbyBwYXJhIGNvbnN0cnVpciBlbCBub21icmUgZGUgbGEgZnVuY2lcdTAwRjNuIChwLiBlai4sIFwiZ2V0SWRcIilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYGdldCR7Y2FtcG8uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1wby5zbGljZSgxKX1gO1xuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZmljYSBzaSBleGlzdGUgdW5hIGZ1bmNpXHUwMEYzbiBjb24gZXNlIG5vbWJyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2Z1bmN0aW9uTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExsYW1hIGEgbGEgZnVuY2lcdTAwRjNuIGRlIG1hbmVyYSBkaW5cdTAwRTFtaWNhIHkgYXNpZ25hIGVsIHJlc3VsdGFkbyBhbCBjYW1wbyBjb3JyZXNwb25kaWVudGUgZGUgbGEgbm90YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGFbY2FtcG9dID0gYXdhaXQgdGhpc1tmdW5jdGlvbk5hbWVdKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBMYSBmdW5jaVx1MDBGM24gJHtmdW5jdGlvbk5hbWV9IG5vIGVzdFx1MDBFMSBkZWZpbmlkYS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hbmVqYSBlbCBjYXNvIGVuIHF1ZSBsYSBmdW5jaVx1MDBGM24gbm8gZXN0XHUwMEU5IGRlZmluaWRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9yIGVqZW1wbG8sIHBvZHJcdTAwRURhcyBhc2lnbmFyIHVuIHZhbG9yIHBvciBkZWZlY3RvIGEgbm90YVtjYW1wb10gbyBzaW1wbGVtZW50ZSBjb250aW51YXIuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsaXphciBsYSBub3RhXG4gICAgICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgICAgICBub3RhLmVzdGFkbyA9IFwiXHVEODNEXHVERDM1XCI7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5vdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWplY3V0YSB0dSBjXHUwMEYzZGlnbyBhcXVcdTAwRUQgc2kgZWwgb2JqZXRvIGBub3RhYCB0aWVuZSBtXHUwMEUxcyBkZSB1bmEgcHJvcGllZGFkXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlWUFNTEZpZWxkcyhub3RhLCBpbmZvTm90YS5maWxlLnBhdGgpXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIC8vTm8gc2UgZW5jb250cmFyb24gY2FtcG9zIHBhcmEgbW9kaWZpY2FyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFxdVx1MDBFRCBpclx1MDBFRGEgZWwgY1x1MDBGM2RpZ28gcGFyYSBwcm9jZXNhciBlbCBvYmpldG8gbm90YSwgY29tbyBndWFyZGFyIGVuIHVuIGFyY2hpdm8gZGVudHJvIGRlICdmb2xkZXInLlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gc2UgcHVkbyBjcmVhciBlbCBvYmpldG8gZGUgcmVnaXN0cm8uXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gc2UgcHVkbyBjcmVhciBlbCBvYmpldG8gZGUgcmVnaXN0cm8uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm90YTsgLy8gUmV0b3JuYSBlbCBvYmpldG8gbm90YSBjb24gdG9kYXMgbGFzIHByb3BpZWRhZGVzIGFncmVnYWRhcy5cbiAgICB9XG5cblxuICAgIGFzeW5jIHVwZGF0ZVlBTUxGaWVsZHMobm90YSwgcnV0YSkge1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHJ1dGEpO1xuICAgICAgICAgICAgYXdhaXQgYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCBmcm9udG1hdHRlciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSXRlcmFyIHNvYnJlIGNhZGEgcHJvcGllZGFkIGRlbCBvYmpldG8gJ25vdGEnXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYW1wbyBpbiBub3RhKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbnRtYXR0ZXIuaGFzT3duUHJvcGVydHkoY2FtcG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY3R1YWxpemFyIGVsIGNhbXBvIGVuIGVsIGZyb250bWF0dGVyIGNvbiBlbCB2YWxvciBjb3JyZXNwb25kaWVudGVcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbnRtYXR0ZXJbY2FtcG9dID0gbm90YVtjYW1wb107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRnJvbnRtYXR0ZXIgYWN0dWFsaXphZG8gY29uIFx1MDBFOXhpdG9cIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGFjdHVhbGl6YXIgZWwgZnJvbnRtYXR0ZXJcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcblxuICAgIGdldFRwKCl7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMucGx1Z2luIHx8ICF0aGlzLnBsdWdpbi5hcHAucGx1Z2lucy5lbmFibGVkUGx1Z2lucy5oYXMoJ3RlbXBsYXRlci1vYnNpZGlhbicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFbCBwbHVnaW4gVGVtcGxhdGVyIG5vIGVzdFx1MDBFMSBoYWJpbGl0YWRvLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vICBGb3JtYSBkZSBhY2NlZGVyIGFsIG9iamV0byB0cCBub3JtYWwgcXVlIGhlIHVzYWRvIGRlc2RlIERWSlMgY3VhbmRvIGN1cnJlbnQgRnVuY3Rpb25zIGVzdGEgY2FyZ2Fkby5cbiAgICAgICAgLy9jb25zdCB0ZW1wbGF0ZXJQbHVnaW4gPSB0aGlzLmFwcC5wbHVnaW5zLnBsdWdpbnNbJ3RlbXBsYXRlci1vYnNpZGlhbiddO1xuICAgICAgICAvL2NvbnN0IHRwID0gdGVtcGxhdGVyUGx1Z2luLnRlbXBsYXRlci5jdXJyZW50X2Z1bmN0aW9uc19vYmplY3Q7XG4gICAgICAgIC8vIC0+IHZlcnNpb24gcXVlIGZhbGxhIHNpIG5vIGVzdGEgYXJyaWJhIGVsIHBsdWdpbiBwb3JxdWUgaGFjZSBnZXQgZGVsIHBsdWdpbiBkaXJlY3RvLiBjb25zdCB0ZW1wbGF0ZXJQbHVnaW4gPSB0aGlzLmFwcC5wbHVnaW5zLmdldFBsdWdpbigndGVtcGxhdGVyLW9ic2lkaWFuJyk7XG4gICAgICAgIFxuICAgICAgICBsZXQgdHBHZW4gPSB0aGlzLnBsdWdpbi5hcHAucGx1Z2lucy5wbHVnaW5zW1widGVtcGxhdGVyLW9ic2lkaWFuXCJdLnRlbXBsYXRlcjtcbiAgICAgICAgdHBHZW4gPSB0cEdlbi5mdW5jdGlvbnNfZ2VuZXJhdG9yLmludGVybmFsX2Z1bmN0aW9ucy5tb2R1bGVzX2FycmF5O1xuICAgICAgICBsZXQgdHAgPSB7fVxuICAgICAgICAvLyBnZXQgYW4gaW5zdGFuY2Ugb2YgdGhlIGRhdGUgbW9kdWxlXG4gICAgICAgIHRwLnN5c3RlbSA9IHRwR2VuLmZpbmQobSA9PiBtLm5hbWUgPT0gXCJzeXN0ZW1cIik7XG5cbiAgICAgICAgaWYgKCF0cC5zeXN0ZW0pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIHNlIHB1ZG8gYWNjZWRlciBhbCBvYmpldG8gZGUgZnVuY2lvbmVzIGFjdHVhbGVzIGRlIFRlbXBsYXRlci5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ3RwIGVuIFlBTUxVcGRhdGVyQVBJIHNlIGhhIGNhcmdhZG8gc2F0aXNmYWN0b3JpYW1lbnRlJyk7XG4gICAgcmV0dXJuIHRwO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEZlY2hhKGZsYWcsIGFjdHVhbCkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0ZWFyRmVjaGEobmV3IERhdGUoKSk7XG4gICAgfVxuXG4gICAgZm9ybWF0ZWFyRmVjaGEoZmVjaGE6IERhdGUpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBmZWNoYS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgIGNvbnN0IGZlY2hhTG9jYWwgPSBuZXcgRGF0ZShmZWNoYS5nZXRUaW1lKCkgLSBvZmZzZXQpO1xuICAgICAgICBjb25zdCBmZWNoYUZvcm1hdG8gPSBmZWNoYUxvY2FsLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICAgICAgY29uc3QgZGlhcyA9IFsnRG9taW5nbycsICdMdW5lcycsICdNYXJ0ZXMnLCAnTWlcdTAwRTlyY29sZXMnLCAnSnVldmVzJywgJ1ZpZXJuZXMnLCAnU1x1MDBFMWJhZG8nXTtcbiAgICAgICAgY29uc3QgZGlhU2VtYW5hID0gZGlhc1tmZWNoYS5nZXREYXkoKV07XG4gICAgICAgIGNvbnN0IGhvcmFGb3JtYXRvID0gZmVjaGEudG9UaW1lU3RyaW5nKCkuc3BsaXQoJyAnKVswXS5zdWJzdHJpbmcoMCwgNSk7XG4gICAgICAgIHJldHVybiBgJHtmZWNoYUZvcm1hdG99ICR7ZGlhU2VtYW5hfSAke2hvcmFGb3JtYXRvfWA7XG4gICAgfVxuXG5cbiAgICBhc3luYyBnZXRIb3JhRmluYWwocGFyYW1ldHJvLCBhY3R1YWwpe1xuICAgICAgICAvLyBFc3RhIGZ1bmNpXHUwMEYzbiBzb2xvIHJlY2liZSBlbiBlbCBwYXJcdTAwRTFtZXRybyBsYSBob3JhIGZpbmFsIG51ZXZhLCBwYXJhIGFjdHVhbGl6YXIgZWwgdmFsb3IuXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBpZiAocGFyYW1ldHJvID09PSB1bmRlZmluZWQpe1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRlYXJGZWNoYShuZXcgRGF0ZSgpKTtcbiAgICAgICAgfWVsc2V7IFxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldFRpZW1wb1RyYWJhamFkbyhwYXJhbWV0cm8sIGFjdHVhbCl7XG4gICAgICAgIGRlYnVnZ2VyXG4gICAgICAgIFxuICAgICAgICBsZXQgaG9yYUluaWNpb1N0ciA9IHRoaXMuaW5mb05vdGEuaG9yYUluaWNpbztcbiAgICAgICAgbGV0IGNpZXJyZTtcbiAgICAgICAgLy8gU3Vwb25pZW5kbyBxdWUgZWwgZm9ybWF0byBlcyBcIllZWVktTU0tREQgZGRkZCBISDptbVwiIHkgcXVpZXJlcyBjb252ZXJ0aXJsbyBhIHVuIGZvcm1hdG8gcmVjb25vY2lkbyBwb3IgRGF0ZVxuICAgICAgICAvLyBQcmltZXJvLCBlbGltaW5hIGxhIHBhcnRlIGRlbCBkXHUwMEVEYSBkZSBsYSBzZW1hbmEsIHlhIHF1ZSBEYXRlKCkgbm8gbGEgbmVjZXNpdGFcbiAgICAgICAgbGV0IFtmZWNoYSwgLCBob3JhXSA9IGhvcmFJbmljaW9TdHIuc3BsaXQoJyAnKTtcbiAgICAgICAgbGV0IGZlY2hhSG9yYUlTTyA9IGAke2ZlY2hhfVQke2hvcmF9YDtcbiAgICAgICAgLy8gQ3JlYXIgb2JqZXRvcyBEYXRlXG4gICAgICAgIGxldCBob3JhSW5pY2lvID0gbmV3IERhdGUoZmVjaGFIb3JhSVNPKTtcbiAgICAgICAgaWYgKHBhcmFtZXRybyA9PSB1bmRlZmluZWQpeyAgICBcbiAgICAgICAgY2llcnJlID0gbmV3IERhdGUoKTtcblxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGxldCBbZmVjaGFDaWVycmUsICxob3JhQ2llcnJlXSA9IHBhcmFtZXRyby5zcGxpdCgnICcpOyAgIFxuICAgICAgICAgICAgbGV0IGZlY2hhSG9yYUNpZXJyZUlTTyA9IGAke2ZlY2hhQ2llcnJlfVQke2hvcmFDaWVycmV9YDtcbiAgICAgICAgICAgIGNpZXJyZSA9IG5ldyBEYXRlKGZlY2hhSG9yYUNpZXJyZUlTTyk7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhciBsYSBkaWZlcmVuY2lhIGVuIG1pbGlzZWd1bmRvc1xuICAgICAgICBsZXQgZGlmZXJlbmNpYUVuTWlsaXNlZ3VuZG9zID0gY2llcnJlIC0gaG9yYUluaWNpbztcbiAgICAgICAgcmV0dXJuIGRpZmVyZW5jaWFFbk1pbGlzZWd1bmRvcztcbiAgICB9XG5cblxuICAgIGFzeW5jIGdldFNlY0lkKGZsYWcsIGFjdHVhbCl7XG5cbiAgICB9XG4gICAgXG4gICAgYXN5bmMgZ2V0VGl0dWxvKGZsYWcsIGFjdHVhbCl7XG4gICAgICAgIGxldCB0aXR1bG8gPSBhd2FpdCB0aGlzLnRwLnN5c3RlbS5wcm9tcHQoYFRpdHVsbyBkZSBlc3RlKGEpICR7dGhpcy5pbmZvU3Vic2lzdGVtYS5uYW1lfWAsIGAke3RoaXMuaW5mb1N1YnNpc3RlbWEubmFtZX0gLSAke3RoaXMubm90YS5pZH1gLCB0cnVlKVxuXHQgICAgLy8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgICAgIGlmICh0aXR1bG8gPT09IG51bGwpIHtcbiAgICAgICAgbmV3IE5vdGljZShcIkNyZWFjaVx1MDBGM24gZGUgbm90YSBjYW5jZWxhZGEgcG9yIGVsIHVzdWFyaW8uXCIpO1xuICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cblx0ICAgIH1cbiAgICAgICAgdGhpcy5ub3RhLnRpdHVsbyA9IHRpdHVsbztcbiAgICAgICAgcmV0dXJuIHRpdHVsbztcbiAgICB9XG5cbiAgICBhc3luYyBnZXREZXNjcmlwY2lvbihmbGFnLCBhY3R1YWwpe1xuICAgICAgICBsZXQgcHJvbXB0ID0gdGhpcy50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJwcm9tcHRcIik7XG4gICAgICAgIGxldCBkZXNjcmlwY2lvbjtcbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiUmVnaXN0cm9UaWVtcG9cIjpcbiAgICAgICAgICAgICAgICAgZGVzY3JpcGNpb24gPSBhd2FpdCBwcm9tcHQoXCJcdTAwQkZEZXRhbGxlIGRlbCBSZWdpc3RybyBUaWVtcG86XCIsIGFjdHVhbCwgZmFsc2UsIHRydWUgKSAgIFxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGVzY3JpcGNpb24gPSBhd2FpdCBwcm9tcHQoXCJcdTAwQkZRdWllcmVzIGFncmVnYXIgdW5hIGRlc2NyaXBjaVx1MDBGM24/XCIsIFwiIFwiICsgYEVzdGEgbm90YSBlcyBzb2JyZSAke3RoaXMubm90YS50aXR1bG99YCwgZmFsc2UsIHRydWUgKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IFxuXHQgICAgLy8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgICAgIGlmIChkZXNjcmlwY2lvbiA9PT0gbnVsbCkge1xuICAgICAgICBuZXcgTm90aWNlKFwiQ3JlYWNpXHUwMEYzbiBkZSBub3RhIGNhbmNlbGFkYSBwb3IgZWwgdXN1YXJpby5cIik7XG4gICAgICAgIHJldHVybjsgLy8gVGVybWluYSBsYSBlamVjdWNpXHUwMEYzbiBkZSBsYSBmdW5jaVx1MDBGM24gYXF1XHUwMEVELlxuXHQgICAgfVxuICAgICAgICB0aGlzLm5vdGEuZGVzY3JpcGNpb24gPSBkZXNjcmlwY2lvbjtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXBjaW9uO1xuICAgIH1cblxuICAgIGFzeW5jIGdldEFsaWFzZXMoZmxhZywgYWN0dWFsKXtcbiAgICAgICAgdGhpcy5ub3RhLmFsaWFzZXMgPSBbXTsgICAgICBcbiAgICAgICAgc3dpdGNoKHRoaXMuaW5mb1N1YnNpc3RlbWEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkF4XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFsaWFzZXMucHVzaChgJHt0aGlzLm5vdGEudGl0dWxvfWApXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RhLmFsaWFzZXMucHVzaChgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLnR5cGV9IC0gJHt0aGlzLm5vdGEudGl0dWxvfWApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQVZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBSVwiOlxuICAgICAgICAgICAgICAgIC8vIDAgLT4gTm9tYnJlLCAxIC0+IHR5cGUgKyBOb21icmVcbiAgICAgICAgICAgICAgICBicmVhazsgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90YS5hbGlhc2VzO1xuICAgICAgIFxuICAgIH1cblxuICAgIGFzeW5jIGdldEFzdW50byhmbGFnLCBhY3R1YWwpe1xuICAgICAgICBsZXQgc2lBc3VudG8sIG5vbWJyZTsgXG4gICAgICAgIGxldCBhY3Rpdm8gPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKGFjdGl2byAhPSBudWxsKXsgXG4gICAgICAgICAgICBub21icmUgPSBhY3Rpdm8uYmFzZW5hbWU7XG4gICAgICAgICAgICBjb25zdCBub3RhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGFjdGl2byk7IFxuICAgICAgICAgICAgc2lBc3VudG8gPSBhd2FpdCB0aGlzLnRwLnN5c3RlbS5zdWdnZXN0ZXIoW1wiU2lcIixcIk5vXCJdLFt0cnVlLCBmYWxzZV0sIHRydWUsIG5vbWJyZSArIFwiIGVzIG9yaWdlbiBkZSBcIiArIHRoaXMubm90YS50aXR1bG8gKyBcIj9cIilcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHNpQXN1bnRvID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9tYnJlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5ub3RhLmFzdW50byA9IHt9O1xuICAgICAgICAgICAgdGhpcy5ub3RhLmFzdW50by5zaUFzdW50byA9IHNpQXN1bnRvO1xuICAgICAgICAgICAgdGhpcy5ub3RhLmFzdW50by5ub21icmUgPSBub21icmU7ICAgIFxuICAgICAgICByZXR1cm4ge3NpQXN1bnRvLCBub21icmV9XG4gICAgfVxuXG5cbiAgICBhc3luYyBnZXRDbGFzaWZpY2FjaW9uKGZsYWcsIGFjdHVhbCl7XG4gICAgICAgIGxldCBjbGFzaWZpY2FjaW9uLCB0YWdDbGFzaWZpY2FjaW9uLCBjbGFzaWZpY2FjaW9uQVgsIHRhZ3NDbGFzaWZpY2FjaW9uQVg7XG4gICAgICAgIGxldCBudWV2YUNsYXNpZmljYWNpb24gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5wYXRoQ2FtcG9zKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcbiAgICAgICAgaWYgKGZyb250bWF0dGVyKSB7XG4gICAgICAgICAgICBjbGFzaWZpY2FjaW9uQVggPSBmcm9udG1hdHRlci50aXR1bG9DbGFzaWZpY2FjaW9uQVggfHwgW107XG4gICAgICAgICAgICB0YWdzQ2xhc2lmaWNhY2lvbkFYID0gZnJvbnRtYXR0ZXIudGFnc0NsYXNpZmljYWNpb25BWCB8fCBbXTtcbiAgICAgICAgICAgIHRhZ0NsYXNpZmljYWNpb24gPSBhd2FpdCB0aGlzLnRwLnN5c3RlbS5zdWdnZXN0ZXIoY2xhc2lmaWNhY2lvbkFYLCB0YWdzQ2xhc2lmaWNhY2lvbkFYLCBmYWxzZSwgXCJcdTAwQkZDbGFzaWZpY2FyXHUwMEVEYXMgZXN0YSBub3RhIGJham8gYWxndW5hIGRlIGxhcyBzaWd1aWVudGVzIGNhdGVnb3JcdTAwRURhcz9cIilcbiAgICAgICAgICAgIC8vIFZlcmlmaWNhciBzaSBlbCB1c3VhcmlvIHByZXNpb25cdTAwRjMgRXNjLiBcbiAgICAgICAgICAgIGlmICh0YWdDbGFzaWZpY2FjaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkNyZWFjaVx1MDBGM24gZGUgbm90YSBjYW5jZWxhZGEgcG9yIGVsIHVzdWFyaW8uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVGVybWluYSBsYSBlamVjdWNpXHUwMEYzbiBkZSBsYSBmdW5jaVx1MDBGM24gYXF1XHUwMEVELlxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdDbGFzaWZpY2FjaW9uPT1cIk51ZXZvXCIpe1xuICAgICAgICAgICAgICAgIGNsYXNpZmljYWNpb24gPSBhd2FpdCB0aGlzLnRwLnN5c3RlbS5wcm9tcHQoXCJcdTAwQkZDdWFsIGVzIGVsIG5vbWJyZSBkZSBsYSBudWV2YSBjbGFzaWZpY2FjaVx1MDBGM24gcXVlIHZhcyBhIGluZ3Jlc2FyP1wiLCBcIk1pQ2xhc2lmaWNhY2lcdTAwRjNuXCIsIHRydWUpXG4gICAgICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGVsIHVzdWFyaW8gcHJlc2lvblx1MDBGMyBFc2MuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzaWZpY2FjaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiQ3JlYWNpXHUwMEYzbiBkZSBub3RhIGNhbmNlbGFkYSBwb3IgZWwgdXN1YXJpby5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhZ0NsYXNpZmljYWNpb24gPSBhd2FpdCB0aGlzLnRwLnN5c3RlbS5wcm9tcHQoXCJcdTAwQkZDdWFsIGVzIGVsIHRhZyBxdWUgdXRpbGl6YXJhcyBwYXJhIFwiICsgY2xhc2lmaWNhY2lvbiArIFwiPy4gTm8gdXRpbGljZXMgZXNwYWNpb3MgZW4gbGEgZGVmaW5pY2lcdTAwRjNuIGRlbCB0YWcuXCIsIFwibnVldm9UYWdcIiwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAvLyBWZXJpZmljYXIgc2kgZWwgdXN1YXJpbyBwcmVzaW9uXHUwMEYzIEVzYy5cbiAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc2lmaWNhY2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiQ3JlYWNpXHUwMEYzbiBkZSBub3RhIGNhbmNlbGFkYSBwb3IgZWwgdXN1YXJpby5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVGVybWluYSBsYSBlamVjdWNpXHUwMEYzbiBkZSBsYSBmdW5jaVx1MDBGM24gYXF1XHUwMEVELlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudWV2YUNsYXNpZmljYWNpb24gPSB0cnVlO1xuICAgICAgICAgICAgfWVsc2UgaWYodGFnQ2xhc2lmaWNhY2lvbj09XCJOaW5ndW5hXCIpe1xuICAgICAgICAgICAgICAgIHRhZ0NsYXNpZmljYWNpb24gPSBcIlwiXG4gICAgICAgICAgICAgICAgY2xhc2lmaWNhY2lvbiA9IFwiXCJcdFxuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpbmRpY2UgPSB0YWdzQ2xhc2lmaWNhY2lvbkFYLmluZGV4T2YodGFnQ2xhc2lmaWNhY2lvbilcbiAgICAgICAgICAgICAgICBjbGFzaWZpY2FjaW9uID0gY2xhc2lmaWNhY2lvbkFYW2luZGljZV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudWV2YUNsYXNpZmljYWNpb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCBmcm9udG1hdHRlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzdW1pZW5kbyBxdWUgJ2FjdHNUZW1hcycgZXMgZWwgY2FtcG8gYSBtb2RpZmljYXJcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q2xhc2lmaWNhY2lvbiA9IFsuLi5jbGFzaWZpY2FjaW9uQVgsIGNsYXNpZmljYWNpb25dXG4gICAgICAgICAgICAgICAgbGV0IG5ld1RhZ0NsYXNpZmljYWNpb24gPSBbLi4udGFnc0NsYXNpZmljYWNpb25BWCwgdGFnQ2xhc2lmaWNhY2lvbl1cbiAgICAgICAgICAgICAgICBmcm9udG1hdHRlci50aXR1bG9DbGFzaWZpY2FjaW9uQVggPSBuZXdDbGFzaWZpY2FjaW9uO1xuICAgICAgICAgICAgICAgIGZyb250bWF0dGVyLnRhZ3NDbGFzaWZpY2FjaW9uQVggPSBuZXdUYWdDbGFzaWZpY2FjaW9uO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRnJvbnRtYXR0ZXIgYWN0dWFsaXphZG8gY29uIFx1MDBFOXhpdG9cIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgYWN0dWFsaXphciBlbCBmcm9udG1hdHRlclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICBpZiAodGFnQ2xhc2lmaWNhY2lvbiAhPSBcIlwiKXtcbiAgICAgICAgICAgIHRhZ0NsYXNpZmljYWNpb24gPSBcImNsL1wiICsgdGFnQ2xhc2lmaWNhY2lvbiBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubm90YS5jbGFzaWZpY2FjaW9uQVggPSBjbGFzaWZpY2FjaW9uO1xuICAgICAgICAgICAgdGhpcy5ub3RhLnRhZ0NsYXNpZmljYWNpb25BWCA9IHRhZ0NsYXNpZmljYWNpb247XG4gICAgICAgICAgICByZXR1cm4ge2NsYXNlOiBjbGFzaWZpY2FjaW9uLCB0YWc6IHRhZ0NsYXNpZmljYWNpb259O1xuICAgIH1cbiAgICAvLyAtPlxuXG4gICAgYXN5bmMgZ2V0RXN0YWRvKHBhcmFtZXRybywgYWN0dWFsKXtcbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIGxldCBjYW1wbztcbiAgICAgICAgaWYgKHBhcmFtZXRybyA9PSB1bmRlZmluZWQpe1xuICAgICAgICBsZXQgc3VnZ2VzdGVyID0gdGhpcy50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG5cdCAgICBjYW1wbyA9IGF3YWl0IHN1Z2dlc3RlcihbXCJcdUQ4M0RcdUREMzUgLT4gQ29tcGxldGFkbyAtIEluZm9ybWFjaVx1MDBGM25cIiwgXCJcdUQ4M0RcdURGRTIgLT4gRmluYWxpemFkb1wiLFwiXHVEODNEXHVERkUxIC0+IEVuIGVqZWN1Y2lcdTAwRjNuXCIsIFwiXHVEODNEXHVERDM0IC0+IERldGVuaWRvXCJdLFtcIlx1RDgzRFx1REQzNVwiLCBcIlx1RDgzRFx1REZFMlwiLFwiXHVEODNEXHVERkUxXCIsIFwiXHVEODNEXHVERDM0XCJdLCBmYWxzZSwgXCJTZWxlY2Npb25lIGVsIG51ZXZvIGVzdGFkbzpcIik7XG4gICAgICAgIC8vIFZlcmlmaWNhciBzaSBlbCB1c3VhcmlvIHByZXNpb25cdTAwRjMgRXNjLlxuICAgICAgICBpZiAoY2FtcG8gPT09IG51bGwpIHtcbiAgICAgICAgbmV3IE5vdGljZShcIk1vZGlmaWNhY2lcdTAwRjNuIGRlIG5vdGEgY2FuY2VsYWRhIHBvciBlbCB1c3VhcmlvLlwiKTtcbiAgICAgICAgcmV0dXJuOyAvLyBUZXJtaW5hIGxhIGVqZWN1Y2lcdTAwRjNuIGRlIGxhIGZ1bmNpXHUwMEYzbiBhcXVcdTAwRUQuXG5cdCAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY2FtcG8gPSBwYXJhbWV0cm87XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vdGEuZXN0YWRvID0gY2FtcG87XG4gICAgICAgIHJldHVybiBjYW1wbztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRGaWxlbmFtZShmbGFnLCBhY3R1YWwpe1xuICAgICAgICBzd2l0Y2godGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiQVZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBSVwiOlxuICAgICAgICAgICAgICAgIHRoaXMubm90YS5maWxlTmFtZSA9IChgJHt0aGlzLmluZm9TdWJzaXN0ZW1hLmZvbGRlcn0vJHt0aGlzLm5vdGEudGl0dWxvfS9pbmRleCR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlfWApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXhcIjpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGEuZmlsZU5hbWUgPSAoYCR7dGhpcy5pbmZvU3Vic2lzdGVtYS5mb2xkZXJ9LyR7dGhpcy5pbmZvU3Vic2lzdGVtYS50eXBlfSAtICR7dGhpcy5ub3RhLmlkfWApXG4gICAgICAgICAgICAgICAgYnJlYWs7ICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdGEuZmlsZU5hbWU7XG4gICAgfVxuXG4gICAgYXN5bmMgbW9kYWxDYW1iaW9IRihub3RhKXtcbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIGxldCBtb2RhbCA9IG5ldyBtb2RhbF9jYW1iaW9IRih0aGlzLnBsdWdpbiwgbm90YSk7XG4gICAgICAgIG1vZGFsLm9wZW4oKTtcbiAgICB9XG4gICBcblxuICB9XG4gICIsICJpbXBvcnQgeyBNb2RhbCwgQXBwLCBURmlsZSwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgWUFNTFVwZGF0ZXJBUEkgfSBmcm9tICcuLi8uLi9ub3RlTGlmZWN5Y2xlTWFuYWdlci9BUEkvWUFNTFVwZGF0ZXJBUEknO1xuXG5leHBvcnQgY2xhc3MgbW9kYWxfY2FtYmlvSEYgZXh0ZW5kcyBNb2RhbCB7XG4gICAgZmlsZTogVEZpbGU7XG4gICAgYXBwOiBBcHA7XG4gICAgaG9yYUZpbmFsSW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFBsdWdpbiwgZmlsZTogVEZpbGUpIHtcbiAgICAgICAgc3VwZXIocGx1Z2luLmFwcCk7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgIH1cblxuICAgIGFzeW5jIG9uT3BlbigpIHtcbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuY2xhc3NMaXN0LmFkZChcIm1vZGFsSW5ib3hcIik7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLnBsdWdpbi5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUodGhpcy5maWxlLmZpbGUpO1xuICAgICAgICBjb25zdCBhbGlhc2VzID0gbWV0YWRhdGE/LmZyb250bWF0dGVyPy5hbGlhc2VzIHx8IFwiQWN0aXZpZGFkIHNpbiBhbGlhc1wiO1xuICAgICAgICAvLyBDb252ZXJ0aXIgaG9yYUluaWNpb1N0ciBhIGZvcm1hdG8gXCJZWVlZLU1NLUREVEhIOk1NXCIgcGFyYSBkYXRldGltZS1sb2NhbFxuICAgICAgICBjb25zdCBob3JhRmluU3RyID0gbWV0YWRhdGE/LmZyb250bWF0dGVyPy5ob3JhRmluYWwgPyB3aW5kb3cubW9tZW50KG1ldGFkYXRhLmZyb250bWF0dGVyLmhvcmFGaW5hbCwgXCJZWVlZLU1NLUREIGRkZGQgSEg6bW1cIikuZm9ybWF0KFwiWVlZWS1NTS1ERFRISDptbVwiKSA6ICcnO1xuXG4gICAgICAgIC8vIENvbmZpZ3VyYSBlbCB0XHUwMEVEdHVsbyBkZWwgbW9kYWwgeSBtdWVzdHJhIGVsIGFsaWFzIGRlIGxhIHRhcmVhXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6IGBDYW1iaW8gaG9yYSBjaWVycmUgZGUgcmVnaXN0cm8uYCB9KTtcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgVGFyZWE6IFwiJHthbGlhc2VzWzBdfVwiYCB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIElucHV0IHBhcmEgbGEgaG9yYSBkZSBpbmljaW8gY29uIHRpcG8gZGF0ZXRpbWUtbG9jYWxcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnSG9yYSBkZSBjaWVycmUgcmVnaXN0cm86JyB9KTtcbiAgICAgICAgdGhpcy5ob3JhRmluYWxJbnB1dCA9IGNvbnRlbnRFbC5jcmVhdGVFbCgnaW5wdXQnLCB7XG4gICAgICAgICAgICB0eXBlOiAnZGF0ZXRpbWUtbG9jYWwnLFxuICAgICAgICAgICAgdmFsdWU6IGhvcmFGaW5TdHJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQm90XHUwMEYzbiBwYXJhIGd1YXJkYXIgY2FtYmlvc1xuICAgICAgICBjb25zdCBzYXZlQnV0dG9uID0gY29udGVudEVsLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdHdWFyZGFyIGNhbWJpb3MnIH0pO1xuICAgICAgICBzYXZlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB0aGlzLmd1YXJkYXJDYW1iaW9zKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ3VhcmRhckNhbWJpb3MoKSB7XG4gICAgICAgIGNvbnN0IG51ZXZhSG9yYUZpbmFsTG9jYWwgPSB0aGlzLmhvcmFGaW5hbElucHV0LnZhbHVlO1xuICAgICAgICAvLyBBc2VndXJhciBxdWUgbGEgbnVldmEgaG9yYSB0aWVuZSB2YWxvciBhbnRlcyBkZSBpbnRlbnRhciBmb3JtYXRlYXJcbiAgICAgICAgaWYgKCFudWV2YUhvcmFGaW5hbExvY2FsKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiUG9yIGZhdm9yLCBzZWxlY2Npb25lIHVuYSBob3JhIGRlIGNpZXJyZS5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0aXIgZGUgXCJZWVlZLU1NLUREVEhIOk1NXCIgYSBcIllZWVktTU0tREQgZGRkZCBISDptbVwiXG4gICAgICAgIGNvbnN0IG51ZXZhSG9yYUZpbmFsID0gd2luZG93Lm1vbWVudChudWV2YUhvcmFGaW5hbExvY2FsKS5mb3JtYXQoXCJZWVlZLU1NLUREIGRkZGQgSEg6bW1cIik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgLy8gRWplY3V0YXIgWUFNTCBVcGRhdGVcbiAgICAgICAgICAgIGxldCBjYW1wb3MgPSBbXCJmZWNoYVwiLGBob3JhRmluYWxfJHtudWV2YUhvcmFGaW5hbH1gLGB0aWVtcG9UcmFiYWphZG9fJHtudWV2YUhvcmFGaW5hbH1gLCBcImVzdGFkb19cdUQ4M0RcdUREMzVcIl07XG4gICAgICAgICAgICBsZXQgcmVzdWx0YWRvID0gYXdhaXQgdGhpcy5wbHVnaW4uWUFNTFVwZGF0ZXJBUEkuYWN0dWFsaXphck5vdGEodGhpcy5maWxlLCBjYW1wb3MpO1xuXG5cblxuXG4gICAgICAgICAgICAvLyBDZXJyYXIgZWwgbW9kYWwgZGVzcHVcdTAwRTlzIGRlIGd1YXJkYXIgbG9zIGNhbWJpb3NcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJIb3JhIGRlIEZpbmFsaXphY2lcdTAwRjNuIGFjdHVhbGl6YWRhIGNvcnJlY3RhbWVudGUuXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGd1YXJkYXIgY2FtYmlvcyBlbiBsYSBub3RhOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRXJyb3IgYWwgZ3VhcmRhciBsb3MgY2FtYmlvcyBlbiBsYSBub3RhLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQge05vdGljZSwgVEZpbGV9IGZyb20gJ29ic2lkaWFuJ1xuaW1wb3J0IHtEYXRlVGltZSwgRHVyYXRpb259IGZyb20gJ2x1eG9uJ1xuaW1wb3J0IHsgc3RhcnRlckFQSSB9IGZyb20gJy4vc3RhcnRlckFQSSc7XG5pbXBvcnQgeyB1dGlsc0FQSSB9IGZyb20gJy4uLy4uL21vZHVsb1JlZ2lzdHJvVGllbXBvL0FQSS91dGlsc0FQSSc7XG5pbXBvcnQgeyByZWdpc3Ryb1RpZW1wb0FQSSB9IGZyb20gJy4uLy4uL21vZHVsb1JlZ2lzdHJvVGllbXBvL0FQSS9yZWdpc3Ryb1RpZW1wb0FQSSc7XG5cbmV4cG9ydCBjbGFzcyBtZW51SG95QVBJIHtcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFBsdWdpbikge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgdGhpcy5hcHAgPSBwbHVnaW4uYXBwOyAgLy8gR3VhcmRhIHVuYSByZWZlcmVuY2lhIGEgbGEgYXBsaWNhY2lcdTAwRjNuIE9ic2lkaWFuIHBhcmEgYWNjZWRlciBhIHN1cyBtXHUwMEU5dG9kb3MgeSBwcm9waWVkYWRlc1xuICAgICAgICB0aGlzLnJlZ2lzdHJvVGllbXBvQVBJID0gbmV3IHJlZ2lzdHJvVGllbXBvQVBJKHRoaXMucGx1Z2luKTtcbiAgICB9XG5cbiAgICAvLyBGdW5jaVx1MDBGM24gcGFyYSBjcmVhciB5IG1vc3RyYXIgZWwgYm90XHUwMEYzbiBpbmljaWFsIFwiTWVuXHUwMEZBIGhveVwiXG4gICAgYXN5bmMgbW9zdHJhck1lbnUoZHYpIHtcbiAgICAgICAgZHYuY29udGFpbmVyLmlubmVySFRNTCA9ICcnOyAvLyBMaW1waWFyIGVsIGNvbnRlbmVkb3JcblxuICAgICAgICBjb25zdCBib3Rvbk1lbnVIb3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYm90b25NZW51SG95LnRleHRDb250ZW50ID0gJ01lblx1MDBGQSBob3knO1xuICAgICAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQoYm90b25NZW51SG95KTtcblxuICAgICAgICBib3Rvbk1lbnVIb3kub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubW9zdHJhckJvdG9uZXMoZHYpOyAvLyBNb3N0cmFyIGxvcyBib3RvbmVzIGFkaWNpb25hbGVzIGFsIGhhY2VyIGNsaWNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNXHUwMEU5dG9kbyBtb2RpZmljYWRvIHBhcmEgYWRhcHRhcnNlIGFsIGNvbnRleHRvIGRlbCBwbHVnaW5cbiAgICBhc3luYyBtb3N0cmFyQm90b25lcyhkdikge1xuICAgICAgICBkdi5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7IC8vIExpbXBpYXIgZWwgY29udGVuZWRvciBwYXJhIHJlbW92ZXIgZWwgYm90XHUwMEYzbiBkZSBtZW5cdTAwRkFcblxuICAgICAgICBjb25zdCBib3RvbmVzID0gW1xuICAgICAgICAgICAgXCJIXHUwMEUxYml0b3NcIiwgXCJCYWxhbmNlXCIsIFwiUmVnaXN0cm8gZGUgVGFyZWFzXCIsIFwiTm90YXMgZFx1MDBFRGFcIiwgXCJQZXJzb25hbGVzXCJcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBDcmVhciB5IG1vc3RyYXIgY2FkYSBib3RcdTAwRjNuXG4gICAgICAgIGJvdG9uZXMuZm9yRWFjaCh0ZXh0b0JvdG9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvdG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICBib3Rvbi50ZXh0Q29udGVudCA9IHRleHRvQm90b247XG4gICAgICAgICAgICBib3Rvbi5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCh0ZXh0b0JvdG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0JhbGFuY2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tb3N0cmFyQm90b25CYWxhbmNlUGVyc29uYWwoZHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0hcdTAwRTFiaXRvcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm1vc3RyYXJGb3JtdWxhcmlvSGFiaXRvcyhkdik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUmVnaXN0cm8gZGUgVGFyZWFzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubW9zdHJhckJvdG9uUmVnaXN0cm9UYXJlYXMoZHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05vdGFzIGRcdTAwRURhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubW9zdHJhckJvdG9uZXNOb3Rhc0RcdTAwRURhKGR2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdQZXJzb25hbGVzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubW9zdHJhckJvdG9uZXNOb3Rhc1BlcnNvbmFsZXMoZHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHt0ZXh0b0JvdG9ufSBwcmVzaW9uYWRvLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3Rvbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGJvdG9uU2FsaXIgPSB0aGlzLmFncmVnYXJCb3RvblNhbGlyKGR2KTtcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGJvdG9uU2FsaXIpO1xuICAgIH1cblxuICAgIC8vIE1cdTAwRTl0b2RvIHBhcmEgYWdyZWdhciBlbCBib3RcdTAwRjNuIGRlIHJlY2FyZ2EgeSBzdSBsXHUwMEYzZ2ljYSAoRWplbXBsbyBhZGFwdGFkbylcbiAgICBhZ3JlZ2FyQm90b25TYWxpcihkdikge1xuICAgICAgICBjb25zdCBib3RvblJlY2FyZ2EgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYm90b25SZWNhcmdhLnRleHRDb250ZW50ID0gJ1NhbGlyJztcbiAgICAgICAgYm90b25SZWNhcmdhLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1vc3RyYXJNZW51KGR2KTsgLy8gUmVzdGFibGVjZXIgYSBsYSB2aXN0YSBkZWwgYm90XHUwMEYzbiBkZSBtZW5cdTAwRkEgaW5pY2lhbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYm90b25SZWNhcmdhO1xuICAgIH1cblxuICAgICAvLyBNXHUwMEU5dG9kbyBwYXJhIGFjdHVhbGl6YXIgY2FtcG9zIFlBTUxcbiAgICAgYXN5bmMgdXBkYXRlWUFNTEZpZWxkcyhmaWxlUGF0aCwgWUFNTGZpZWxkLCB2YWxvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUnV0YSBhbCBhcmNoaXZvIHF1ZSBzZSB2YSBhIG1vZGlmaWNhclxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgIC8vIExlZXIgeSBhY3R1YWxpemFyIGVsIGZyb250bWF0dGVyIHVzYW5kbyBwcm9jZXNzRnJvbnRNYXR0ZXJcbiAgICAgICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBhd2FpdCBhcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKGZpbGUsIGZyb250bWF0dGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0dWFsaXphciBlbCB2YWxvciBkZWwgY2FtcG8gZXNwZWNpZmljYWRvXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmcm9udG1hdHRlcltZQU1MZmllbGRdID0gdmFsb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gT3BjaW9uYWw6IE5vdGlmaWNhciBhbCB1c3VhcmlvIHF1ZSBsYSBhY3R1YWxpemFjaVx1MDBGM24gZnVlIGV4aXRvc2FcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdZQU1MIGFjdHVhbGl6YWRvIGNvbiBcdTAwRTl4aXRvLicpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGFjdHVhbGl6YXIgZWwgZnJvbnRtYXR0ZXJcIiwgZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBcmNoaXZvIG5vIGVuY29udHJhZG9cIiwgZXJyKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0Vycm9yIGFsIGFjdHVhbGl6YXIgZWwgWUFNTC4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1cdTAwRTl0b2RvIGFkYXB0YWRvIHBhcmEgbW9zdHJhckJvdG9uQmFsYW5jZVBlcnNvbmFsXG4gICAgYXN5bmMgbW9zdHJhckJvdG9uQmFsYW5jZVBlcnNvbmFsKGR2KSB7XG4gICAgICAgIC8vIExpbXBpYXIgZWwgY29udGVuZWRvclxuICAgICAgICBkdi5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgXG4gICAgICAgIC8vIE1lbnNhamUgaW5pY2lhbFxuICAgICAgICBjb25zdCBtZW5zYWplID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICAgICAgbWVuc2FqZS50ZXh0Q29udGVudCA9ICdFdmFsXHUwMEZBYSBlbCBiYWxhbmNlIGRlIHR1IHZpZGEgaG95JztcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKG1lbnNhamUpO1xuICAgIFxuICAgICAgICBjb25zdCBpbnN0cnVjY2lvbmVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgICBpbnN0cnVjY2lvbmVzLnRleHRDb250ZW50ID0gJ0V2YWxcdTAwRkFhIGRlIDEgYSA1IGNhZGEgXHUwMEUxcmVhOic7XG4gICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnN0cnVjY2lvbmVzKTtcbiAgICBcbiAgICAgICAgLy8gXHUwMEMxcmVhcyBhIGV2YWx1YXJcbiAgICAgICAgY29uc3QgYXJlYXMgPSBbXG4gICAgICAgICAgICBcIlByb2R1Y3RpdmlkYWRcIiwgXCJFc3Bpcml0dWFsXCIsIFwiU2FsdWRcIiwgXCJSdXRpbmFzXCIsXG4gICAgICAgICAgICBcIlZpZGEgU29jaWFsXCIsIFwiRmFtaWxpYXJcIiwgXCJBcHJlbmRpemFqZXNcIiwgXCJDcmVhdGl2aWRhZFwiXG4gICAgICAgIF07XG4gICAgXG4gICAgICAgIC8vIE9idGVuZXIgZWwgYXJjaGl2byBhY3R1YWwgeSBzdSBtZXRhZGF0YVxuICAgICAgICBjb25zdCBmaWxlID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIENyZWFyIGlucHV0IHJhbmdlIHBhcmEgY2FkYSBcdTAwRTFyZWFcbiAgICAgICAgYXJlYXMuZm9yRWFjaChhcmVhID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNhZmVOYW1lID0gYXJlYS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyAvZywgJ18nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbCA9IG1ldGFkYXRhICYmIG1ldGFkYXRhW3NhZmVOYW1lXSA/IG1ldGFkYXRhW3NhZmVOYW1lXSA6IDA7XG4gICAgXG4gICAgICAgICAgICBjb25zdCBjb250ZW5lZG9yQXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY29udGVuZWRvckFyZWEuY2xhc3NMaXN0LmFkZCgnYXJlYS1ldmFsdWFjaW9uJyk7XG4gICAgXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9IGFyZWEgKyAnOiAnO1xuICAgICAgICAgICAgbGFiZWwuaHRtbEZvciA9IHNhZmVOYW1lO1xuICAgIFxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgaW5wdXQudHlwZSA9ICdyYW5nZSc7XG4gICAgICAgICAgICBpbnB1dC5pZCA9IHNhZmVOYW1lO1xuICAgICAgICAgICAgaW5wdXQubmFtZSA9IHNhZmVOYW1lO1xuICAgICAgICAgICAgaW5wdXQubWluID0gJzEnO1xuICAgICAgICAgICAgaW5wdXQubWF4ID0gJzUnO1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBjdXJyZW50VmFsLnRvU3RyaW5nKCk7IC8vIFVzYXIgdmFsb3IgYWN0dWFsIG8gMFxuICAgIFxuICAgICAgICAgICAgY29uc3QgdmFsb3JMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHZhbG9yTGFiZWwudGV4dENvbnRlbnQgPSBpbnB1dC52YWx1ZTsgLy8gTW9zdHJhciBlbCB2YWxvciBhY3R1YWwgYWwgbGFkb1xuICAgIFxuICAgICAgICAgICAgaW5wdXQub25pbnB1dCA9ICgpID0+IHZhbG9yTGFiZWwudGV4dENvbnRlbnQgPSBpbnB1dC52YWx1ZTsgLy8gQWN0dWFsaXphciBlbCB2YWxvciBtb3N0cmFkbyBhbCBtb3ZlciBlbCByYW5nZVxuICAgIFxuICAgICAgICAgICAgY29udGVuZWRvckFyZWEuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICAgICAgY29udGVuZWRvckFyZWEuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgY29udGVuZWRvckFyZWEuYXBwZW5kQ2hpbGQodmFsb3JMYWJlbCk7XG4gICAgICAgICAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGVuZWRvckFyZWEpO1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgLy8gQm90XHUwMEYzbiBwYXJhIGd1YXJkYXIgbG9zIHZhbG9yZXNcbiAgICAgICAgY29uc3QgYm90b25HdWFyZGFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGJvdG9uR3VhcmRhci50ZXh0Q29udGVudCA9ICdHdWFyZGFyJztcbiAgICAgICAgYm90b25HdWFyZGFyLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhcmVhIG9mIGFyZWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNhZmVOYW1lID0gYXJlYS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyAvZywgJ18nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2FmZU5hbWUpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbG9yID0gcGFyc2VJbnQoaW5wdXRFbGVtZW50LnZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlWUFNTEZpZWxkcyhmaWxlLnBhdGgsIHNhZmVOYW1lLCB2YWxvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0JhbGFuY2VzIGFjdHVhbGl6YWRvcyBjb24gXHUwMEU5eGl0by4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnTm8gc2UgcHVkbyBvYnRlbmVyIGVsIGFyY2hpdm8gYWN0dWFsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQoYm90b25HdWFyZGFyKTtcbiAgICBcbiAgICAgICAgLy8gQWdyZWdhciBib3RcdTAwRjNuIGRlIHNhbGlyIHNpIG5lY2VzYXJpb1xuICAgICAgICBjb25zdCBib3RvblNhbGlyID0gdGhpcy5hZ3JlZ2FyQm90b25TYWxpcihkdik7XG4gICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3RvblNhbGlyKTtcbiAgICB9XG5cblxuICAgIGFzeW5jIG1vc3RyYXJGb3JtdWxhcmlvSGFiaXRvcyhkdikge1xuICAgICAgICAvLyBMaW1waWFyIGVsIGNvbnRlbmVkb3JcbiAgICAgICAgZHYuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaGFiaXRvcyA9IFtcbiAgICAgICAgICAgIFwiQ2x1YiA1YW1cIixcbiAgICAgICAgICAgIFwiUmVnaXN0cm8gQWtcdTAwRTFzaGlrb1wiLFxuICAgICAgICAgICAgXCJHaW1uYXNpb1wiLFxuICAgICAgICAgICAgXCJDb21lciBTYWx1ZGFibGVcIixcbiAgICAgICAgICAgIFwiTGVlciBsaWJyb1wiLFxuICAgICAgICAgICAgXCJFc2NyaWJpciBiaXRcdTAwRTFjb3JhIGVsIG1pc21vIGRcdTAwRURhXCIsXG4gICAgICAgICAgICBcIkNyZWFyIHBsYW4gZFx1MDBFRGEgc2lndWllbnRlXCIsXG4gICAgICAgICAgICBcIk1lIGZ1XHUwMEVEIGEgZG9ybWlyIGFudGVzIGRlIGxhcyAxMDozMHBtXCJcbiAgICAgICAgXTtcbiAgICBcbiAgICAgICAgLy8gRnVuY2lcdTAwRjNuIHBhcmEgY2FyZ2FyIHkgbWFyY2FyIGNoZWNrYm94ZXMgc2VsZWNjaW9uYWRvcyBwcmV2aWFtZW50ZVxuICAgICAgICBjb25zdCBjYXJnYXJDaGVja2JveGVzU2VsZWNjaW9uYWRvcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgICAgIC8vIExlZXIgZWwgYXJjaGl2byBwYXJhIG9idGVuZXIgZWwgY2FtcG8gJ2hhYml0b3MnIGRlbCBZQU1MXG4gICAgICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IGFwcC52YXVsdC5yZWFkKGZpbGUpO1xuICAgICAgICAgICAgY29uc3QgZnJvbnRNYXR0ZXIgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIYWJpdHMgPSBmcm9udE1hdHRlcj8uaGFiaXRvcyB8fCBbXTtcbiAgICBcbiAgICAgICAgICAgIGhhYml0b3MuZm9yRWFjaChoYWJpdG8gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICAgICAgICBjaGVja2JveC5pZCA9IGhhYml0bztcbiAgICAgICAgICAgICAgICBjaGVja2JveC5uYW1lID0gJ2hhYml0b3MnO1xuICAgICAgICAgICAgICAgIGNoZWNrYm94LnZhbHVlID0gaGFiaXRvO1xuICAgICAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBleGlzdGluZ0hhYml0cy5pbmNsdWRlcyhoYWJpdG8pO1xuICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgICAgICAgICBsYWJlbC5odG1sRm9yID0gaGFiaXRvO1xuICAgICAgICAgICAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gaGFiaXRvO1xuICAgIFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGVja2JveCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICBcbiAgICAgICAgICAgICAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICBhd2FpdCBjYXJnYXJDaGVja2JveGVzU2VsZWNjaW9uYWRvcygpO1xuICAgIFxuICAgICAgICAvLyBDcmVhciB5IGNvbmZpZ3VyYXIgZWwgYm90XHUwMEYzbiBkZSBndWFyZGFyXG4gICAgICAgIGNvbnN0IGd1YXJkYXJCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgZ3VhcmRhckJ0bi50ZXh0Q29udGVudCA9ICdHdWFyZGFyJztcbiAgICAgICAgZ3VhcmRhckJ0bi5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tib3hlcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT1cImhhYml0b3NcIl06Y2hlY2tlZCcpKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkSGFiaXRzID0gY2hlY2tib3hlcy5tYXAoY2hlY2tib3ggPT4gY2hlY2tib3gudmFsdWUpO1xuICAgIFxuICAgICAgICAgICAgLy8gQWN0dWFsaXphciBlbCBjYW1wbyAnaGFiaXRvcycgZW4gZWwgYXJjaGl2byBZQU1MIHVzYW5kbyBlbCBtXHUwMEU5dG9kbyB1cGRhdGVZQU1MRmllbGRzXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVlBTUxGaWVsZHMoZmlsZS5wYXRoLCAnaGFiaXRvcycsIHNlbGVjdGVkSGFiaXRzKTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLy8gQVx1MDBGMWFkaXIgZWwgYm90XHUwMEYzbiBkZSBndWFyZGFyIGFsIGNvbnRlbmVkb3JcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGd1YXJkYXJCdG4pO1xuXG4gICAgICAgIC8vIEFncmVnYXIgYm90XHUwMEYzbiBkZSBzYWxpciBzaSBuZWNlc2FyaW9cbiAgICAgICAgY29uc3QgYm90b25TYWxpciA9IHRoaXMuYWdyZWdhckJvdG9uU2FsaXIoZHYpO1xuICAgICAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQoYm90b25TYWxpcik7XG4gICAgfVxuICAgIFxuICAgIC8vIE1cdTAwRTl0b2RvIGFkYXB0YWRvIHBhcmEgbW9zdHJhckJvdG9uQmFsYW5jZVBlcnNvbmFsXG4gICAgYXN5bmMgbW9zdHJhckJvdG9uUmVnaXN0cm9UYXJlYXMoZHYpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIExpbXBpYXIgZWwgY29udGVuZWRvclxuICAgICAgICBkdi5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGxldCBib3RvbmVzO1xuICAgICAgICBjb25zdCB1dGlsc0FQSW5zdGFuY2UgPSBuZXcgdXRpbHNBUEkodGhpcy5wbHVnaW4pO1xuICAgICAgICBjb25zdCBhY3Rpdm8gPSBhd2FpdCB1dGlsc0FQSW5zdGFuY2UuYnVzY2FyUmVnaXN0cm9zQWN0aXZvcyhhcHApXG4gICAgICAgIGlmIChhY3Rpdm8gaW5zdGFuY2VvZiBURmlsZSl7IC8vIFZlcmlmaWNhIHNpIGhheSBhbGd1biBhcmNoaXZvIGFjdGl2byBcbiAgICAgICAgICAgIGJvdG9uZXMgPSBbXCJDZXJyYWRhcyBIb3lcIiwgXCJSZWdpc3Ryb3MgSG95XCIsIFwiTnVldm8gUmVnaXN0cm8gVGllbXBvXCIsIFwiQ2VycmFyIFJlZ2lzdHJvIFRpZW1wb1wiXTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBib3RvbmVzID0gW1wiQ2VycmFkYXMgSG95XCIsIFwiUmVnaXN0cm9zIEhveVwiLCBcIk51ZXZvIFJlZ2lzdHJvIFRpZW1wb1wiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWFyIHkgbW9zdHJhciBjYWRhIGJvdFx1MDBGM25cbiAgICAgICAgYm90b25lcy5mb3JFYWNoKHRleHRvQm90b24gPT4ge1xuICAgICAgICAgICAgY29uc3QgYm90b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIGJvdG9uLnRleHRDb250ZW50ID0gdGV4dG9Cb3RvbjtcbiAgICAgICAgICAgIGJvdG9uLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKHRleHRvQm90b24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ2VycmFkYXMgSG95JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubW9zdHJhckNlcnJhZGFzSG95KGR2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdSZWdpc3Ryb3MgSG95JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubW9zdHJhclJlZ2lzdHJvc0hveShkdik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ2VycmFyIFJlZ2lzdHJvIFRpZW1wbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0cm9UaWVtcG9BUEkuY2VycmFyUmVnaXN0cm8oYWN0aXZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdOdWV2byBSZWdpc3RybyBUaWVtcG8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRlckFQSW5zdGFuY2UgPSBuZXcgc3RhcnRlckFQSSh0aGlzLnBsdWdpbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0YXJ0ZXJBUEluc3RhbmNlLmNyZWF0ZU5vdGUoXCJSZWdpc3Ryb1RpZW1wb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7dGV4dG9Cb3Rvbn0gcHJlc2lvbmFkby5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQoYm90b24pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBib3RvblNhbGlyID0gdGhpcy5hZ3JlZ2FyQm90b25TYWxpcihkdik7XG4gICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3RvblNhbGlyKTtcbiAgICB9XG5cbiAgICBhc3luYyBtb3N0cmFyQ2VycmFkYXNIb3koZHYpIHtcbiAgICAgICAgZHYuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIFxuICAgICAgICBjb25zdCBhY3Rpdm8gPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgbGV0IGZlY2hhQWN0aXZvID0gYWN0aXZvPy5iYXNlbmFtZS5zcGxpdChcIiBcIilbMF07XG4gICAgICAgIGNvbnN0IGhveSA9IG5ldyBEYXRlKGZlY2hhQWN0aXZvKS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBcbiAgICAgICAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgICAgICBcbiAgICAgICAgbGV0IHRhcmVhc1Byb21lc2FzID0gZmlsZXMubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICAgICAgICBsZXQgY29udGVuaWRvID0gYXdhaXQgYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgICAgICBsZXQgdGFyZWFzRXh0cmFpZGFzID0gZXh0cmFlclRhcmVhcyhjb250ZW5pZG8pO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGZyb250TWF0dGVyID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzID0gZnJvbnRNYXR0ZXI/LmFsaWFzZXMgPyBmcm9udE1hdHRlci5hbGlhc2VzWzBdIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5wYXRoO1xuICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlsZVBhdGgsXG4gICAgICAgICAgICAgICAgYWxpYXMsXG4gICAgICAgICAgICAgICAgdGFyZWFzOiB0YXJlYXNFeHRyYWlkYXMuZmlsdGVyKHRhcmVhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZlY2hhVGFyZWEgPSBuZXcgRGF0ZSh0YXJlYS5jb21wbGV0aW9uRGF0ZSkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJlYS5jb21wbGV0ZWQgJiYgdGFyZWEuY29tcGxldGlvbkRhdGUgJiYgZmVjaGFUYXJlYSA9PT0gaG95O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGxldCByZXN1bHRhZG9zID0gYXdhaXQgUHJvbWlzZS5hbGwodGFyZWFzUHJvbWVzYXMpO1xuICAgICAgICBsZXQgdG90YWxUYXJlYXNDZXJyYWRhcyA9IHJlc3VsdGFkb3MucmVkdWNlKCh0b3RhbCwgeyB0YXJlYXMgfSkgPT4gdG90YWwgKyB0YXJlYXMubGVuZ3RoLCAwKTtcblxuICAgICAgICAvLyBNZW5zYWplIHNvYnJlIGVsIGVzdGFkbyBkZSBsYXMgdGFyZWFzIGNlcnJhZGFzIGhveVxuICAgICAgICBpZiAodG90YWxUYXJlYXNDZXJyYWRhcyA+IDApIHtcbiAgICAgICAgICAgIGR2LmhlYWRlcigzLCBgSG95IHNlIGhhbiBjZXJyYWRvICR7dG90YWxUYXJlYXNDZXJyYWRhc30gdGFyZWFzLmApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgLy8gQ3JlYXIgbGEgdGFibGEgSFRNTFxuICAgICAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgICAgIHRhYmxlLmNsYXNzTGlzdC5hZGQoJ3RhYmxlJyk7IC8vIEFncmVnYXIgdW5hIGNsYXNlIHBhcmEgbGEgdGFibGEgcGFyYSBlbCBlc3RpbG9cbiAgICAgICAgdGFibGUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgXG4gICAgICAgIC8vIEFcdTAwRjFhZGlyIGVuY2FiZXphZG9zIGRlIHRhYmxhXG4gICAgICAgIGNvbnN0IGhlYWRlclJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgIGxldCBoZWFkZXJzID0gW1wiTm90YVwiLCBcIlRhcmVhcyBDZXJyYWRhc1wiXTtcbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKGhlYWRlclRleHQgPT4ge1xuICAgICAgICAgICAgbGV0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XG4gICAgICAgICAgICBoZWFkZXIudGV4dENvbnRlbnQgPSBoZWFkZXJUZXh0O1xuICAgICAgICAgICAgaGVhZGVyLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgaGVhZGVyUm93LmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChoZWFkZXJSb3cpO1xuICAgIFxuICAgICAgICAvLyBBXHUwMEYxYWRpciBmaWxhcyBkZSBkYXRvcyBhIGxhIHRhYmxhXG4gICAgICAgIHJlc3VsdGFkb3MuZm9yRWFjaCgoe2ZpbGVQYXRoLCBhbGlhcywgdGFyZWFzfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRhcmVhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQ29sdW1uYSBkZSBlbmxhY2UgY2VudHJhZG8gdmVydGljYWxtZW50ZVxuICAgICAgICAgICAgICAgIGxldCBsaW5rQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICAgICAgbGlua0NlbGwuc3R5bGUudmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgIGxldCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdocmVmJywgYG9ic2lkaWFuOi8vb3Blbj92YXVsdD0ke2FwcC52YXVsdC5nZXROYW1lKCl9JmZpbGU9JHtlbmNvZGVVUklDb21wb25lbnQoZmlsZVBhdGgpfWApO1xuICAgICAgICAgICAgICAgIGEudGV4dENvbnRlbnQgPSBhbGlhcyB8fCBmaWxlUGF0aDtcbiAgICAgICAgICAgICAgICBsaW5rQ2VsbC5hcHBlbmRDaGlsZChhKTtcbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQobGlua0NlbGwpO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIENvbHVtbmEgZGUgdGFyZWFzIGNlcnJhZGFzXG4gICAgICAgICAgICAgICAgbGV0IHRhc2tzQ2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICAgICAgbGV0IHRhc2tzTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgICAgICAgICAgdGFyZWFzLmZvckVhY2godGFyZWEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgICAgICAgICBsaS50ZXh0Q29udGVudCA9IHRhcmVhLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzTGlzdC5hcHBlbmRDaGlsZChsaSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGFza3NDZWxsLmFwcGVuZENoaWxkKHRhc2tzTGlzdCk7XG4gICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHRhc2tzQ2VsbCk7XG4gICAgXG4gICAgICAgICAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIC8vIEFcdTAwRjFhZGlyIGxhIHRhYmxhIGFsIGNvbnRlbmVkb3IgZGUgRGF0YXZpZXdcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKHRhYmxlKTtcbiAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkdi5wYXJhZ3JhcGgoXCJObyBoYXkgdGFyZWFzIGNlcnJhZGFzIGhveS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICBjb25zdCBib3RvblNhbGlyID0gdGhpcy5hZ3JlZ2FyQm90b25TYWxpcihkdik7XG4gICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3RvblNhbGlyKTtcbiAgICBcbiAgICBmdW5jdGlvbiBleHRyYWVyVGFyZWFzKGNvbnRlbmlkbykge1xuICAgICAgICBjb25zdCB0YXJlYXMgPSBbXTtcbiAgICAgICAgY29uc3QgbGluZWFzID0gY29udGVuaWRvLnNwbGl0KFwiXFxuXCIpO1xuICAgIFxuICAgICAgICBmb3IgKGNvbnN0IGxpbmVhIG9mIGxpbmVhcykge1xuICAgICAgICAgICAgY29uc3QgdGFyZWFSZWdleCA9IC9eXFxzKi1cXHMqXFxbKHh8WHwgKVxcXVxccyooLispJC87XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRhcmVhUmVnZXguZXhlYyhsaW5lYSk7XG4gICAgXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0YWRhID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0b1RhcmVhID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgbGV0IGZlY2hhQ29tcGxldGl0dWQgPSBudWxsO1xuICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGZlY2hhUmVnZXggPSAvXFxbY29tcGxldGlvbjo6IChcXGR7NH0tXFxkezJ9LVxcZHsyfSlcXF0vO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZlY2hhTWF0Y2ggPSBmZWNoYVJlZ2V4LmV4ZWModGV4dG9UYXJlYSk7XG4gICAgICAgICAgICAgICAgaWYgKGZlY2hhTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVjaGFDb21wbGV0aXR1ZCA9IGZlY2hhTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgIHRleHRvVGFyZWEgPSB0ZXh0b1RhcmVhLnJlcGxhY2UoZmVjaGFSZWdleCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgdGFyZWFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0b1RhcmVhLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6IGNvbXBsZXRhZGEsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25EYXRlOiBmZWNoYUNvbXBsZXRpdHVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiB0YXJlYXM7XG4gICAgfVxuICAgIFxuICAgIFxufVxuXG5cbiAgICBhc3luYyBtb3N0cmFyUmVnaXN0cm9zSG95KGR2KSB7XG4gICAgICAgICAgIC8vIE9idGVuZXIgZWwgbGVhZiBhY3Rpdm8gYWN0dWFsXG4gICAgICAgICAgIGNvbnN0IGFjdGl2ZUxlYWYgPSBhcHAud29ya3NwYWNlLmFjdGl2ZUxlYWY7XG5cbiAgICAgICAgICAgLy8gT2J0ZW5lciBlbCBwYXRoIGRlbCBURmlsZSBhc29jaWFkbyBjb24gZWwgbGVhZiBhY3Rpdm8sIHNpIGV4aXN0ZVxuICAgICAgICAgICBjb25zdCBjdXJyZW50RmlsZVBhdGggPSBhY3RpdmVMZWFmLnZpZXc/LmZpbGU/LnBhdGg7XG4gICBcbiAgICAgICAgICAgLy8gQ3JlYXIgdW5hIG51ZXZhIGRpdmlzaVx1MDBGM24gYSBsYSBkZXJlY2hhIGRlbCBsZWFmIGFjdGl2b1xuICAgICAgICAgICBjb25zdCBuZXdMZWFmID0gYXdhaXQgYXBwLndvcmtzcGFjZS5zcGxpdEFjdGl2ZUxlYWYoJ3ZlcnRpY2FsJyk7XG4gICBcbiAgICAgICAgICAgLy8gQ29uZmlndXJhciBlbCBudWV2byBsZWFmIHBhcmEgbW9zdHJhciB0dSB2aXN0YSBwZXJzb25hbGl6YWRhXG4gICAgICAgICAgIC8vIHkgcGFzYXIgZWwgcGF0aCBkZWwgVEZpbGUgY29tbyBwYXJ0ZSBkZWwgZXN0YWRvXG4gICAgXG4gICAgICAgICAgIGF3YWl0IG5ld0xlYWYuc2V0Vmlld1N0YXRlKHtcbiAgICAgICAgICAgICAgIHR5cGU6IFwidmlzdGEtcmVnaXN0cm8tZGlhcmlvXCIsXG4gICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICBhcHAud29ya3NwYWNlLnJldmVhbExlYWYobmV3TGVhZik7ICAgIFxufVxuXG4gICAgY3JlYXRlQnV0dG9uVGFibGUoYnV0dG9uVGV4dCwgb25DbGlja0NhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSBidXR0b25UZXh0O1xuICAgICAgICBidXR0b24udHlwZSA9ICdidXR0b24nOyAvLyBBc2VnXHUwMEZBcmF0ZSBkZSBxdWUgbm8gc2UgZW52aWFyXHUwMEUxIHVuIGZvcm11bGFyaW8gYWwgaGFjZXIgY2xpYyBlbiBcdTAwRTlsXG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCd5b3VyLWJ1dHRvbi1jbGFzcycpOyAvLyBBZ3JlZ2EgdW5hIGNsYXNlIHBhcmEgZWwgZXN0aWxvIGRlbCBib3RcdTAwRjNuIHNpIGVzIG5lY2VzYXJpb1xuXG4gICAgICAgIC8vIEFcdTAwRjFhZGUgZWwgZXZlbnRvIGRlIGNsaWMgYWwgYm90XHUwMEYzblxuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrQ2FsbGJhY2spO1xuXG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIENyZWEgbGEgbm90YSBkZXNkZSBlbCB0ZW1wbGF0ZXIgZGUgUmVnaXN0cm9UaWVtcG9cbiAgICBhc3luYyByZXRvbWFyVGFyZWEoaWQpIHsgXG4gICAgICAgIC8vIEFzZWdcdTAwRkFyYXRlIGRlIHJlZW1wbGF6YXIgJ3J1dGEvYWwvYXJjaGl2by5tZCcgY29uIGxhIHJ1dGEgZXhhY3RhIGRlbCBhcmNoaXZvIHF1ZSBkZXNlYXMgb2J0ZW5lclxuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBgUGxhbnRpbGxhcy8ke3RoaXMucGx1Z2luLnNldHRpbmdzW2Bmb2xkZXJfUmVnaXN0cm9UaWVtcG9gXX0vUGx0IC0gUmVnaXN0cm9UaWVtcG8ubWRgO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgICAgIGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICAvLyBBaG9yYSAnZmlsZScgZXMgdHUgYXJjaGl2byBkZXNlYWRvLCB5IHB1ZWRlcyB0cmFiYWphciBjb24gXHUwMEU5bCBjb21vIG5lY2VzaXRlc1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBcmNoaXZvIGVuY29udHJhZG86XCIsIHRlbXBsYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpIGVsIGFyY2hpdm8gbm8gc2UgZW5jb250clx1MDBGMywgJ2ZpbGUnIHNlclx1MDBFMSBudWxsXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFyY2hpdm8gbm8gZW5jb250cmFkby5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBcIlJldG9tYXIgXCIgKyBpZDtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChcIkluYm94XCIpO1xuICAgICAgICBjb25zdCB0cCA9IHRoaXMuZ2V0VHAoKTtcbiAgICAgICAgbGV0IGNyZWFyTm90YSA9IHRwLmZpbGUuc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJjcmVhdGVfbmV3XCIpXG4gICAgICAgIGF3YWl0IGNyZWFyTm90YSAodGVtcGxhdGUsIGZpbGVuYW1lLCBmYWxzZSwgZm9sZGVyKS5iYXNlbmFtZTtcbiAgICAgIH1cblxuICAgIGdldFRwKCl7XG4gICAgICAgIGlmICghdGhpcy5wbHVnaW4gfHwgIXRoaXMucGx1Z2luLmFwcC5wbHVnaW5zLmVuYWJsZWRQbHVnaW5zLmhhcygndGVtcGxhdGVyLW9ic2lkaWFuJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VsIHBsdWdpbiBUZW1wbGF0ZXIgbm8gZXN0XHUwMEUxIGhhYmlsaXRhZG8uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gICBcbiAgICAgICAgbGV0IHRwR2VuID0gdGhpcy5wbHVnaW4uYXBwLnBsdWdpbnMucGx1Z2luc1tcInRlbXBsYXRlci1vYnNpZGlhblwiXS50ZW1wbGF0ZXI7XG4gICAgICAgIHRwR2VuID0gdHBHZW4uZnVuY3Rpb25zX2dlbmVyYXRvci5pbnRlcm5hbF9mdW5jdGlvbnMubW9kdWxlc19hcnJheTtcbiAgICAgICAgbGV0IHRwID0ge31cbiAgICAgICAgLy8gZ2V0IGFuIGluc3RhbmNlIG9mIG1vZHVsZXNcbiAgICAgICAgdHAuZmlsZSA9IHRwR2VuLmZpbmQobSA9PiBtLm5hbWUgPT0gXCJmaWxlXCIpO1xuICAgICAgICB0cC5zeXN0ZW0gPSB0cEdlbi5maW5kKG0gPT4gbS5uYW1lID09IFwic3lzdGVtXCIpO1xuXG4gICAgICAgIGlmICghdHAuZmlsZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gc2UgcHVkbyBhY2NlZGVyIGFsIG9iamV0byBkZSBmdW5jaW9uZXMgYWN0dWFsZXMgZGUgVGVtcGxhdGVyLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCd0cCBjb24gcHJvcGllZGFkZXMgXCJmaWxlXCIgc2UgaGEgY2FyZ2FkbyBzYXRpc2ZhY3RvcmlhbWVudGUnKTtcbiAgICAgICAgcmV0dXJuIHRwO1xuICAgIH1cblxufVxuICAgIFxuIiwgImltcG9ydCB7Tm90aWNlLCBURmlsZX0gZnJvbSAnb2JzaWRpYW4nXG5pbXBvcnQge0RhdGVUaW1lLCBEdXJhdGlvbn0gZnJvbSAnbHV4b24nXG5pbXBvcnQgeyBzdGFydGVyQVBJIH0gZnJvbSAnLi9zdGFydGVyQVBJJztcbmltcG9ydCB7IHV0aWxzQVBJIH0gZnJvbSAnLi4vLi4vbW9kdWxvUmVnaXN0cm9UaWVtcG8vQVBJL3V0aWxzQVBJJztcbmltcG9ydCB7IFZpc3RhUmVzdW1lblNlbWFuYWwgfSBmcm9tICcuLi92aWV3cy92aXN0YVJlc3VtZW5TZW1hbmFsJztcblxuZXhwb3J0IGNsYXNzIG1lbnVTZW1hbmFsQVBJIHtcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFBsdWdpbikge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgdGhpcy5hcHAgPSBwbHVnaW4uYXBwOyAgLy8gR3VhcmRhIHVuYSByZWZlcmVuY2lhIGEgbGEgYXBsaWNhY2lcdTAwRjNuIE9ic2lkaWFuIHBhcmEgYWNjZWRlciBhIHN1cyBtXHUwMEU5dG9kb3MgeSBwcm9waWVkYWRlc1xuICAgICAgICAvLyB0aGlzLnJlZ2lzdHJvVGllbXBvQVBJID0gbmV3IHJlZ2lzdHJvVGllbXBvQVBJKHRoaXMucGx1Z2luKTtcbiAgICB9XG5cbiAgICAvLyBGdW5jaVx1MDBGM24gcGFyYSBjcmVhciB5IG1vc3RyYXIgZWwgYm90XHUwMEYzbiBpbmljaWFsIFwiTWVuXHUwMEZBIGhveVwiXG4gICAgYXN5bmMgbW9zdHJhck1lbnUoZHYpIHtcbiAgICAgICAgZHYuY29udGFpbmVyLmlubmVySFRNTCA9ICcnOyAvLyBMaW1waWFyIGVsIGNvbnRlbmVkb3JcblxuICAgICAgICBjb25zdCBib3Rvbk1lbnVIb3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYm90b25NZW51SG95LnRleHRDb250ZW50ID0gJ01lblx1MDBGQSBTZW1hbmFsJztcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGJvdG9uTWVudUhveSk7XG5cbiAgICAgICAgYm90b25NZW51SG95Lm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1vc3RyYXJCb3RvbmVzKGR2KTsgLy8gTW9zdHJhciBsb3MgYm90b25lcyBhZGljaW9uYWxlcyBhbCBoYWNlciBjbGljXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTVx1MDBFOXRvZG8gbW9kaWZpY2FkbyBwYXJhIGFkYXB0YXJzZSBhbCBjb250ZXh0byBkZWwgcGx1Z2luXG4gICAgYXN5bmMgbW9zdHJhckJvdG9uZXMoZHYpIHtcbiAgICAgICAgZHYuY29udGFpbmVyLmlubmVySFRNTCA9ICcnOyAvLyBMaW1waWFyIGVsIGNvbnRlbmVkb3IgcGFyYSByZW1vdmVyIGVsIGJvdFx1MDBGM24gZGUgbWVuXHUwMEZBXG5cbiAgICAgICAgY29uc3QgYm90b25lcyA9IFtcbiAgICAgICAgICAgIFwiUmVzdW1lbiBkaWFyaW9cIiwgXCJBZ3JhZGVjaW1pZW50b3NcIiwgXCJDcmVhZGFzXCIsIFwiTW9kaWZpY2FkYXNcIiwgXCJ4IEZlY2hhXCIsIFwiVGFyZWFzIENlcnJhZGFzXCJcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBDcmVhciB5IG1vc3RyYXIgY2FkYSBib3RcdTAwRjNuXG4gICAgICAgIGJvdG9uZXMuZm9yRWFjaCh0ZXh0b0JvdG9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvdG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICBib3Rvbi50ZXh0Q29udGVudCA9IHRleHRvQm90b247XG4gICAgICAgICAgICBib3Rvbi5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCh0ZXh0b0JvdG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1Jlc3VtZW4gZGlhcmlvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubW9zdHJhclJlc3VtZW5EaWFyaW8oZHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0FncmFkZWNpbWllbnRvcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm1vc3RyYXJBZ3JhZGVjaW1pZW50b3MoZHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NyZWFkYXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tb3N0cmFyQ3JlYWRhcyhkdik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTW9kaWZpY2FkYXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tb3N0cmFyTW9kaWZpY2FkYXMoZHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ggRmVjaGEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tb3N0cmFyeEZlY2hhKGR2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUYXJlYXMgQ2VycmFkYXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tb3N0cmFyVGFyZWFzQ2VycmFkYXMoZHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHt0ZXh0b0JvdG9ufSBwcmVzaW9uYWRvLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3Rvbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGJvdG9uU2FsaXIgPSB0aGlzLmFncmVnYXJCb3RvblNhbGlyKGR2KTtcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGJvdG9uU2FsaXIpO1xuICAgIH1cblxuICAgIC8vIE1cdTAwRTl0b2RvIHBhcmEgYWdyZWdhciBlbCBib3RcdTAwRjNuIGRlIHJlY2FyZ2EgeSBzdSBsXHUwMEYzZ2ljYSAoRWplbXBsbyBhZGFwdGFkbylcbiAgICBhZ3JlZ2FyQm90b25TYWxpcihkdikge1xuICAgICAgICBjb25zdCBib3RvblJlY2FyZ2EgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYm90b25SZWNhcmdhLnRleHRDb250ZW50ID0gJ1NhbGlyJztcbiAgICAgICAgYm90b25SZWNhcmdhLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1vc3RyYXJNZW51KGR2KTsgLy8gUmVzdGFibGVjZXIgYSBsYSB2aXN0YSBkZWwgYm90XHUwMEYzbiBkZSBtZW5cdTAwRkEgaW5pY2lhbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYm90b25SZWNhcmdhO1xuICAgIH1cblxuICAgICAvLyBNXHUwMEU5dG9kbyBwYXJhIGFjdHVhbGl6YXIgY2FtcG9zIFlBTUxcbiAgICAgYXN5bmMgdXBkYXRlWUFNTEZpZWxkcyhmaWxlUGF0aCwgWUFNTGZpZWxkLCB2YWxvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUnV0YSBhbCBhcmNoaXZvIHF1ZSBzZSB2YSBhIG1vZGlmaWNhclxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgIC8vIExlZXIgeSBhY3R1YWxpemFyIGVsIGZyb250bWF0dGVyIHVzYW5kbyBwcm9jZXNzRnJvbnRNYXR0ZXJcbiAgICAgICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBhd2FpdCBhcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKGZpbGUsIGZyb250bWF0dGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0dWFsaXphciBlbCB2YWxvciBkZWwgY2FtcG8gZXNwZWNpZmljYWRvXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmcm9udG1hdHRlcltZQU1MZmllbGRdID0gdmFsb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gT3BjaW9uYWw6IE5vdGlmaWNhciBhbCB1c3VhcmlvIHF1ZSBsYSBhY3R1YWxpemFjaVx1MDBGM24gZnVlIGV4aXRvc2FcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdZQU1MIGFjdHVhbGl6YWRvIGNvbiBcdTAwRTl4aXRvLicpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGFjdHVhbGl6YXIgZWwgZnJvbnRtYXR0ZXJcIiwgZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBcmNoaXZvIG5vIGVuY29udHJhZG9cIiwgZXJyKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0Vycm9yIGFsIGFjdHVhbGl6YXIgZWwgWUFNTC4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIG1vc3RyYXJSZXN1bWVuRGlhcmlvKGR2KXtcbiAgICAgICAgZGVidWdnZXI7XG5cbiAgICAgICAgLy8gT2J0ZW5lciBlbCBsZWFmIGFjdGl2byBhY3R1YWxcbiAgICAgICAgY29uc3QgYWN0aXZlTGVhZiA9IGFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZjtcblxuICAgICAgICAvLyBPYnRlbmVyIGVsIHBhdGggZGVsIFRGaWxlIGFzb2NpYWRvIGNvbiBlbCBsZWFmIGFjdGl2bywgc2kgZXhpc3RlXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGaWxlUGF0aCA9IGFjdGl2ZUxlYWYudmlldz8uZmlsZT8ucGF0aDtcblxuICAgICAgICAvLyBDcmVhciB1bmEgbnVldmEgZGl2aXNpXHUwMEYzbiBhIGxhIGRlcmVjaGEgZGVsIGxlYWYgYWN0aXZvXG4gICAgICAgIGNvbnN0IG5ld0xlYWYgPSBhd2FpdCBhcHAud29ya3NwYWNlLnNwbGl0QWN0aXZlTGVhZigndmVydGljYWwnKTtcblxuICAgICAgICAvLyBDb25maWd1cmFyIGVsIG51ZXZvIGxlYWYgcGFyYSBtb3N0cmFyIHR1IHZpc3RhIHBlcnNvbmFsaXphZGFcbiAgICAgICAgLy8geSBwYXNhciBlbCBwYXRoIGRlbCBURmlsZSBjb21vIHBhcnRlIGRlbCBlc3RhZG9cbiBcbiAgICAgICAgYXdhaXQgbmV3TGVhZi5zZXRWaWV3U3RhdGUoe1xuICAgICAgICAgICAgdHlwZTogXCJ2aXN0YS1yZXN1bWVuLXNlbWFuYWxcIixcbiAgICAgICAgfSk7XG4gXG4gICAgICAgIGFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihuZXdMZWFmKTtcbiAgICB9XG4gICAgXG5cblxuXG4gICAgLy8gTVx1MDBFOXRvZG8gYWRhcHRhZG8gcGFyYSBtb3N0cmFyQm90b25CYWxhbmNlUGVyc29uYWxcbiAgICBhc3luYyBtb3N0cmFyQm90b25CYWxhbmNlUGVyc29uYWwoZHYpIHtcbiAgICAgICAgLy8gTGltcGlhciBlbCBjb250ZW5lZG9yXG4gICAgICAgIGR2LmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICBcbiAgICAgICAgLy8gTWVuc2FqZSBpbmljaWFsXG4gICAgICAgIGNvbnN0IG1lbnNhamUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuICAgICAgICBtZW5zYWplLnRleHRDb250ZW50ID0gJ0V2YWxcdTAwRkFhIGVsIGJhbGFuY2UgZGUgdHUgdmlkYSBob3knO1xuICAgICAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQobWVuc2FqZSk7XG4gICAgXG4gICAgICAgIGNvbnN0IGluc3RydWNjaW9uZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgIGluc3RydWNjaW9uZXMudGV4dENvbnRlbnQgPSAnRXZhbFx1MDBGQWEgZGUgMSBhIDUgY2FkYSBcdTAwRTFyZWE6JztcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGluc3RydWNjaW9uZXMpO1xuICAgIFxuICAgICAgICAvLyBcdTAwQzFyZWFzIGEgZXZhbHVhclxuICAgICAgICBjb25zdCBhcmVhcyA9IFtcbiAgICAgICAgICAgIFwiUHJvZHVjdGl2aWRhZFwiLCBcIkVzcGlyaXR1YWxcIiwgXCJTYWx1ZFwiLCBcIlJ1dGluYXNcIixcbiAgICAgICAgICAgIFwiVmlkYSBTb2NpYWxcIiwgXCJGYW1pbGlhclwiLCBcIkFwcmVuZGl6YWplc1wiLCBcIkNyZWF0aXZpZGFkXCJcbiAgICAgICAgXTtcbiAgICBcbiAgICAgICAgLy8gT2J0ZW5lciBlbCBhcmNoaXZvIGFjdHVhbCB5IHN1IG1ldGFkYXRhXG4gICAgICAgIGNvbnN0IGZpbGUgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQ3JlYXIgaW5wdXQgcmFuZ2UgcGFyYSBjYWRhIFx1MDBFMXJlYVxuICAgICAgICBhcmVhcy5mb3JFYWNoKGFyZWEgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2FmZU5hbWUgPSBhcmVhLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvIC9nLCAnXycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsID0gbWV0YWRhdGEgJiYgbWV0YWRhdGFbc2FmZU5hbWVdID8gbWV0YWRhdGFbc2FmZU5hbWVdIDogMDtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbmVkb3JBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjb250ZW5lZG9yQXJlYS5jbGFzc0xpc3QuYWRkKCdhcmVhLWV2YWx1YWNpb24nKTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gYXJlYSArICc6ICc7XG4gICAgICAgICAgICBsYWJlbC5odG1sRm9yID0gc2FmZU5hbWU7XG4gICAgXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBpbnB1dC50eXBlID0gJ3JhbmdlJztcbiAgICAgICAgICAgIGlucHV0LmlkID0gc2FmZU5hbWU7XG4gICAgICAgICAgICBpbnB1dC5uYW1lID0gc2FmZU5hbWU7XG4gICAgICAgICAgICBpbnB1dC5taW4gPSAnMSc7XG4gICAgICAgICAgICBpbnB1dC5tYXggPSAnNSc7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGN1cnJlbnRWYWwudG9TdHJpbmcoKTsgLy8gVXNhciB2YWxvciBhY3R1YWwgbyAwXG4gICAgXG4gICAgICAgICAgICBjb25zdCB2YWxvckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgdmFsb3JMYWJlbC50ZXh0Q29udGVudCA9IGlucHV0LnZhbHVlOyAvLyBNb3N0cmFyIGVsIHZhbG9yIGFjdHVhbCBhbCBsYWRvXG4gICAgXG4gICAgICAgICAgICBpbnB1dC5vbmlucHV0ID0gKCkgPT4gdmFsb3JMYWJlbC50ZXh0Q29udGVudCA9IGlucHV0LnZhbHVlOyAvLyBBY3R1YWxpemFyIGVsIHZhbG9yIG1vc3RyYWRvIGFsIG1vdmVyIGVsIHJhbmdlXG4gICAgXG4gICAgICAgICAgICBjb250ZW5lZG9yQXJlYS5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgICAgICBjb250ZW5lZG9yQXJlYS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICBjb250ZW5lZG9yQXJlYS5hcHBlbmRDaGlsZCh2YWxvckxhYmVsKTtcbiAgICAgICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250ZW5lZG9yQXJlYSk7XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAvLyBCb3RcdTAwRjNuIHBhcmEgZ3VhcmRhciBsb3MgdmFsb3Jlc1xuICAgICAgICBjb25zdCBib3Rvbkd1YXJkYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYm90b25HdWFyZGFyLnRleHRDb250ZW50ID0gJ0d1YXJkYXInO1xuICAgICAgICBib3Rvbkd1YXJkYXIub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFyZWEgb2YgYXJlYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FmZU5hbWUgPSBhcmVhLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvIC9nLCAnXycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzYWZlTmFtZSkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsb3IgPSBwYXJzZUludChpbnB1dEVsZW1lbnQudmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVZQU1MRmllbGRzKGZpbGUucGF0aCwgc2FmZU5hbWUsIHZhbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnQmFsYW5jZXMgYWN0dWFsaXphZG9zIGNvbiBcdTAwRTl4aXRvLicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdObyBzZSBwdWRvIG9idGVuZXIgZWwgYXJjaGl2byBhY3R1YWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3Rvbkd1YXJkYXIpO1xuICAgIFxuICAgICAgICAvLyBBZ3JlZ2FyIGJvdFx1MDBGM24gZGUgc2FsaXIgc2kgbmVjZXNhcmlvXG4gICAgICAgIGNvbnN0IGJvdG9uU2FsaXIgPSB0aGlzLmFncmVnYXJCb3RvblNhbGlyKGR2KTtcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGJvdG9uU2FsaXIpO1xuICAgIH1cblxuXG4gICAgYXN5bmMgbW9zdHJhckZvcm11bGFyaW9IYWJpdG9zKGR2KSB7XG4gICAgICAgIC8vIExpbXBpYXIgZWwgY29udGVuZWRvclxuICAgICAgICBkdi5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBoYWJpdG9zID0gW1xuICAgICAgICAgICAgXCJDbHViIDVhbVwiLFxuICAgICAgICAgICAgXCJSZWdpc3RybyBBa1x1MDBFMXNoaWtvXCIsXG4gICAgICAgICAgICBcIkdpbW5hc2lvXCIsXG4gICAgICAgICAgICBcIkNvbWVyIFNhbHVkYWJsZVwiLFxuICAgICAgICAgICAgXCJMZWVyIGxpYnJvXCIsXG4gICAgICAgICAgICBcIkVzY3JpYmlyIGJpdFx1MDBFMWNvcmEgZWwgbWlzbW8gZFx1MDBFRGFcIixcbiAgICAgICAgICAgIFwiQ3JlYXIgcGxhbiBkXHUwMEVEYSBzaWd1aWVudGVcIixcbiAgICAgICAgICAgIFwiTWUgZnVcdTAwRUQgYSBkb3JtaXIgYW50ZXMgZGUgbGFzIDEwOjMwcG1cIlxuICAgICAgICBdO1xuICAgIFxuICAgICAgICAvLyBGdW5jaVx1MDBGM24gcGFyYSBjYXJnYXIgeSBtYXJjYXIgY2hlY2tib3hlcyBzZWxlY2Npb25hZG9zIHByZXZpYW1lbnRlXG4gICAgICAgIGNvbnN0IGNhcmdhckNoZWNrYm94ZXNTZWxlY2Npb25hZG9zID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICAgICAgLy8gTGVlciBlbCBhcmNoaXZvIHBhcmEgb2J0ZW5lciBlbCBjYW1wbyAnaGFiaXRvcycgZGVsIFlBTUxcbiAgICAgICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgICAgICBjb25zdCBmcm9udE1hdHRlciA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hhYml0cyA9IGZyb250TWF0dGVyPy5oYWJpdG9zIHx8IFtdO1xuICAgIFxuICAgICAgICAgICAgaGFiaXRvcy5mb3JFYWNoKGhhYml0byA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICAgICAgICAgIGNoZWNrYm94LmlkID0gaGFiaXRvO1xuICAgICAgICAgICAgICAgIGNoZWNrYm94Lm5hbWUgPSAnaGFiaXRvcyc7XG4gICAgICAgICAgICAgICAgY2hlY2tib3gudmFsdWUgPSBoYWJpdG87XG4gICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGV4aXN0aW5nSGFiaXRzLmluY2x1ZGVzKGhhYml0byk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgICAgIGxhYmVsLmh0bWxGb3IgPSBoYWJpdG87XG4gICAgICAgICAgICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSBoYWJpdG87XG4gICAgXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoZWNrYm94KTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIFxuICAgICAgICAgICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIGF3YWl0IGNhcmdhckNoZWNrYm94ZXNTZWxlY2Npb25hZG9zKCk7XG4gICAgXG4gICAgICAgIC8vIENyZWFyIHkgY29uZmlndXJhciBlbCBib3RcdTAwRjNuIGRlIGd1YXJkYXJcbiAgICAgICAgY29uc3QgZ3VhcmRhckJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBndWFyZGFyQnRuLnRleHRDb250ZW50ID0gJ0d1YXJkYXInO1xuICAgICAgICBndWFyZGFyQnRuLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgICAgICBjb25zdCBjaGVja2JveGVzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPVwiaGFiaXRvc1wiXTpjaGVja2VkJykpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRIYWJpdHMgPSBjaGVja2JveGVzLm1hcChjaGVja2JveCA9PiBjaGVja2JveC52YWx1ZSk7XG4gICAgXG4gICAgICAgICAgICAvLyBBY3R1YWxpemFyIGVsIGNhbXBvICdoYWJpdG9zJyBlbiBlbCBhcmNoaXZvIFlBTUwgdXNhbmRvIGVsIG1cdTAwRTl0b2RvIHVwZGF0ZVlBTUxGaWVsZHNcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlWUFNTEZpZWxkcyhmaWxlLnBhdGgsICdoYWJpdG9zJywgc2VsZWN0ZWRIYWJpdHMpO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLyBBXHUwMEYxYWRpciBlbCBib3RcdTAwRjNuIGRlIGd1YXJkYXIgYWwgY29udGVuZWRvclxuICAgICAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQoZ3VhcmRhckJ0bik7XG5cbiAgICAgICAgLy8gQWdyZWdhciBib3RcdTAwRjNuIGRlIHNhbGlyIHNpIG5lY2VzYXJpb1xuICAgICAgICBjb25zdCBib3RvblNhbGlyID0gdGhpcy5hZ3JlZ2FyQm90b25TYWxpcihkdik7XG4gICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3RvblNhbGlyKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTVx1MDBFOXRvZG8gYWRhcHRhZG8gcGFyYSBtb3N0cmFyQm90b25CYWxhbmNlUGVyc29uYWxcbiAgICBhc3luYyBtb3N0cmFyQm90b25SZWdpc3Ryb1RhcmVhcyhkdikge1xuICAgICAgICBcbiAgICAgICAgLy8gTGltcGlhciBlbCBjb250ZW5lZG9yXG4gICAgICAgIGR2LmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgbGV0IGJvdG9uZXM7XG4gICAgICAgIGNvbnN0IHV0aWxzQVBJbnN0YW5jZSA9IG5ldyB1dGlsc0FQSSh0aGlzLnBsdWdpbik7XG4gICAgICAgIGNvbnN0IGFjdGl2byA9IGF3YWl0IHV0aWxzQVBJbnN0YW5jZS5idXNjYXJSZWdpc3Ryb3NBY3Rpdm9zKGFwcClcbiAgICAgICAgaWYgKGFjdGl2byBpbnN0YW5jZW9mIFRGaWxlKXsgLy8gVmVyaWZpY2Egc2kgaGF5IGFsZ3VuIGFyY2hpdm8gYWN0aXZvIFxuICAgICAgICAgICAgYm90b25lcyA9IFtcIkNlcnJhZGFzIEhveVwiLCBcIlJlZ2lzdHJvcyBIb3lcIiwgXCJOdWV2byBSZWdpc3RybyBUaWVtcG9cIiwgXCJDZXJyYXIgUmVnaXN0cm8gVGllbXBvXCJdO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGJvdG9uZXMgPSBbXCJDZXJyYWRhcyBIb3lcIiwgXCJSZWdpc3Ryb3MgSG95XCIsIFwiTnVldm8gUmVnaXN0cm8gVGllbXBvXCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXIgeSBtb3N0cmFyIGNhZGEgYm90XHUwMEYzblxuICAgICAgICBib3RvbmVzLmZvckVhY2godGV4dG9Cb3RvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBib3RvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgYm90b24udGV4dENvbnRlbnQgPSB0ZXh0b0JvdG9uO1xuICAgICAgICAgICAgYm90b24ub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2godGV4dG9Cb3Rvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDZXJyYWRhcyBIb3knOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tb3N0cmFyQ2VycmFkYXNIb3koZHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1JlZ2lzdHJvcyBIb3knOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tb3N0cmFyUmVnaXN0cm9zSG95KGR2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDZXJyYXIgUmVnaXN0cm8gVGllbXBvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3Ryb1RpZW1wb0FQSS5jZXJyYXJSZWdpc3RybyhhY3Rpdm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ051ZXZvIFJlZ2lzdHJvIFRpZW1wbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydGVyQVBJbnN0YW5jZSA9IG5ldyBzdGFydGVyQVBJKHRoaXMucGx1Z2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RhcnRlckFQSW5zdGFuY2UuY3JlYXRlTm90ZShcIlJlZ2lzdHJvVGllbXBvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHt0ZXh0b0JvdG9ufSBwcmVzaW9uYWRvLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3Rvbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGJvdG9uU2FsaXIgPSB0aGlzLmFncmVnYXJCb3RvblNhbGlyKGR2KTtcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGJvdG9uU2FsaXIpO1xuICAgIH1cblxuICAgIGFzeW5jIG1vc3RyYXJDZXJyYWRhc0hveShkdikge1xuICAgICAgICBkdi5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgXG4gICAgICAgIGNvbnN0IGFjdGl2byA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICBsZXQgZmVjaGFBY3Rpdm8gPSBhY3Rpdm8/LmJhc2VuYW1lLnNwbGl0KFwiIFwiKVswXTtcbiAgICAgICAgY29uc3QgaG95ID0gbmV3IERhdGUoZmVjaGFBY3Rpdm8pLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIFxuICAgICAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgdGFyZWFzUHJvbWVzYXMgPSBmaWxlcy5tYXAoYXN5bmMgKGZpbGUpID0+IHtcbiAgICAgICAgICAgIGxldCBjb250ZW5pZG8gPSBhd2FpdCBhcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgICAgICAgIGxldCB0YXJlYXNFeHRyYWlkYXMgPSBleHRyYWVyVGFyZWFzKGNvbnRlbmlkbyk7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZnJvbnRNYXR0ZXIgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBmcm9udE1hdHRlcj8uYWxpYXNlcyA/IGZyb250TWF0dGVyLmFsaWFzZXNbMF0gOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLnBhdGg7XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgICBhbGlhcyxcbiAgICAgICAgICAgICAgICB0YXJlYXM6IHRhcmVhc0V4dHJhaWRhcy5maWx0ZXIodGFyZWEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmVjaGFUYXJlYSA9IG5ldyBEYXRlKHRhcmVhLmNvbXBsZXRpb25EYXRlKS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmVhLmNvbXBsZXRlZCAmJiB0YXJlYS5jb21wbGV0aW9uRGF0ZSAmJiBmZWNoYVRhcmVhID09PSBob3k7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgbGV0IHJlc3VsdGFkb3MgPSBhd2FpdCBQcm9taXNlLmFsbCh0YXJlYXNQcm9tZXNhcyk7XG4gICAgICAgIGxldCB0b3RhbFRhcmVhc0NlcnJhZGFzID0gcmVzdWx0YWRvcy5yZWR1Y2UoKHRvdGFsLCB7IHRhcmVhcyB9KSA9PiB0b3RhbCArIHRhcmVhcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIC8vIE1lbnNhamUgc29icmUgZWwgZXN0YWRvIGRlIGxhcyB0YXJlYXMgY2VycmFkYXMgaG95XG4gICAgICAgIGlmICh0b3RhbFRhcmVhc0NlcnJhZGFzID4gMCkge1xuICAgICAgICAgICAgZHYuaGVhZGVyKDMsIGBIb3kgc2UgaGFuIGNlcnJhZG8gJHt0b3RhbFRhcmVhc0NlcnJhZGFzfSB0YXJlYXMuYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAvLyBDcmVhciBsYSB0YWJsYSBIVE1MXG4gICAgICAgIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcbiAgICAgICAgdGFibGUuY2xhc3NMaXN0LmFkZCgndGFibGUnKTsgLy8gQWdyZWdhciB1bmEgY2xhc2UgcGFyYSBsYSB0YWJsYSBwYXJhIGVsIGVzdGlsb1xuICAgICAgICB0YWJsZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBcbiAgICAgICAgLy8gQVx1MDBGMWFkaXIgZW5jYWJlemFkb3MgZGUgdGFibGFcbiAgICAgICAgY29uc3QgaGVhZGVyUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSBbXCJOb3RhXCIsIFwiVGFyZWFzIENlcnJhZGFzXCJdO1xuICAgICAgICBoZWFkZXJzLmZvckVhY2goaGVhZGVyVGV4dCA9PiB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcbiAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9IGhlYWRlclRleHQ7XG4gICAgICAgICAgICBoZWFkZXIuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICBoZWFkZXJSb3cuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKGhlYWRlclJvdyk7XG4gICAgXG4gICAgICAgIC8vIEFcdTAwRjFhZGlyIGZpbGFzIGRlIGRhdG9zIGEgbGEgdGFibGFcbiAgICAgICAgcmVzdWx0YWRvcy5mb3JFYWNoKCh7ZmlsZVBhdGgsIGFsaWFzLCB0YXJlYXN9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGFyZWFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBDb2x1bW5hIGRlIGVubGFjZSBjZW50cmFkbyB2ZXJ0aWNhbG1lbnRlXG4gICAgICAgICAgICAgICAgbGV0IGxpbmtDZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICBsaW5rQ2VsbC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgbGV0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBgb2JzaWRpYW46Ly9vcGVuP3ZhdWx0PSR7YXBwLnZhdWx0LmdldE5hbWUoKX0mZmlsZT0ke2VuY29kZVVSSUNvbXBvbmVudChmaWxlUGF0aCl9YCk7XG4gICAgICAgICAgICAgICAgYS50ZXh0Q29udGVudCA9IGFsaWFzIHx8IGZpbGVQYXRoO1xuICAgICAgICAgICAgICAgIGxpbmtDZWxsLmFwcGVuZENoaWxkKGEpO1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChsaW5rQ2VsbCk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gQ29sdW1uYSBkZSB0YXJlYXMgY2VycmFkYXNcbiAgICAgICAgICAgICAgICBsZXQgdGFza3NDZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICBsZXQgdGFza3NMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgICAgICAgICB0YXJlYXMuZm9yRWFjaCh0YXJlYSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICAgICAgICAgIGxpLnRleHRDb250ZW50ID0gdGFyZWEudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGFza3NMaXN0LmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0YXNrc0NlbGwuYXBwZW5kQ2hpbGQodGFza3NMaXN0KTtcbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodGFza3NDZWxsKTtcbiAgICBcbiAgICAgICAgICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgLy8gQVx1MDBGMWFkaXIgbGEgdGFibGEgYWwgY29udGVuZWRvciBkZSBEYXRhdmlld1xuICAgICAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQodGFibGUpO1xuICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR2LnBhcmFncmFwaChcIk5vIGhheSB0YXJlYXMgY2VycmFkYXMgaG95LlwiKTtcbiAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIGNvbnN0IGJvdG9uU2FsaXIgPSB0aGlzLmFncmVnYXJCb3RvblNhbGlyKGR2KTtcbiAgICAgICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGJvdG9uU2FsaXIpO1xuICAgIFxuICAgIGZ1bmN0aW9uIGV4dHJhZXJUYXJlYXMoY29udGVuaWRvKSB7XG4gICAgICAgIGNvbnN0IHRhcmVhcyA9IFtdO1xuICAgICAgICBjb25zdCBsaW5lYXMgPSBjb250ZW5pZG8uc3BsaXQoXCJcXG5cIik7XG4gICAgXG4gICAgICAgIGZvciAoY29uc3QgbGluZWEgb2YgbGluZWFzKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJlYVJlZ2V4ID0gL15cXHMqLVxccypcXFsoeHxYfCApXFxdXFxzKiguKykkLztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGFyZWFSZWdleC5leGVjKGxpbmVhKTtcbiAgICBcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRhZGEgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpID09PSAneCc7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRvVGFyZWEgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICBsZXQgZmVjaGFDb21wbGV0aXR1ZCA9IG51bGw7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgZmVjaGFSZWdleCA9IC9cXFtjb21wbGV0aW9uOjogKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KVxcXS87XG4gICAgICAgICAgICAgICAgY29uc3QgZmVjaGFNYXRjaCA9IGZlY2hhUmVnZXguZXhlYyh0ZXh0b1RhcmVhKTtcbiAgICAgICAgICAgICAgICBpZiAoZmVjaGFNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBmZWNoYUNvbXBsZXRpdHVkID0gZmVjaGFNYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dG9UYXJlYSA9IHRleHRvVGFyZWEucmVwbGFjZShmZWNoYVJlZ2V4LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICB0YXJlYXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHRvVGFyZWEsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogY29tcGxldGFkYSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbkRhdGU6IGZlY2hhQ29tcGxldGl0dWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmV0dXJuIHRhcmVhcztcbiAgICB9XG4gICAgXG4gICAgXG59XG5cblxuICAgIGFzeW5jIG1vc3RyYXJSZWdpc3Ryb3NIb3koZHYpIHtcbiAgICAgICAgZHYuY29udGFpbmVyLmlubmVySFRNTCA9ICcnOyAvLyBMaW1waWFyIGVsIGNvbnRlbmVkb3IgZGUgRGF0YXZpZXdcbiAgICAgICAgXG4gICAgICAgIC8vIE9idFx1MDBFOW4gbGEgZmVjaGEgYWN0dWFsIGJhc2FkYSBlbiBlbCBub21icmUgZGVsIGFyY2hpdm9cbiAgICAgICAgY29uc3QgZmVjaGFIb3kgPSBEYXRlVGltZS5mcm9tRm9ybWF0KGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpLmJhc2VuYW1lLnNwbGl0KFwiIFwiKVswXSwgJ3l5eXktTU0tZGQnLCB7IGxvY2FsZTogJ2VzJyB9KTtcbiAgICAgICBcbiAgICAgICAgLy8gRW5jdWVudHJhIGFyY2hpdm9zIHF1ZSBjb250aWVuZW4gcmVnaXN0cm9zIGRlIHRpZW1wb1xuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfUmVnaXN0cm9UaWVtcG9cbiAgICAgICAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZpbHRlcihmaWxlID0+IGZpbGUucGF0aC5pbmNsdWRlcyhmb2xkZXIpKTtcblxuICAgICAgICAvLyBMZWUgeSBwcm9jZXNhIGVsIGNvbnRlbmlkbyBkZSBjYWRhIGFyY2hpdm8gcGFyYSBleHRyYWVyIHJlZ2lzdHJvcyBkZSB0aWVtcG9cbiAgICAgICAgbGV0IHRvdGFsRGlhID0gMDtcbiAgICAgICAgbGV0IHJlZ2lzdHJvc0hveSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuXG4gICAgICAgICAgICBpZiAobWV0YWRhdGE/LmhvcmFJbmljaW8pIHtcbiAgICAgICAgICAgICAgICBsZXQgaG9yYUluaWNpbyA9IERhdGVUaW1lLmZyb21Gb3JtYXQobWV0YWRhdGEuaG9yYUluaWNpbywgJ3l5eXktTU0tZGQgRUVFRSBISDptbScsIHsgbG9jYWxlOiAnZXMnIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2ZEYXkgPSBob3JhSW5pY2lvLnN0YXJ0T2YoJ2RheScpO1xuICAgIFxuICAgICAgICAgICAgICAgIGlmIChzdGFydE9mRGF5LnRzID09PSBmZWNoYUhveS5zdGFydE9mKCdkYXknKS50cykge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3Ryb3NIb3kucHVzaCh7cGF0aDogZmlsZS5wYXRoLCBmcm9udG1hdHRlciA6IG1ldGFkYXRhfSk7IC8vIENvcnJlZ2lkbyBwYXJhIGFncmVnYXIgZWwgb2JqZXRvIGFyY2hpdm8gZGlyZWN0YW1lbnRlXG4gICAgICAgICAgICAgICAgICAgIC8vIEFzZWdcdTAwRkFyYXRlIGRlIGNvbnZlcnRpciB0aWVtcG9UcmFiYWphZG8gYSBuXHUwMEZBbWVybyBhbnRlcyBkZSBzdW1hclxuICAgICAgICAgICAgICAgICAgICB0b3RhbERpYSArPSBtZXRhZGF0YS50aWVtcG9UcmFiYWphZG8gPyBwYXJzZUludChtZXRhZGF0YS50aWVtcG9UcmFiYWphZG8pIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW9zdHJhciBlbCB0b3RhbCBkZSB0aWVtcG8gdHJhYmFqYWRvIGhveVxuICAgICAgICBkdi5oZWFkZXIoMywgXCJUaWVtcG8gcmVnaXN0cmFkbyBob3k6IFwiICsgRHVyYXRpb24uZnJvbU1pbGxpcyh0b3RhbERpYSkudG9Gb3JtYXQoJ2hoOm1tOnNzJykpO1xuXG5cbiAgICAgICAgICAgIC8vIE9yZGVuYSBsb3MgcmVnaXN0cm9zIHBvciBob3JhIGRlIGluaWNpbyBhbnRlcyBkZSBnZW5lcmFyIGxhIHRhYmxhXG4gICAgICAgIHJlZ2lzdHJvc0hveS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBWZXJpZmljYSBzaSBob3JhSW5pY2lvIGVzdFx1MDBFMSBwcmVzZW50ZSB5IGVzIHVuYSBjYWRlbmEgdlx1MDBFMWxpZGEgcGFyYSBhbWJvcyBvYmpldG9zXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhLmZyb250bWF0dGVyLmhvcmFJbmljaW8gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBiLmZyb250bWF0dGVyLmhvcmFJbmljaW8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWxsaXNBID0gRGF0ZVRpbWUuZnJvbUZvcm1hdChhLmZyb250bWF0dGVyLmhvcmFJbmljaW8sICd5eXl5LU1NLWRkIEVFRUUgSEg6bW0nLCB7IGxvY2FsZTogJ2VzJyB9KS50b01pbGxpcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlsbGlzQiA9IERhdGVUaW1lLmZyb21Gb3JtYXQoYi5mcm9udG1hdHRlci5ob3JhSW5pY2lvLCAneXl5eS1NTS1kZCBFRUVFIEhIOm1tJywgeyBsb2NhbGU6ICdlcycgfSkudG9NaWxsaXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtaWxsaXNCIC0gbWlsbGlzQTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBhcnNpbmcgZGF0ZXM6XCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYW5lam8gZGUgY2Fzb3MgZG9uZGUgbG9zIGRhdG9zIG5vIHNlYW4gc3RyaW5ncyB2XHUwMEUxbGlkb3NcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGRhdGUgZm9ybWF0IGZvciBzb3J0aW5nOicsIGEuaG9yYUluaWNpbywgYi5ob3JhSW5pY2lvKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG5pZiAocmVnaXN0cm9zSG95Lmxlbmd0aD4wKXtcbi8vIENyZWEgbGEgdGFibGEgSFRNTFxuY29uc3QgdGFibGUgPSBkdi5jb250YWluZXIuY3JlYXRlRWwoJ3RhYmxlJywge2NsczogJ2RhdGF2aWV3IHRhYmxlJ30pO1xudGFibGUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cbi8vIENyZWEgeSBhXHUwMEYxYWRlIGxvcyBlbmNhYmV6YWRvcyBkZSBsYSB0YWJsYVxuY29uc3QgaGVhZGVyID0gZHYuZWwoJ3RyJywgJycsIHRhYmxlKTtcbltcIlJlZ2lzdHJvXCIsIFwiRGVzY3JpcGNpXHUwMEYzblwiLCBcIkhvcmEgSW5pY2lvXCIsIFwiVGllbXBvXCIsIFwiRXN0YWRvXCIsIFwiSWRcIiwgXCJBY2NpXHUwMEYzblwiXS5mb3JFYWNoKHRleHQgPT4gZHYuZWwoJ3RoJywgdGV4dCwgaGVhZGVyKSk7XG5cbi8vIENyZWEgeSBhXHUwMEYxYWRlIGNhZGEgZmlsYSBkZSByZWdpc3RybyBhIGxhIHRhYmxhXG5yZWdpc3Ryb3NIb3kuZm9yRWFjaChyZWdpc3RybyA9PiB7XG4gICAgY29uc3Qgcm93ID0gZHYuZWwoJ3RyJywnJyx0YWJsZSlcbiAgICBkdi5lbCgndGQnLCBkdi5mdW5jLmxpbmsocmVnaXN0cm8ucGF0aCxyZWdpc3Ryby5mcm9udG1hdHRlci5hbGlhc2VzWzBdKSwgcm93KTtcbiAgICAgLy8gQVx1MDBGMWFkZSBsYSBjZWxkYSBkZSBkZXNjcmlwY2lcdTAwRjNuIHkgdFx1MDBFRHR1bG9cbiAgICBkdi5lbCgndGQnLCByZWdpc3Ryby5mcm9udG1hdHRlci5kZXNjcmlwY2lvbiA/IHJlZ2lzdHJvLmZyb250bWF0dGVyLmRlc2NyaXBjaW9uIDogJ1NpbiBkZXNjcmlwY2lcdTAwRjNuJywgcm93KTtcbiAgICBkdi5lbCgndGQnLCBEYXRlVGltZS5mcm9tRm9ybWF0KHJlZ2lzdHJvLmZyb250bWF0dGVyLmhvcmFJbmljaW8sICd5eXl5LU1NLWRkIEVFRUUgSEg6bW0nLCB7IGxvY2FsZTogJ2VzJyB9KS50b0Zvcm1hdCgnaDptbSBhJykgK1xuICAgIFwiIC8gXCIgKyBEYXRlVGltZS5mcm9tRm9ybWF0KHJlZ2lzdHJvLmZyb250bWF0dGVyLmhvcmFGaW5hbCwgJ3l5eXktTU0tZGQgRUVFRSBISDptbScsIHsgbG9jYWxlOiAnZXMnIH0pLnRvRm9ybWF0KCdoOm1tIGEnKSwgcm93KTtcbiAgICBpZiAocmVnaXN0cm8uZnJvbnRtYXR0ZXIuZXN0YWRvID09PSBcIlx1RDgzRFx1REZFMlwiKXtcbiAgICAvLyBTZXBhcmFtb3MgbGEgZmVjaGEgeSBsYSBob3JhLCB5IGVsaW1pbmFtb3MgZWwgZFx1MDBFRGEgZGUgbGEgc2VtYW5hXG4gICAgbGV0IHBhcnRlcyA9IHJlZ2lzdHJvLmZyb250bWF0dGVyLmhvcmFJbmljaW8uc3BsaXQoJyAnKTtcbiAgICAvLyBSZW9yZ2FuaXphbW9zIGxhcyBwYXJ0ZXMgcGFyYSBmb3JtYXIgdW5hIGZlY2hhIGVuIGZvcm1hdG8gXCJZWVlZLU1NLUREVEhIOm1tXCJcbiAgICBsZXQgZmVjaGFIb3JhSVNPID0gYCR7cGFydGVzWzBdfVQke3BhcnRlc1syXX1gO1xuICAgIC8vIFBhcnNlYW1vcyBsYSBmZWNoYSBlbiBmb3JtYXRvIElTT1xuICAgIGxldCBpbmljaW8gPSBEYXRlLnBhcnNlKGZlY2hhSG9yYUlTTyk7XG4gICAgbGV0IGFob3JhID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgZGlmZXJlbmNpYSA9IGFob3JhIC0gaW5pY2lvOyAvLyBEaWZlcmVuY2lhIGVuIG1pbGlzZWd1bmRvc1xuICAgIGR2LmVsKCd0ZCcsIER1cmF0aW9uLmZyb21NaWxsaXMoZGlmZXJlbmNpYSkudG9Gb3JtYXQoJ2g6bW0nKSwgcm93KVxuICAgIH1lbHNle1xuICAgIGR2LmVsKCd0ZCcsIER1cmF0aW9uLmZyb21NaWxsaXMocmVnaXN0cm8uZnJvbnRtYXR0ZXIudGllbXBvVHJhYmFqYWRvKS50b0Zvcm1hdCgnaDptbScpLCByb3cpO1xuICAgIH1cbiAgICBkdi5lbCgndGQnLCByZWdpc3Ryby5mcm9udG1hdHRlci5lc3RhZG8sIHJvdyk7XG4gICAgZHYuZWwoJ3RkJywgcmVnaXN0cm8uZnJvbnRtYXR0ZXIuaWQsIHJvdyk7XG4gICAgaWYgKHJlZ2lzdHJvLmZyb250bWF0dGVyLmVzdGFkbyA9PT0gXCJcdUQ4M0RcdURGRTJcIil7XG4gICAgICAgIGR2LmVsKCd0ZCcsIHRoaXMuY3JlYXRlQnV0dG9uVGFibGUoJ0NlcnJhcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZGVidWdnZXJcbiAgICAgICAgLy8gTFx1MDBGM2dpY2EgcXVlIG1hbmVqYXJcdTAwRTEgZWwgY2xpYyBkZWwgYm90XHUwMEYzbi5cbiAgICAgICAgLy8gUG9yIGVqZW1wbG8sIHJldG9tYXIgbGEgdGFyZWEgcmVwcmVzZW50YWRhIHBvciBgcmVnaXN0cm9gXG4gICAgICAgIGF3YWl0IHRoaXMucmVnaXN0cm9UaWVtcG9BUEkuY2VycmFyUmVnaXN0cm8ocmVnaXN0cm8uZnJvbnRtYXR0ZXIuaWQpO1xuICAgICAgICAvL3RoaXMuY2VycmFyVGFyZWEocmVnaXN0cm8uZnJvbnRtYXR0ZXIuaWQpO1xuICAgICAgICB9KSwgcm93KTtcbiAgICB9ZWxzZXtcbiAgICBkdi5lbCgndGQnLCB0aGlzLmNyZWF0ZUJ1dHRvblRhYmxlKCdSZXRvbWFyJywgKCkgPT4ge1xuICAgICAgICAvLyBMXHUwMEYzZ2ljYSBxdWUgbWFuZWphclx1MDBFMSBlbCBjbGljIGRlbCBib3RcdTAwRjNuLlxuICAgICAgICAvLyBQb3IgZWplbXBsbywgcmV0b21hciBsYSB0YXJlYSByZXByZXNlbnRhZGEgcG9yIGByZWdpc3Ryb2BcbiAgICAgICAgdGhpcy5yZXRvbWFyVGFyZWEocmVnaXN0cm8uZnJvbnRtYXR0ZXIuaWQpO1xuICAgICAgICB9KSwgcm93KTtcbiAgICB9XG4gICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJvdG9uU2FsaXIgPSB0aGlzLmFncmVnYXJCb3RvblNhbGlyKGR2KTtcbiAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQoYm90b25TYWxpcik7XG4gICAgXG59XG5cbiAgICBjcmVhdGVCdXR0b25UYWJsZShidXR0b25UZXh0LCBvbkNsaWNrQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IGJ1dHRvblRleHQ7XG4gICAgICAgIGJ1dHRvbi50eXBlID0gJ2J1dHRvbic7IC8vIEFzZWdcdTAwRkFyYXRlIGRlIHF1ZSBubyBzZSBlbnZpYXJcdTAwRTEgdW4gZm9ybXVsYXJpbyBhbCBoYWNlciBjbGljIGVuIFx1MDBFOWxcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3lvdXItYnV0dG9uLWNsYXNzJyk7IC8vIEFncmVnYSB1bmEgY2xhc2UgcGFyYSBlbCBlc3RpbG8gZGVsIGJvdFx1MDBGM24gc2kgZXMgbmVjZXNhcmlvXG5cbiAgICAgICAgLy8gQVx1MDBGMWFkZSBlbCBldmVudG8gZGUgY2xpYyBhbCBib3RcdTAwRjNuXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2tDYWxsYmFjayk7XG5cbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLy8gQ3JlYSBsYSBub3RhIGRlc2RlIGVsIHRlbXBsYXRlciBkZSBSZWdpc3Ryb1RpZW1wb1xuICAgIGFzeW5jIHJldG9tYXJUYXJlYShpZCkgeyBcbiAgICAgICAgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgcmVlbXBsYXphciAncnV0YS9hbC9hcmNoaXZvLm1kJyBjb24gbGEgcnV0YSBleGFjdGEgZGVsIGFyY2hpdm8gcXVlIGRlc2VhcyBvYnRlbmVyXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGBQbGFudGlsbGFzLyR7dGhpcy5wbHVnaW4uc2V0dGluZ3NbYGZvbGRlcl9SZWdpc3Ryb1RpZW1wb2BdfS9QbHQgLSBSZWdpc3Ryb1RpZW1wby5tZGA7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCk7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgIC8vIEFob3JhICdmaWxlJyBlcyB0dSBhcmNoaXZvIGRlc2VhZG8sIHkgcHVlZGVzIHRyYWJhamFyIGNvbiBcdTAwRTlsIGNvbW8gbmVjZXNpdGVzXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFyY2hpdm8gZW5jb250cmFkbzpcIiwgdGVtcGxhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2kgZWwgYXJjaGl2byBubyBzZSBlbmNvbnRyXHUwMEYzLCAnZmlsZScgc2VyXHUwMEUxIG51bGxcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXJjaGl2byBubyBlbmNvbnRyYWRvLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IFwiUmV0b21hciBcIiArIGlkO1xuICAgICAgICBjb25zdCBmb2xkZXIgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKFwiSW5ib3hcIik7XG4gICAgICAgIGNvbnN0IHRwID0gdGhpcy5nZXRUcCgpO1xuICAgICAgICBsZXQgY3JlYXJOb3RhID0gdHAuZmlsZS5zdGF0aWNfZnVuY3Rpb25zLmdldChcImNyZWF0ZV9uZXdcIilcbiAgICAgICAgYXdhaXQgY3JlYXJOb3RhICh0ZW1wbGF0ZSwgZmlsZW5hbWUsIGZhbHNlLCBmb2xkZXIpLmJhc2VuYW1lO1xuICAgICAgfVxuXG4gICAgZ2V0VHAoKXtcbiAgICAgICAgaWYgKCF0aGlzLnBsdWdpbiB8fCAhdGhpcy5wbHVnaW4uYXBwLnBsdWdpbnMuZW5hYmxlZFBsdWdpbnMuaGFzKCd0ZW1wbGF0ZXItb2JzaWRpYW4nKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRWwgcGx1Z2luIFRlbXBsYXRlciBubyBlc3RcdTAwRTEgaGFiaWxpdGFkby4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAgIFxuICAgICAgICBsZXQgdHBHZW4gPSB0aGlzLnBsdWdpbi5hcHAucGx1Z2lucy5wbHVnaW5zW1widGVtcGxhdGVyLW9ic2lkaWFuXCJdLnRlbXBsYXRlcjtcbiAgICAgICAgdHBHZW4gPSB0cEdlbi5mdW5jdGlvbnNfZ2VuZXJhdG9yLmludGVybmFsX2Z1bmN0aW9ucy5tb2R1bGVzX2FycmF5O1xuICAgICAgICBsZXQgdHAgPSB7fVxuICAgICAgICAvLyBnZXQgYW4gaW5zdGFuY2Ugb2YgbW9kdWxlc1xuICAgICAgICB0cC5maWxlID0gdHBHZW4uZmluZChtID0+IG0ubmFtZSA9PSBcImZpbGVcIik7XG4gICAgICAgIHRwLnN5c3RlbSA9IHRwR2VuLmZpbmQobSA9PiBtLm5hbWUgPT0gXCJzeXN0ZW1cIik7XG5cbiAgICAgICAgaWYgKCF0cC5maWxlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBzZSBwdWRvIGFjY2VkZXIgYWwgb2JqZXRvIGRlIGZ1bmNpb25lcyBhY3R1YWxlcyBkZSBUZW1wbGF0ZXIuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ3RwIGNvbiBwcm9waWVkYWRlcyBcImZpbGVcIiBzZSBoYSBjYXJnYWRvIHNhdGlzZmFjdG9yaWFtZW50ZScpO1xuICAgICAgICByZXR1cm4gdHA7XG4gICAgfVxuXG59XG4gICAgXG4iLCAiaW1wb3J0IHsgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gJ2x1eG9uJztcblxuZXhwb3J0IGNsYXNzIFZpc3RhUmVzdW1lblNlbWFuYWwgZXh0ZW5kcyBJdGVtVmlldyB7XG4gICAgaW50ZXJ2YWxJZDogbnVtYmVyO1xuIFxuXG4gICAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcHVibGljIHBsdWdpbjogYW55KSB7XG4gICAgICAgIHN1cGVyKGxlYWYpO1xuICAgIH1cblxuICAgIGdldFZpZXdUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ2aXN0YS1yZXN1bWVuLXNlbWFuYWxcIjtcbiAgICB9XG5cbiAgICBnZXREaXNwbGF5VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVzdW1lbiBTZW1hbmFsXCI7XG4gICAgfVxuXG4gICAgZ2V0SWNvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiaGlzdG9yeVwiOyAvLyBFc3RlIGVzIHVuIGVqZW1wbG8sIGNhbWJpYSBcImRvY3VtZW50b1wiIHBvciBlbCBub21icmUgZGVsIFx1MDBFRGNvbm8gcXVlIGRlc2VlcyB1c2FyXG4gICAgfVxuXG4gICAgYXN5bmMgb25PcGVuKCkge1xuICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKCFhY3RpdmVGaWxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbC5zZXRUZXh0KFwiTm8gaGF5IHVuIGFyY2hpdm8gYWN0aXZvLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVDYWNoZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGFjdGl2ZUZpbGUpO1xuICAgICAgICBhd2FpdCB0aGlzLmFjdHVhbGl6YXJWaXN0YShmaWxlQ2FjaGUpOyAvLyBQdWVkZXMgdXNhciB0aGlzLmZpbGUgZGVudHJvIGRlIGFjdHVhbGl6YXJWaXN0YVxuICAgIFxuICAgICAgICAvL2F3YWl0IHRoaXMuYWN0dWFsaXphclZpc3RhKCk7IC8vIEFjdHVhbGl6YSBsYSB2aXN0YSBpbm1lZGlhdGFtZW50ZSBhbCBhYnJpclxuXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFjdHVhbGl6YXJWaXN0YShmaWxlQ2FjaGUpOyAvLyBBY3R1YWxpemEgbGEgdmlzdGEgY2FkYSAxMCBzZWd1bmRvc1xuICAgICAgICB9LCAxMDAwMCk7XG4gICAgfVxuICAgIFxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTsgLy8gTGltcGlhIGVsIGludGVydmFsbyBhbCBjZXJyYXIgbGEgdmlzdGFcbiAgICB9XG5cbiAgICBhc3luYyBhY3R1YWxpemFyVmlzdGEoZmlsZUNhY2hlKSB7XG4gICAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7IC8vIExpbXBpYSBlbCBjb250ZW5pZG8gZXhpc3RlbnRlIGFudGVzIGRlIGFjdHVhbGl6YXJcbiAgICBcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGluaWNpb1dTdHIgPSBmaWxlQ2FjaGUuZnJvbnRtYXR0ZXI/LmluaWNpb1c7IFxuICAgICAgICBpZiAoIWluaWNpb1dTdHIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsLnNldFRleHQoXCJMYSBjb25maWd1cmFjaVx1MDBGM24gZGUgaW5pY2lvVyBubyBlc3RcdTAwRTEgZXN0YWJsZWNpZGEuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvbGRlckRpYXJpbyA9IFwiRXN0cnVjdHVyYS9Kb3VybmFsL0RpYXJpby9Ob3Rhc1wiO1xuICAgICAgICBjb25zdCBpbmljaW9XID0gRGF0ZVRpbWUuZnJvbUZvcm1hdChpbmljaW9XU3RyLCBcInl5eXktTU0tZGQgRUVFRVwiLCB7IGxvY2FsZTogXCJlc1wiIH0pO1xuICAgICAgICBjb25zdCBmaW5XID0gaW5pY2lvVy5wbHVzKHsgZGF5czogNiB9KTsgLy8gQWp1c3RlIHBhcmEgYXNlZ3VyYXIgcXVlIGVsIGZpbiBlcyBlbCBkb21pbmdvIGRlIGxhIG1pc21hIHNlbWFuYVxuICAgIFxuICAgICAgICBjb25zdCBhcmNoaXZvc0RpYXJpbyA9IHRoaXMuYXBwLnZhdWx0LmdldEZpbGVzKClcbiAgICAgICAgICAgIC5maWx0ZXIoZmlsZSA9PiBmaWxlLnBhdGguc3RhcnRzV2l0aChmb2xkZXJEaWFyaW8pICYmIGZpbGUuZXh0ZW5zaW9uID09PSAnbWQnKTtcbiAgICBcbiAgICAgICAgY29uc3QgYml0YWNvcmFzID0gYXJjaGl2b3NEaWFyaW9cbiAgICAgICAgICAgIC5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmVjaGFBcmNoaXZvID0gRGF0ZVRpbWUuZnJvbUlTTyhmaWxlLmJhc2VuYW1lLnN1YnN0cmluZygwLCAxMCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdG9zID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFyY2hpdm86IGZpbGUuYmFzZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZmVjaGFBcmNoaXZvLFxuICAgICAgICAgICAgICAgICAgICBkYXRvc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeyBmZWNoYUFyY2hpdm8gfSkgPT4gZmVjaGFBcmNoaXZvID49IGluaWNpb1cgJiYgZmVjaGFBcmNoaXZvIDw9IGZpblcpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5mZWNoYUFyY2hpdm8udG9NaWxsaXMoKSAtIGIuZmVjaGFBcmNoaXZvLnRvTWlsbGlzKCkpO1xuICAgIFxuICAgICAgICAvLyBDcmVhciB0XHUwMEVEdHVsbyBjb24gbGFzIGZlY2hhcyBkZSBsYSBzZW1hbmFcbiAgICAgICAgbGV0IHRyaW0gPSBmaW5XLnF1YXJ0ZXI7XG4gICAgICAgIGxldCBzZW0gPSAoZmluVy53ZWVrTnVtYmVyIC0gKGZpblcucXVhcnRlciAtIDEpKjEzKVxuICAgICAgICBpZiAoc2VtPT0wKXtzZW0gPSAxM31cblxuICAgICAgICBjb25zdCB0aXR1bG8gPSB0aGlzLmNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6IGBSZXN1bWVuIGRlIGxhIHNlbWFuYSAke3NlbX0gLSBRJHt0cmltfSAvIFcke2ZpblcudG9Gb3JtYXQoJ1dXJyl9LmB9KTtcbiAgICAgICAgY29uc3Qgc3VidGl0dWxvID0gdGhpcy5jb250ZW50RWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiBgRGVzZGUgZWwgJHtpbmljaW9XLnRvRm9ybWF0KCdFRUVFLCBERCcpfSBhbCAke2ZpblcudG9Gb3JtYXQoJ0VFRUUsIEREJyl9YCB9KTtcbiAgICAgICAgdGl0dWxvLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBzdWJ0aXR1bG8uc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIC8vIENyZWFyIHRhYmxhXG4gICAgICAgIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcbiAgICAgICAgdGFibGUuY2xhc3NOYW1lID0gJ3RhYmxlLXJlc3VtZW5TZW1hbmFsJztcbiAgICBcbiAgICAgICAgLy8gQ3JlYXIgY2FiZWNlcmEgZGUgbGEgdGFibGFcbiAgICAgICAgY29uc3QgdGhlYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aGVhZCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICBbJ0RcdTAwRURhJywgJ1Jlc3VtZW4nXS5mb3JFYWNoKGhlYWRlclRleHQgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xuICAgICAgICAgICAgdGgudGV4dENvbnRlbnQgPSBoZWFkZXJUZXh0O1xuICAgICAgICAgICAgaGVhZGVyUm93LmFwcGVuZENoaWxkKHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoZWFkLmFwcGVuZENoaWxkKGhlYWRlclJvdyk7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRoZWFkKTtcbiAgICBcbiAgICAgICAgLy8gQ3JlYXIgY3VlcnBvIGRlIGxhIHRhYmxhXG4gICAgICAgIGNvbnN0IHRib2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgICAgICAgYml0YWNvcmFzLmZvckVhY2goKHsgYXJjaGl2bywgcGF0aCwgZGF0b3MgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgIFxuICAgICAgICAgICAgY29uc3QgdGRBcmNoaXZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGxpbmtFbC50ZXh0Q29udGVudCA9IGFyY2hpdm87XG4gICAgICAgICAgICBsaW5rRWwuaHJlZiA9IHBhdGg7XG4gICAgICAgICAgICBsaW5rRWwub25jbGljayA9IGFzeW5jIChldikgPT4ge1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKS5vcGVuRmlsZShmaWxlLCB7IGVTdGF0ZTogeyBmb2N1czogdHJ1ZSB9IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0ZEFyY2hpdm8uYXBwZW5kQ2hpbGQobGlua0VsKTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHRkUmVzdW1lbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICBjb25zdCB1bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgICAgICAoZGF0b3MudGl0dWxvIHx8IFsnU2luIHRcdTAwRUR0dWxvJ10pLmZvckVhY2godGl0dWxvID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICAgICAgbGkudGV4dENvbnRlbnQgPSB0aXR1bG87XG4gICAgICAgICAgICAgICAgdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0ZFJlc3VtZW4uYXBwZW5kQ2hpbGQodWwpO1xuICAgIFxuICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGRBcmNoaXZvKTtcbiAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkUmVzdW1lbik7XG4gICAgXG4gICAgICAgICAgICB0Ym9keS5hcHBlbmRDaGlsZCh0cik7XG4gICAgICAgIH0pO1xuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZCh0Ym9keSk7XG4gICAgXG4gICAgICAgIC8vIEFncmVnYXIgbGEgdGFibGEgYWwgY29udGVuZWRvclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5hcHBlbmRDaGlsZCh0YWJsZSk7XG4gICAgfVxuICAgIFxuICAgIFxuXG5cbiAgICAvLyBPcGNpb25hbDogSW1wbGVtZW50YSBvbkNsb3NlIHNpIG5lY2VzaXRhcyBsaW1waWV6YSBhbCBjZXJyYXIgbGEgdmlzdGEuXG59IiwgImltcG9ydCB7IEl0ZW1WaWV3LCBXb3Jrc3BhY2VMZWFmLCBQbHVnaW4sIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBEYXRlVGltZSwgRHVyYXRpb24gfSBmcm9tIFwibHV4b25cIjsgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgdGVuZXIgTHV4b24gZGlzcG9uaWJsZSBwYXJhIG1hbmlwdWxhciBmZWNoYXMgeSBob3Jhc1xuaW1wb3J0IHsgcmVnaXN0cm9UaWVtcG9BUEkgfSBmcm9tIFwiLi4vQVBJL3JlZ2lzdHJvVGllbXBvQVBJXCI7XG5pbXBvcnQgeyBzdGFydGVyQVBJIH0gZnJvbSBcIi4uLy4uL25vdGVMaWZlY3ljbGVNYW5hZ2VyL0FQSS9zdGFydGVyQVBJXCI7XG5cbmV4cG9ydCBjbGFzcyBWaXN0YVJlZ2lzdHJvQWN0aXZvIGV4dGVuZHMgSXRlbVZpZXcge1xuICAgIHBsdWdpbiA6IFBsdWdpbjtcbiAgICBjb25zdHJ1Y3RvcihsZWFmOiBXb3Jrc3BhY2VMZWFmLCBwbHVnaW46IFBsdWdpbikge1xuICAgICAgICBzdXBlcihsZWFmKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMucmVnaXN0cm9UaWVtcG9BUEkgPSBuZXcgcmVnaXN0cm9UaWVtcG9BUEkodGhpcy5wbHVnaW4pO1xuICAgIH1cblxuICAgIGdldFZpZXdUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ2aXN0YS1yZWdpc3Ryby1hY3Rpdm9cIjtcbiAgICB9XG5cbiAgICBnZXREaXNwbGF5VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVnaXN0cm8gQWN0aXZvXCI7XG4gICAgfVxuXG4gICAgZ2V0SWNvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiY2hlY2ttYXJrXCI7IC8vIENhbWJpYSBhIHVuIFx1MDBFRGNvbm8gYWRlY3VhZG8gcGFyYSByZWdpc3Ryb3MgYWN0aXZvc1xuICAgIH1cblxuICAgIGFzeW5jIG9uT3BlbigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hY3R1YWxpemFyVmlzdGEoKTsgLy8gQWN0dWFsaXphIGxhIHZpc3RhIGlubWVkaWF0YW1lbnRlIGFsIGFicmlyXG4gICAgXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWN0dWFsaXphclZpc3RhKCk7IC8vIEFjdHVhbGl6YSBsYSB2aXN0YSBjYWRhIDUgc2VndW5kb3NcbiAgICAgICAgfSwgNTAwMCk7XG4gICAgfVxuICAgIFxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTsgLy8gTGltcGlhIGVsIGludGVydmFsbyBhbCBjZXJyYXIgbGEgdmlzdGFcbiAgICB9XG5cbiAgICBhc3luYyBhY3R1YWxpemFyVmlzdGEoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuZW1wdHkoKTsgLy8gTGltcGlhIGVsIGNvbnRlbmlkbyBleGlzdGVudGUgYW50ZXMgZGUgYWN0dWFsaXphclxuXG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9SZWdpc3Ryb1RpZW1wbzsgLy8gQWp1c3RhIGVzdG8gYWwgZGlyZWN0b3JpbyBkb25kZSBndWFyZGFzIHR1cyByZWdpc3Ryb3NcbiAgICAgICAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZpbHRlcihmaWxlID0+IGZpbGUucGF0aC5pbmNsdWRlcyhmb2xkZXIpKTtcbiAgICAgICAgbGV0IHJlZ2lzdHJvc0FjdGl2b3MgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuXG4gICAgICAgICAgICBpZiAobWV0YWRhdGE/LmVzdGFkbyA9PT0gXCJcdUQ4M0RcdURGRTJcIikge1xuICAgICAgICAgICAgICAgIGxldCByZWdpc3Ryb0FjdGl2byA9IHtmaWxlfTsgLy8gQXN1bWllbmRvIHF1ZSBxdWllcmVzIGd1YXJkYXIgZWwgcGF0aCBkZWwgYXJjaGl2b1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVnaXN0cm9BY3Rpdm8sIG1ldGFkYXRhKTsgLy8gQWdyZWdhIGVsIG1ldGFkYXRhIGFsIG9iamV0byByZWdpc3Ryb0FjdGl2b1xuICAgICAgICAgICAgICAgIHJlZ2lzdHJvc0FjdGl2b3MucHVzaChyZWdpc3Ryb0FjdGl2byk7IC8vIEFcdTAwRjFhZGUgZWwgcmVnaXN0cm8gYWN0aXZvIGFsIGFycmF5ICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWEgbGEgdGFibGEgSFRNTCBwYXJhIG1vc3RyYXIgbGEgaW5mb3JtYWNpXHUwMEYzblxuICAgICAgICBpZiAocmVnaXN0cm9zQWN0aXZvcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdObyBoYXkgbmluZ1x1MDBGQW4gcmVnaXN0cm8gZGUgdGllbXBvIGVqZWN1dGFuZG9zZS4nIH0pO1xuICAgICAgICAgICAgY29uc3QgYm90b25DcmVhciA9IHRoaXMuY29udGFpbmVyRWwuY3JlYXRlRWwoJ2J1dHRvbicpO1xuICAgICAgICAgICAgYm90b25DcmVhci50ZXh0Q29udGVudCA9ICdOdWV2byBSZWdpc3RybyBUaWVtcG8nO1xuICAgICAgICAgICAgYm90b25DcmVhci5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ZXJBUEluc3RhbmNlID0gbmV3IHN0YXJ0ZXJBUEkodGhpcy5wbHVnaW4pXG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhcnRlckFQSW5zdGFuY2UuY3JlYXRlTm90ZShcIlJlZ2lzdHJvVGllbXBvXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWwuY3JlYXRlRWwoJ2RpdicsIHtjbHM6ICdzZXBhcmFkb3InfSk7XG4gICAgICAgICAgICAvLyBMb2dpY2EgcGFyYSBjcmVhciB0YWJsYSBzZW5jaWxsYSBkZSA1IHVsdGltb3MgUlRcbiAgICAgICAgICAgIGxldCByZWdpc3Ryb3NGaW5hbGl6YWRvcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGE/LmVzdGFkbyA9PT0gXCJcdUQ4M0RcdUREMzVcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVnaXN0cm9GaW5hbGl6YWRvID0ge2ZpbGV9OyAvLyBBc3VtaWVuZG8gcXVlIHF1aWVyZXMgZ3VhcmRhciBlbCBwYXRoIGRlbCBhcmNoaXZvXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVnaXN0cm9GaW5hbGl6YWRvLCBtZXRhZGF0YSk7IC8vIEFncmVnYSBlbCBtZXRhZGF0YSBhbCBvYmpldG8gcmVnaXN0cm9BY3Rpdm9cbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0cm9zRmluYWxpemFkb3MucHVzaChyZWdpc3Ryb0ZpbmFsaXphZG8pOyAvLyBBXHUwMEYxYWRlIGVsIHJlZ2lzdHJvIGFjdGl2byBhbCBhcnJheSAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3JkZW5hIGxvcyByZWdpc3Ryb3MgYWN0aXZvcyBwb3IgZWwgY2FtcG8gJ2lkJyBkZSBtYW5lcmEgZGVzY2VuZGVudGVcbiAgICAgICAgICAgIHJlZ2lzdHJvc0ZpbmFsaXphZG9zLnNvcnQoKGEsIGIpID0+IGIuaWQgLSBhLmlkKTtcbiAgICAgICAgICAgIC8vIFNlbGVjY2lvbmEgbG9zIHByaW1lcm9zIDUgcmVnaXN0cm9zIGRlc3B1XHUwMEU5cyBkZSBvcmRlbmFyXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCB0b3A1UmVnaXN0cm9zQWN0aXZvcyA9IHJlZ2lzdHJvc0ZpbmFsaXphZG9zLnNsaWNlKDAsIDgpO1xuICAgICAgICAgICAgLy8gQWhvcmEgdG9wNVJlZ2lzdHJvc0FjdGl2b3MgY29udGllbmUgbG9zIDUgYXJjaGl2b3MgY29uIGxvcyBJRCBtXHUwMEUxcyBhbHRvc1xuXG5cbiAgICAgICAgICAgIGlmICh0b3A1UmVnaXN0cm9zQWN0aXZvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbC5jbGFzc0xpc3QuYWRkKFwidGFibGUtY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5jb250YWluZXJFbC5jcmVhdGVFbCgndGFibGUnLCB7Y2xzOiAndGFibGUtc21hbGwnfSk7XG4gICAgICAgICAgICAgICAgdGFibGUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdGFibGUuY3JlYXRlRWwoJ3RyJyk7XG4gICAgICAgICAgICAgICAgW1wiQWxpYXNcIiwgXCJEZXNjcmlwY2lcdTAwRjNuXCIsIFwiUmV0b21hclwiXS5mb3JFYWNoKHRleHQgPT4gaGVhZGVyLmNyZWF0ZUVsKCd0aCcsIHt0ZXh0OiB0ZXh0fSkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRvcDVSZWdpc3Ryb3NBY3Rpdm9zLmZvckVhY2gocmVnaXN0cm8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGFibGUuY3JlYXRlRWwoJ3RyJyk7XG4gICAgICAgICAgICAgICAgICAgIC8qIFNpbiBMaW5rXG4gICAgICAgICAgICAgICAgICAgIHJvdy5jcmVhdGVFbCgndGQnLCB7dGV4dDogcmVnaXN0cm8uYWxpYXNlc1swXX0pO1xuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgIC8vIENvbiBsaW5rXG4gICAgICAgICAgICAgICAgICAgLy8gQ3JlYSB1bmEgY2VsZGEgcGFyYSBlbCBhbGlhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhIHVuYSBjZWxkYSBwYXJhIGVsIGFsaWFzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzQ2VsbCA9IHJvdy5jcmVhdGVFbCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYSB1biBlbGVtZW50byBzcGFuIHBhcmEgY29udGVuZXIgZWwgYWxpYXMgY29tbyB0ZXh0b1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGlhc0xpbmsgPSBhbGlhc0NlbGwuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiByZWdpc3Ryby5hbGlhc2VzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiAnY2xpY2thYmxlLWFsaWFzJyAvLyBVbmEgY2xhc2UgcGFyYSBlc3RpbGl6YXIsIHNpIGVzIG5lY2VzYXJpb1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEVzdGFibGVjZSBlbCBjb21wb3J0YW1pZW50byBhbCBoYWNlciBjbGljIGVuIGVsIGFsaWFzXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzTGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2J0aWVuZSBlbCBhcmNoaXZvIHBvciBzdSBydXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocmVnaXN0cm8uZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBYnJlIGVsIGFyY2hpdm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhcHAud29ya3NwYWNlLmdldExlYWYodHJ1ZSkub3BlbkZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByb3cuY3JlYXRlRWwoJ3RkJywge3RleHQ6IHJlZ2lzdHJvLmRlc2NyaXBjaW9uIHx8IFwiTm8gRGVmaW5pZGFcIn0pO1xuICAgICAgICAgICAgICAgICAgIC8vIENyZWEgdW5hIG51ZXZhIGNlbGRhIHBhcmEgZWwgYm90XHUwMEYzblxuICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbkNlbGwgPSByb3cuY3JlYXRlRWwoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICAgLy8gQ3JlYSBlbCBib3RcdTAwRjNuIHkgYVx1MDBGMVx1MDBFMWRlbG8gYSBsYSBudWV2YSBjZWxkYVxuICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uVGFibGUoJ1x1MjNGMVx1RkUwRicsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0cm9UaWVtcG9BUEkucmV0b21hclRhcmVhKHJlZ2lzdHJvLmlkKTtcbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2VsbC5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHt0ZXh0OiAnTm8gaGF5IHJlZ2lzdHJvcyBmaW5hbGl6YWRvcy4nfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfWVsc2UgaWYgKHJlZ2lzdHJvc0FjdGl2b3MubGVuZ3RoID09PSAxKXtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWwuY2xhc3NMaXN0LmFkZChcInZpc3RhLVJUXCIpO1xuICAgICAgICAgICAgbGV0IGFsaWFzID0gcmVnaXN0cm9zQWN0aXZvc1swXS5hbGlhc2VzID8gcmVnaXN0cm9zQWN0aXZvc1swXS5hbGlhc2VzWzBdIDogJ1NpbiBhbGlhcyc7XG4gICAgICAgICAgICBsZXQgZGVzY3JpcGNpb24gPSByZWdpc3Ryb3NBY3Rpdm9zWzBdLmRlc2NyaXBjaW9uID8gcmVnaXN0cm9zQWN0aXZvc1swXS5kZXNjcmlwY2lvbiA6ICdTaW4gZGVzY3JpcGNpb24nO1xuICAgICAgICAgICAgbGV0IHBhcnRlcyA9IHJlZ2lzdHJvc0FjdGl2b3NbMF0uaG9yYUluaWNpby5zcGxpdCgnICcpO1xuICAgICAgICAgICAgbGV0IGZlY2hhSG9yYUlTTyA9IGAke3BhcnRlc1swXX1UJHtwYXJ0ZXNbMl19YDtcbiAgICAgICAgICAgIGxldCBpbmljaW8gPSBEYXRlVGltZS5mcm9tSVNPKGZlY2hhSG9yYUlTTyk7XG4gICAgICAgICAgICBsZXQgYWhvcmEgPSBEYXRlVGltZS5ub3coKTtcbiAgICAgICAgICAgIGxldCBkaWZlcmVuY2lhID0gYWhvcmEuZGlmZihpbmljaW8pO1xuICAgICAgICAgICAgbGV0IHRpZW1wbyA9IER1cmF0aW9uLmZyb21NaWxsaXMoZGlmZXJlbmNpYS50b01pbGxpcygpKS50b0Zvcm1hdCgnaDptbScpXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoNScsIHsgdGV4dDogJ1RhcmVhIEFjdHVhbCd9KTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbC5jcmVhdGVFbCgnc3BhbicsIHsgdGV4dDogJ05vbWJyZTogJ30pO1xuICAgICAgICAgICAgLy8gTW9kaWZpY2FkbyBwYXJhIGNyZWFyIHVuIGVsZW1lbnRvIHNwYW4gY2xpY2tlYWJsZSBwYXJhIGVsIGFsaWFzXG4gICAgICAgICAgICBjb25zdCBhbGlhc1NwYW4gPSB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgICAgICAgICAgIHRleHQ6IGFsaWFzLFxuICAgICAgICAgICAgICAgIGNsczogJ2NsaWNrYWJsZS1hbGlhcycgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgdGVuZXIgZXN0YSBjbGFzZSBwYXJhIGVzdGlsaXphciBlbCBzcGFuIGNvbW8gdW4gbGlua1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbGlhc1NwYW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHJlZ2lzdHJvc0FjdGl2b3NbMF0uZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFwcC53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKS5vcGVuRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbC5jcmVhdGVFbCgnc3BhbicsIHsgdGV4dDogJ1xcbicgKyBkZXNjcmlwY2lvbiB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdFc3RhIHRhcmVhIGxsZXZhOiAnICsgdGllbXBvIH0pO1xuICAgICAgICAgICAgY29uc3QgYm90b25lcmEgPSB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdG9uQ2VycmFyID0gYm90b25lcmEuY3JlYXRlRWwoJ2J1dHRvbicpO1xuICAgICAgICAgICAgYm90b25DZXJyYXIudGV4dENvbnRlbnQgPSAnQ2VycmFyIFRhcmVhJztcbiAgICAgICAgICAgIGJvdG9uQ2VycmFyLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3Ryb1RpZW1wb0FQSS5jZXJyYXJSZWdpc3RybyhyZWdpc3Ryb3NBY3Rpdm9zWzBdLmZpbGUpOyAvLyBSZXN0YWJsZWNlciBhIGxhIHZpc3RhIGRlbCBib3RcdTAwRjNuIGRlIG1lblx1MDBGQSBpbmljaWFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYm90b25EZXRhbGxlID0gYm90b25lcmEuY3JlYXRlRWwoJ2J1dHRvbicpO1xuICAgICAgICAgICAgYm90b25EZXRhbGxlLnRleHRDb250ZW50ID0gJ0NhbWJpYXIgRGVzY3JpcGNpXHUwMEYzbic7XG4gICAgICAgICAgICBib3RvbkRldGFsbGUub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlZ2lzdHJvVGllbXBvQVBJLmRldGFsbGVSZWdpc3RybyhyZWdpc3Ryb3NBY3Rpdm9zWzBdLmZpbGUpOyAvLyBSZXN0YWJsZWNlciBhIGxhIHZpc3RhIGRlbCBib3RcdTAwRjNuIGRlIG1lblx1MDBGQSBpbmljaWFsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHt0ZXh0OiAnIEhheSB1biBlcnJvciBjb24gbGEgY2FudGlkYWQgZGUgcmVnaXN0cm9zIGFjdGl2b3MuJ30pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlQnV0dG9uVGFibGUoYnV0dG9uVGV4dCwgb25DbGlja0NhbGxiYWNrKSB7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gYnV0dG9uVGV4dDtcbiAgICAgICAgYnV0dG9uLnR5cGUgPSAnYnV0dG9uJzsgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgcXVlIG5vIHNlIGVudmlhclx1MDBFMSB1biBmb3JtdWxhcmlvIGFsIGhhY2VyIGNsaWMgZW4gXHUwMEU5bFxuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgneW91ci1idXR0b24tY2xhc3MnKTsgLy8gQWdyZWdhIHVuYSBjbGFzZSBwYXJhIGVsIGVzdGlsbyBkZWwgYm90XHUwMEYzbiBzaSBlcyBuZWNlc2FyaW9cblxuICAgICAgICAvLyBBXHUwMEYxYWRlIGVsIGV2ZW50byBkZSBjbGljIGFsIGJvdFx1MDBGM25cbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGlja0NhbGxiYWNrKTtcblxuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICBcbiAgICBcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgcmVnaXN0ZXJDb21tYW5kcywgZGVhY3RpdmF0ZUNvbW1hbmRzIH0gZnJvbSBcIi4vY29tbWFuZHNcIjtcblxuZXhwb3J0IGNsYXNzIE1vZHVsb0dURCB7XG4gICAgcGx1Z2luOiBQbHVnaW47XG4gICAgbW9kdWxvR1REOiBNb2R1bG9HVEQgfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogUGx1Z2luKSB7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5tb2R1bG9HVEQpIHJldHVybjsgLy8gU2kgeWEgZXN0XHUwMEUxIGFjdGl2bywgbm8gaGFjZXIgbmFkYVxuXG4gICAgICAgIHJlZ2lzdGVyQ29tbWFuZHModGhpcy5wbHVnaW4pO1xuICAgIH1cblxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2R1bG9HVEQpIHJldHVybjsgLy8gU2kgeWEgZXN0XHUwMEUxIGRlc2FjdGl2YWRvLCBubyBoYWNlciBuYWRhXG4gICAgICAgIGRlYWN0aXZhdGVDb21tYW5kcyh0aGlzLnBsdWdpbik7XG4gICAgICAgXG4gICAgfVxuXG5cbn0iLCAiaW1wb3J0IHsgTm90aWNlLCBQbHVnaW4sIFRGaWxlLCBNYXJrZG93blZpZXcsIEFsZXJ0IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tICdsdXhvbic7XG5pbXBvcnQgeyBCYW5kZWphRGVFbnRyYWRhTW9kYWx9IGZyb20gJy4uL21vZGFsZXMvaW5ib3hNb2RhbCdcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluZ3Jlc2FyQmFuZGVqYUVudHJhZGEocGx1Z2luOiBQbHVnaW4pOiB2b2lkIHtcbiAgICBsZXQgaW5ib3hQYXRoID0gYCR7cGx1Z2luLnNldHRpbmdzLmZpbGVfSW5ib3h9Lm1kYDtcbiAgICBsZXQgaW5ib3hGaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChpbmJveFBhdGgpO1xuICAgIGNvbnN0IGFjdGl2ZUZpbGUgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcblxuICAgIGlmICghYWN0aXZlRmlsZSkge1xuICAgICAgICBuZXcgTm90aWNlKFwiTm8gaGF5IGFyY2hpdm8gYWN0aXZvXCIpO1xuICAgICAgICByZXR1cm47IC8vIEFzZWd1cmEgcXVlIGhheSB1biBhcmNoaXZvIGFjdGl2byBhbnRlcyBkZSBjb250aW51YXJcbiAgICB9XG4gICAgbGV0IGluYm94O1xuXG5cbiAgICAvLyBVc28gZGVsIE1vZGFsXG4gICAgY29uc3QgbW9kYWwgPSBuZXcgQmFuZGVqYURlRW50cmFkYU1vZGFsKHBsdWdpbi5hcHApO1xuICAgIG1vZGFsLm9wZW4oKTtcblxuICAgIGNvbnN0IHsgdGV4dCwgc2F2ZUluQ3VycmVudCB9ID0gYXdhaXQgbW9kYWwud2FpdEZvcklucHV0KCk7XG4gICAgXG4gICAgaWYgKHRleHQubGVuZ3RoIDwgMykge1xuICAgICAgICBuZXcgTm90aWNlKFwiSW5ib3ggY2FuY2VsYWRhXCIpO1xuICAgICAgICByZXR1cm47IC8vIFRlcm1pbmEgbGEgZWplY3VjaVx1MDBGM24gZGUgbGEgZnVuY2lcdTAwRjNuIGFxdVx1MDBFRC5cbiAgICB9XG4gICAgbGV0IGRlc3Rpbm8gPSBzYXZlSW5DdXJyZW50ID8gYWN0aXZlRmlsZSA6IGluYm94RmlsZTtcbiAgICBsZXQgaG95ID0gRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXktTU0tZGQnKTtcbiAgICBsZXQgaG9yYSA9IERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCdISDptbScpO1xuICAgIGluYm94ID0gYC0gWyBdIFx1RDgzRVx1RERFMCAke3RleHR9ICNpbmJveCBbY3JlYXRlZDo6ICR7aG95fV0gYSBsYXMgJHtob3JhfVxcbmA7XG5cbiAgICBcbiAgICAvLyBMXHUwMEYzZ2ljYSBwYXJhIGVzY3JpYmlyIGVuIGVsIGFyY2hpdm9cbiAgICBpZiAoZGVzdGlubyBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgIGlmIChkZXN0aW5vID09PSBpbmJveEZpbGUpIHtcbiAgICAgICAgICAgIC8vIE1hbmVqYW1vcyBsYSBwcm9tZXNhIGNvbiAudGhlbigpIHkgLmNhdGNoKCkgcGFyYSBlbCBtYW5lam8gZGUgZXJyb3Jlc1xuICAgICAgICAgICAgaW5zZXJ0QXRTdGFydFVzaW5nUHJvY2VzcyhpbmJveCwgZGVzdGlubylcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpIGxhIHByb21lc2Egc2UgcmVzdWVsdmUgc2luIGVycm9yZXMsIG11ZXN0cmEgdW4gTm90aWNlXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJCYW5kZWphIGRlIGVudHJhZGEgYWN0dWFsaXphZGEgY29uIFx1MDBFOXhpdG8uXCIpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpIG9jdXJyZSB1biBlcnJvciwgbXVlc3RyYSB1biBBbGVydFxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiRXJyb3IgYWwgYWdyZWdhciBjb250ZW5pZG8gYWwgaW5pY2lvIGRlbCBhcmNoaXZvOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBpbnNlcnRJbmJveEF0Q3Vyc29yKGluYm94KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5zZXJ0SW5ib3hBdEN1cnNvcihpbmJveCkge1xuICAgIGRlYnVnZ2VyXG4gICAgY29uc3QgYWN0aXZlTGVhZiA9IGFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZjtcbiAgICBpZiAoYWN0aXZlTGVhZikge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVMZWFmLnZpZXcuc291cmNlTW9kZS5jbUVkaXRvcjtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBlZGl0b3IucmVwbGFjZVJhbmdlKGluYm94LCBjdXJzb3IpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5zZXJ0QXRTdGFydFVzaW5nUHJvY2VzcyhpbmJveCwgZmlsZSkge1xuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHJldHVybjtcbiAgICAvLyBVdGlsaXphIFZhdWx0LnByb2Nlc3MgcGFyYSBtb2RpZmljYXIgZWwgY29udGVuaWRvIGRlbCBhcmNoaXZvXG4gICAgYXdhaXQgYXBwLnZhdWx0LnByb2Nlc3MoZmlsZSwgKGNvbnRlbnQpID0+IHtcbiAgICAgICAgLy8gQ29uY2F0ZW5hIGVsIHRleHRvIGRlIGVudHJhZGEgZW4gbGEgcHJpbWVyYSBsXHUwMEVEbmVhIHkgZWwgY29udGVuaWRvIG9yaWdpbmFsXG4gICAgICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBpbmJveCArIGNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBuZXdDb250ZW50OyAvLyBSZXRvcm5hIGVsIG51ZXZvIGNvbnRlbmlkbyBwYXJhIHNlciBndWFyZGFkb1xuICAgIH0pO1xufVxuXG5cblxuIiwgImltcG9ydCB7IE1vZGFsLCBBcHAgfSBmcm9tICdvYnNpZGlhbic7XG5cbmV4cG9ydCBjbGFzcyBCYW5kZWphRGVFbnRyYWRhTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgaW5wdXRBcmVhOiBIVE1MVGV4dEFyZWFFbGVtZW50O1xuICAgIGNoZWNrQm94OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIHByaXZhdGUgcmVzb2x2ZXI6ICh2YWx1ZTogeyB0ZXh0OiBzdHJpbmc7IHNhdmVJbkN1cnJlbnQ6IGJvb2xlYW4gfSkgPT4gdm9pZDtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLmNsYXNzTGlzdC5hZGQoXCJtb2RhbEluYm94XCIpO1xuICAgICAgICBsZXQge2NvbnRlbnRFbH0gPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgdGhpcy50aXRsZUVsLnNldFRleHQoXCJCYW5kZWphIGRlIEVudHJhZGFcIik7XG4gICAgICAgIFxuICAgICAgICAvLyBFbnZ1ZWx2ZSBlbCBcdTAwRTFyZWEgZGUgdGV4dG8gZW4gdW4gZGl2IHBhcmEgY29udHJvbCBkZSBmbHVqb1xuICAgICAgICBsZXQgdGV4dEFyZWFEaXYgPSBjb250ZW50RWwuY3JlYXRlRWwoJ2RpdicpO1xuICAgICAgICB0aGlzLmlucHV0QXJlYSA9IHRleHRBcmVhRGl2LmNyZWF0ZUVsKCd0ZXh0YXJlYScpO1xuICAgICAgICB0aGlzLmlucHV0QXJlYS5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgJ0VzY3JpYmUgdHUgdGFyZWEgYXF1XHUwMEVELi4uJyk7XG4gICAgICAgIC8vIEFcdTAwRjFhZGUgdW4gbGlzdGVuZXIgZGUgZXZlbnRvICdrZXlkb3duJyBhbCB0ZXh0YXJlYVxuICAgICAgICB0aGlzLmlucHV0QXJlYS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgIC8vIFZlcmlmaWNhIHNpIGxhIHRlY2xhIHByZXNpb25hZGEgZXMgRW50ZXIgeSBxdWUgbm8gaGF5YSBuaW5ndW5hIG1vZGlmaWNhY2lcdTAwRjNuIChzaGlmdCwgY3RybCwgYWx0KVxuICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnRW50ZXInICYmICFlLnNoaWZ0S2V5ICYmICFlLmN0cmxLZXkgJiYgIWUuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2aWVuZSBlbCBjb21wb3J0YW1pZW50byBwb3IgZGVmZWN0byBwYXJhIG5vIGluc2VydGFyIHVuYSBudWV2YSBsXHUwMEVEbmVhXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJtaXRGb3JtKCk7IC8vIExsYW1hIGEgbGEgZnVuY2lcdTAwRjNuIHF1ZSBtYW5lamEgZWwgZW52XHUwMEVEb1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoYWN0aXZlRmlsZSk7XG4gICAgICAgIGxldCBuYW1lQWN0aXZlRmlsZSA9IG1ldGFkYXRhLmFsaWFzZXMgPyBtZXRhZGF0YS5hbGlhc2VzWzBdIDogYWN0aXZlRmlsZS5iYXNlbmFtZTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVudnVlbHZlIGVsIGNoZWNrYm94IHkgc3UgZXRpcXVldGEgZW4gdW4gZGl2IHBhcmEgY29udHJvbCBkZSBmbHVqb1xuICAgICAgICBsZXQgY2hlY2tCb3hEaXYgPSBjb250ZW50RWwuY3JlYXRlRWwoJ2RpdicpO1xuICAgICAgICB0aGlzLmNoZWNrQm94ID0gY2hlY2tCb3hEaXYuY3JlYXRlRWwoJ2lucHV0Jywge3R5cGU6ICdjaGVja2JveCd9KTtcbiAgICAgICAgY2hlY2tCb3hEaXYuY3JlYXRlRWwoJ2xhYmVsJywge3RleHQ6IGBHdWFyZGFyIGVuICR7bmFtZUFjdGl2ZUZpbGV9YH0pLnByZXBlbmQodGhpcy5jaGVja0JveCk7XG4gICAgICAgIGNvbnN0IHNhdmVCdXR0b24gPSBjaGVja0JveERpdi5jcmVhdGVFbCgnYnV0dG9uJywge3RleHQ6ICdHdWFyZGFyJ30pO1xuICAgICAgICBzYXZlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5zdWJtaXRGb3JtKCkpO1xuICAgIH1cbiAgICBcbiAgICBzdWJtaXRGb3JtKCkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5pbnB1dEFyZWEudmFsdWU7XG4gICAgICAgIGNvbnN0IHNhdmVJbkN1cnJlbnQgPSB0aGlzLmNoZWNrQm94LmNoZWNrZWQ7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXIoeyB0ZXh0LCBzYXZlSW5DdXJyZW50IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuXG4gICAgd2FpdEZvcklucHV0KCk6IFByb21pc2U8eyB0ZXh0OiBzdHJpbmc7IHNhdmVJbkN1cnJlbnQ6IGJvb2xlYW4gfT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgaW5ncmVzYXJCYW5kZWphRW50cmFkYSB9IGZyb20gXCIuL2luYm94XCI7XG5cbi8vIENPTUFORE9TIERFTCBNT0RVTE8gR1REXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21tYW5kcyhwbHVnaW46IFBsdWdpbik6IHZvaWQge1xuICAgIFxuICAgIGNvbnN0IGlkMSA9IHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICAgICAgaWQ6IFwiaW5ncmVzYXItaW5ib3hcIixcbiAgICAgICAgbmFtZTogXCJJbmdyZXNhciBCYW5kZWphIGRlIEVudHJhZGEgLT4gSW5ib3hcIixcbiAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGluZ3Jlc2FyQmFuZGVqYUVudHJhZGEocGx1Z2luKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFsbWFjZW5hciBlbCBJRCBkZWwgY29tYW5kbyBlbiByZWdpc3RlcmVkQ29tbWFuZElkcy5cblxuICAgIHBsdWdpbi5yZWdpc3RlcmVkQ29tbWFuZElkc0dURC5wdXNoKGlkMS5pZCk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYWN0aXZhdGVDb21tYW5kcyhwbHVnaW46IFBsdWdpbik6IHZvaWQge1xuICAgIFxuICAgIGlmICghcGx1Z2luLnJlZ2lzdGVyZWRDb21tYW5kSWRzR1REKSByZXR1cm47XG4gICAgLy8gRWplbXBsbyBkZSBjXHUwMEYzbW8gcG9kclx1MDBFRGFzIG1hbmVqYXIgbGEgXCJkZXNhY3RpdmFjaVx1MDBGM25cIiBkZSBjb21hbmRvcy5cbiAgICBwbHVnaW4ucmVnaXN0ZXJlZENvbW1hbmRJZHNHVEQuZm9yRWFjaChjb21tYW5kSWQgPT4ge1xuICAgICAgICBjb25zdCBjb21tYW5kID0gcGx1Z2luLmFwcC5jb21tYW5kcy5jb21tYW5kc1tjb21tYW5kSWRdO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIC8vIFNvYnJlc2NyaWJpciBlbCBjYWxsYmFjayBkZWwgY29tYW5kbyBwYXJhIHF1ZSBubyBoYWdhIG5hZGEuXG4gICAgICAgICAgICBjb21tYW5kLmNhbGxiYWNrID0gKCkgPT4gbmV3IE5vdGljZShcIkVzdGUgY29tYW5kbyBoYSBzaWRvIGRlc2FjdGl2YWRvLlwiKTtcbiAgICAgICAgICAgIC8vIE8gc2ltcGxlbWVudGUgZWxpbWluYXIgZWwgY2FsbGJhY2sgc2kgZXNvIHNlIGFqdXN0YSBhIHR1IGxcdTAwRjNnaWNhIGRlIGFwbGljYWNpXHUwMEYzbi5cbiAgICAgICAgICAgIC8vIGRlbGV0ZSBjb21tYW5kLmNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0IHsgVEZpbGUsIFRGb2xkZXIgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW50ZXJmYWNlIEdydXBvQVYge1xuICBncnVwbzogc3RyaW5nO1xuICBhdjogc3RyaW5nO1xuICB0ZXh0bzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3Mgc3Vic2lzdGVtYXNBUEkge1xuICBjb25zdHJ1Y3RvcihwbHVnaW4pIHtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB0aGlzLnBhdGhDYW1wb3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5maWxlX2NhbXBvc0NlbnRyYWwgKyBcIi5tZFwiO1xuICB9XG5cbiAgLy8gRnVuY2lcdTAwRjNuIHBhcmEgY3JlYXIgeSBtb3N0cmFyIGVsIGJvdFx1MDBGM24gaW5pY2lhbCBcIk1lblx1MDBGQSBob3lcIlxuICBhc3luYyBtb3N0cmFyQm90b25DcmVhckFWKGR2KSB7XG4gICAgZHYuY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7IC8vIExpbXBpYXIgZWwgY29udGVuZWRvclxuXG4gICAgY29uc3QgYm90b25NZW51SG95ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBib3Rvbk1lbnVIb3kudGV4dENvbnRlbnQgPSBcIlByb2Nlc2FyIEFyZWFzIGRlIFZpZGFcIjtcbiAgICBkdi5jb250YWluZXIuYXBwZW5kQ2hpbGQoYm90b25NZW51SG95KTtcblxuICAgIGJvdG9uTWVudUhveS5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5wcm9jZXNhckFWKGR2KTsgLy8gTW9zdHJhciBsb3MgYm90b25lcyBhZGljaW9uYWxlcyBhbCBoYWNlciBjbGljXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIG1vc3RyYXJCb3RvbkNyZWFyQVZUcmltZXN0cmFsKGR2KSB7XG4gICAgZHYuY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7IC8vIExpbXBpYXIgZWwgY29udGVuZWRvclxuXG4gICAgY29uc3QgYm90b25NZW51SG95ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBib3Rvbk1lbnVIb3kudGV4dENvbnRlbnQgPSBcIlByb2Nlc2FyIEFyZWFzIGRlIFZpZGEgZGVsIHRyaW1lc3RyZVwiO1xuICAgIGR2LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3Rvbk1lbnVIb3kpO1xuXG4gICAgYm90b25NZW51SG95Lm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc2FyQVZUcmltZXN0cmUoZHYpOyAvLyBNb3N0cmFyIGxvcyBib3RvbmVzIGFkaWNpb25hbGVzIGFsIGhhY2VyIGNsaWNcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcHJvY2VzYXJBVihkdikge1xuICAgIC8vIE9idGVuZXIgUXMgcGFyYSBwcmVndW50YXIgZWwgUSBwYXJhIGVsIHF1ZSBkZXNlYSBjcmVhciBsYXMgXHUwMEUxcmVhcyBkZSB2aWRhLlxuICAgIGNvbnN0IGZvbGRlclEgPSB0aGlzLnBsdWdpbi5zZXR0aW5nc1tcImZvbGRlcl9UcmltZXN0cmFsXCJdO1xuICAgIGNvbnN0IGZpbGVzUSA9IGFwcC52YXVsdFxuICAgICAgLmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgLmZpbHRlcihcbiAgICAgICAgKGZpbGUpID0+XG4gICAgICAgICAgZmlsZS5wYXRoLmluY2x1ZGVzKGZvbGRlclEpICYmXG4gICAgICAgICAgIWZpbGUucGF0aC5pbmNsdWRlcyhcIlBsYW50aWxsYXNcIikgJiZcbiAgICAgICAgICAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiQXJjaGl2b1wiKVxuICAgICAgKTtcbiAgICBsZXQgcUNyZWFkb3MgPSBbXTtcblxuICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXNRKSB7XG4gICAgICBsZXQgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuXG4gICAgICBpZiAobWV0YWRhdGE/LnR5cGUgPT09IFwiVFFcIiAmJiBtZXRhZGF0YT8udHJpbWVzdHJlKSB7XG4gICAgICAgIGxldCBxQWN0aXZvID0geyBmaWxlIH07IC8vIEFzdW1pZW5kbyBxdWUgcXVpZXJlcyBndWFyZGFyIGVsIHBhdGggZGVsIGFyY2hpdm9cbiAgICAgICAgT2JqZWN0LmFzc2lnbihxQWN0aXZvLCBtZXRhZGF0YSk7IC8vIEFncmVnYSBlbCBtZXRhZGF0YSBhbCBvYmpldG8gcUFjdGl2b1xuICAgICAgICBxQ3JlYWRvcy5wdXNoKHFBY3Rpdm8pOyAvLyBBXHUwMEYxYWRlIGVsIHJlZ2lzdHJvIGFjdGl2byBhbCBhcnJheVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdWdnZXN0ZXIgPSB0aGlzLnBsdWdpbi50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG4gICAgbGV0IHEgPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICBxQ3JlYWRvcy5tYXAoKGIpID0+IGIudHJpbWVzdHJlKSxcbiAgICAgIHFDcmVhZG9zLm1hcCgoYikgPT4gYiksXG4gICAgICB0cnVlLFxuICAgICAgYERlIHF1ZSB0cmltZXN0cmUgdmFtb3MgYSBwcm9jZXNhciB0dXMgQXJlYXMgZGUgVmlkYWBcbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdGFkb0FWOiBHcnVwb0FWW10gPSBbXTtcbiAgICBjb25zdCBmaWxlQ2FtcG9zID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnBhdGhDYW1wb3MpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoZmlsZUNhbXBvcyBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgIC8vIFVzYSBtZXRhZGF0YUNhY2hlIHBhcmEgb2J0ZW5lciBsb3MgbWV0YWRhdG9zIGRlbCBhcmNoaXZvXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGVDYW1wb3MpO1xuICAgICAgICBjb25zdCBhcnJlZ2xvQVYgPSBtZXRhZGF0YT8uZnJvbnRtYXR0ZXI/LkFyZWFzVmlkYSB8fCBbXTtcbiAgICAgICAgLy8gUmVsbGVuYSBlbCBhcnJlZ2xvIGNvbiBsb3MgZGF0b3MgZGVsIGFycmVnbG9SZXN1bHRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyZWdsb0FWKSkge1xuICAgICAgICAgIGFycmVnbG9BVi5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSAmJiBpdGVtLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgIHJlc3VsdGFkb0FWLnB1c2goe1xuICAgICAgICAgICAgICAgIGdydXBvOiBpdGVtWzBdLFxuICAgICAgICAgICAgICAgIGF2OiBpdGVtWzFdLFxuICAgICAgICAgICAgICAgIHRleHRvOiBpdGVtWzBdICsgXCIgLyBcIiArIGl0ZW1bMV0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvYnRlbmllbmRvIGVsIGFyY2hpdm8gZGUgY2FtcG9zOlwiLCBlcnJvcik7XG4gICAgICAvLyBBcXVcdTAwRUQgbWFuZWphclx1MDBFRGFzIGVsIGVycm9yIGNvbW8gc2VhIGFwcm9waWFkbyBwYXJhIHR1IGFwbGljYWNpXHUwMEYzblxuICAgICAgdGhyb3cgZXJyb3I7IC8vIE8gZGV2b2x2ZXIgdW4gYXJyZWdsbyB2YWNcdTAwRURvIGNvbW8gcmVzdWx0YWRvIGRlIGVycm9yXG4gICAgfVxuXG4gICAgY29uc3QgYWxsRmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIGxldCBiYXNlUGF0aCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9BcmVhc1ZpZGE7XG5cbiAgICAvLyAtLi4tPiBSZXZpc2lcdTAwRjNuIGRlIGVzY2VuYXJpb3MuXG5cbiAgICBmb3IgKGxldCBhcmVhVmlkYSBvZiByZXN1bHRhZG9BVikge1xuICAgICAgLy8gVmVyaWZpY2Egc2kgbGEgY2FycGV0YSBleGlzdGUgZW4gbGEgdWJpY2FjaVx1MDBGM24gZXNwZWNcdTAwRURmaWNhXG4gICAgICBjb25zdCBmdWxsRm9sZGVyUGF0aCA9IGAke2Jhc2VQYXRofS8ke2FyZWFWaWRhLmF2fWA7XG4gICAgICBjb25zdCBmb2xkZXIgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZ1bGxGb2xkZXJQYXRoKTtcblxuICAgICAgLy9QMCAtPiBWZXJpZmljYSBzaSBsYSBjYXJwZXRhIHBhdGgvYXJlYVZpZGEgZXhpc3RlXG4gICAgICAvL1AwIC0gU0lcbiAgICAgIGlmIChmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBMYSBjYXJwZXRhICR7YXJlYVZpZGEuYXZ9IGV4aXN0ZSBkZW50cm8gZGUgJHtiYXNlUGF0aH0uYCk7XG4gICAgICAgIC8vIEFob3JhLCB2ZXJpZmljYSBzaSBsYSBub3RhIGV4aXN0ZSBkZW50cm8gZGUgbGEgY2FycGV0YVxuICAgICAgICBjb25zdCBpbnN0YW5jZXNPZkFWID0gYXBwLnZhdWx0XG4gICAgICAgICAgLmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAoZmlsZSkgPT5cbiAgICAgICAgICAgICAgZmlsZS5wYXRoLmluY2x1ZGVzKGZ1bGxGb2xkZXJQYXRoKSAmJlxuICAgICAgICAgICAgICAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiUGxhbnRpbGxhc1wiKSAmJlxuICAgICAgICAgICAgICAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiQXJjaGl2b1wiKVxuICAgICAgICAgICk7XG4gICAgICAgIC8vIFAxIEV4aXN0ZSBub2RlQXJlYVZpZGE/XG4gICAgICAgIGNvbnN0IG5vZGVBVkV4aXN0cyA9IGluc3RhbmNlc09mQVYuc29tZShcbiAgICAgICAgICAoZmlsZSkgPT4gZmlsZS5iYXNlbmFtZSA9PT0gYXJlYVZpZGEuYXZcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQMSBTSVxuICAgICAgICBpZiAobm9kZUFWRXhpc3RzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgTGEgbm90YSAke2FyZWFWaWRhLmF2fSBleGlzdGUgZGVudHJvIGRlIGxhIGNhcnBldGEgJHthcmVhVmlkYS5hdn0uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gUDIgYXJlYVZpZGEgUSBFeGlzdGU/XG4gICAgICAgICAgYXdhaXQgdGhpcy52YWxpZGFjaW9uQVZRKGZ1bGxGb2xkZXJQYXRoLCBxLCBhcmVhVmlkYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9QMSAtIE5PIChub2RlQXJlYVZpZGEgbm8gRXhpc3RlKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAvLyBDYXNvIDMgeSA0XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgTGEgbm90YSAke2FyZWFWaWRhLmF2fSBubyBleGlzdGUgZGVudHJvIGRlIGxhIGNhcnBldGEgJHthcmVhVmlkYS5hdn0uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gUDMgQWdyZWdhciBOb2RvIEFyZWEgVmlkYT9cbiAgICAgICAgICBsZXQgbkFWID0gYXdhaXQgdGhpcy5hZ3JlZ2FyTm9kb0FyZWFWaWRhKGFyZWFWaWRhKTsgLy8gUXVpZXJlcyBBZ3JlZ2FyIGVzdGEgQVYgYSB0dSBzaXN0ZW1hIGRlIEdlc3RpXHUwMEYzbj9cbiAgICAgICAgICAvL1AzIC0+IFNJXG4gICAgICAgICAgaWYgKG5BVikge1xuICAgICAgICAgICAgLy8gUDIgLi4gLT4gU2kgeSBOb1xuICAgICAgICAgICAgYXdhaXQgdGhpcy52YWxpZGFjaW9uQVZRKGZ1bGxGb2xkZXJQYXRoLCBxLCBhcmVhVmlkYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vUDMgLT4gTk9cbiAgICAgICAgICBlbHNlIGlmIChuQVYgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvL1NlbnRlbmNpYSBxdWUgZGViZSBwYXNhciBhbCBzaWd1aWVudGUgZWxlbWVudG8gZGVsIGNpY2xvIGZvci5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBFbiBjYXNvIGRlIHF1ZSBzZSBkZSBlc2NhcGUuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBQTyAtPiBOTyAoTGEgQ2FycGV0YSBubyBleGlzdGUpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYExhIGNhcnBldGEgJHthcmVhVmlkYS5hdn0gbm8gZXhpc3RlIGFcdTAwRkFuIGRlbnRybyBkZSAke2Jhc2VQYXRofS5gXG4gICAgICAgICk7XG4gICAgICAgIC8vIFAzIEFncmVnYXIgTm9kbyBBcmVhIFZpZGE/XG4gICAgICAgIGxldCBuQVYgPSBhd2FpdCB0aGlzLmFncmVnYXJOb2RvQXJlYVZpZGEoYXJlYVZpZGEpOyAvLyBRdWllcmVzIEFncmVnYXIgZXN0YSBBViBhIHR1IHNpc3RlbWEgZGUgR2VzdGlcdTAwRjNuP1xuICAgICAgICAvLyBQMyAtPiBTSVxuICAgICAgICBpZiAobkFWKSB7XG4gICAgICAgICAgLy8gUDJcbiAgICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYWNpb25BVlEoZnVsbEZvbGRlclBhdGgsIHEsIGFyZWFWaWRhKTtcbiAgICAgICAgfVxuICAgICAgICAvL1AzIC0+IE5PXG4gICAgICAgIGVsc2UgaWYgKG5BViA9PSBmYWxzZSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvL1NlbnRlbmNpYSBxdWUgZGViZSBwYXNhciBhbCBzaWd1aWVudGUgZWxlbWVudG8gZGVsIGNpY2xvIGZvci5cbiAgICAgICAgfVxuICAgICAgICAvLyBQMyAtPiBFc2NhcGVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBFbiBjYXNvIGRlIHF1ZSBzZSBkZSBlc2NhcGUuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEZpbiBGb3IgQXJlYXNWaWRhIGZpbGVDYW1wb3NcbiAgfSAvLyBGaW4gcHJvY2VzYXJBVigpXG5cblxuICBhc3luYyBwcm9jZXNhckFWVHJpbWVzdHJlKGR2KSB7XG4gICAgXG4gICAgbGV0IHEgPSB7fTsgXG4gICAgcS50cmltZXN0cmUgPSBkdi5jdXJyZW50KCkudHJpbWVzdHJlO1xuICAgIGNvbnN0IHJlc3VsdGFkb0FWOiBHcnVwb0FWW10gPSBbXTtcbiAgICBjb25zdCBmaWxlQ2FtcG9zID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnBhdGhDYW1wb3MpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoZmlsZUNhbXBvcyBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgIC8vIFVzYSBtZXRhZGF0YUNhY2hlIHBhcmEgb2J0ZW5lciBsb3MgbWV0YWRhdG9zIGRlbCBhcmNoaXZvXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGVDYW1wb3MpO1xuICAgICAgICBjb25zdCBhcnJlZ2xvQVYgPSBtZXRhZGF0YT8uZnJvbnRtYXR0ZXI/LkFyZWFzVmlkYSB8fCBbXTtcbiAgICAgICAgLy8gUmVsbGVuYSBlbCBhcnJlZ2xvIGNvbiBsb3MgZGF0b3MgZGVsIGFycmVnbG9SZXN1bHRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyZWdsb0FWKSkge1xuICAgICAgICAgIGFycmVnbG9BVi5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSAmJiBpdGVtLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgIHJlc3VsdGFkb0FWLnB1c2goe1xuICAgICAgICAgICAgICAgIGdydXBvOiBpdGVtWzBdLFxuICAgICAgICAgICAgICAgIGF2OiBpdGVtWzFdLFxuICAgICAgICAgICAgICAgIHRleHRvOiBpdGVtWzBdICsgXCIgLyBcIiArIGl0ZW1bMV0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvYnRlbmllbmRvIGVsIGFyY2hpdm8gZGUgY2FtcG9zOlwiLCBlcnJvcik7XG4gICAgICAvLyBBcXVcdTAwRUQgbWFuZWphclx1MDBFRGFzIGVsIGVycm9yIGNvbW8gc2VhIGFwcm9waWFkbyBwYXJhIHR1IGFwbGljYWNpXHUwMEYzblxuICAgICAgdGhyb3cgZXJyb3I7IC8vIE8gZGV2b2x2ZXIgdW4gYXJyZWdsbyB2YWNcdTAwRURvIGNvbW8gcmVzdWx0YWRvIGRlIGVycm9yXG4gICAgfVxuXG4gICAgY29uc3QgYWxsRmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIGxldCBiYXNlUGF0aCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9BcmVhc1ZpZGE7XG5cbiAgICAvLyAtLi4tPiBSZXZpc2lcdTAwRjNuIGRlIGVzY2VuYXJpb3MuXG5cbiAgICBmb3IgKGxldCBhcmVhVmlkYSBvZiByZXN1bHRhZG9BVikge1xuICAgICAgLy8gVmVyaWZpY2Egc2kgbGEgY2FycGV0YSBleGlzdGUgZW4gbGEgdWJpY2FjaVx1MDBGM24gZXNwZWNcdTAwRURmaWNhXG4gICAgICBjb25zdCBmdWxsRm9sZGVyUGF0aCA9IGAke2Jhc2VQYXRofS8ke2FyZWFWaWRhLmF2fWA7XG4gICAgICBjb25zdCBmb2xkZXIgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZ1bGxGb2xkZXJQYXRoKTtcblxuICAgICAgLy9QMCAtPiBWZXJpZmljYSBzaSBsYSBjYXJwZXRhIHBhdGgvYXJlYVZpZGEgZXhpc3RlXG4gICAgICAvL1AwIC0gU0lcbiAgICAgIGlmIChmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBMYSBjYXJwZXRhICR7YXJlYVZpZGEuYXZ9IGV4aXN0ZSBkZW50cm8gZGUgJHtiYXNlUGF0aH0uYCk7XG4gICAgICAgIC8vIEFob3JhLCB2ZXJpZmljYSBzaSBsYSBub3RhIGV4aXN0ZSBkZW50cm8gZGUgbGEgY2FycGV0YVxuICAgICAgICBjb25zdCBpbnN0YW5jZXNPZkFWID0gYXBwLnZhdWx0XG4gICAgICAgICAgLmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAoZmlsZSkgPT5cbiAgICAgICAgICAgICAgZmlsZS5wYXRoLmluY2x1ZGVzKGZ1bGxGb2xkZXJQYXRoKSAmJlxuICAgICAgICAgICAgICAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiUGxhbnRpbGxhc1wiKSAmJlxuICAgICAgICAgICAgICAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiQXJjaGl2b1wiKVxuICAgICAgICAgICk7XG4gICAgICAgIC8vIFAxIEV4aXN0ZSBub2RlQXJlYVZpZGE/XG4gICAgICAgIGNvbnN0IG5vZGVBVkV4aXN0cyA9IGluc3RhbmNlc09mQVYuc29tZShcbiAgICAgICAgICAoZmlsZSkgPT4gZmlsZS5iYXNlbmFtZSA9PT0gYXJlYVZpZGEuYXZcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQMSBTSVxuICAgICAgICBpZiAobm9kZUFWRXhpc3RzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgTGEgbm90YSAke2FyZWFWaWRhLmF2fSBleGlzdGUgZGVudHJvIGRlIGxhIGNhcnBldGEgJHthcmVhVmlkYS5hdn0uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gUDIgYXJlYVZpZGEgUSBFeGlzdGU/XG4gICAgICAgICAgYXdhaXQgdGhpcy52YWxpZGFjaW9uQVZRKGZ1bGxGb2xkZXJQYXRoLCBxLCBhcmVhVmlkYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9QMSAtIE5PIChub2RlQXJlYVZpZGEgbm8gRXhpc3RlKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAvLyBDYXNvIDMgeSA0XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgTGEgbm90YSAke2FyZWFWaWRhLmF2fSBubyBleGlzdGUgZGVudHJvIGRlIGxhIGNhcnBldGEgJHthcmVhVmlkYS5hdn0uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gUDMgQWdyZWdhciBOb2RvIEFyZWEgVmlkYT9cbiAgICAgICAgICBsZXQgbkFWID0gYXdhaXQgdGhpcy5hZ3JlZ2FyTm9kb0FyZWFWaWRhKGFyZWFWaWRhKTsgLy8gUXVpZXJlcyBBZ3JlZ2FyIGVzdGEgQVYgYSB0dSBzaXN0ZW1hIGRlIEdlc3RpXHUwMEYzbj9cbiAgICAgICAgICAvL1AzIC0+IFNJXG4gICAgICAgICAgaWYgKG5BVikge1xuICAgICAgICAgICAgLy8gUDIgLi4gLT4gU2kgeSBOb1xuICAgICAgICAgICAgYXdhaXQgdGhpcy52YWxpZGFjaW9uQVZRKGZ1bGxGb2xkZXJQYXRoLCBxLCBhcmVhVmlkYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vUDMgLT4gTk9cbiAgICAgICAgICBlbHNlIGlmIChuQVYgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvL1NlbnRlbmNpYSBxdWUgZGViZSBwYXNhciBhbCBzaWd1aWVudGUgZWxlbWVudG8gZGVsIGNpY2xvIGZvci5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBFbiBjYXNvIGRlIHF1ZSBzZSBkZSBlc2NhcGUuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBQTyAtPiBOTyAoTGEgQ2FycGV0YSBubyBleGlzdGUpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYExhIGNhcnBldGEgJHthcmVhVmlkYS5hdn0gbm8gZXhpc3RlIGFcdTAwRkFuIGRlbnRybyBkZSAke2Jhc2VQYXRofS5gXG4gICAgICAgICk7XG4gICAgICAgIC8vIFAzIEFncmVnYXIgTm9kbyBBcmVhIFZpZGE/XG4gICAgICAgIGxldCBuQVYgPSBhd2FpdCB0aGlzLmFncmVnYXJOb2RvQXJlYVZpZGEoYXJlYVZpZGEpOyAvLyBRdWllcmVzIEFncmVnYXIgZXN0YSBBViBhIHR1IHNpc3RlbWEgZGUgR2VzdGlcdTAwRjNuP1xuICAgICAgICAvLyBQMyAtPiBTSVxuICAgICAgICBpZiAobkFWKSB7XG4gICAgICAgICAgLy8gUDJcbiAgICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYWNpb25BVlEoZnVsbEZvbGRlclBhdGgsIHEsIGFyZWFWaWRhKTtcbiAgICAgICAgfVxuICAgICAgICAvL1AzIC0+IE5PXG4gICAgICAgIGVsc2UgaWYgKG5BViA9PSBmYWxzZSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvL1NlbnRlbmNpYSBxdWUgZGViZSBwYXNhciBhbCBzaWd1aWVudGUgZWxlbWVudG8gZGVsIGNpY2xvIGZvci5cbiAgICAgICAgfVxuICAgICAgICAvLyBQMyAtPiBFc2NhcGVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBFbiBjYXNvIGRlIHF1ZSBzZSBkZSBlc2NhcGUuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEZpbiBGb3IgQXJlYXNWaWRhIGZpbGVDYW1wb3NcbiAgfSAvLyBGaW4gcHJvY2VzYXJBVlRyaW1lc3RyZSgpXG5cblxuICAvL1AyIGFyZWFWaWRhIFEgRXhpc3RlP1xuICBhc3luYyB2YWxpZGFjaW9uQVZRKFxuICAgIGZ1bGxGb2xkZXJQYXRoOiBzdHJpbmcsXG4gICAgcTogYW55LFxuICAgIGFyZWFWaWRhOiBhbnlcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGF0aEFWUSA9IGAke2Z1bGxGb2xkZXJQYXRofS8ke3EudHJpbWVzdHJlfSAtICR7YXJlYVZpZGEuYXZ9Lm1kYDtcbiAgICBjb25zdCBmaWxlQVZRID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoQVZRKTtcbiAgICBkZWJ1Z2dlcjtcbiAgICAvLyBWZXJpZmljYXIgc2kgZWwgQVYgZGUgUSBFeGlzdGVcbiAgICAvLyBQMiBTSVxuICAgIC8vIENBU08gNFxuICAgIC8vIENBU08gNVxuICAgIGlmIChmaWxlQVZRIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgIGxldCBzdWdnZXN0ZXIgPSB0aGlzLnBsdWdpbi50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG4gICAgICBsZXQgbmV4dFN0ZXAgPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICAgIFtcbiAgICAgICAgICBcIkFjdHVhbGl6YXIgZXN0YWRvIGRlbCBBVlwiLFxuICAgICAgICAgIFwiQm9ycmFyIHkgQ3JlYXIgZGUgbnVldm8gZWwgQVZcIixcbiAgICAgICAgICBcIkRlamFyIGVsIEFWIGNvbW8gZXN0XHUwMEUxIFwiLFxuICAgICAgICBdLFxuICAgICAgICBbXCJ1cGRcIiwgXCJkZWwrY3JlXCIsIFwiY29udGludWVcIl0sXG4gICAgICAgIHRydWUsXG4gICAgICAgIGBcdTAwQkYke3EudHJpbWVzdHJlfSAke2FyZWFWaWRhLmF2fSB5YSBleGlzdGUuIEVsaWdlIHVuYSBvcGNpXHUwMEYzbjpgXG4gICAgICApO1xuICAgICAgc3dpdGNoIChuZXh0U3RlcCkge1xuICAgICAgICBjYXNlIFwidXBkXCI6XG4gICAgICAgICAgYXdhaXQgdGhpcy5hY3R1YWxpemFyQVZRKGZpbGVBVlEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGVsK2NyZVwiOlxuICAgICAgICAgIGF3YWl0IHRoaXMuYm9ycmFyQVZRKGZpbGVBVlEpO1xuICAgICAgICAgIGF3YWl0IHRoaXMuYWdyZWdhckFWUShhcmVhVmlkYSwgcS50cmltZXN0cmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ29udGludWFyIHNpbiBoYWNlciBuYWRhIGNvbiAke2ZpbGVBVlEuYmFzZW5hbWV9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBTaSBBViBkZSBRIGV4aXN0ZSAoMSkgbXVlc3RyYSBlbCBlc3RhZG8geSBwZXJtaXRlIGNhbWJpYXJsby5cbiAgICB9XG4gICAgLy8gUDIgTk9cbiAgICAvLyAtPj4gQ0FTTyAxXG4gICAgLy8gLT4+IENBU08gM1xuICAgIC8vIC0tPiBDQVNPIDZcbiAgICBlbHNlIHtcbiAgICAgIGRlYnVnZ2VyO1xuICAgICAgLy8gU2kgQVYgZGUgUSBubyBFeGlzdGUgKDIpIEFncmVnYSBBcmVhVmlkYSBkZSBRLCBwcmVndW50YW5kbyBlbiBxdWUgZXN0YWRvIHF1aWVyZSB0ZW5lciBlc2EgQVYgZXNlIFFcbiAgICAgIGF3YWl0IHRoaXMuYWdyZWdhckFWUShhcmVhVmlkYSwgcS50cmltZXN0cmUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFAzIEFncmVnYXIgbm9kb0FyZWFWaWRhP1xuICBhc3luYyBhZ3JlZ2FyTm9kb0FyZWFWaWRhKGFyZWFWaWRhKSB7XG4gICAgLy8gcHJlZ3VudGFyIHByaW1lcm8gc2kgc2kgbG8gZGVzZWEgYWdyZWdhci5cblxuICAgIGxldCBzdWdnZXN0ZXIgPSB0aGlzLnBsdWdpbi50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG4gICAgbGV0IGFncmVnYXIgPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICBbXCJTaVwiLCBcIk5vXCJdLFxuICAgICAgW3RydWUsIGZhbHNlXSxcbiAgICAgIHRydWUsXG4gICAgICBgXHUwMEJGRGVzZWFzIGFncmVnYXIgJHthcmVhVmlkYS5hdn0gYSB0dSBzaXN0ZW1hIGRlIGdlc3RpXHUwMEYzbj9gXG4gICAgKTtcbiAgICAvLyBQMyBTSVxuICAgIGlmIChhZ3JlZ2FyKSB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IGBQbGFudGlsbGFzLyR7XG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW2Bmb2xkZXJfQXJlYXNWaWRhYF1cbiAgICAgIH0vUGx0IC0gbm9kb0FyZWFzVmlkYS5tZGA7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpO1xuICAgICAgaWYgKHRlbXBsYXRlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBcmNoaXZvIG5vZG9BcmVhVmlkYSB0ZW1wbGF0ZSBlbmNvbnRyYWRvOlwiLCB0ZW1wbGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFyY2hpdm8gdGVtcGxhdGUgbm9kb0FyZWFWaWRhIG5vIGVuY29udHJhZG8uXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWxlbmFtZSA9IGFyZWFWaWRhLmdydXBvICsgXCIgLSBcIiArIGFyZWFWaWRhLmF2O1xuICAgICAgbGV0IGZvbGRlclBhdGggPSBgJHt0aGlzLnBsdWdpbi5zZXR0aW5nc1tgZm9sZGVyX0FyZWFzVmlkYWBdfS8ke1xuICAgICAgICBhcmVhVmlkYS5hdlxuICAgICAgfWA7XG4gICAgICAvLyBTZSBhc2VndXJhIGRlIHF1ZSBsYSBjYXJwZXRhIGV4aXN0YSBwYXJhIHBvZGVyIGNyZWFyIGVsIGFyY2hpdm8gZGlyZWN0YW1lbnRlIGVuIGVzYSBjYXJwZXRhXG4gICAgICBhd2FpdCB0aGlzLmNyZWFyQ2FycGV0YShmb2xkZXJQYXRoKTtcbiAgICAgIGNvbnN0IGZvbGRlciA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyUGF0aCk7XG4gICAgICBsZXQgY3JlYXJOb3RhOiAoXG4gICAgICAgIHRlbXBsYXRlOiBURmlsZSxcbiAgICAgICAgZmlsZW5hbWU6IHN0cmluZyxcbiAgICAgICAgb3ZlcndyaXRlOiBib29sZWFuLFxuICAgICAgICBmb2xkZXI6IFRGb2xkZXJcbiAgICAgICkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgICAgIGNyZWFyTm90YSA9IHRoaXMucGx1Z2luLnRwLmZpbGUuc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJjcmVhdGVfbmV3XCIpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgbm90YSA9IGF3YWl0IGNyZWFyTm90YSh0ZW1wbGF0ZSwgZmlsZW5hbWUsIGZhbHNlLCBmb2xkZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhbmRvIE5vZG9BcmVhVmlkYTogXCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgYWdyZWdhckFWUShhcmVhVmlkYTogYW55LCB0cmltZXN0cmU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gYFBsYW50aWxsYXMvJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb2xkZXJfQXJlYXNWaWRhfS9QbHQgLSBBcmVhc1ZpZGEubWRgO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCk7XG5cbiAgICBpZiAoISh0ZW1wbGF0ZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgY29uc29sZS5sb2coXCJBcmNoaXZvIG5vIGVuY29udHJhZG8uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBBc2VndXJhIHF1ZSBsYSBmdW5jaVx1MDBGM24gcmV0b3JuYSB1biBib29sZWFubyBpbmNsdXNvIGVuIGNhc28gZGUgZXJyb3IuXG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiQXJjaGl2byBlbmNvbnRyYWRvOlwiLCB0ZW1wbGF0ZSk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBgJHt0cmltZXN0cmV9IC0tICR7YXJlYVZpZGEuYXZ9IC0tICR7YXJlYVZpZGEuZ3J1cG99YDtcbiAgICBsZXQgZm9sZGVyUGF0aCA9IGAke3RoaXMucGx1Z2luLnNldHRpbmdzW2Bmb2xkZXJfQXJlYXNWaWRhYF19LyR7XG4gICAgICBhcmVhVmlkYS5hdlxuICAgIH1gO1xuICAgIGNvbnN0IGZvbGRlciA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyUGF0aCkgYXMgVEZvbGRlcjsgLy8gQXNlZ1x1MDBGQXJhdGUgZGUgcXVlIFwiSW5ib3hcIiByZWFsbWVudGUgZXhpc3RhIHkgc2VhIHVuIFRGb2xkZXIuXG5cbiAgICAvLyBBc3VtaWVuZG8gcXVlIGVsIHRpcG8gZGUgYGZvbGRlcmAgZXMgY29ycmVjdG8geSBxdWUgY3JlYXJOb3RhIGVzIHVuYSBmdW5jaVx1MDBGM24gYXNpbmNyXHUwMEYzbmljYSBxdWUgZGV2dWVsdmUgdm9pZC5cbiAgICBsZXQgY3JlYXJOb3RhID0gdGhpcy5wbHVnaW4udHAuZmlsZS5zdGF0aWNfZnVuY3Rpb25zLmdldChcImNyZWF0ZV9uZXdcIikgYXMgKFxuICAgICAgdGVtcGxhdGU6IFRGaWxlLFxuICAgICAgZmlsZW5hbWU6IHN0cmluZyxcbiAgICAgIG92ZXJ3cml0ZTogYm9vbGVhbixcbiAgICAgIGZvbGRlcjogVEZvbGRlclxuICAgICkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjcmVhck5vdGEodGVtcGxhdGUsIGZpbGVuYW1lLCBmYWxzZSwgZm9sZGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYW5kbyBBcmVhVmlkYTogXCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBib3JyYXJBVlEoZmlsZUFWUSkge1xuICAgIGNvbnNvbGUubG9nKGBMb2dpY2EgZGUgYm9ycmFkbyBkZSAke2ZpbGVBVlEuYmFzZW5hbWV9YCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEFzZWd1cmFyc2UgZGUgcXVlIGZpbGVBVlEgZXMgdW4gb2JqZXRvIFRGaWxlIHZcdTAwRTFsaWRvXG4gICAgICBpZiAoZmlsZUFWUSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgIGF3YWl0IGFwcC52YXVsdC5kZWxldGUoZmlsZUFWUSk7IC8vIEJvcnJhciBlbCBhcmNoaXZvXG4gICAgICAgIGNvbnNvbGUubG9nKGAke2ZpbGVBVlEuYmFzZW5hbWV9IGhhIHNpZG8gYm9ycmFkbyBjb24gXHUwMEU5eGl0by5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYCR7ZmlsZUFWUS5iYXNlbmFtZX0gbm8gZXMgdW4gYXJjaGl2byB2XHUwMEUxbGlkbyBvIG5vIGV4aXN0ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhbCBpbnRlbnRhciBib3JyYXIgJHtmaWxlQVZRLmJhc2VuYW1lfTpgLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGFjdHVhbGl6YXJBVlEoZmlsZUFWUSkge1xuICAgIGNvbnNvbGUubG9nKGBMb2dpY2EgZGUgYWN0dWFsaXphY2lcdTAwRjNuIGRlIGVzdGFkbyBkZSAke2ZpbGVBVlEuYmFzZW5hbWV9YCk7XG5cbiAgICAvLyBPYnRlbmVyIGFjY2VzbyBhIGZ1bmNpb25lcyBkZWwgc2lzdGVtYSB5IG1ldGFkYXRhQ2FjaGVcbiAgICBsZXQgc3VnZ2VzdGVyID0gdGhpcy5wbHVnaW4udHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwic3VnZ2VzdGVyXCIpO1xuICAgIGxldCBtZXRhZGF0YUNhY2hlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGVBVlEpO1xuXG4gICAgLy8gSW5pY2lhbGl6YXIgdmFyaWFibGVzXG4gICAgbGV0IGVzdGFkb0FjdHVhbCA9IFwiXCI7XG4gICAgbGV0IG51ZXZvRXN0YWRvID0gXCJcIjtcblxuICAgIC8vIE9idGVuZXIgZWwgZXN0YWRvIGFjdHVhbCBkZXNkZSBlbCBmcm9udG1hdHRlciB1c2FuZG8gbWV0YWRhdGFDYWNoZVxuICAgIGlmIChcbiAgICAgIG1ldGFkYXRhQ2FjaGUuZnJvbnRtYXR0ZXIgJiZcbiAgICAgIG1ldGFkYXRhQ2FjaGUuZnJvbnRtYXR0ZXIuaGFzT3duUHJvcGVydHkoXCJlc3RhZG9cIilcbiAgICApIHtcbiAgICAgIGVzdGFkb0FjdHVhbCA9IG1ldGFkYXRhQ2FjaGUuZnJvbnRtYXR0ZXIuZXN0YWRvO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIk5vIHNlIGVuY29udHJcdTAwRjMgZWwgZXN0YWRvIGFjdHVhbCBlbiBlbCBmcm9udG1hdHRlci5cIik7XG4gICAgICByZXR1cm47IC8vIFNhbGlyIHNpIG5vIGhheSBlc3RhZG8gYWN0dWFsXG4gICAgfVxuXG4gICAgLy8gTW9zdHJhciBlbCBzdWdnZXN0ZXIgcGFyYSBzZWxlY2Npb25hciBlbCBudWV2byBlc3RhZG9cbiAgICB0cnkge1xuICAgICAgbnVldm9Fc3RhZG8gPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICAgIFtcIlx1RDgzRFx1REQzNSAtPiBBcmNoaXZhZG9cIiwgXCJcdUQ4M0RcdURGRTIgLT4gQWN0aXZvXCIsIFwiXHVEODNEXHVERkUxIC0+IEVuIFBhdXNhXCIsIFwiXHVEODNEXHVERDM0IC0+IERldGVuaWRvXCJdLCAvLyBvcGNpb25lcyBwYXJhIG1vc3RyYXJcbiAgICAgICAgW1wiXHVEODNEXHVERDM1XCIsIFwiXHVEODNEXHVERkUyXCIsIFwiXHVEODNEXHVERkUxXCIsIFwiXHVEODNEXHVERDM0XCJdLCAvLyB2YWxvcmVzIGEgcmV0b3JuYXJcbiAgICAgICAgZmFsc2UsIC8vIHBlcm1pdGUgc2VsZWNjaVx1MDBGM24gbVx1MDBGQWx0aXBsZVxuICAgICAgICBgJHtmaWxlQVZRLmJhc2VuYW1lfSBlc3RcdTAwRTEgJHtlc3RhZG9BY3R1YWx9LiBBc2lnbmFyIGVzdGFkbzpgIC8vIG1lbnNhamVcbiAgICAgICk7XG5cbiAgICAgIC8vIFZlcmlmaWNhciBzaSBzZSBzZWxlY2Npb25cdTAwRjMgdW4gbnVldm8gZXN0YWRvXG4gICAgICBpZiAoIW51ZXZvRXN0YWRvKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gc2Ugc2VsZWNjaW9uXHUwMEYzIHVuIG51ZXZvIGVzdGFkby5cIik7XG4gICAgICAgIHJldHVybjsgLy8gU2FsaXIgc2kgbm8gc2Ugc2VsZWNjaW9uXHUwMEYzIHVuIG51ZXZvIGVzdGFkb1xuICAgICAgfVxuXG4gICAgICAvLyBBY3R1YWxpemFyIGVsIGVzdGFkbyBlbiBlbCBmcm9udG1hdHRlclxuICAgICAgYXdhaXQgYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlQVZRLCAoZnJvbnRtYXR0ZXIpID0+IHtcbiAgICAgICAgaWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KFwiZXN0YWRvXCIpKSB7XG4gICAgICAgICAgZnJvbnRtYXR0ZXIuZXN0YWRvID0gbnVldm9Fc3RhZG87IC8vIEFjdHVhbGl6YXIgZWwgZXN0YWRvXG4gICAgICAgICAgY29uc29sZS5sb2coXCJFc3RhZG8gYWN0dWFsaXphZG8gY29uIFx1MDBFOXhpdG8gYTpcIiwgbnVldm9Fc3RhZG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBhY3R1YWxpemFyIGVsIGVzdGFkbyBlbiBlbCBmcm9udG1hdHRlcjpcIiwgZXJyKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjcmVhckNhcnBldGEoZm9sZGVyUGF0aDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFZlcmlmaWNhIHNpIGxhIGNhcnBldGEgeWEgZXhpc3RlXG5cbiAgICAgIGNvbnN0IGNhcnBldGFFeGlzdGVudGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZvbGRlclBhdGgpO1xuICAgICAgaWYgKGNhcnBldGFFeGlzdGVudGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBMYSBjYXJwZXRhICcke2ZvbGRlclBhdGh9JyB5YSBleGlzdGUuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENyZWEgbGEgY2FycGV0YVxuICAgICAgYXdhaXQgYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihmb2xkZXJQYXRoKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDYXJwZXRhICcke2ZvbGRlclBhdGh9JyBjcmVhZGEgZXhpdG9zYW1lbnRlLmApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhbCBjcmVhciBsYSBjYXJwZXRhICcke2ZvbGRlclBhdGh9JzpgLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gUEFSQSBQUk9DRVNBUiBMT1MgQ09NUEFTU1xuXG4gIC8vIEZ1bmNpXHUwMEYzbiBwYXJhIGNyZWFyIHkgbW9zdHJhciBlbCBib3RcdTAwRjNuIGRlIHByb2Nlc2FyIE9iamV0aXZvcyBkZSBsYXMgQVYgYW51YWxlcyBlbiBlbCBwcm9jZXNvIGRlIENvbXBhc3MuXG4gIGFzeW5jIG1vc3RyYXJCb3RvbkNvbXBhc3NBbnVhbChkdikge1xuICAgIGR2LmNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiOyAvLyBMaW1waWFyIGVsIGNvbnRlbmVkb3JcblxuICAgIGNvbnN0IGJvdG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBib3Rvbi50ZXh0Q29udGVudCA9IFwiUHJvY2VzYXIgT2JqZXRpdm9zIEFWIEFudWFsXCI7XG4gICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGJvdG9uKTtcblxuICAgIGJvdG9uLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc2FyQ29tcGFzc0FudWFsKGR2KTsgLy8gTW9zdHJhciBsb3MgYm90b25lcyBhZGljaW9uYWxlcyBhbCBoYWNlciBjbGljXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIG1vc3RyYXJCb3RvbkNvbXBhc3NUcmltZXN0cmFsKGR2KSB7XG4gICAgZHYuY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7IC8vIExpbXBpYXIgZWwgY29udGVuZWRvclxuXG4gICAgY29uc3QgYm90b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJvdG9uLnRleHRDb250ZW50ID0gXCJQcm9jZXNhciBPYmpldGl2b3MgQVYgVHJpbWVzdHJhbGVzXCI7XG4gICAgZHYuY29udGFpbmVyLmFwcGVuZENoaWxkKGJvdG9uKTtcblxuICAgIGJvdG9uLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc2FyQ29tcGFzc1RyaW1lc3RyYWwoZHYpOyBcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcHJvY2VzYXJDb21wYXNzQW51YWwoZHYpIHtcbiAgXG4gICAgbGV0IGFcdTAwRjFvID0gZHYuY3VycmVudCgpLmFcdTAwRjFvO1xuICAgIGNvbnN0IHJlc3VsdGFkb0FWOiBHcnVwb0FWW10gPSBbXTtcbiAgICBjb25zdCBmaWxlQ2FtcG9zID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnBhdGhDYW1wb3MpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoZmlsZUNhbXBvcyBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgIC8vIFVzYSBtZXRhZGF0YUNhY2hlIHBhcmEgb2J0ZW5lciBsb3MgbWV0YWRhdG9zIGRlbCBhcmNoaXZvXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGVDYW1wb3MpO1xuICAgICAgICBjb25zdCBhcnJlZ2xvQVYgPSBtZXRhZGF0YT8uZnJvbnRtYXR0ZXI/LkFyZWFzVmlkYSB8fCBbXTtcbiAgICAgICAgLy8gUmVsbGVuYSBlbCBhcnJlZ2xvIGNvbiBsb3MgZGF0b3MgZGVsIGFycmVnbG9SZXN1bHRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyZWdsb0FWKSkge1xuICAgICAgICAgIGFycmVnbG9BVi5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSAmJiBpdGVtLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgIHJlc3VsdGFkb0FWLnB1c2goe1xuICAgICAgICAgICAgICAgIGdydXBvOiBpdGVtWzBdLFxuICAgICAgICAgICAgICAgIGF2OiBpdGVtWzFdLFxuICAgICAgICAgICAgICAgIHRleHRvOiBpdGVtWzBdICsgXCIgLyBcIiArIGl0ZW1bMV0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvYnRlbmllbmRvIGVsIGFyY2hpdm8gZGUgY2FtcG9zOlwiLCBlcnJvcik7XG4gICAgICAvLyBBcXVcdTAwRUQgbWFuZWphclx1MDBFRGFzIGVsIGVycm9yIGNvbW8gc2VhIGFwcm9waWFkbyBwYXJhIHR1IGFwbGljYWNpXHUwMEYzblxuICAgICAgdGhyb3cgZXJyb3I7IC8vIE8gZGV2b2x2ZXIgdW4gYXJyZWdsbyB2YWNcdTAwRURvIGNvbW8gcmVzdWx0YWRvIGRlIGVycm9yXG4gICAgfVxuXG4gICAgY29uc3QgYWxsRmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgIGxldCBiYXNlUGF0aCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9BcmVhc1ZpZGE7XG5cbiAgICAvLyAtLi4tPiBSZXZpc2lcdTAwRjNuIGRlIGVzY2VuYXJpb3MuXG4gICAgZGVidWdnZXI7XG4gICAgZm9yIChsZXQgYXJlYVZpZGEgb2YgcmVzdWx0YWRvQVYpIHtcbiAgICAgIC8vIFZlcmlmaWNhIHNpIGxhIGNhcnBldGEgZXhpc3RlIGVuIGxhIHViaWNhY2lcdTAwRjNuIGVzcGVjXHUwMEVEZmljYVxuICAgICAgY29uc3QgZnVsbEZvbGRlclBhdGggPSBgJHtiYXNlUGF0aH0vJHthcmVhVmlkYS5hdn1gO1xuICAgICAgY29uc3QgZm9sZGVyID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmdWxsRm9sZGVyUGF0aCk7XG5cbiAgICAgIC8vUDAgLT4gVmVyaWZpY2Egc2kgbGEgY2FycGV0YSBwYXRoL2FyZWFWaWRhIGV4aXN0ZVxuICAgICAgLy9QMCAtIFNJXG4gICAgICBpZiAoZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikge1xuICAgICAgICBjb25zb2xlLmxvZyhgTGEgY2FycGV0YSAke2FyZWFWaWRhLmF2fSBleGlzdGUgZGVudHJvIGRlICR7YmFzZVBhdGh9LmApO1xuICAgICAgICAvLyBBaG9yYSwgdmVyaWZpY2Egc2kgbGEgbm90YSBleGlzdGUgZGVudHJvIGRlIGxhIGNhcnBldGFcbiAgICAgICAgY29uc3QgaW5zdGFuY2VzT2ZBViA9IGFwcC52YXVsdFxuICAgICAgICAgIC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgKGZpbGUpID0+XG4gICAgICAgICAgICAgIGZpbGUucGF0aC5pbmNsdWRlcyhmdWxsRm9sZGVyUGF0aCkgJiZcbiAgICAgICAgICAgICAgIWZpbGUucGF0aC5pbmNsdWRlcyhcIlBsYW50aWxsYXNcIikgJiZcbiAgICAgICAgICAgICAgIWZpbGUucGF0aC5pbmNsdWRlcyhcIkFyY2hpdm9cIilcbiAgICAgICAgICApO1xuICAgICAgICAvLyBQMSBFeGlzdGUgbm9kZUFyZWFWaWRhP1xuICAgICAgICBjb25zdCBub2RlQVZFeGlzdHMgPSBpbnN0YW5jZXNPZkFWLnNvbWUoXG4gICAgICAgICAgKGZpbGUpID0+IGZpbGUuYmFzZW5hbWUgPT09IGFyZWFWaWRhLmF2XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUDEgU0lcbiAgICAgICAgaWYgKG5vZGVBVkV4aXN0cykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYExhIG5vdGEgJHthcmVhVmlkYS5hdn0gZXhpc3RlIGRlbnRybyBkZSBsYSBjYXJwZXRhICR7YXJlYVZpZGEuYXZ9LmBcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIFAyIGFyZWFWaWRhIFEgRXhpc3RlP1xuICAgICAgICAgIC8vIFByZWd1bnRhciBFbCBvYmpldGl2byB5IGd1YXJkYXJsbyBlbiBlbCBub2RvIGRlIEFWLlxuICAgICAgICAgIGF3YWl0IHRoaXMub2JqZXRpdm9BbnVhbChhXHUwMEYxbywgYXJlYVZpZGEuYXYpO1xuICAgICAgICB9XG4gICAgICAgIC8vUDEgLSBOTyAobm9kZUFyZWFWaWRhIG5vIEV4aXN0ZSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gQ2FzbyAzIHkgNFxuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYExhIG5vdGEgJHthcmVhVmlkYS5hdn0gbm8gZXhpc3RlIGRlbnRybyBkZSBsYSBjYXJwZXRhICR7YXJlYVZpZGEuYXZ9LmBcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIFAzIEFncmVnYXIgTm9kbyBBcmVhIFZpZGE/XG4gICAgICAgICAgbGV0IG5BViA9IGF3YWl0IHRoaXMuYWdyZWdhck5vZG9BcmVhVmlkYShhcmVhVmlkYSk7IC8vIFF1aWVyZXMgQWdyZWdhciBlc3RhIEFWIGEgdHUgc2lzdGVtYSBkZSBHZXN0aVx1MDBGM24/XG4gICAgICAgICAgLy9QMyAtPiBTSVxuICAgICAgICAgIGlmIChuQVYpIHtcbiAgICAgICAgICAgIC8vIFAyIC4uIC0+IFNpIHkgTm9cbiAgICAgICAgICAgIGF3YWl0IHRoaXMub2JqZXRpdm9BbnVhbChhXHUwMEYxbywgYXJlYVZpZGEuYXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL1AzIC0+IE5PXG4gICAgICAgICAgZWxzZSBpZiAobkFWID09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTsgLy9TZW50ZW5jaWEgcXVlIGRlYmUgcGFzYXIgYWwgc2lndWllbnRlIGVsZW1lbnRvIGRlbCBjaWNsbyBmb3IuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gRW4gY2FzbyBkZSBxdWUgc2UgZGUgZXNjYXBlLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUE8gLT4gTk8gKExhIENhcnBldGEgbm8gZXhpc3RlKVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGBMYSBjYXJwZXRhICR7YXJlYVZpZGEuYXZ9IG5vIGV4aXN0ZSBhXHUwMEZBbiBkZW50cm8gZGUgJHtiYXNlUGF0aH0uYFxuICAgICAgICApO1xuICAgICAgICAvLyBQMyBBZ3JlZ2FyIE5vZG8gQXJlYSBWaWRhP1xuICAgICAgICBsZXQgbkFWID0gYXdhaXQgdGhpcy5hZ3JlZ2FyTm9kb0FyZWFWaWRhKGFyZWFWaWRhKTsgLy8gUXVpZXJlcyBBZ3JlZ2FyIGVzdGEgQVYgYSB0dSBzaXN0ZW1hIGRlIEdlc3RpXHUwMEYzbj9cbiAgICAgICAgLy8gUDMgLT4gU0lcbiAgICAgICAgaWYgKG5BVikge1xuICAgICAgICAgIC8vIFAyXG4gICAgICAgICAgYXdhaXQgdGhpcy5vYmpldGl2b0FudWFsKGFcdTAwRjFvLCBhcmVhVmlkYS5hdik7XG4gICAgICAgIH1cbiAgICAgICAgLy9QMyAtPiBOT1xuICAgICAgICBlbHNlIGlmIChuQVYgPT0gZmFsc2UpIHtcbiAgICAgICAgICBjb250aW51ZTsgLy9TZW50ZW5jaWEgcXVlIGRlYmUgcGFzYXIgYWwgc2lndWllbnRlIGVsZW1lbnRvIGRlbCBjaWNsbyBmb3IuXG4gICAgICAgIH1cbiAgICAgICAgLy8gUDMgLT4gRXNjYXBlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybjsgLy8gRW4gY2FzbyBkZSBxdWUgc2UgZGUgZXNjYXBlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBGaW4gRm9yIEFyZWFzVmlkYSBmaWxlQ2FtcG9zXG4gIH0gLy8gTWV0b2RvIFByb2Nlc2FyIENvbXBhc3MgQW51YWxcblxuICBhc3luYyBwcm9jZXNhckNvbXBhc3NUcmltZXN0cmFsKGR2KSB7XG4gICAgZGVidWdnZXI7XG4gICAgbGV0IHRyaW1lc3RyZSA9IGR2LmN1cnJlbnQoKS50cmltZXN0cmU7XG4gICAgY29uc3QgcmVzdWx0YWRvQVY6IEdydXBvQVZbXSA9IFtdO1xuICAgIGNvbnN0IGZpbGVDYW1wb3MgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMucGF0aENhbXBvcyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmaWxlQ2FtcG9zIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgLy8gVXNhIG1ldGFkYXRhQ2FjaGUgcGFyYSBvYnRlbmVyIGxvcyBtZXRhZGF0b3MgZGVsIGFyY2hpdm9cbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZUNhbXBvcyk7XG4gICAgICAgIGNvbnN0IGFycmVnbG9BViA9IG1ldGFkYXRhPy5mcm9udG1hdHRlcj8uQXJlYXNWaWRhIHx8IFtdO1xuICAgICAgICAvLyBSZWxsZW5hIGVsIGFycmVnbG8gY29uIGxvcyBkYXRvcyBkZWwgYXJyZWdsb1Jlc3VsdFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJlZ2xvQVYpKSB7XG4gICAgICAgICAgYXJyZWdsb0FWLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pICYmIGl0ZW0ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0YWRvQVYucHVzaCh7XG4gICAgICAgICAgICAgICAgZ3J1cG86IGl0ZW1bMF0sXG4gICAgICAgICAgICAgICAgYXY6IGl0ZW1bMV0sXG4gICAgICAgICAgICAgICAgdGV4dG86IGl0ZW1bMF0gKyBcIiAvIFwiICsgaXRlbVsxXSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9idGVuaWVuZG8gZWwgYXJjaGl2byBkZSBjYW1wb3M6XCIsIGVycm9yKTtcbiAgICAgIC8vIEFxdVx1MDBFRCBtYW5lamFyXHUwMEVEYXMgZWwgZXJyb3IgY29tbyBzZWEgYXByb3BpYWRvIHBhcmEgdHUgYXBsaWNhY2lcdTAwRjNuXG4gICAgICB0aHJvdyBlcnJvcjsgLy8gTyBkZXZvbHZlciB1biBhcnJlZ2xvIHZhY1x1MDBFRG8gY29tbyByZXN1bHRhZG8gZGUgZXJyb3JcbiAgICB9XG5cbiAgICBjb25zdCBhbGxGaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgbGV0IGJhc2VQYXRoID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyX0FyZWFzVmlkYTtcblxuICAgIC8vIC0uLi0+IFJldmlzaVx1MDBGM24gZGUgZXNjZW5hcmlvcy5cbiAgICBmb3IgKGxldCBhcmVhVmlkYSBvZiByZXN1bHRhZG9BVikge1xuICAgICAgLy8gVmVyaWZpY2Egc2kgbGEgY2FycGV0YSBleGlzdGUgZW4gbGEgdWJpY2FjaVx1MDBGM24gZXNwZWNcdTAwRURmaWNhXG4gICAgICBjb25zdCBmdWxsRm9sZGVyUGF0aCA9IGAke2Jhc2VQYXRofS8ke2FyZWFWaWRhLmF2fWA7XG4gICAgICBjb25zdCBmb2xkZXIgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZ1bGxGb2xkZXJQYXRoKTtcblxuICAgICAgLy9QMCAtPiBWZXJpZmljYSBzaSBsYSBjYXJwZXRhIHBhdGgvYXJlYVZpZGEgZXhpc3RlXG4gICAgICAvL1AwIC0gU0lcbiAgICAgIGlmIChmb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBMYSBjYXJwZXRhICR7YXJlYVZpZGEuYXZ9IGV4aXN0ZSBkZW50cm8gZGUgJHtiYXNlUGF0aH0uYCk7XG4gICAgICAgIC8vIEFob3JhLCB2ZXJpZmljYSBzaSBsYSBub3RhIGV4aXN0ZSBkZW50cm8gZGUgbGEgY2FycGV0YVxuICAgICAgICBjb25zdCBpbnN0YW5jZXNPZkFWID0gYXBwLnZhdWx0XG4gICAgICAgICAgLmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAoZmlsZSkgPT5cbiAgICAgICAgICAgICAgZmlsZS5wYXRoLmluY2x1ZGVzKGZ1bGxGb2xkZXJQYXRoKSAmJlxuICAgICAgICAgICAgICAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiUGxhbnRpbGxhc1wiKSAmJlxuICAgICAgICAgICAgICAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiQXJjaGl2b1wiKVxuICAgICAgICAgICk7XG4gICAgICAgIC8vIFAxIEV4aXN0ZSBub2RlQXJlYVZpZGE/XG4gICAgICAgIGNvbnN0IG5vZGVBVkV4aXN0cyA9IGluc3RhbmNlc09mQVYuc29tZShcbiAgICAgICAgICAoZmlsZSkgPT4gZmlsZS5iYXNlbmFtZSA9PT0gYXJlYVZpZGEuYXZcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQMSBTSVxuICAgICAgICBpZiAobm9kZUFWRXhpc3RzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgTGEgbm90YSAke2FyZWFWaWRhLmF2fSBleGlzdGUgZGVudHJvIGRlIGxhIGNhcnBldGEgJHthcmVhVmlkYS5hdn0uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gUDIgYXJlYVZpZGEgUSBFeGlzdGU/XG4gICAgICAgICAgLy8gUHJlZ3VudGFyIEVsIG9iamV0aXZvIHkgZ3VhcmRhcmxvIGVuIGVsIG5vZG8gZGUgQVYuXG4gICAgICAgICAgYXdhaXQgdGhpcy5vYmpldGl2b1RyaW1lc3RyYWwodHJpbWVzdHJlLCBhcmVhVmlkYS5hdik7XG4gICAgICAgIH1cbiAgICAgICAgLy9QMSAtIE5PIChub2RlQXJlYVZpZGEgbm8gRXhpc3RlKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBDYXNvIDMgeSA0XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgTGEgbm90YSAke2FyZWFWaWRhLmF2fSBubyBleGlzdGUgZGVudHJvIGRlIGxhIGNhcnBldGEgJHthcmVhVmlkYS5hdn0uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gUDMgQWdyZWdhciBOb2RvIEFyZWEgVmlkYT9cbiAgICAgICAgICBsZXQgbkFWID0gYXdhaXQgdGhpcy5hZ3JlZ2FyTm9kb0FyZWFWaWRhKGFyZWFWaWRhKTsgLy8gUXVpZXJlcyBBZ3JlZ2FyIGVzdGEgQVYgYSB0dSBzaXN0ZW1hIGRlIEdlc3RpXHUwMEYzbj9cbiAgICAgICAgICAvL1AzIC0+IFNJXG4gICAgICAgICAgaWYgKG5BVikge1xuICAgICAgICAgICAgLy8gUDIgLi4gLT4gU2kgeSBOb1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5vYmpldGl2b1RyaW1lc3RyYWwodHJpbWVzdHJlLCBhcmVhVmlkYS5hdik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vUDMgLT4gTk9cbiAgICAgICAgICBlbHNlIGlmIChuQVYgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvL1NlbnRlbmNpYSBxdWUgZGViZSBwYXNhciBhbCBzaWd1aWVudGUgZWxlbWVudG8gZGVsIGNpY2xvIGZvci5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBFbiBjYXNvIGRlIHF1ZSBzZSBkZSBlc2NhcGUuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBQTyAtPiBOTyAoTGEgQ2FycGV0YSBubyBleGlzdGUpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYExhIGNhcnBldGEgJHthcmVhVmlkYS5hdn0gbm8gZXhpc3RlIGFcdTAwRkFuIGRlbnRybyBkZSAke2Jhc2VQYXRofS5gXG4gICAgICAgICk7XG4gICAgICAgIC8vIFAzIEFncmVnYXIgTm9kbyBBcmVhIFZpZGE/XG4gICAgICAgIGxldCBuQVYgPSBhd2FpdCB0aGlzLmFncmVnYXJOb2RvQXJlYVZpZGEoYXJlYVZpZGEpOyAvLyBRdWllcmVzIEFncmVnYXIgZXN0YSBBViBhIHR1IHNpc3RlbWEgZGUgR2VzdGlcdTAwRjNuP1xuICAgICAgICAvLyBQMyAtPiBTSVxuICAgICAgICBpZiAobkFWKSB7XG4gICAgICAgICAgLy8gUDJcbiAgICAgICAgICBhd2FpdCB0aGlzLm9iamV0aXZvVHJpbWVzdHJhbCh0cmltZXN0cmUsIGFyZWFWaWRhLmF2KTtcbiAgICAgICAgfVxuICAgICAgICAvL1AzIC0+IE5PXG4gICAgICAgIGVsc2UgaWYgKG5BViA9PSBmYWxzZSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvL1NlbnRlbmNpYSBxdWUgZGViZSBwYXNhciBhbCBzaWd1aWVudGUgZWxlbWVudG8gZGVsIGNpY2xvIGZvci5cbiAgICAgICAgfVxuICAgICAgICAvLyBQMyAtPiBFc2NhcGVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBFbiBjYXNvIGRlIHF1ZSBzZSBkZSBlc2NhcGUuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEZpbiBGb3IgQXJlYXNWaWRhIGZpbGVDYW1wb3NcbiAgfSAvLyBNZXRvZG8gUHJvY2VzYXIgQ29tcGFzcyBUcmltZXN0cmFsIFxuXG5cbiAgYXN5bmMgb2JqZXRpdm9BbnVhbChhXHUwMEYxbzogYW55LCBhcmVhVmlkYTogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQnVzY2FyIHNpIHlhIGhheSBvYmpldGl2b3MgY3JlYWRvcyBwYXJhIGVzZSBhXHUwMEYxbyB5IGVzYSBhcmVhIGRlIHZpZGEuXG5cbiAgICBjb25zdCBmb2xkZXJPYmogPSB0aGlzLnBsdWdpbi5zZXR0aW5nc1tcImZvbGRlcl9PYmpDb21wYXNzQW51YWxcIl07XG4gICAgY29uc3QgZmlsZXNPYmogPSBhcHAudmF1bHRcbiAgICAgIC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICAgIC5maWx0ZXIoXG4gICAgICAgIChmaWxlKSA9PlxuICAgICAgICAgIGZpbGUucGF0aC5pbmNsdWRlcyhmb2xkZXJPYmopICYmXG4gICAgICAgICAgIWZpbGUucGF0aC5pbmNsdWRlcyhcIlBsYW50aWxsYXNcIikgJiZcbiAgICAgICAgICAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiQXJjaGl2b1wiKVxuICAgICAgKTtcbiAgICBsZXQgb2JqQ3JlYWRvcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlc09iaikge1xuICAgICAgZGVidWdnZXI7XG4gICAgICBsZXQgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyO1xuICAgICAgY29uc3QgcmVnZXggPSAvXFxbXFxbXFxzKiguKj8pXFxzKlxcXVxcXS87XG4gICAgICBsZXQgZmlsZUFWID0gbWV0YWRhdGE/LmFyZWFWaWRhLm1hdGNoKHJlZ2V4KVsxXTtcbiAgICAgIGNvbnN0IHNhbWVBViA9IGZpbGVBViA9PT0gYXJlYVZpZGE7XG5cbiAgICAgIGlmIChtZXRhZGF0YT8uYVx1MDBGMW8gPT09IGFcdTAwRjFvICYmIHNhbWVBVikge1xuICAgICAgICBsZXQgb2JqQWN0aXZvID0geyBmaWxlIH07IC8vIEFzdW1pZW5kbyBxdWUgcXVpZXJlcyBndWFyZGFyIGVsIHBhdGggZGVsIGFyY2hpdm9cbiAgICAgICAgT2JqZWN0LmFzc2lnbihvYmpBY3Rpdm8sIG1ldGFkYXRhKTsgLy8gQWdyZWdhIGVsIG1ldGFkYXRhIGFsIG9iamV0byBxQWN0aXZvXG4gICAgICAgIG9iakNyZWFkb3MucHVzaChvYmpBY3Rpdm8pOyAvLyBBXHUwMEYxYWRlIGVsIHJlZ2lzdHJvIGFjdGl2byBhbCBhcnJheVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJvbXB0ID0gdGhpcy5wbHVnaW4udHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwicHJvbXB0XCIpO1xuICAgIGxldCBzdWdnZXN0ZXIgPSB0aGlzLnBsdWdpbi50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJzdWdnZXN0ZXJcIik7XG4gICAgbGV0IG9iamV0aXZvcyA9IFtdO1xuICAgIGxldCBkZXNlYUFncmVnYXJPYmpldGl2bztcbiAgICBpZiAob2JqQ3JlYWRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFNpIGhheSBvYmpldGl2b3MgY3JlYWRvcy5cbiAgICAgICAgLy8gTG9naWNhIGN1YW5kbyB5YSBoYXkgb2JqZXRpdm9zIGNyZWFkb3MuXG4gICAgICBsZXQgbmV4dFN0ZXAgPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICAgIFtcbiAgICAgICAgICBcIkFncmVnYXIgT2JqZXRpdm9zXCIsXG4gICAgICAgICAgXCJCb3JyYXIgeSBDcmVhciBkZSBudWV2byBsb3Mgb2JqZXRpdm9zXCIsXG4gICAgICAgICAgXCJEZWphciBsb3Mgb2JqZXRpdm9zIGNvbW8gZXN0XHUwMEUxbiBcIixcbiAgICAgICAgXSxcbiAgICAgICAgW1widXBkXCIsIFwiZGVsK2NyZVwiLCBcImNvbnRpbnVlXCJdLFxuICAgICAgICB0cnVlLFxuICAgICAgICBgXHUwMEJGWWEgaGF5ICR7b2JqQ3JlYWRvcy5sZW5ndGh9IG9iamV0aXZvcyBjcmVhZG9zIHBhcmEgJHthcmVhVmlkYX0gZW4gZWwgJHthXHUwMEYxb30uIEVsaWdlIHVuYSBvcGNpXHUwMEYzbjpgXG4gICAgICApO1xuXG4gICAgICAgIHN3aXRjaCAobmV4dFN0ZXApIHtcbiAgICAgICAgICBjYXNlIFwidXBkXCI6XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGxldCBvYmpldGl2byA9IGF3YWl0IHRoaXMuY3JlYXJPYmpldGl2byhhcmVhVmlkYSwgYVx1MDBGMW8pO1xuXG4gICAgICAgICAgICAgIC8vIFByZWd1bnRhciBudWV2YW1lbnRlIHNpIGRlc2VhIGFncmVnYXIgb3RybyBvYmpldGl2by5cbiAgICAgICAgICAgICAgZGVzZWFBZ3JlZ2FyT2JqZXRpdm8gPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICAgICAgICAgICAgW1wiU2lcIiwgXCJOb1wiXSxcbiAgICAgICAgICAgICAgICBbdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgYFx1MDBCRkRlc2VhIGFncmVnYXIgb3RybyBvYmpldGl2byBwYXJhICR7YXJlYVZpZGF9IGVuICR7YVx1MDBGMW99P2BcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGRlc2VhQWdyZWdhck9iamV0aXZvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkZWwrY3JlXCI6XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJvcnJhck9iamV0aXZvcyhvYmpDcmVhZG9zKTtcbiAgICAgICAgICAgIGRlc2VhQWdyZWdhck9iamV0aXZvID0gYXdhaXQgc3VnZ2VzdGVyKFxuICAgICAgICAgICAgICBbXCJTaVwiLCBcIk5vXCJdLFxuICAgICAgICAgICAgICBbdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICBgXHUwMEJGRGVzZWEgYWdyZWdhciBhbGdcdTAwRkFuIG9iamV0aXZvIHBhcmEgJHthcmVhVmlkYX0gZW4gJHthXHUwMEYxb30/YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdoaWxlIChkZXNlYUFncmVnYXJPYmpldGl2bykge1xuICAgICAgICAgICAgICBsZXQgb2JqZXRpdm8gPSBhd2FpdCB0aGlzLmNyZWFyT2JqZXRpdm8oYXJlYVZpZGEsIGFcdTAwRjFvKTtcbiAgICAgICAgICAgICAgLy8gQm9ycmFyIGxvcyBvYmpldGl2b3MgYW50ZXJpb3Jlcy5cbiAgICAgICAgICAgICAgLy8gUHJlZ3VudGFyIG51ZXZhbWVudGUgc2kgZGVzZWEgYWdyZWdhciBvdHJvIG9iamV0aXZvLlxuICAgICAgICAgICAgICBkZXNlYUFncmVnYXJPYmpldGl2byA9IGF3YWl0IHN1Z2dlc3RlcihcbiAgICAgICAgICAgICAgICBbXCJTaVwiLCBcIk5vXCJdLFxuICAgICAgICAgICAgICAgIFt0cnVlLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBgXHUwMEJGRGVzZWEgYWdyZWdhciBvdHJvIG9iamV0aXZvIHBhcmEgJHthcmVhVmlkYX0gZW4gJHthXHUwMEYxb30/YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNvbnRpbnVlXCI6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQ29udGludWFyIHNpbiBoYWNlciBuYWRhIGNvbiBsb3Mgb2JqZXRpdm9zIGRlICR7YXJlYVZpZGF9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTm8gaGF5IG9iamV0aXZvcyBjcmVhZG9zLlxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFZlcmlmaWNhciBzaSBkZXNlYSBhZ3JlZ2FyIGFsZ1x1MDBGQW4gb2JqZXRpdm8uXG4gICAgICAgIGRlc2VhQWdyZWdhck9iamV0aXZvID0gYXdhaXQgc3VnZ2VzdGVyKFxuICAgICAgICAgIFtcIlNpXCIsIFwiTm9cIl0sXG4gICAgICAgICAgW3RydWUsIGZhbHNlXSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIGBcdTAwQkZEZXNlYSBhZ3JlZ2FyIGFsZ1x1MDBGQW4gb2JqZXRpdm8gcGFyYSAke2FyZWFWaWRhfSBlbiAke2FcdTAwRjFvfT9gXG4gICAgICAgICk7XG4gICAgICAgIHdoaWxlIChkZXNlYUFncmVnYXJPYmpldGl2bykge1xuICAgICAgICAgIGxldCBvYmpldGl2byA9IGF3YWl0IHRoaXMuY3JlYXJPYmpldGl2byhhcmVhVmlkYSwgYVx1MDBGMW8pO1xuICAgICAgICAgIG9iamV0aXZvcy5wdXNoKFtvYmpldGl2b10pO1xuXG4gICAgICAgICAgLy8gUHJlZ3VudGFyIG51ZXZhbWVudGUgc2kgZGVzZWEgYWdyZWdhciBvdHJvIG9iamV0aXZvLlxuICAgICAgICAgIGRlc2VhQWdyZWdhck9iamV0aXZvID0gYXdhaXQgc3VnZ2VzdGVyKFxuICAgICAgICAgICAgW1wiU2lcIiwgXCJOb1wiXSxcbiAgICAgICAgICAgIFt0cnVlLCBmYWxzZV0sXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgYFx1MDBCRkRlc2VhIGFncmVnYXIgb3RybyBvYmpldGl2byBwYXJhICR7YXJlYVZpZGF9IGVuICR7YVx1MDBGMW99P2BcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gIH0gLy8gTVx1MDBFOXRvZG8gb2JqZXRpdm9BbnVhbC5cbiAgXG4gIGFzeW5jIG9iamV0aXZvVHJpbWVzdHJhbCh0cmltZXN0cmU6IGFueSwgYXJlYVZpZGE6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGRlYnVnZ2VyO1xuICAgIC8vIEJ1c2NhciBzaSB5YSBoYXkgb2JqZXRpdm9zIGNyZWFkb3MgcGFyYSBlc2UgYVx1MDBGMW8geSBlc2EgYXJlYSBkZSB2aWRhLlxuXG4gICAgY29uc3QgZm9sZGVyT2JqID0gdGhpcy5wbHVnaW4uc2V0dGluZ3NbXCJmb2xkZXJfT2JqQ29tcGFzc0FudWFsXCJdO1xuICAgIGNvbnN0IGZpbGVzT2JqID0gYXBwLnZhdWx0XG4gICAgICAuZ2V0TWFya2Rvd25GaWxlcygpXG4gICAgICAuZmlsdGVyKFxuICAgICAgICAoZmlsZSkgPT5cbiAgICAgICAgICBmaWxlLnBhdGguaW5jbHVkZXMoZm9sZGVyT2JqKSAmJlxuICAgICAgICAgICFmaWxlLnBhdGguaW5jbHVkZXMoXCJQbGFudGlsbGFzXCIpICYmXG4gICAgICAgICAgIWZpbGUucGF0aC5pbmNsdWRlcyhcIkFyY2hpdm9cIilcbiAgICAgICk7XG4gICAgbGV0IG9iakNyZWFkb3MgPSBbXTtcblxuICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXNPYmopIHtcbiAgICAgIGRlYnVnZ2VyO1xuICAgICAgbGV0IG1ldGFkYXRhID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlcjtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL1xcW1xcW1xccyooLio/KVxccypcXF1cXF0vO1xuICAgICAgbGV0IGZpbGVBViA9IG1ldGFkYXRhPy5hcmVhVmlkYS5tYXRjaChyZWdleClbMV07XG4gICAgICBjb25zdCBzYW1lQVYgPSBmaWxlQVYgPT09IGFyZWFWaWRhO1xuXG4gICAgICBpZiAobWV0YWRhdGE/LnRyaW1lc3RyZT8ucGF0aCAmJiB0eXBlb2YgKG1ldGFkYXRhLnRyaW1lc3RyZS5wYXRoID09PSAnc3RyaW5nJykgJiYgIG1ldGFkYXRhLnRyaW1lc3RyZS5wYXRoLmluY2x1ZGVzKHRyaW1lc3RyZSkgJiYgc2FtZUFWKSB7XG4gICAgICAgIGxldCBvYmpBY3Rpdm8gPSB7IGZpbGUgfTsgLy8gQXN1bWllbmRvIHF1ZSBxdWllcmVzIGd1YXJkYXIgZWwgcGF0aCBkZWwgYXJjaGl2b1xuICAgICAgICBPYmplY3QuYXNzaWduKG9iakFjdGl2bywgbWV0YWRhdGEpOyAvLyBBZ3JlZ2EgZWwgbWV0YWRhdGEgYWwgb2JqZXRvIHFBY3Rpdm9cbiAgICAgICAgb2JqQ3JlYWRvcy5wdXNoKG9iakFjdGl2byk7IC8vIEFcdTAwRjFhZGUgZWwgcmVnaXN0cm8gYWN0aXZvIGFsIGFycmF5XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwcm9tcHQgPSB0aGlzLnBsdWdpbi50cC5zeXN0ZW0uc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJwcm9tcHRcIik7XG4gICAgbGV0IHN1Z2dlc3RlciA9IHRoaXMucGx1Z2luLnRwLnN5c3RlbS5zdGF0aWNfZnVuY3Rpb25zLmdldChcInN1Z2dlc3RlclwiKTtcbiAgICBsZXQgb2JqZXRpdm9zID0gW107XG4gICAgbGV0IGRlc2VhQWdyZWdhck9iamV0aXZvO1xuICAgIGlmIChvYmpDcmVhZG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gU2kgaGF5IG9iamV0aXZvcyBjcmVhZG9zLlxuICAgICAgICAvLyBMb2dpY2EgY3VhbmRvIHlhIGhheSBvYmpldGl2b3MgY3JlYWRvcy5cbiAgICAgIGxldCBuZXh0U3RlcCA9IGF3YWl0IHN1Z2dlc3RlcihcbiAgICAgICAgW1xuICAgICAgICAgIFwiQWdyZWdhciBPYmpldGl2b3NcIixcbiAgICAgICAgICBcIkJvcnJhciB5IENyZWFyIGRlIG51ZXZvIGxvcyBvYmpldGl2b3NcIixcbiAgICAgICAgICBcIkRlamFyIGxvcyBvYmpldGl2b3MgY29tbyBlc3RcdTAwRTFuIFwiLFxuICAgICAgICBdLFxuICAgICAgICBbXCJ1cGRcIiwgXCJkZWwrY3JlXCIsIFwiY29udGludWVcIl0sXG4gICAgICAgIHRydWUsXG4gICAgICAgIGBcdTAwQkZZYSBoYXkgJHtvYmpDcmVhZG9zLmxlbmd0aH0gb2JqZXRpdm9zIGNyZWFkb3MgcGFyYSAke2FyZWFWaWRhfSBlbiBlbCAke3RyaW1lc3RyZX0uIEVsaWdlIHVuYSBvcGNpXHUwMEYzbjpgXG4gICAgICApO1xuXG4gICAgICAgIHN3aXRjaCAobmV4dFN0ZXApIHtcbiAgICAgICAgICBjYXNlIFwidXBkXCI6XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGxldCBvYmpldGl2byA9IGF3YWl0IHRoaXMuY3JlYXJPYmpldGl2b1RyaW1lc3RyZShhcmVhVmlkYSwgdHJpbWVzdHJlKTtcblxuICAgICAgICAgICAgICAvLyBQcmVndW50YXIgbnVldmFtZW50ZSBzaSBkZXNlYSBhZ3JlZ2FyIG90cm8gb2JqZXRpdm8uXG4gICAgICAgICAgICAgIGRlc2VhQWdyZWdhck9iamV0aXZvID0gYXdhaXQgc3VnZ2VzdGVyKFxuICAgICAgICAgICAgICAgIFtcIlNpXCIsIFwiTm9cIl0sXG4gICAgICAgICAgICAgICAgW3RydWUsIGZhbHNlXSxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIGBcdTAwQkZEZXNlYSBhZ3JlZ2FyIG90cm8gb2JqZXRpdm8gcGFyYSAke2FyZWFWaWRhfSBlbiAke3RyaW1lc3RyZX0/YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSB3aGlsZSAoZGVzZWFBZ3JlZ2FyT2JqZXRpdm8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRlbCtjcmVcIjpcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYm9ycmFyT2JqZXRpdm9zKG9iakNyZWFkb3MpO1xuICAgICAgICAgICAgZGVzZWFBZ3JlZ2FyT2JqZXRpdm8gPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICAgICAgICAgIFtcIlNpXCIsIFwiTm9cIl0sXG4gICAgICAgICAgICAgIFt0cnVlLCBmYWxzZV0sXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgIGBcdTAwQkZEZXNlYSBhZ3JlZ2FyIGFsZ1x1MDBGQW4gb2JqZXRpdm8gcGFyYSAke2FyZWFWaWRhfSBlbiAke3RyaW1lc3RyZX0/YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdoaWxlIChkZXNlYUFncmVnYXJPYmpldGl2bykge1xuICAgICAgICAgICAgICBsZXQgb2JqZXRpdm8gPSBhd2FpdCB0aGlzLmNyZWFyT2JqZXRpdm9UcmltZXN0cmUoYXJlYVZpZGEsIHRyaW1lc3RyZSk7XG4gICAgICAgICAgICAgIC8vIEJvcnJhciBsb3Mgb2JqZXRpdm9zIGFudGVyaW9yZXMuXG4gICAgICAgICAgICAgIC8vIFByZWd1bnRhciBudWV2YW1lbnRlIHNpIGRlc2VhIGFncmVnYXIgb3RybyBvYmpldGl2by5cbiAgICAgICAgICAgICAgZGVzZWFBZ3JlZ2FyT2JqZXRpdm8gPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICAgICAgICAgICAgW1wiU2lcIiwgXCJOb1wiXSxcbiAgICAgICAgICAgICAgICBbdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgYFx1MDBCRkRlc2VhIGFncmVnYXIgb3RybyBvYmpldGl2byBwYXJhICR7YXJlYVZpZGF9IGVuICR7dHJpbWVzdHJlfT9gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDb250aW51YXIgc2luIGhhY2VyIG5hZGEgY29uIGxvcyBvYmpldGl2b3MgZGUgJHthcmVhVmlkYX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBObyBoYXkgb2JqZXRpdm9zIGNyZWFkb3MuXG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gVmVyaWZpY2FyIHNpIGRlc2VhIGFncmVnYXIgYWxnXHUwMEZBbiBvYmpldGl2by5cbiAgICAgICAgZGVzZWFBZ3JlZ2FyT2JqZXRpdm8gPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICAgICAgW1wiU2lcIiwgXCJOb1wiXSxcbiAgICAgICAgICBbdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgYFx1MDBCRkRlc2VhIGFncmVnYXIgYWxnXHUwMEZBbiBvYmpldGl2byBwYXJhICR7YXJlYVZpZGF9IGVuICR7dHJpbWVzdHJlfT9gXG4gICAgICAgICk7XG4gICAgICAgIHdoaWxlIChkZXNlYUFncmVnYXJPYmpldGl2bykge1xuICAgICAgICAgIGxldCBvYmpldGl2byA9IGF3YWl0IHRoaXMuY3JlYXJPYmpldGl2b1RyaW1lc3RyZShhcmVhVmlkYSwgdHJpbWVzdHJlKTtcbiAgICAgICAgICBvYmpldGl2b3MucHVzaChbb2JqZXRpdm9dKTtcblxuICAgICAgICAgIC8vIFByZWd1bnRhciBudWV2YW1lbnRlIHNpIGRlc2VhIGFncmVnYXIgb3RybyBvYmpldGl2by5cbiAgICAgICAgICBkZXNlYUFncmVnYXJPYmpldGl2byA9IGF3YWl0IHN1Z2dlc3RlcihcbiAgICAgICAgICAgIFtcIlNpXCIsIFwiTm9cIl0sXG4gICAgICAgICAgICBbdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGBcdTAwQkZEZXNlYSBhZ3JlZ2FyIG90cm8gb2JqZXRpdm8gcGFyYSAke2FyZWFWaWRhfSBlbiAke3RyaW1lc3RyZX0/YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSAvLyBNXHUwMEU5dG9kbyBvYmpldGl2b1RyaW1lc3RyYWwuXG5cblxuXG4vKiBcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbk1cdTAwRTl0b2RvIHF1ZSBjcmVhIGVsIGJvdFx1MDBGM24gcXVlIHNlIGFncmVnYSBlbiBsYSB0YWJsYSBkZSBwcm95ZWN0b3MgZW4gZWwgXG5Db21wYXNzIEFudWFsLCBwYXJhIGNyZWFyIGVsIHByb3llY3RvIGEgY2FkYSBPYmpldGl2by5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovIFxuICBjcmVhdGVCdXR0b25UYWJsZShkdiwgb2JqZXRpdm8pIHtcbiAgICBjb25zdCBidXR0b25Db250YWluZXIgPSBkdi5lbChcImRpdlwiLCBcIlwiKTtcbiAgICBjb25zdCBidXR0b24gPSBkdi5lbChcImJ1dHRvblwiLCBcIk51ZXZvIFByb3llY3RvXCIpO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXJQcm95ZWN0b09iamV0aXZvKGR2LCBvYmpldGl2byk7XG4gICAgfSk7XG4gICAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgcmV0dXJuIGJ1dHRvbkNvbnRhaW5lcjtcbn1cblxuLyogXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5NZXRvZG8gaW52b2NhZG8gcG9yIGVsIGJvdG9uIGRlIGxhIHRhYmxhIGRlbCBjb21wYXNzIGFudWFsIFwiTnVldm8gUHJveWVjdG9cIiBcbnBhcmEgY3JlYXIgcHJveWVjdG8gYSB1biBvYmpldGl2byBhbnVhbCBlc3RhYmxlY2lkby5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovIFxuYXN5bmMgY3JlYXJQcm95ZWN0b09iamV0aXZvKGR2LCBvYmpldGl2byl7XG4gIGRlYnVnZ2VyO1xuICBsZXQgc3VnZ2VzdGVyID0gdGhpcy5wbHVnaW4udHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwic3VnZ2VzdGVyXCIpO1xuICBsZXQgdGlwb1Byb3llY3RvID0gYXdhaXQgc3VnZ2VzdGVyKFxuICAgIFtcIlByb3llY3RvIEdURFwiLCBcIlByb3llY3RvIGRlIFFcIl0sXG4gICAgW3RydWUsIGZhbHNlXSxcbiAgICB0cnVlLFxuICAgIGBcdTAwQkZFbCBwcm95ZWN0byAke29iamV0aXZvLmZpbGUubmFtZX0gcmVxdWllcmUgdW4gUHJveWVjdG8gR1REIG8gUHJveWVjdG8gZGUgUT9gXG4gICk7XG4gIGxldCBwcm95ZWN0bztcbiAgaWYgKHRpcG9Qcm95ZWN0byl7XG4gICAgcHJveWVjdG8gPSB0aGlzLmNyZWFyUHJveWVjdG9HVEQob2JqZXRpdm8pOy8vIENyZWFyIFByb3llY3RvIEdURFxuICB9ZWxzZXtcbiAgICAvKiBcbiAgICBCdXNjYW5kbyBvcHRpbWl6YXIgZWwgdXNvIGRlbCBtXHUwMEU5dG9kbyBjcmVhciBwcm95ZWN0b1EsIFxuICAgIHZhbW9zIGEgY29uZmlybWFyIGVsIHRyaW1lc3RyZSBkZXNkZSBjcmVhclByb3llY3RvT2JqZXRpdm87IFxuICAgICovXG4gICAgZGVidWdnZXI7XG4gICAgY29uc3QgcmVnZXhUcmltID0gL1xcWz9cXFs/KFxcZHs0fS1RWzEtNF0pXFxdP1xcXT8vZztcbiAgICBjb25zdCB0cmltZXN0cmUgPSBvYmpldGl2by50cmltZXN0cmUucGF0aC5tYXRjaChyZWdleFRyaW0pO1xuXG4gICAgY29uc3QgY29uZmlybWFUcmltID0gYXdhaXQgc3VnZ2VzdGVyKFxuICAgICAgW1wiU2lcIiwgXCJOb1wiXSxcbiAgICAgIFt0cnVlLCBmYWxzZV0sXG4gICAgICB0cnVlLFxuICAgICAgYFx1MDBCRlZhbW9zIGEgY3JlYXIgZWwgcHJveWVjdG8gJHtvYmpldGl2by5maWxlLm5hbWV9IGVuIGVsIHRyaW1lc3RyZSAke3RyaW1lc3RyZX0/YFxuICAgICk7XG4gICBcbiAgICBpZiAoIWNvbmZpcm1hVHJpbSl7ICBcbiAgICAgIGNvbnN0IHEgPSBhd2FpdCB0aGlzLmVzdGFibGVjZXJUcmltZXN0cmUoXCJvYmpldGl2byBkZWwgYVx1MDBGMW9cIik7XG4gICAgICAvL29iamV0aXZvLnRyaW1lc3RyZS5wYXRoID0gcS50cmltZXN0cmU7XG4gICAgICBkZWJ1Z2dlcjtcbiAgICAgIGF3YWl0IHRoaXMuYWN0dWFsaXphcllBTUxzKHt0cmltZXN0cmU6IGBbWyR7cS50cmltZXN0cmV9XV1gfSwgb2JqZXRpdm8uZmlsZS5wYXRoKTtcbiAgICAgIH1cbiAgICBwcm95ZWN0byA9IGF3YWl0IHRoaXMuY3JlYXJQcm95ZWN0b1Eob2JqZXRpdm8pO1xuICB9XG59XG5cbi8qIFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuTWV0b2RvIHF1ZSBpbmljaWFsaXphIGxhIGNyZWFjaVx1MDBGM24gZGUgbGEgcGxhbnRpbGxhIGRlIG9iamV0aXZvIENvbXBhc3MuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qLyBcbmFzeW5jIGNyZWFyT2JqZXRpdm8oYXJlYVZpZGEsIGFcdTAwRjFvKXtcbiAgZGVidWdnZXI7XG4gIGNvbnN0IHRlbXBsYXRlUGF0aCA9IGBQbGFudGlsbGFzLyR7dGhpcy5wbHVnaW4uc2V0dGluZ3NbXCJmb2xkZXJfT2JqQ29tcGFzc0FudWFsXCJdfS9QbHQgLSBPYmpDb21wYXNzQW51YWwubWRgO1xuICBjb25zdCB0ZW1wbGF0ZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGVtcGxhdGVQYXRoKTtcbiAgY29uc3QgZm9sZGVyID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChcIkluYm94XCIpO1xuICBsZXQgY3JlYXJOb3RhID0gdGhpcy5wbHVnaW4udHAuZmlsZS5zdGF0aWNfZnVuY3Rpb25zLmdldChcImNyZWF0ZV9uZXdcIikgXG4gIGxldCBmaWxlbmFtZSA9IGAke2FcdTAwRjFvfSAtIE9iamV0aXZvIHBhcmEgJHthcmVhVmlkYX1gO1xuICBsZXQgb2JqZXRpdm8gPSBhd2FpdCBjcmVhck5vdGEgKHRlbXBsYXRlLCBmaWxlbmFtZSwgZmFsc2UsIGZvbGRlcik7XG4gIHJldHVybiBvYmpldGl2bztcbn1cblxuYXN5bmMgY3JlYXJPYmpldGl2b1RyaW1lc3RyZShhcmVhVmlkYSwgdHJpbWVzdHJlKXtcbiAgZGVidWdnZXI7XG4gIGNvbnN0IHRlbXBsYXRlUGF0aCA9IGBQbGFudGlsbGFzLyR7dGhpcy5wbHVnaW4uc2V0dGluZ3NbXCJmb2xkZXJfT2JqQ29tcGFzc0FudWFsXCJdfS9QbHQgLSBPYmpDb21wYXNzQW51YWwubWRgO1xuICBjb25zdCB0ZW1wbGF0ZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGVtcGxhdGVQYXRoKTtcbiAgY29uc3QgZm9sZGVyID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChcIkluYm94XCIpO1xuICBsZXQgY3JlYXJOb3RhID0gdGhpcy5wbHVnaW4udHAuZmlsZS5zdGF0aWNfZnVuY3Rpb25zLmdldChcImNyZWF0ZV9uZXdcIikgXG4gIGxldCBmaWxlbmFtZSA9IGBUcmltZXN0cmUgJHt0cmltZXN0cmV9IC0gT2JqZXRpdm8gcGFyYSAke2FyZWFWaWRhfWA7XG4gIGxldCBvYmpldGl2byA9IGF3YWl0IGNyZWFyTm90YSAodGVtcGxhdGUsIGZpbGVuYW1lLCBmYWxzZSwgZm9sZGVyKTtcbiAgcmV0dXJuIG9iamV0aXZvO1xufVxuXG4vKiBcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbk1ldG9kbyBpbnZvY2FkbyBkZXNkZSBjcmVhclByb3llY3RvT2JqZXRpdm8oZHYsIG9iamV0aXZvKVxuRXN0XHUwMEU5IG1cdTAwRTl0b2RvIGhhY2UgcGFydGUgZGVsIHByb2Nlc28gZGUgQ29tcGFzcyBBbnVhbC5cbkZhY2lsaXRhIGxhIGNyZWFjaVx1MDBGM24gZGVsIHVuIHByb3llY3RvIGRlIFEgcGFyYSB1biBvYmpldGl2byBhbnVhbCBlc3RhYmxlY2lkby5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovIFxuYXN5bmMgY3JlYXJQcm95ZWN0b1Eob2JqZXRpdm8pe1xuICBsZXQgc3VnZ2VzdGVyID0gdGhpcy5wbHVnaW4udHAuc3lzdGVtLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwic3VnZ2VzdGVyXCIpO1xuICBkZWJ1Z2dlcjtcbiAgY29uc3QgdGVtcGxhdGVQYXRoID0gYFBsYW50aWxsYXMvJHt0aGlzLnBsdWdpbi5zZXR0aW5nc1tcImZvbGRlcl9Qcm95ZWN0b3NRXCJdfS9QbHQgLSBQcm95ZWN0b3NRLm1kYDtcbiAgY29uc3QgdGVtcGxhdGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRlbXBsYXRlUGF0aCk7XG4gIGNvbnN0IGZvbGRlciA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoXCJJbmJveFwiKTtcbiAgbGV0IGNyZWFyTm90YSA9IHRoaXMucGx1Z2luLnRwLmZpbGUuc3RhdGljX2Z1bmN0aW9ucy5nZXQoXCJjcmVhdGVfbmV3XCIpIFxuICBsZXQgZmlsZW5hbWUgPSBgUHJveWVjdG8gcGFyYSBPYmpldGl2byBDb21wYXNzIEFudWFsIC0gJHtvYmpldGl2by5pZH1gO1xuICBsZXQgcHJveWVjdG8gPSBhd2FpdCBjcmVhck5vdGEodGVtcGxhdGUsIGZpbGVuYW1lLCB0cnVlLCBmb2xkZXIpO1xuICByZXR1cm4gcHJveWVjdG87XG59XG5cbmFzeW5jIGNyZWFyUHJveWVjdG9HVEQob2JqZXRpdm8pe1xuICBkZWJ1Z2dlcjtcbiAgY29uc3QgdGVtcGxhdGVQYXRoID0gYFBsYW50aWxsYXMvJHt0aGlzLnBsdWdpbi5zZXR0aW5nc1tcImZvbGRlcl9Qcm95ZWN0b3NHVERcIl19L1BsdCAtIFByb3llY3Rvc0dURC5tZGA7XG4gIGNvbnN0IHRlbXBsYXRlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0ZW1wbGF0ZVBhdGgpO1xuICBjb25zdCBmb2xkZXIgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKFwiSW5ib3hcIik7XG4gIGxldCBjcmVhck5vdGEgPSB0aGlzLnBsdWdpbi50cC5maWxlLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwiY3JlYXRlX25ld1wiKSBcbiAgbGV0IGZpbGVuYW1lID0gYFByb3llY3RvIHBhcmEgT2JqZXRpdm8gQ29tcGFzcyBBbnVhbCAtICR7b2JqZXRpdm8uaWR9YDtcbiAgbGV0IHByb3llY3RvID0gYXdhaXQgY3JlYXJOb3RhICh0ZW1wbGF0ZSwgZmlsZW5hbWUsIHRydWUsIGZvbGRlcik7XG4gIHJldHVybiBwcm95ZWN0bztcbn1cblxuXG4vKiBcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbk1ldG9kbyBpbnZvY2FkbyBlbiBlbCBwcm9jZXNvIGRlIENvbXBhc3MgQW51YWwsIGN1YW5kbyBlbGlqbyB2b2x2ZXJcbmEgY3JlYXIgdG9kb3MgbG9zIHByb3llY3RvcyBkZSB1biBhcmVhIGRlIHZpZGEgcGFyYSB1biBhXHUwMEYxby5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovIFxuYXN5bmMgYm9ycmFyT2JqZXRpdm9zKG9iamV0aXZvcyl7XG4gIGRlYnVnZ2VyO1xuICBmb3IgKGxldCBvYmpldGl2byBvZiBvYmpldGl2b3MpeyBcbiAgICB0cnkge1xuICAgICAgLy8gSW50ZW50YSBib3JyYXIgZWwgYXJjaGl2byBhY3R1YWwgZGVsIGFycmVnbG9cbiAgICAgIGF3YWl0IGFwcC52YXVsdC5kZWxldGUob2JqZXRpdm8uZmlsZSk7XG4gICAgICBjb25zb2xlLmxvZyhgQXJjaGl2byBib3JyYWRvOiAke29iamV0aXZvLmZpbGUucGF0aH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhbCBib3JyYXIgZWwgYXJjaGl2byAke29iamV0aXZvLmZpbGUucGF0aH06ICR7ZXJyb3J9YCk7XG4gICAgIH1cbiAgfVxuXG4gIH1cblxuXG4vKiBcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbk1ldG9kbyBxdWUgcGVybWl0ZSBwYXJhIGN1YWxxdWllciBjYXNvIGVuIGVsIHF1ZSBzZSByZXF1aWVyYSBlbGVnaXIgXG51biB0cmltZXN0cmUgcGFyYSBjb250aW51YXIgdW4gcHJvY2VzbywgaGFjZXIgbGEgdmVyaWZpY2FjaVx1MDBGM24gc29icmUgbG9zXG50cmltZXN0cmVzIHF1ZSBlc3RlbiBjcmVhZG9zIGEgcGFydGlyIGRlIGxhIG5vdGEgVFEuICBcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG4gIGFzeW5jIGVzdGFibGVjZXJUcmltZXN0cmUodGVtYVRyaW1lc3RyZSl7XG4gICAgLy8gT2J0ZW5lciBRcyBwYXJhIHByZWd1bnRhciBlbCBRIHBhcmEgZWwgcXVlIGRlc2VhIGNyZWFyIGxhcyBcdTAwRTFyZWFzIGRlIHZpZGEuXG4gICAgY29uc3QgZm9sZGVyUSA9IHRoaXMucGx1Z2luLnNldHRpbmdzW1wiZm9sZGVyX1RyaW1lc3RyYWxcIl07XG4gICAgY29uc3QgZmlsZXNRID0gYXBwLnZhdWx0XG4gICAgICAuZ2V0TWFya2Rvd25GaWxlcygpXG4gICAgICAuZmlsdGVyKFxuICAgICAgICAoZmlsZSkgPT5cbiAgICAgICAgICBmaWxlLnBhdGguaW5jbHVkZXMoZm9sZGVyUSkgJiZcbiAgICAgICAgICAhZmlsZS5wYXRoLmluY2x1ZGVzKFwiUGxhbnRpbGxhc1wiKSAmJlxuICAgICAgICAgICFmaWxlLnBhdGguaW5jbHVkZXMoXCJBcmNoaXZvXCIpXG4gICAgICApO1xuICAgIGxldCBxQ3JlYWRvcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlc1EpIHtcbiAgICAgIGxldCBtZXRhZGF0YSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG5cbiAgICAgIGlmIChtZXRhZGF0YT8udHlwZSA9PT0gXCJUUVwiICYmIG1ldGFkYXRhPy50cmltZXN0cmUpIHtcbiAgICAgICAgbGV0IHFBY3Rpdm8gPSB7IGZpbGUgfTsgLy8gQXN1bWllbmRvIHF1ZSBxdWllcmVzIGd1YXJkYXIgZWwgcGF0aCBkZWwgYXJjaGl2b1xuICAgICAgICBPYmplY3QuYXNzaWduKHFBY3Rpdm8sIG1ldGFkYXRhKTsgLy8gQWdyZWdhIGVsIG1ldGFkYXRhIGFsIG9iamV0byBxQWN0aXZvXG4gICAgICAgIHFDcmVhZG9zLnB1c2gocUFjdGl2byk7IC8vIEFcdTAwRjFhZGUgZWwgcmVnaXN0cm8gYWN0aXZvIGFsIGFycmF5XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHN1Z2dlc3RlciA9IHRoaXMucGx1Z2luLnRwLnN5c3RlbS5zdGF0aWNfZnVuY3Rpb25zLmdldChcInN1Z2dlc3RlclwiKTtcbiAgICB0cnkge1xuICAgICAgbGV0IHEgPSBhd2FpdCBzdWdnZXN0ZXIoXG4gICAgICAgIHFDcmVhZG9zLm1hcCgoYikgPT4gYi50cmltZXN0cmUpLFxuICAgICAgICBxQ3JlYWRvcy5tYXAoKGIpID0+IGIpLFxuICAgICAgICB0cnVlLFxuICAgICAgICBgRGUgcXVlIHRyaW1lc3RyZSB2YW1vcyBhIHByb2Nlc2FyIHR1cyAke3RlbWFUcmltZXN0cmV9YFxuICAgICAgKTtcbiAgXG4gICAgICAvLyBBcXVcdTAwRUQgYXN1bWltb3MgcXVlIHNpIHEgZXMgdW5kZWZpbmVkLCBlbCB1c3VhcmlvIGNhbmNlbFx1MDBGMyBsYSBvcGVyYWNpXHUwMEYzbi5cbiAgICAgIGlmIChxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk9wZXJhY2lcdTAwRjNuIGNhbmNlbGFkYSBwb3IgZWwgdXN1YXJpby5cIik7XG4gICAgICAgICAgLy8gTWFuZWphIGVsIGVzY2FwZSBvIGNhbmNlbGFjaVx1MDBGM24gYXF1XHUwMEVELiBQb3IgZWplbXBsbywgcG9kclx1MDBFRGFzIHNhbGlyIGRlIGxhIGZ1bmNpXHUwMEYzbiBhY3R1YWwgbyBoYWNlciBvdHJhIGNvc2EuXG4gICAgICAgICAgcmV0dXJuOyAvLyBTYWxlIGRlIGxhIGZ1bmNpXHUwMEYzbiBzaSBlbCB1c3VhcmlvIGNhbmNlbGEuXG4gICAgICB9XG4gIFxuICAgICAgLy8gQ29udGludWFyIGNvbiBsYSBsXHUwMEYzZ2ljYSBkZXNwdVx1MDBFOXMgZGUgcXVlIGVsIHVzdWFyaW8gaGEgc2VsZWNjaW9uYWRvIHVuYSBvcGNpXHUwMEYzblxuICAgICAgICBjb25zb2xlLmxvZyhcIkVsIHVzdWFyaW8gc2VsZWNjaW9uXHUwMEYzOlwiLCBxKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBlbiBlbCBzdWdnZXN0ZXI6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgfVxuXG4vKiBcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbkNvbiBlc3RlIG1cdTAwRTl0b2RvIHB1ZWRvIGFjdHVhbGl6YXIgdmFsb3JlcyBlbiBsYXMgbm90YXMgeWEgZXhpc3RlbnRlcy5cbkxvIHV0aWxpem8gZW4gZXN0YSBjbGFzZSwgcGFyYSBhY3R1YWxpemFyIGVsIHRyaW1lc3RyZS5cbkVzdGEgZnVuY2lcdTAwRjNuIHNvbG8gYWN0dWFsaXphLCBubyBjcmVhIGVsIGNhbXBvcyBzaSBubyBleGlzdGUuIFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKi9cbiAgYXN5bmMgYWN0dWFsaXphcllBTUxzKGNhbXBvcywgcnV0YSkge1xuICAgICAgICBcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBmaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChydXRhKTtcbiAgICAgICAgYXdhaXQgYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihmaWxlLCBmcm9udG1hdHRlciA9PiB7XG4gICAgICAgICAgICAvLyBJdGVyYXIgc29icmUgY2FkYSBwcm9waWVkYWQgZGVsIG9iamV0byAnbm90YSdcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FtcG8gaW4gY2FtcG9zKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KGNhbXBvKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBY3R1YWxpemFyIGVsIGNhbXBvIGVuIGVsIGZyb250bWF0dGVyIGNvbiBlbCB2YWxvciBjb3JyZXNwb25kaWVudGVcbiAgICAgICAgICAgICAgICAgICAgZnJvbnRtYXR0ZXJbY2FtcG9dID0gY2FtcG9zW2NhbXBvXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZyb250bWF0dGVyIGFjdHVhbGl6YWRvIGNvbiBcdTAwRTl4aXRvXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgYWN0dWFsaXphciBlbCBmcm9udG1hdHRlclwiLCBlcnIpO1xuICAgIH1cbn1cblxufVxuIiwgImltcG9ydCB7IEl0ZW1WaWV3LCBXb3Jrc3BhY2VMZWFmLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgRGF0ZVRpbWUsIER1cmF0aW9uIH0gZnJvbSAnbHV4b24nO1xuaW1wb3J0IHsgcmVnaXN0cm9UaWVtcG9BUEkgfSBmcm9tIFwiLi4vLi4vbW9kdWxvUmVnaXN0cm9UaWVtcG8vQVBJL3JlZ2lzdHJvVGllbXBvQVBJXCI7XG5cbmV4cG9ydCBjbGFzcyBWaXN0YVJlZ2lzdHJvRGlhcmlvIGV4dGVuZHMgSXRlbVZpZXcge1xuICAgIGludGVydmFsSWQ6IG51bWJlcjtcbiBcblxuICAgIGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYsIHB1YmxpYyBwbHVnaW46IGFueSkge1xuICAgICAgICBzdXBlcihsZWFmKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgICAgIHRoaXMucmVnaXN0cm9UaWVtcG9BUEkgPSBuZXcgcmVnaXN0cm9UaWVtcG9BUEkodGhpcy5wbHVnaW4pO1xuICAgIH1cblxuICAgIGdldFZpZXdUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ2aXN0YS1yZWdpc3Ryby1kaWFyaW9cIjtcbiAgICB9XG5cbiAgICBnZXREaXNwbGF5VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVnaXN0cm8gRGlhcmlvXCI7XG4gICAgfVxuXG4gICAgZ2V0SWNvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsZS1jbG9ja1wiOyAvLyBFc3RlIGVzIHVuIGVqZW1wbG8sIGNhbWJpYSBcImRvY3VtZW50b1wiIHBvciBlbCBub21icmUgZGVsIFx1MDBFRGNvbm8gcXVlIGRlc2VlcyB1c2FyXG4gICAgfVxuXG4gICAgYXN5bmMgb25PcGVuKCkge1xuICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKCFhY3RpdmVGaWxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbC5zZXRUZXh0KFwiTm8gaGF5IHVuIGFyY2hpdm8gYWN0aXZvLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMuYWN0dWFsaXphclZpc3RhKGFjdGl2ZUZpbGUpOyAvLyBQdWVkZXMgdXNhciB0aGlzLmZpbGUgZGVudHJvIGRlIGFjdHVhbGl6YXJWaXN0YVxuICAgIFxuICAgICAgICAvL2F3YWl0IHRoaXMuYWN0dWFsaXphclZpc3RhKCk7IC8vIEFjdHVhbGl6YSBsYSB2aXN0YSBpbm1lZGlhdGFtZW50ZSBhbCBhYnJpclxuXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFjdHVhbGl6YXJWaXN0YShhY3RpdmVGaWxlKTsgLy8gQWN0dWFsaXphIGxhIHZpc3RhIGNhZGEgMTAgc2VndW5kb3NcbiAgICAgICAgfSwgNTAwMCk7XG4gICAgfVxuICAgIFxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTsgLy8gTGltcGlhIGVsIGludGVydmFsbyBhbCBjZXJyYXIgbGEgdmlzdGFcbiAgICB9XG5cbiAgICBhc3luYyBhY3R1YWxpemFyVmlzdGEoYWN0aXZlRmlsZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnRFbC5lbXB0eSgpOyAvLyBMaW1waWEgZWwgY29udGVuaWRvIGV4aXN0ZW50ZSBhbnRlcyBkZSBhY3R1YWxpemFyXG4gICAgICAgIFxuICAgICAgICBjb25zdCBmZWNoYUhveSA9IERhdGVUaW1lLmZyb21Gb3JtYXQoYWN0aXZlRmlsZS5iYXNlbmFtZS5zcGxpdChcIiBcIilbMF0sICd5eXl5LU1NLWRkJywgeyBsb2NhbGU6ICdlcycgfSk7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcl9SZWdpc3Ryb1RpZW1wbztcbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkuZmlsdGVyKGZpbGUgPT4gZmlsZS5wYXRoLmluY2x1ZGVzKGZvbGRlcikpO1xuXG4gICAgICAgIGxldCB0b3RhbERpYSA9IDA7XG4gICAgICAgIGxldCByZWdpc3Ryb3NIb3kgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGE/LmhvcmFJbmljaW8pIHtcbiAgICAgICAgICAgICAgICBsZXQgaG9yYUluaWNpbyA9IERhdGVUaW1lLmZyb21Gb3JtYXQobWV0YWRhdGEuaG9yYUluaWNpbywgJ3l5eXktTU0tZGQgRUVFRSBISDptbScsIHsgbG9jYWxlOiAnZXMnIH0pO1xuICAgICAgICAgICAgICAgIGlmIChob3JhSW5pY2lvLnN0YXJ0T2YoJ2RheScpLnRzID09PSBmZWNoYUhveS5zdGFydE9mKCdkYXknKS50cykge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3Ryb3NIb3kucHVzaCh7IHBhdGg6IGZpbGUucGF0aCwgZnJvbnRtYXR0ZXI6IG1ldGFkYXRhIH0pO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbERpYSArPSBwYXJzZUludChtZXRhZGF0YS50aWVtcG9UcmFiYWphZG8gfHwgJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3Ryb3NIb3kuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgbGV0IGZlY2hhQSA9IERhdGVUaW1lLmZyb21Gb3JtYXQoYS5mcm9udG1hdHRlci5ob3JhSW5pY2lvLCAneXl5eS1NTS1kZCBFRUVFIEhIOm1tJywgeyBsb2NhbGU6ICdlcycgfSkudHM7XG4gICAgICAgICAgICBsZXQgZmVjaGFCID0gRGF0ZVRpbWUuZnJvbUZvcm1hdChiLmZyb250bWF0dGVyLmhvcmFJbmljaW8sICd5eXl5LU1NLWRkIEVFRUUgSEg6bW0nLCB7IGxvY2FsZTogJ2VzJyB9KS50cztcbiAgICAgICAgICAgIHJldHVybiBmZWNoYUEgLSBmZWNoYUI7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0aXR1bG8gPSB0aGlzLmNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6IGBSZWdpc3Ryb3MgZGUgdGllbXBvIGRlbCAke2ZlY2hhSG95LnRvRm9ybWF0KCdFRUVFLCBERCcpfS5gfSk7XG4gICAgICAgIHRpdHVsby5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWFjaVx1MDBGM24gZGUgZWxlbWVudG9zIEhUTUwgZGlyZWN0YW1lbnRlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5jb250ZW50RWwuY3JlYXRlRWwoJ3RhYmxlJywgeyBjbHM6ICd0YWJsZS1yZXN1bWVuU2VtYW5hbCcgfSk7XG4gICAgICAgIGNvbnN0IHRoZWFkID0gdGFibGUuY3JlYXRlRWwoJ3RoZWFkJyk7XG4gICAgICAgIGNvbnN0IGhlYWRlclJvdyA9IHRoZWFkLmNyZWF0ZUVsKCd0cicpO1xuICAgICAgICBbJ1JlZ2lzdHJvJywgJ0Rlc2NyaXBjaVx1MDBGM24nLCAnUGVyaW9kbycsICdUaWVtcG8nLCAnRXN0YWRvJywgJ0lkJywgJ0FjY2lcdTAwRjNuJ10uZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgaGVhZGVyUm93LmNyZWF0ZUVsKCd0aCcsIHsgdGV4dDogaGVhZGVyIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0Ym9keSA9IHRhYmxlLmNyZWF0ZUVsKCd0Ym9keScpO1xuICAgICAgICByZWdpc3Ryb3NIb3kuZm9yRWFjaChyZWdpc3RybyA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSB0Ym9keS5jcmVhdGVFbCgndHInKTtcbiAgICAgICAgICAgIC8vIEFxdVx1MDBFRCByZWxsZW5hcyBsYXMgY2VsZGFzIGRlIGxhIGZpbGFcbiAgICAgICAgICAgIHRoaXMuZmlsbFJvd1dpdGhEYXRhKHJvdywgcmVnaXN0cm8pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5hcHBlbmRDaGlsZCh0YWJsZSk7XG4gICAgfVxuXG4gICAgZmlsbFJvd1dpdGhEYXRhKHJvdywgcmVnaXN0cm8pIHtcbiAgICAgICAgY29uc3QgdGRBcmNoaXZvID0gcm93LmNyZWF0ZUVsKCd0ZCcpO1xuICAgICAgICBjb25zdCBsaW5rRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGxpbmtFbC50ZXh0Q29udGVudCA9IHJlZ2lzdHJvLmZyb250bWF0dGVyLmFsaWFzZXNbMF07ICAvLyBVc2EgZWwgYWxpYXMgY29tbyB0ZXh0byBkZWwgZW5sYWNlXG4gICAgICAgIGxpbmtFbC5ocmVmID0gJyMnO1xuICAgICAgICBsaW5rRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXYpID0+IHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIEV2aXRhIGxhIG5hdmVnYWNpXHUwMEYzbiBwcmVkZXRlcm1pbmFkYSBkZWwgZW5sYWNlXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHJlZ2lzdHJvLnBhdGgpO1xuICAgICAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgIC8vIEFicmUgZWwgYXJjaGl2byBlbiB1bmEgbnVldmEgaG9qYSBkZSBlc3BhY2lvIGRlIHRyYWJham9cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKS5vcGVuRmlsZShmaWxlLCB7IGZvY3VzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGRBcmNoaXZvLmFwcGVuZENoaWxkKGxpbmtFbCk7XG4gICAgICAgIFxuICAgICAgICByb3cuY3JlYXRlRWwoJ3RkJywgeyB0ZXh0OiByZWdpc3Ryby5mcm9udG1hdHRlci5kZXNjcmlwY2lvbiB9KTtcbiAgICAgICAgcm93LmNyZWF0ZUVsKCd0ZCcsIHsgdGV4dDogYCR7RGF0ZVRpbWUuZnJvbUZvcm1hdChyZWdpc3Ryby5mcm9udG1hdHRlci5ob3JhSW5pY2lvLCAneXl5eS1NTS1kZCBFRUVFIEhIOm1tJywgeyBsb2NhbGU6ICdlcycgfSkudG9Gb3JtYXQoJ2g6bW0gYScpfSAvICR7RGF0ZVRpbWUuZnJvbUZvcm1hdChyZWdpc3Ryby5mcm9udG1hdHRlci5ob3JhRmluYWwsICd5eXl5LU1NLWRkIEVFRUUgSEg6bW0nLCB7IGxvY2FsZTogJ2VzJyB9KS50b0Zvcm1hdCgnaDptbSBhJyl9YH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYSB5IG11ZXN0cmEgZWwgdGllbXBvIGVuIGZvcm1hdG8gZGUgZFx1MDBFRGFzLCBob3JhcyB5IG1pbnV0b3NcbiAgICAgICAgY29uc3QgdGRQZXJpb2RvID0gcm93LmNyZWF0ZUVsKCd0ZCcpO1xuICAgICAgICBpZiAocmVnaXN0cm8uZnJvbnRtYXR0ZXIuZXN0YWRvID09PSBcIlx1RDgzRFx1REZFMlwiKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhIGVsIHRpZW1wbyBkZXNkZSBhaG9yYSBoYXN0YSBsYSBob3JhIGRlIGluaWNpb1xuICAgICAgICAgICAgbGV0IGFob3JhID0gRGF0ZVRpbWUubG9jYWwoKTtcbiAgICAgICAgICAgIGxldCBpbmljaW8gPSBEYXRlVGltZS5mcm9tRm9ybWF0KHJlZ2lzdHJvLmZyb250bWF0dGVyLmhvcmFJbmljaW8sICd5eXl5LU1NLWRkIEVFRUUgSEg6bW0nLCB7IGxvY2FsZTogJ2VzJyB9KTtcbiAgICAgICAgICAgIGxldCBkdXJhY2lvbiA9IGFob3JhLmRpZmYoaW5pY2lvLCBbJ2RheXMnLCAnaG91cnMnLCAnbWludXRlcyddKTtcbiAgICAgICAgICAgIHRkUGVyaW9kby50ZXh0Q29udGVudCA9IHRoaXMuZm9ybWF0RHVyYXRpb24oZHVyYWNpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTXVlc3RyYSBlbCB0aWVtcG8gdHJhYmFqYWRvIGVuIG1pbGlzZWd1bmRvcyBjb252ZXJ0aWRvIGEgZm9ybWF0byBsZWdpYmxlXG4gICAgICAgICAgICBsZXQgdGllbXBvVHJhYmFqYWRvID0gdGhpcy5mb3JtYXREdXJhdGlvbihyZWdpc3Ryby5mcm9udG1hdHRlci50aWVtcG9UcmFiYWphZG8pO1xuICAgICAgICAgICAgdGRQZXJpb2RvLnRleHRDb250ZW50ID0gdGllbXBvVHJhYmFqYWRvO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByb3cuY3JlYXRlRWwoJ3RkJywgeyB0ZXh0OiByZWdpc3Ryby5mcm9udG1hdHRlci5lc3RhZG8gfSk7XG4gICAgICAgIHJvdy5jcmVhdGVFbCgndGQnLCB7IHRleHQ6IHJlZ2lzdHJvLmZyb250bWF0dGVyLmlkIH0pO1xuXG4gICAgICAgIGNvbnN0IGFjdGlvbkNlbGwgPSByb3cuY3JlYXRlRWwoJ3RkJyk7XG4gICAgICAgIGlmIChyZWdpc3Ryby5mcm9udG1hdHRlci5lc3RhZG8gPT09IFwiXHVEODNEXHVERkUyXCIpIHtcbiAgICAgICAgICAgIGFjdGlvbkNlbGwuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVCdXR0b25UYWJsZSgnQ2VycmFyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0cm9UaWVtcG9BUEkuY2VycmFyUmVnaXN0cm8ocmVnaXN0cm8uZnJvbnRtYXR0ZXIuaWQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uQ2VsbC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUJ1dHRvblRhYmxlKCdSZXRvbWFyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0b21hclRhcmVhKHJlZ2lzdHJvLmZyb250bWF0dGVyLmlkKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZ1bmNpXHUwMEYzbiBhdXhpbGlhciBwYXJhIGZvcm1hdGVhciBsYSBkdXJhY2lcdTAwRjNuIGRlIEx1eG9uIGEgdW4gZm9ybWF0byBsZWdpYmxlXG4gICAgZm9ybWF0RHVyYXRpb24obXMpIHtcbiAgICAgICAgICAgIGlmIChtcyA9PT0gbnVsbCB8fCBtcyA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKG1zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGRlZmluaWRvXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnRpciBtaWxpc2VndW5kb3MgYSBtaW51dG9zLCBob3JhcyB5IGRcdTAwRURhc1xuICAgICAgICAgICAgICAgIGxldCBtaW51dG9zID0gTWF0aC5mbG9vcihtcyAvICgxMDAwICogNjApKTtcbiAgICAgICAgICAgICAgICBsZXQgaG9yYXMgPSBNYXRoLmZsb29yKG1pbnV0b3MgLyA2MCk7XG4gICAgICAgICAgICAgICAgbWludXRvcyA9IG1pbnV0b3MgJSA2MDsgLy8gUmVzdG8gZGUgbGEgZGl2aXNpXHUwMEYzbiBwYXJhIG9idGVuZXIgbG9zIG1pbnV0b3Mgc29icmFudGVzXG4gICAgICAgICAgICAgICAgbGV0IGRpYXMgPSBNYXRoLmZsb29yKGhvcmFzIC8gMjQpO1xuICAgICAgICAgICAgICAgIGhvcmFzID0gaG9yYXMgJSAyNDsgLy8gUmVzdG8gZGUgbGEgZGl2aXNpXHUwMEYzbiBwYXJhIG9idGVuZXIgbGFzIGhvcmFzIHNvYnJhbnRlc1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXRlYXIgZWwgc3RyaW5nIGRlIHNhbGlkYVxuICAgICAgICAgICAgICAgIGlmIChkaWFzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZGlhc30gZCAke2hvcmFzfSBoICR7bWludXRvc30gbWluYDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhvcmFzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7aG9yYXN9IGggJHttaW51dG9zfSBtaW5gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHttaW51dG9zfSBtaW5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVCdXR0b25UYWJsZShidXR0b25UZXh0LCBvbkNsaWNrQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IGJ1dHRvblRleHQ7XG4gICAgICAgIGJ1dHRvbi50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCd5b3VyLWJ1dHRvbi1jbGFzcycpO1xuXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2tDYWxsYmFjayk7XG5cbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgXG4gICAgYXN5bmMgcmV0b21hclRhcmVhKGlkKSB7IFxuICAgICAgICAvLyBBc2VnXHUwMEZBcmF0ZSBkZSByZWVtcGxhemFyICdydXRhL2FsL2FyY2hpdm8ubWQnIGNvbiBsYSBydXRhIGV4YWN0YSBkZWwgYXJjaGl2byBxdWUgZGVzZWFzIG9idGVuZXJcbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gYFBsYW50aWxsYXMvJHt0aGlzLnBsdWdpbi5zZXR0aW5nc1tgZm9sZGVyX1JlZ2lzdHJvVGllbXBvYF19L1BsdCAtIFJlZ2lzdHJvVGllbXBvLm1kYDtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVQYXRoKTtcblxuICAgICAgICBpZiAodGVtcGxhdGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgLy8gQWhvcmEgJ2ZpbGUnIGVzIHR1IGFyY2hpdm8gZGVzZWFkbywgeSBwdWVkZXMgdHJhYmFqYXIgY29uIFx1MDBFOWwgY29tbyBuZWNlc2l0ZXNcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXJjaGl2byBlbmNvbnRyYWRvOlwiLCB0ZW1wbGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaSBlbCBhcmNoaXZvIG5vIHNlIGVuY29udHJcdTAwRjMsICdmaWxlJyBzZXJcdTAwRTEgbnVsbFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBcmNoaXZvIG5vIGVuY29udHJhZG8uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gXCJSZXRvbWFyIFwiICsgaWQ7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoXCJJbmJveFwiKTtcbiAgICAgICAgY29uc3QgdHAgPSB0aGlzLmdldFRwKCk7XG4gICAgICAgIGxldCBjcmVhck5vdGEgPSB0cC5maWxlLnN0YXRpY19mdW5jdGlvbnMuZ2V0KFwiY3JlYXRlX25ld1wiKVxuICAgICAgICBhd2FpdCBjcmVhck5vdGEgKHRlbXBsYXRlLCBmaWxlbmFtZSwgZmFsc2UsIGZvbGRlcikuYmFzZW5hbWU7XG4gICAgICB9XG5cbiAgICBnZXRUcCgpe1xuICAgICAgICBpZiAoIXRoaXMucGx1Z2luIHx8ICF0aGlzLnBsdWdpbi5hcHAucGx1Z2lucy5lbmFibGVkUGx1Z2lucy5oYXMoJ3RlbXBsYXRlci1vYnNpZGlhbicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFbCBwbHVnaW4gVGVtcGxhdGVyIG5vIGVzdFx1MDBFMSBoYWJpbGl0YWRvLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9ICAgXG4gICAgICAgIGxldCB0cEdlbiA9IHRoaXMucGx1Z2luLmFwcC5wbHVnaW5zLnBsdWdpbnNbXCJ0ZW1wbGF0ZXItb2JzaWRpYW5cIl0udGVtcGxhdGVyO1xuICAgICAgICB0cEdlbiA9IHRwR2VuLmZ1bmN0aW9uc19nZW5lcmF0b3IuaW50ZXJuYWxfZnVuY3Rpb25zLm1vZHVsZXNfYXJyYXk7XG4gICAgICAgIGxldCB0cCA9IHt9XG4gICAgICAgIC8vIGdldCBhbiBpbnN0YW5jZSBvZiBtb2R1bGVzXG4gICAgICAgIHRwLmZpbGUgPSB0cEdlbi5maW5kKG0gPT4gbS5uYW1lID09IFwiZmlsZVwiKTtcbiAgICAgICAgdHAuc3lzdGVtID0gdHBHZW4uZmluZChtID0+IG0ubmFtZSA9PSBcInN5c3RlbVwiKTtcblxuICAgICAgICBpZiAoIXRwLmZpbGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIHNlIHB1ZG8gYWNjZWRlciBhbCBvYmpldG8gZGUgZnVuY2lvbmVzIGFjdHVhbGVzIGRlIFRlbXBsYXRlci5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygndHAgY29uIHByb3BpZWRhZGVzIFwiZmlsZVwiIHNlIGhhIGNhcmdhZG8gc2F0aXNmYWN0b3JpYW1lbnRlJyk7XG4gICAgICAgIHJldHVybiB0cDtcbiAgICB9XG4gICAgXG5cblxuICAgIC8vIE9wY2lvbmFsOiBJbXBsZW1lbnRhIG9uQ2xvc2Ugc2kgbmVjZXNpdGFzIGxpbXBpZXphIGFsIGNlcnJhciBsYSB2aXN0YS5cbn0iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCwgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHUFRob3JhUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuICAgICAgICBzdXBlcihhcHApO1xuICAgIH1cblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnc2hvdy1sb2NhbC10aW1lJyxcbiAgICAgICAgICAgIG5hbWU6ICdIb3JhIExvY2FsJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLnNob3dMb2NhbFRpbWVNb2RhbCgpXG4gICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2hvd0xvY2FsVGltZU1vZGFsKCkge1xuICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBMb2NhbFRpbWVNb2RhbCh0aGlzLmFwcCk7XG4gICAgICAgIG1vZGFsLm9wZW4oKTtcbiAgICB9XG59XG5cbmNsYXNzIExvY2FsVGltZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcyA7XG4gICAgICAgIGNvbnRlbnRFbC5lbXB0eSgpO1xuXG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGhvdXJzID0gbm93LmdldEhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICAgICAgY29uc3QgbWludXRlcyA9IG5vdy5nZXRNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICBjb25zdCBhbXBtID0gbm93LmdldEhvdXJzKCkgPj0gMTIgPyAnUE0nIDogJ0FNJztcbiAgICAgICAgY29uc3QgdGltZVN0cmluZyA9IGAke2hvdXJzfToke21pbnV0ZXN9ICR7YW1wbX1gO1xuXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDEnLCB7IHRleHQ6ICdIb3JhIExvY2FsJyB9KTtcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiB0aW1lU3RyaW5nIH0pO1xuXG4gICAgICAgIC8vIEVzdGlsbyBkZWwgbW9kYWxcbiAgICAgICAgY29udGVudEVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjMkUzNDQwJztcbiAgICAgICAgY29udGVudEVsLnN0eWxlLmNvbG9yID0gJyNEOERFRTknO1xuICAgICAgICBjb250ZW50RWwuc3R5bGUucGFkZGluZyA9ICcyMHB4JztcbiAgICAgICAgY29udGVudEVsLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzIDtcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFFLElBQUFBLG9CQUF1Qjs7O0FDQXpCLHNCQUFrRDtBQUUzQyxJQUFNLHdCQUFOLGNBQW9DLGlDQUFpQjtBQUFBLEVBR3hELFlBQVksUUFBZ0I7QUFDeEIsVUFBTSxPQUFPLEtBQUssTUFBTTtBQUN4QixTQUFLLFNBQVM7QUFBQSxFQUNsQjtBQUFBLEVBRUEsVUFBZ0I7QUFDWixVQUFNLEVBQUUsWUFBWSxJQUFJO0FBQ3hCLGdCQUFZLE1BQU07QUFDbEIsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxxREFBK0MsQ0FBQztBQUdu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b0IsbUJBQW1CO0FBQ3JELFFBQUksS0FBSyxDQUFDO0FBRVYsT0FBRyxPQUFPLE1BQU0sS0FBSyxPQUFLLEVBQUUsUUFBUSxNQUFNO0FBQzFDLE9BQUcsU0FBUyxNQUFNLEtBQUssT0FBSyxFQUFFLFFBQVEsUUFBUTtBQUU5QyxRQUFJLENBQUMsR0FBRyxRQUFRO0FBQ2QsY0FBUSxNQUFNLGtFQUFrRTtBQUNoRjtBQUFBLElBQ0o7QUFDRSxZQUFRLElBQUksc0RBQXNEO0FBQ2xFLFdBQU87QUFBQSxFQUNUO0FBQ047IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiYXBwIiwgIm9mZnNldCIsICJyZWdpc3RlclJpYmJvbk1lbnUiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAicmVnaXN0ZXJDb21tYW5kcyIsICJkZWFjdGl2YXRlQ29tbWFuZHMiLCAicmVnaXN0ZXJSaWJib25NZW51IiwgInJlZ2lzdGVyQ29tbWFuZHMiLCAiZGVhY3RpdmF0ZUNvbW1hbmRzIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJtZW51T3RybyIsICJ0aXBvIiwgInR5cGUiLCAicyIsICJzaW5nbGV0b24iLCAib2Zmc2V0IiwgInMiLCAiZGVmYXVsdFpvbmUiLCAib2Zmc2V0IiwgIm4iLCAibiIsICJvZmZzZXQiLCAicyIsICJuIiwgImZvcm1hdE9mZnNldCIsICJzIiwgIm1hdGNoIiwgIm9mZnNldCIsICJsIiwgIm4iLCAicyIsICJJTlZBTElEIiwgInMiLCAiZSIsICJzIiwgInR5cGUiLCAiSU5WQUxJRCIsICJjbG9uZSIsICJvZmZzZXQiLCAib3JkZXJlZFVuaXRzIiwgImFwcCIsICJhbGlhcyIsICJmb2xkZXIiLCAic2FtZU5hbWUiLCAibmFtZUZpbGUiLCAiYXBwIiwgIm9mZnNldCIsICJpbXBvcnRfb2JzaWRpYW4iLCAicmVnaXN0cm8iLCAiaW1wb3J0X29ic2lkaWFuIiwgIm9mZnNldCIsICJuaXZlbCIsICJhY3RpdmVSZXNvdXJjZXMiLCAiY2xhc2lmaWNhY2lvbiIsICJ0YWdDbGFzaWZpY2FjaW9uIiwgIm51ZXZhQ2xhc2lmaWNhY2lvbiIsICJmcm9udG1hdHRlciIsICJhcHAiLCAicGFydGVzIiwgInR5cGUiLCAiYXJlYXNWaWRhIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiWUFNTFVwZGF0ZXJBUEkiLCAib2Zmc2V0IiwgImNsYXNpZmljYWNpb24iLCAidGFnQ2xhc2lmaWNhY2lvbiIsICJudWV2YUNsYXNpZmljYWNpb24iLCAiZnJvbnRtYXR0ZXIiLCAiaW1wb3J0X29ic2lkaWFuIiwgIm1hdGNoIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiX2EiLCAidGl0dWxvIiwgIm1hdGNoIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAicmVnaXN0ZXJDb21tYW5kcyIsICJkZWFjdGl2YXRlQ29tbWFuZHMiLCAicmVnaXN0ZXJDb21tYW5kcyIsICJkZWFjdGl2YXRlQ29tbWFuZHMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgIm5vdyIsICJZQU1MVXBkYXRlckFQSSJdCn0K
